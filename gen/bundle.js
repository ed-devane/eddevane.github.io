/*! For license information please see bundle.js.LICENSE.txt */
(()=>{"use strict";var e={56:(e,n,t)=>{e.exports=function(e){var n=t.nc;n&&e.setAttribute("nonce",n)}},72:e=>{var n=[];function t(e){for(var t=-1,a=0;a<n.length;a++)if(n[a].identifier===e){t=a;break}return t}function a(e,a){for(var c={},r=[],i=0;i<e.length;i++){var l=e[i],s=a.base?l[0]+a.base:l[0],u=c[s]||0,d="".concat(s," ").concat(u);c[s]=u+1;var p=t(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)n[p].references++,n[p].updater(f);else{var m=o(f,a);a.byIndex=i,n.splice(i,0,{identifier:d,updater:m,references:1})}r.push(d)}return r}function o(e,n){var t=n.domAPI(n);return t.update(e),function(n){if(n){if(n.css===e.css&&n.media===e.media&&n.sourceMap===e.sourceMap&&n.supports===e.supports&&n.layer===e.layer)return;t.update(e=n)}else t.remove()}}e.exports=function(e,o){var c=a(e=e||[],o=o||{});return function(e){e=e||[];for(var r=0;r<c.length;r++){var i=t(c[r]);n[i].references--}for(var l=a(e,o),s=0;s<c.length;s++){var u=t(c[s]);0===n[u].references&&(n[u].updater(),n.splice(u,1))}c=l}}},113:e=>{e.exports=function(e,n){if(n.styleSheet)n.styleSheet.cssText=e;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(e))}}},159:e=>{e.exports=function(e){var n=document.createElement("style");return e.setAttributes(n,e.attributes),e.insert(n,e.options),n}},249:(e,n,t)=>{t.d(n,{A:()=>i});var a=t(601),o=t.n(a),c=t(314),r=t.n(c)()(o());r.push([e.id,"/* CSS Variables from original */\n:root{\n  --bg-canvas:#e5e7eb;\n  --bg-panel:#0c1428;\n  --fg:#e2e8f0;\n  --muted:#94a3b8;\n  --border:#1f2937;\n}\n\n/* Reset and body */\nhtml, body, #root { \n  height:100%; \n  margin:0; \n  background:var(--bg-canvas); \n  color:var(--fg); \n  font-family: ui-sans-serif, system-ui, sans-serif;\n}\n\nbutton { cursor:pointer }\n\n/* Real-time parameter system animations */\n@keyframes pulse {\n    0%, 100% { opacity: 1; }\n    50% { opacity: 0.5; }\n}\n\n/* Original button styles */\n.btn { \n  padding:6px 8px; \n  border-radius:8px; \n  border:0; \n  font-size:12px;\n}\n\n.btn-blue{ background:#0ea5e9; color:#fff }\n.btn-green{ background:#22c55e; color:#052e16; font-weight:800 }\n.btn-amber{ background:#f59e0b; color:#1f2937; font-weight:800 }\n.btn-red{ background:#dc2626; color:#fff; font-weight:800 }\n.btn-ghost{ background:#111827; color:#e2e8f0; border:1px solid #334155; }\n\n/* Main Layout - Simple 3 column structure */\n.app {\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n    background: var(--bg-canvas);\n    color: var(--fg);\n}\n\n/* Toolbar */\n.toolbar {\n    height: 50px;\n    background: var(--bg-panel);\n    border-bottom: 1px solid var(--border);\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 0 20px;\n    flex-shrink: 0;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    z-index: 1001;\n    width: 100%;\n}\n\n.toolbar h1 {\n    font-size: 18px;\n    font-weight: 700;\n    color: #22c55e;\n}\n\n.toolbar-actions {\n    display: flex;\n    gap: 8px;\n}\n\n/* Main Content - 3 columns: palette, canvas, inspector */\n.main-content {\n    flex: 1;\n    display: flex;\n    height: calc(100vh - 50px);\n    overflow: hidden;\n    width: 100%;\n    margin-top: 50px;\n}\n\n/* Module Palette - Left panel */\n.module-palette {\n    width: 250px;\n    background: var(--bg-panel);\n    border-right: 1px solid var(--border);\n    padding: 12px;\n    overflow-y: auto;\n    flex-shrink: 0;\n}\n\n.module-palette h2 {\n    font-size: 14px;\n    font-weight: 700;\n    color: var(--fg);\n    margin-bottom: 16px;\n}\n\n.module-categories {\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.category h3 {\n    font-size: 12px;\n    color: #22c55e;\n    margin-bottom: 8px;\n    text-transform: uppercase;\n    font-weight: 700;\n}\n\n.module-list {\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n}\n\n.module-item {\n    padding: 8px 12px;\n    background: #111827;\n    border: 1px solid #334155;\n    border-radius: 8px;\n    font-size: 12px;\n    cursor: pointer;\n    transition: all 0.2s;\n    color: var(--fg);\n    font-weight: 500;\n}\n\n.module-item:hover {\n    background: #1e293b;\n    border-color: #22c55e;\n    color: #22c55e;\n}\n\n/* Patch Canvas - Center panel */\n.patch-canvas {\n    width: calc(100vw - 570px); /* Full viewport minus left sidebar (250px) + wider right sidebar (320px) */\n    position: relative;\n    overflow: auto;\n    background: #e5e7eb;\n    cursor: grab;\n    min-height: 100%;\n    user-select: none; /* Prevent text selection on shift+click for stereo connections */\n    -webkit-user-select: none;\n}\n\n.patch-canvas.panning {\n    cursor: grabbing;\n}\n\n.patch-canvas.subpatch-context {\n    background: #9ca3af; /* Darker shade when inside subpatch */\n}\n\n.patch-svg {\n    width: 100%;\n    height: 100%;\n    user-select: none; /* Prevent text selection on shift+click */\n    -webkit-user-select: none;\n}\n\n/* Inspector - Right panel */\n.inspector {\n    background: var(--bg-panel);\n    border-left: 1px solid var(--border);\n    padding: 12px;\n    overflow-y: auto;\n    position: fixed;\n    top: 50px;\n    right: 0;\n    width: 320px;\n    height: calc(100vh - 50px);\n    z-index: 1000;\n}\n\n.inspector h2 {\n    font-size: 14px;\n    font-weight: 700;\n    color: var(--fg);\n    margin-bottom: 8px;\n}\n\n.inspector-content {\n    font-size: 12px;\n    color: var(--muted);\n}\n\n.module-desc {\n    font-size: 12px;\n    color: var(--muted);\n    margin-bottom: 16px;\n    font-style: italic;\n}\n\n.params {\n    margin-top: 12px;\n}\n\n.params h3 {\n    font-size: 12px;\n    color: var(--muted);\n    margin-bottom: 8px;\n    font-weight: 700;\n}\n\n.param {\n    margin-bottom: 8px;\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n}\n\n.param label {\n    font-size: 12px;\n    color: #cbd5e1;\n    margin-bottom: 4px;\n    display: block;\n}\n\n.param input,\n.param select {\n    width: 100%;\n    padding: 6px;\n    border-radius: 8px;\n    border: 1px solid #334155;\n    background: #0f172a;\n    color: var(--fg);\n    font-size: 12px;\n}\n\n.param input:focus,\n.param select:focus {\n    outline: none;\n    border-color: #22c55e;\n    box-shadow: 0 0 0 1px #22c55e;\n}\n\n.param select option {\n    background: #0f172a;\n    color: var(--fg);\n}\n\n/* Original Module Node Styles */\n.node { \n    position: absolute; \n    border-radius: 10px; \n    background: #0b1220; \n    box-shadow: 0 6px 16px rgba(0,0,0,0.35); \n    user-select: none; \n    cursor: move; \n    z-index: 10; \n    overflow: visible;\n}\n\n.node.selected {\n    box-shadow: 0 6px 16px rgba(0,0,0,0.35), 0 0 0 2px #22c55e;\n}\n\n.node-head{ \n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 2px 6px;\n    height: 24px;\n    border-top-left-radius: 8px;\n    border-top-right-radius: 8px;\n}\n\n/* Original Jack Styles */\n.jack { \n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    border: 2px solid #1f2937;\n    cursor: pointer; \n    position: absolute; \n    z-index: 20;\n}\n\n.jack-audio { \n    background: #10b981;\n}\n\n.jack-ctrl { \n    background: #9333ea;\n}\n\n.jack-armed { \n    box-shadow: 0 0 0 2px #22d3ee inset;\n}\n\n.jack-label { \n    position: absolute; \n    font-size: 10px; \n    white-space: nowrap; \n    pointer-events: none; \n    color: #cbd5e1;\n}\n\n/* Cable styles */\n.cables { \n    position: absolute; \n    left: 0; \n    top: 0; \n    z-index: 30;\n}\n\n.cable-hit { \n    cursor: pointer;\n}\n\n.cable-selected { \n    filter: drop-shadow(0 0 2px #22c55e);\n}\n\n.cable:hover {\n    opacity: 1 !important;\n    stroke-width: 3px;\n}\n\n/* Delete button styles */\n.delete-btn:hover rect {\n    opacity: 1;\n    fill: #374151;\n    stroke: #6b7280;\n}\n\n.delete-btn:hover text {\n    fill: #ffffff;\n}\n\n.delete-btn:active rect {\n    fill: #4b5563;\n}\n\n/* Toolbar button updates */\n.toolbar button {\n    font-size: 12px;\n    padding: 6px 8px;\n    border-radius: 8px;\n    border: 0;\n}\n\n.toolbar button.primary {\n    background: #22c55e;\n    color: #052e16;\n    font-weight: 800;\n}\n\n/* Scrollbar styling for better visibility */\n::-webkit-scrollbar {\n    width: 12px;\n    height: 12px;\n}\n\n::-webkit-scrollbar-track {\n    background: #1f2937;\n    border-radius: 6px;\n}\n\n::-webkit-scrollbar-thumb {\n    background: #4b5563;\n    border-radius: 6px;\n    border: 2px solid #1f2937;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: #6b7280;\n}\n\n::-webkit-scrollbar-corner {\n    background: #1f2937;\n}\n\n/* For Firefox */\n* {\n    scrollbar-width: auto;\n    scrollbar-color: #4b5563 #1f2937;\n}\n\n/* Modal Styles for WavetableEditor and other modals */\n.modal-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 1);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 1000;\n}\n\n.modal-content {\n    background: #1e293b;\n    border-radius: 12px;\n    padding: 20px;\n    max-width: 90vw;\n    max-height: 90vh;\n    overflow-y: auto;\n    position: relative;\n}\n\n.modal-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 20px;\n    padding-bottom: 10px;\n    border-bottom: 1px solid #334155;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #f1f5f9;\n}\n\n.close-btn {\n    background: transparent;\n    border: none;\n    color: #94a3b8;\n    font-size: 24px;\n    cursor: pointer;\n    padding: 4px 8px;\n    transition: color 0.2s;\n}\n\n.close-btn:hover {\n    color: #f1f5f9;\n}",""]);const i=r},287:(e,n)=>{var t=Symbol.for("react.element"),a=Symbol.for("react.portal"),o=Symbol.for("react.fragment"),c=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),l=Symbol.for("react.context"),s=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),p=Symbol.for("react.lazy"),f=Symbol.iterator,m={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},_=Object.assign,g={};function h(e,n,t){this.props=e,this.context=n,this.refs=g,this.updater=t||m}function v(){}function b(e,n,t){this.props=e,this.context=n,this.refs=g,this.updater=t||m}h.prototype.isReactComponent={},h.prototype.setState=function(e,n){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,n,"setState")},h.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},v.prototype=h.prototype;var y=b.prototype=new v;y.constructor=b,_(y,h.prototype),y.isPureReactComponent=!0;var k=Array.isArray,x=Object.prototype.hasOwnProperty,S={current:null},E={key:!0,ref:!0,__self:!0,__source:!0};function P(e,n,a){var o,c={},r=null,i=null;if(null!=n)for(o in void 0!==n.ref&&(i=n.ref),void 0!==n.key&&(r=""+n.key),n)x.call(n,o)&&!E.hasOwnProperty(o)&&(c[o]=n[o]);var l=arguments.length-2;if(1===l)c.children=a;else if(1<l){for(var s=Array(l),u=0;u<l;u++)s[u]=arguments[u+2];c.children=s}if(e&&e.defaultProps)for(o in l=e.defaultProps)void 0===c[o]&&(c[o]=l[o]);return{$$typeof:t,type:e,key:r,ref:i,props:c,_owner:S.current}}function w(e){return"object"==typeof e&&null!==e&&e.$$typeof===t}var C=/\/+/g;function I(e,n){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var n={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(e){return n[e]})}(""+e.key):n.toString(36)}function R(e,n,o,c,r){var i=typeof e;"undefined"!==i&&"boolean"!==i||(e=null);var l=!1;if(null===e)l=!0;else switch(i){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case t:case a:l=!0}}if(l)return r=r(l=e),e=""===c?"."+I(l,0):c,k(r)?(o="",null!=e&&(o=e.replace(C,"$&/")+"/"),R(r,n,o,"",function(e){return e})):null!=r&&(w(r)&&(r=function(e,n){return{$$typeof:t,type:e.type,key:n,ref:e.ref,props:e.props,_owner:e._owner}}(r,o+(!r.key||l&&l.key===r.key?"":(""+r.key).replace(C,"$&/")+"/")+e)),n.push(r)),1;if(l=0,c=""===c?".":c+":",k(e))for(var s=0;s<e.length;s++){var u=c+I(i=e[s],s);l+=R(i,n,o,u,r)}else if(u=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=f&&e[f]||e["@@iterator"])?e:null}(e),"function"==typeof u)for(e=u.call(e),s=0;!(i=e.next()).done;)l+=R(i=i.value,n,o,u=c+I(i,s++),r);else if("object"===i)throw n=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===n?"object with keys {"+Object.keys(e).join(", ")+"}":n)+"). If you meant to render a collection of children, use an array instead.");return l}function L(e,n,t){if(null==e)return e;var a=[],o=0;return R(e,a,"","",function(e){return n.call(t,e,o++)}),a}function M(e){if(-1===e._status){var n=e._result;(n=n()).then(function(n){0!==e._status&&-1!==e._status||(e._status=1,e._result=n)},function(n){0!==e._status&&-1!==e._status||(e._status=2,e._result=n)}),-1===e._status&&(e._status=0,e._result=n)}if(1===e._status)return e._result.default;throw e._result}var D={current:null},A={transition:null},O={ReactCurrentDispatcher:D,ReactCurrentBatchConfig:A,ReactCurrentOwner:S};function B(){throw Error("act(...) is not supported in production builds of React.")}n.Children={map:L,forEach:function(e,n,t){L(e,function(){n.apply(this,arguments)},t)},count:function(e){var n=0;return L(e,function(){n++}),n},toArray:function(e){return L(e,function(e){return e})||[]},only:function(e){if(!w(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},n.Component=h,n.Fragment=o,n.Profiler=r,n.PureComponent=b,n.StrictMode=c,n.Suspense=u,n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=O,n.act=B,n.cloneElement=function(e,n,a){if(null==e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var o=_({},e.props),c=e.key,r=e.ref,i=e._owner;if(null!=n){if(void 0!==n.ref&&(r=n.ref,i=S.current),void 0!==n.key&&(c=""+n.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(s in n)x.call(n,s)&&!E.hasOwnProperty(s)&&(o[s]=void 0===n[s]&&void 0!==l?l[s]:n[s])}var s=arguments.length-2;if(1===s)o.children=a;else if(1<s){l=Array(s);for(var u=0;u<s;u++)l[u]=arguments[u+2];o.children=l}return{$$typeof:t,type:e.type,key:c,ref:r,props:o,_owner:i}},n.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:i,_context:e},e.Consumer=e},n.createElement=P,n.createFactory=function(e){var n=P.bind(null,e);return n.type=e,n},n.createRef=function(){return{current:null}},n.forwardRef=function(e){return{$$typeof:s,render:e}},n.isValidElement=w,n.lazy=function(e){return{$$typeof:p,_payload:{_status:-1,_result:e},_init:M}},n.memo=function(e,n){return{$$typeof:d,type:e,compare:void 0===n?null:n}},n.startTransition=function(e){var n=A.transition;A.transition={};try{e()}finally{A.transition=n}},n.unstable_act=B,n.useCallback=function(e,n){return D.current.useCallback(e,n)},n.useContext=function(e){return D.current.useContext(e)},n.useDebugValue=function(){},n.useDeferredValue=function(e){return D.current.useDeferredValue(e)},n.useEffect=function(e,n){return D.current.useEffect(e,n)},n.useId=function(){return D.current.useId()},n.useImperativeHandle=function(e,n,t){return D.current.useImperativeHandle(e,n,t)},n.useInsertionEffect=function(e,n){return D.current.useInsertionEffect(e,n)},n.useLayoutEffect=function(e,n){return D.current.useLayoutEffect(e,n)},n.useMemo=function(e,n){return D.current.useMemo(e,n)},n.useReducer=function(e,n,t){return D.current.useReducer(e,n,t)},n.useRef=function(e){return D.current.useRef(e)},n.useState=function(e){return D.current.useState(e)},n.useSyncExternalStore=function(e,n,t){return D.current.useSyncExternalStore(e,n,t)},n.useTransition=function(){return D.current.useTransition()},n.version="18.3.1"},314:e=>{e.exports=function(e){var n=[];return n.toString=function(){return this.map(function(n){var t="",a=void 0!==n[5];return n[4]&&(t+="@supports (".concat(n[4],") {")),n[2]&&(t+="@media ".concat(n[2]," {")),a&&(t+="@layer".concat(n[5].length>0?" ".concat(n[5]):""," {")),t+=e(n),a&&(t+="}"),n[2]&&(t+="}"),n[4]&&(t+="}"),t}).join("")},n.i=function(e,t,a,o,c){"string"==typeof e&&(e=[[null,e,void 0]]);var r={};if(a)for(var i=0;i<this.length;i++){var l=this[i][0];null!=l&&(r[l]=!0)}for(var s=0;s<e.length;s++){var u=[].concat(e[s]);a&&r[u[0]]||(void 0!==c&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=c),t&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=t):u[2]=t),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),n.push(u))}},n}},338:(e,n,t)=>{var a=t(961);n.createRoot=a.createRoot,n.hydrateRoot=a.hydrateRoot},463:(e,n)=>{function t(e,n){var t=e.length;e.push(n);e:for(;0<t;){var a=t-1>>>1,o=e[a];if(!(0<c(o,n)))break e;e[a]=n,e[t]=o,t=a}}function a(e){return 0===e.length?null:e[0]}function o(e){if(0===e.length)return null;var n=e[0],t=e.pop();if(t!==n){e[0]=t;e:for(var a=0,o=e.length,r=o>>>1;a<r;){var i=2*(a+1)-1,l=e[i],s=i+1,u=e[s];if(0>c(l,t))s<o&&0>c(u,l)?(e[a]=u,e[s]=t,a=s):(e[a]=l,e[i]=t,a=i);else{if(!(s<o&&0>c(u,t)))break e;e[a]=u,e[s]=t,a=s}}}return n}function c(e,n){var t=e.sortIndex-n.sortIndex;return 0!==t?t:e.id-n.id}if("object"==typeof performance&&"function"==typeof performance.now){var r=performance;n.unstable_now=function(){return r.now()}}else{var i=Date,l=i.now();n.unstable_now=function(){return i.now()-l}}var s=[],u=[],d=1,p=null,f=3,m=!1,_=!1,g=!1,h="function"==typeof setTimeout?setTimeout:null,v="function"==typeof clearTimeout?clearTimeout:null,b="undefined"!=typeof setImmediate?setImmediate:null;function y(e){for(var n=a(u);null!==n;){if(null===n.callback)o(u);else{if(!(n.startTime<=e))break;o(u),n.sortIndex=n.expirationTime,t(s,n)}n=a(u)}}function k(e){if(g=!1,y(e),!_)if(null!==a(s))_=!0,A(x);else{var n=a(u);null!==n&&O(k,n.startTime-e)}}function x(e,t){_=!1,g&&(g=!1,v(w),w=-1),m=!0;var c=f;try{for(y(t),p=a(s);null!==p&&(!(p.expirationTime>t)||e&&!R());){var r=p.callback;if("function"==typeof r){p.callback=null,f=p.priorityLevel;var i=r(p.expirationTime<=t);t=n.unstable_now(),"function"==typeof i?p.callback=i:p===a(s)&&o(s),y(t)}else o(s);p=a(s)}if(null!==p)var l=!0;else{var d=a(u);null!==d&&O(k,d.startTime-t),l=!1}return l}finally{p=null,f=c,m=!1}}"undefined"!=typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,E=!1,P=null,w=-1,C=5,I=-1;function R(){return!(n.unstable_now()-I<C)}function L(){if(null!==P){var e=n.unstable_now();I=e;var t=!0;try{t=P(!0,e)}finally{t?S():(E=!1,P=null)}}else E=!1}if("function"==typeof b)S=function(){b(L)};else if("undefined"!=typeof MessageChannel){var M=new MessageChannel,D=M.port2;M.port1.onmessage=L,S=function(){D.postMessage(null)}}else S=function(){h(L,0)};function A(e){P=e,E||(E=!0,S())}function O(e,t){w=h(function(){e(n.unstable_now())},t)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(e){e.callback=null},n.unstable_continueExecution=function(){_||m||(_=!0,A(x))},n.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):C=0<e?Math.floor(1e3/e):5},n.unstable_getCurrentPriorityLevel=function(){return f},n.unstable_getFirstCallbackNode=function(){return a(s)},n.unstable_next=function(e){switch(f){case 1:case 2:case 3:var n=3;break;default:n=f}var t=f;f=n;try{return e()}finally{f=t}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(e,n){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var t=f;f=e;try{return n()}finally{f=t}},n.unstable_scheduleCallback=function(e,o,c){var r=n.unstable_now();switch(c="object"==typeof c&&null!==c&&"number"==typeof(c=c.delay)&&0<c?r+c:r,e){case 1:var i=-1;break;case 2:i=250;break;case 5:i=1073741823;break;case 4:i=1e4;break;default:i=5e3}return e={id:d++,callback:o,priorityLevel:e,startTime:c,expirationTime:i=c+i,sortIndex:-1},c>r?(e.sortIndex=c,t(u,e),null===a(s)&&e===a(u)&&(g?(v(w),w=-1):g=!0,O(k,c-r))):(e.sortIndex=i,t(s,e),_||m||(_=!0,A(x))),e},n.unstable_shouldYield=R,n.unstable_wrapCallback=function(e){var n=f;return function(){var t=f;f=n;try{return e.apply(this,arguments)}finally{f=t}}}},540:(e,n,t)=>{e.exports=t(287)},551:(e,n,t)=>{var a=t(540),o=t(982);function c(e){for(var n="https://reactjs.org/docs/error-decoder.html?invariant="+e,t=1;t<arguments.length;t++)n+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+e+"; visit "+n+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var r=new Set,i={};function l(e,n){s(e,n),s(e+"Capture",n)}function s(e,n){for(i[e]=n,e=0;e<n.length;e++)r.add(n[e])}var u=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement),d=Object.prototype.hasOwnProperty,p=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,f={},m={};function _(e,n,t,a,o,c,r){this.acceptsBooleans=2===n||3===n||4===n,this.attributeName=a,this.attributeNamespace=o,this.mustUseProperty=t,this.propertyName=e,this.type=n,this.sanitizeURL=c,this.removeEmptyString=r}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){g[e]=new _(e,0,!1,e,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var n=e[0];g[n]=new _(n,1,!1,e[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(e){g[e]=new _(e,2,!1,e.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){g[e]=new _(e,2,!1,e,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){g[e]=new _(e,3,!1,e.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(e){g[e]=new _(e,3,!0,e,null,!1,!1)}),["capture","download"].forEach(function(e){g[e]=new _(e,4,!1,e,null,!1,!1)}),["cols","rows","size","span"].forEach(function(e){g[e]=new _(e,6,!1,e,null,!1,!1)}),["rowSpan","start"].forEach(function(e){g[e]=new _(e,5,!1,e.toLowerCase(),null,!1,!1)});var h=/[\-:]([a-z])/g;function v(e){return e[1].toUpperCase()}function b(e,n,t,a){var o=g.hasOwnProperty(n)?g[n]:null;(null!==o?0!==o.type:a||!(2<n.length)||"o"!==n[0]&&"O"!==n[0]||"n"!==n[1]&&"N"!==n[1])&&(function(e,n,t,a){if(null==n||function(e,n,t,a){if(null!==t&&0===t.type)return!1;switch(typeof n){case"function":case"symbol":return!0;case"boolean":return!a&&(null!==t?!t.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,n,t,a))return!0;if(a)return!1;if(null!==t)switch(t.type){case 3:return!n;case 4:return!1===n;case 5:return isNaN(n);case 6:return isNaN(n)||1>n}return!1}(n,t,o,a)&&(t=null),a||null===o?function(e){return!!d.call(m,e)||!d.call(f,e)&&(p.test(e)?m[e]=!0:(f[e]=!0,!1))}(n)&&(null===t?e.removeAttribute(n):e.setAttribute(n,""+t)):o.mustUseProperty?e[o.propertyName]=null===t?3!==o.type&&"":t:(n=o.attributeName,a=o.attributeNamespace,null===t?e.removeAttribute(n):(t=3===(o=o.type)||4===o&&!0===t?"":""+t,a?e.setAttributeNS(a,n,t):e.setAttribute(n,t))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var n=e.replace(h,v);g[n]=new _(n,1,!1,e,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var n=e.replace(h,v);g[n]=new _(n,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(e){var n=e.replace(h,v);g[n]=new _(n,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(e){g[e]=new _(e,1,!1,e.toLowerCase(),null,!1,!1)}),g.xlinkHref=new _("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(e){g[e]=new _(e,1,!1,e.toLowerCase(),null,!0,!0)});var y=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,k=Symbol.for("react.element"),x=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),E=Symbol.for("react.strict_mode"),P=Symbol.for("react.profiler"),w=Symbol.for("react.provider"),C=Symbol.for("react.context"),I=Symbol.for("react.forward_ref"),R=Symbol.for("react.suspense"),L=Symbol.for("react.suspense_list"),M=Symbol.for("react.memo"),D=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var A=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var O=Symbol.iterator;function B(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=O&&e[O]||e["@@iterator"])?e:null}var T,F=Object.assign;function N(e){if(void 0===T)try{throw Error()}catch(e){var n=e.stack.trim().match(/\n( *(at )?)/);T=n&&n[1]||""}return"\n"+T+e}var z=!1;function G(e,n){if(!e||z)return"";z=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(n)if(n=function(){throw Error()},Object.defineProperty(n.prototype,"props",{set:function(){throw Error()}}),"object"==typeof Reflect&&Reflect.construct){try{Reflect.construct(n,[])}catch(e){var a=e}Reflect.construct(e,[],n)}else{try{n.call()}catch(e){a=e}e.call(n.prototype)}else{try{throw Error()}catch(e){a=e}e()}}catch(n){if(n&&a&&"string"==typeof n.stack){for(var o=n.stack.split("\n"),c=a.stack.split("\n"),r=o.length-1,i=c.length-1;1<=r&&0<=i&&o[r]!==c[i];)i--;for(;1<=r&&0<=i;r--,i--)if(o[r]!==c[i]){if(1!==r||1!==i)do{if(r--,0>--i||o[r]!==c[i]){var l="\n"+o[r].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}}while(1<=r&&0<=i);break}}}finally{z=!1,Error.prepareStackTrace=t}return(e=e?e.displayName||e.name:"")?N(e):""}function q(e){switch(e.tag){case 5:return N(e.type);case 16:return N("Lazy");case 13:return N("Suspense");case 19:return N("SuspenseList");case 0:case 2:case 15:return G(e.type,!1);case 11:return G(e.type.render,!1);case 1:return G(e.type,!0);default:return""}}function U(e){if(null==e)return null;if("function"==typeof e)return e.displayName||e.name||null;if("string"==typeof e)return e;switch(e){case S:return"Fragment";case x:return"Portal";case P:return"Profiler";case E:return"StrictMode";case R:return"Suspense";case L:return"SuspenseList"}if("object"==typeof e)switch(e.$$typeof){case C:return(e.displayName||"Context")+".Consumer";case w:return(e._context.displayName||"Context")+".Provider";case I:var n=e.render;return(e=e.displayName)||(e=""!==(e=n.displayName||n.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case M:return null!==(n=e.displayName||null)?n:U(e.type)||"Memo";case D:n=e._payload,e=e._init;try{return U(e(n))}catch(e){}}return null}function W(e){var n=e.type;switch(e.tag){case 24:return"Cache";case 9:return(n.displayName||"Context")+".Consumer";case 10:return(n._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=n.render).displayName||e.name||"",n.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return n;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return U(n);case 8:return n===E?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"==typeof n)return n.displayName||n.name||null;if("string"==typeof n)return n}return null}function V(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function H(e){var n=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===n||"radio"===n)}function j(e){e._valueTracker||(e._valueTracker=function(e){var n=H(e)?"checked":"value",t=Object.getOwnPropertyDescriptor(e.constructor.prototype,n),a=""+e[n];if(!e.hasOwnProperty(n)&&void 0!==t&&"function"==typeof t.get&&"function"==typeof t.set){var o=t.get,c=t.set;return Object.defineProperty(e,n,{configurable:!0,get:function(){return o.call(this)},set:function(e){a=""+e,c.call(this,e)}}),Object.defineProperty(e,n,{enumerable:t.enumerable}),{getValue:function(){return a},setValue:function(e){a=""+e},stopTracking:function(){e._valueTracker=null,delete e[n]}}}}(e))}function K(e){if(!e)return!1;var n=e._valueTracker;if(!n)return!0;var t=n.getValue(),a="";return e&&(a=H(e)?e.checked?"true":"false":e.value),(e=a)!==t&&(n.setValue(e),!0)}function Y(e){if(void 0===(e=e||("undefined"!=typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(n){return e.body}}function $(e,n){var t=n.checked;return F({},n,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=t?t:e._wrapperState.initialChecked})}function X(e,n){var t=null==n.defaultValue?"":n.defaultValue,a=null!=n.checked?n.checked:n.defaultChecked;t=V(null!=n.value?n.value:t),e._wrapperState={initialChecked:a,initialValue:t,controlled:"checkbox"===n.type||"radio"===n.type?null!=n.checked:null!=n.value}}function Z(e,n){null!=(n=n.checked)&&b(e,"checked",n,!1)}function Q(e,n){Z(e,n);var t=V(n.value),a=n.type;if(null!=t)"number"===a?(0===t&&""===e.value||e.value!=t)&&(e.value=""+t):e.value!==""+t&&(e.value=""+t);else if("submit"===a||"reset"===a)return void e.removeAttribute("value");n.hasOwnProperty("value")?ee(e,n.type,t):n.hasOwnProperty("defaultValue")&&ee(e,n.type,V(n.defaultValue)),null==n.checked&&null!=n.defaultChecked&&(e.defaultChecked=!!n.defaultChecked)}function J(e,n,t){if(n.hasOwnProperty("value")||n.hasOwnProperty("defaultValue")){var a=n.type;if(!("submit"!==a&&"reset"!==a||void 0!==n.value&&null!==n.value))return;n=""+e._wrapperState.initialValue,t||n===e.value||(e.value=n),e.defaultValue=n}""!==(t=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==t&&(e.name=t)}function ee(e,n,t){"number"===n&&Y(e.ownerDocument)===e||(null==t?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+t&&(e.defaultValue=""+t))}var ne=Array.isArray;function te(e,n,t,a){if(e=e.options,n){n={};for(var o=0;o<t.length;o++)n["$"+t[o]]=!0;for(t=0;t<e.length;t++)o=n.hasOwnProperty("$"+e[t].value),e[t].selected!==o&&(e[t].selected=o),o&&a&&(e[t].defaultSelected=!0)}else{for(t=""+V(t),n=null,o=0;o<e.length;o++){if(e[o].value===t)return e[o].selected=!0,void(a&&(e[o].defaultSelected=!0));null!==n||e[o].disabled||(n=e[o])}null!==n&&(n.selected=!0)}}function ae(e,n){if(null!=n.dangerouslySetInnerHTML)throw Error(c(91));return F({},n,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function oe(e,n){var t=n.value;if(null==t){if(t=n.children,n=n.defaultValue,null!=t){if(null!=n)throw Error(c(92));if(ne(t)){if(1<t.length)throw Error(c(93));t=t[0]}n=t}null==n&&(n=""),t=n}e._wrapperState={initialValue:V(t)}}function ce(e,n){var t=V(n.value),a=V(n.defaultValue);null!=t&&((t=""+t)!==e.value&&(e.value=t),null==n.defaultValue&&e.defaultValue!==t&&(e.defaultValue=t)),null!=a&&(e.defaultValue=""+a)}function re(e){var n=e.textContent;n===e._wrapperState.initialValue&&""!==n&&null!==n&&(e.value=n)}function ie(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function le(e,n){return null==e||"http://www.w3.org/1999/xhtml"===e?ie(n):"http://www.w3.org/2000/svg"===e&&"foreignObject"===n?"http://www.w3.org/1999/xhtml":e}var se,ue,de=(ue=function(e,n){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=n;else{for((se=se||document.createElement("div")).innerHTML="<svg>"+n.valueOf().toString()+"</svg>",n=se.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;n.firstChild;)e.appendChild(n.firstChild)}},"undefined"!=typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,n,t,a){MSApp.execUnsafeLocalFunction(function(){return ue(e,n)})}:ue);function pe(e,n){if(n){var t=e.firstChild;if(t&&t===e.lastChild&&3===t.nodeType)return void(t.nodeValue=n)}e.textContent=n}var fe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},me=["Webkit","ms","Moz","O"];function _e(e,n,t){return null==n||"boolean"==typeof n||""===n?"":t||"number"!=typeof n||0===n||fe.hasOwnProperty(e)&&fe[e]?(""+n).trim():n+"px"}function ge(e,n){for(var t in e=e.style,n)if(n.hasOwnProperty(t)){var a=0===t.indexOf("--"),o=_e(t,n[t],a);"float"===t&&(t="cssFloat"),a?e.setProperty(t,o):e[t]=o}}Object.keys(fe).forEach(function(e){me.forEach(function(n){n=n+e.charAt(0).toUpperCase()+e.substring(1),fe[n]=fe[e]})});var he=F({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ve(e,n){if(n){if(he[e]&&(null!=n.children||null!=n.dangerouslySetInnerHTML))throw Error(c(137,e));if(null!=n.dangerouslySetInnerHTML){if(null!=n.children)throw Error(c(60));if("object"!=typeof n.dangerouslySetInnerHTML||!("__html"in n.dangerouslySetInnerHTML))throw Error(c(61))}if(null!=n.style&&"object"!=typeof n.style)throw Error(c(62))}}function be(e,n){if(-1===e.indexOf("-"))return"string"==typeof n.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ye=null;function ke(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var xe=null,Se=null,Ee=null;function Pe(e){if(e=yo(e)){if("function"!=typeof xe)throw Error(c(280));var n=e.stateNode;n&&(n=xo(n),xe(e.stateNode,e.type,n))}}function we(e){Se?Ee?Ee.push(e):Ee=[e]:Se=e}function Ce(){if(Se){var e=Se,n=Ee;if(Ee=Se=null,Pe(e),n)for(e=0;e<n.length;e++)Pe(n[e])}}function Ie(e,n){return e(n)}function Re(){}var Le=!1;function Me(e,n,t){if(Le)return e(n,t);Le=!0;try{return Ie(e,n,t)}finally{Le=!1,(null!==Se||null!==Ee)&&(Re(),Ce())}}function De(e,n){var t=e.stateNode;if(null===t)return null;var a=xo(t);if(null===a)return null;t=a[n];e:switch(n){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(a=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!a;break e;default:e=!1}if(e)return null;if(t&&"function"!=typeof t)throw Error(c(231,n,typeof t));return t}var Ae=!1;if(u)try{var Oe={};Object.defineProperty(Oe,"passive",{get:function(){Ae=!0}}),window.addEventListener("test",Oe,Oe),window.removeEventListener("test",Oe,Oe)}catch(ue){Ae=!1}function Be(e,n,t,a,o,c,r,i,l){var s=Array.prototype.slice.call(arguments,3);try{n.apply(t,s)}catch(e){this.onError(e)}}var Te=!1,Fe=null,Ne=!1,ze=null,Ge={onError:function(e){Te=!0,Fe=e}};function qe(e,n,t,a,o,c,r,i,l){Te=!1,Fe=null,Be.apply(Ge,arguments)}function Ue(e){var n=e,t=e;if(e.alternate)for(;n.return;)n=n.return;else{e=n;do{!!(4098&(n=e).flags)&&(t=n.return),e=n.return}while(e)}return 3===n.tag?t:null}function We(e){if(13===e.tag){var n=e.memoizedState;if(null===n&&null!==(e=e.alternate)&&(n=e.memoizedState),null!==n)return n.dehydrated}return null}function Ve(e){if(Ue(e)!==e)throw Error(c(188))}function He(e){return null!==(e=function(e){var n=e.alternate;if(!n){if(null===(n=Ue(e)))throw Error(c(188));return n!==e?null:e}for(var t=e,a=n;;){var o=t.return;if(null===o)break;var r=o.alternate;if(null===r){if(null!==(a=o.return)){t=a;continue}break}if(o.child===r.child){for(r=o.child;r;){if(r===t)return Ve(o),e;if(r===a)return Ve(o),n;r=r.sibling}throw Error(c(188))}if(t.return!==a.return)t=o,a=r;else{for(var i=!1,l=o.child;l;){if(l===t){i=!0,t=o,a=r;break}if(l===a){i=!0,a=o,t=r;break}l=l.sibling}if(!i){for(l=r.child;l;){if(l===t){i=!0,t=r,a=o;break}if(l===a){i=!0,a=r,t=o;break}l=l.sibling}if(!i)throw Error(c(189))}}if(t.alternate!==a)throw Error(c(190))}if(3!==t.tag)throw Error(c(188));return t.stateNode.current===t?e:n}(e))?je(e):null}function je(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var n=je(e);if(null!==n)return n;e=e.sibling}return null}var Ke=o.unstable_scheduleCallback,Ye=o.unstable_cancelCallback,$e=o.unstable_shouldYield,Xe=o.unstable_requestPaint,Ze=o.unstable_now,Qe=o.unstable_getCurrentPriorityLevel,Je=o.unstable_ImmediatePriority,en=o.unstable_UserBlockingPriority,nn=o.unstable_NormalPriority,tn=o.unstable_LowPriority,an=o.unstable_IdlePriority,on=null,cn=null,rn=Math.clz32?Math.clz32:function(e){return 0===(e>>>=0)?32:31-(ln(e)/sn|0)|0},ln=Math.log,sn=Math.LN2,un=64,dn=4194304;function pn(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function fn(e,n){var t=e.pendingLanes;if(0===t)return 0;var a=0,o=e.suspendedLanes,c=e.pingedLanes,r=268435455&t;if(0!==r){var i=r&~o;0!==i?a=pn(i):0!==(c&=r)&&(a=pn(c))}else 0!==(r=t&~o)?a=pn(r):0!==c&&(a=pn(c));if(0===a)return 0;if(0!==n&&n!==a&&0===(n&o)&&((o=a&-a)>=(c=n&-n)||16===o&&4194240&c))return n;if(4&a&&(a|=16&t),0!==(n=e.entangledLanes))for(e=e.entanglements,n&=a;0<n;)o=1<<(t=31-rn(n)),a|=e[t],n&=~o;return a}function mn(e,n){switch(e){case 1:case 2:case 4:return n+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return n+5e3;default:return-1}}function _n(e){return 0!=(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function gn(){var e=un;return!(4194240&(un<<=1))&&(un=64),e}function hn(e){for(var n=[],t=0;31>t;t++)n.push(e);return n}function vn(e,n,t){e.pendingLanes|=n,536870912!==n&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[n=31-rn(n)]=t}function bn(e,n){var t=e.entangledLanes|=n;for(e=e.entanglements;t;){var a=31-rn(t),o=1<<a;o&n|e[a]&n&&(e[a]|=n),t&=~o}}var yn=0;function kn(e){return 1<(e&=-e)?4<e?268435455&e?16:536870912:4:1}var xn,Sn,En,Pn,wn,Cn=!1,In=[],Rn=null,Ln=null,Mn=null,Dn=new Map,An=new Map,On=[],Bn="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Tn(e,n){switch(e){case"focusin":case"focusout":Rn=null;break;case"dragenter":case"dragleave":Ln=null;break;case"mouseover":case"mouseout":Mn=null;break;case"pointerover":case"pointerout":Dn.delete(n.pointerId);break;case"gotpointercapture":case"lostpointercapture":An.delete(n.pointerId)}}function Fn(e,n,t,a,o,c){return null===e||e.nativeEvent!==c?(e={blockedOn:n,domEventName:t,eventSystemFlags:a,nativeEvent:c,targetContainers:[o]},null!==n&&null!==(n=yo(n))&&Sn(n),e):(e.eventSystemFlags|=a,n=e.targetContainers,null!==o&&-1===n.indexOf(o)&&n.push(o),e)}function Nn(e){var n=bo(e.target);if(null!==n){var t=Ue(n);if(null!==t)if(13===(n=t.tag)){if(null!==(n=We(t)))return e.blockedOn=n,void wn(e.priority,function(){En(t)})}else if(3===n&&t.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===t.tag?t.stateNode.containerInfo:null)}e.blockedOn=null}function zn(e){if(null!==e.blockedOn)return!1;for(var n=e.targetContainers;0<n.length;){var t=Xn(e.domEventName,e.eventSystemFlags,n[0],e.nativeEvent);if(null!==t)return null!==(n=yo(t))&&Sn(n),e.blockedOn=t,!1;var a=new(t=e.nativeEvent).constructor(t.type,t);ye=a,t.target.dispatchEvent(a),ye=null,n.shift()}return!0}function Gn(e,n,t){zn(e)&&t.delete(n)}function qn(){Cn=!1,null!==Rn&&zn(Rn)&&(Rn=null),null!==Ln&&zn(Ln)&&(Ln=null),null!==Mn&&zn(Mn)&&(Mn=null),Dn.forEach(Gn),An.forEach(Gn)}function Un(e,n){e.blockedOn===n&&(e.blockedOn=null,Cn||(Cn=!0,o.unstable_scheduleCallback(o.unstable_NormalPriority,qn)))}function Wn(e){function n(n){return Un(n,e)}if(0<In.length){Un(In[0],e);for(var t=1;t<In.length;t++){var a=In[t];a.blockedOn===e&&(a.blockedOn=null)}}for(null!==Rn&&Un(Rn,e),null!==Ln&&Un(Ln,e),null!==Mn&&Un(Mn,e),Dn.forEach(n),An.forEach(n),t=0;t<On.length;t++)(a=On[t]).blockedOn===e&&(a.blockedOn=null);for(;0<On.length&&null===(t=On[0]).blockedOn;)Nn(t),null===t.blockedOn&&On.shift()}var Vn=y.ReactCurrentBatchConfig,Hn=!0;function jn(e,n,t,a){var o=yn,c=Vn.transition;Vn.transition=null;try{yn=1,Yn(e,n,t,a)}finally{yn=o,Vn.transition=c}}function Kn(e,n,t,a){var o=yn,c=Vn.transition;Vn.transition=null;try{yn=4,Yn(e,n,t,a)}finally{yn=o,Vn.transition=c}}function Yn(e,n,t,a){if(Hn){var o=Xn(e,n,t,a);if(null===o)Va(e,n,a,$n,t),Tn(e,a);else if(function(e,n,t,a,o){switch(n){case"focusin":return Rn=Fn(Rn,e,n,t,a,o),!0;case"dragenter":return Ln=Fn(Ln,e,n,t,a,o),!0;case"mouseover":return Mn=Fn(Mn,e,n,t,a,o),!0;case"pointerover":var c=o.pointerId;return Dn.set(c,Fn(Dn.get(c)||null,e,n,t,a,o)),!0;case"gotpointercapture":return c=o.pointerId,An.set(c,Fn(An.get(c)||null,e,n,t,a,o)),!0}return!1}(o,e,n,t,a))a.stopPropagation();else if(Tn(e,a),4&n&&-1<Bn.indexOf(e)){for(;null!==o;){var c=yo(o);if(null!==c&&xn(c),null===(c=Xn(e,n,t,a))&&Va(e,n,a,$n,t),c===o)break;o=c}null!==o&&a.stopPropagation()}else Va(e,n,a,null,t)}}var $n=null;function Xn(e,n,t,a){if($n=null,null!==(e=bo(e=ke(a))))if(null===(n=Ue(e)))e=null;else if(13===(t=n.tag)){if(null!==(e=We(n)))return e;e=null}else if(3===t){if(n.stateNode.current.memoizedState.isDehydrated)return 3===n.tag?n.stateNode.containerInfo:null;e=null}else n!==e&&(e=null);return $n=e,null}function Zn(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Qe()){case Je:return 1;case en:return 4;case nn:case tn:return 16;case an:return 536870912;default:return 16}default:return 16}}var Qn=null,Jn=null,et=null;function nt(){if(et)return et;var e,n,t=Jn,a=t.length,o="value"in Qn?Qn.value:Qn.textContent,c=o.length;for(e=0;e<a&&t[e]===o[e];e++);var r=a-e;for(n=1;n<=r&&t[a-n]===o[c-n];n++);return et=o.slice(e,1<n?1-n:void 0)}function tt(e){var n=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===n&&(e=13):e=n,10===e&&(e=13),32<=e||13===e?e:0}function at(){return!0}function ot(){return!1}function ct(e){function n(n,t,a,o,c){for(var r in this._reactName=n,this._targetInst=a,this.type=t,this.nativeEvent=o,this.target=c,this.currentTarget=null,e)e.hasOwnProperty(r)&&(n=e[r],this[r]=n?n(o):o[r]);return this.isDefaultPrevented=(null!=o.defaultPrevented?o.defaultPrevented:!1===o.returnValue)?at:ot,this.isPropagationStopped=ot,this}return F(n.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!=typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=at)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!=typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=at)},persist:function(){},isPersistent:at}),n}var rt,it,lt,st={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},ut=ct(st),dt=F({},st,{view:0,detail:0}),pt=ct(dt),ft=F({},dt,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Pt,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==lt&&(lt&&"mousemove"===e.type?(rt=e.screenX-lt.screenX,it=e.screenY-lt.screenY):it=rt=0,lt=e),rt)},movementY:function(e){return"movementY"in e?e.movementY:it}}),mt=ct(ft),_t=ct(F({},ft,{dataTransfer:0})),gt=ct(F({},dt,{relatedTarget:0})),ht=ct(F({},st,{animationName:0,elapsedTime:0,pseudoElement:0})),vt=F({},st,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),bt=ct(vt),yt=ct(F({},st,{data:0})),kt={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},xt={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},St={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Et(e){var n=this.nativeEvent;return n.getModifierState?n.getModifierState(e):!!(e=St[e])&&!!n[e]}function Pt(){return Et}var wt=F({},dt,{key:function(e){if(e.key){var n=kt[e.key]||e.key;if("Unidentified"!==n)return n}return"keypress"===e.type?13===(e=tt(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?xt[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Pt,charCode:function(e){return"keypress"===e.type?tt(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tt(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Ct=ct(wt),It=ct(F({},ft,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Rt=ct(F({},dt,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Pt})),Lt=ct(F({},st,{propertyName:0,elapsedTime:0,pseudoElement:0})),Mt=F({},ft,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Dt=ct(Mt),At=[9,13,27,32],Ot=u&&"CompositionEvent"in window,Bt=null;u&&"documentMode"in document&&(Bt=document.documentMode);var Tt=u&&"TextEvent"in window&&!Bt,Ft=u&&(!Ot||Bt&&8<Bt&&11>=Bt),Nt=String.fromCharCode(32),zt=!1;function Gt(e,n){switch(e){case"keyup":return-1!==At.indexOf(n.keyCode);case"keydown":return 229!==n.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function qt(e){return"object"==typeof(e=e.detail)&&"data"in e?e.data:null}var Ut=!1,Wt={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Vt(e){var n=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===n?!!Wt[e.type]:"textarea"===n}function Ht(e,n,t,a){we(a),0<(n=ja(n,"onChange")).length&&(t=new ut("onChange","change",null,t,a),e.push({event:t,listeners:n}))}var jt=null,Kt=null;function Yt(e){Na(e,0)}function $t(e){if(K(ko(e)))return e}function Xt(e,n){if("change"===e)return n}var Zt=!1;if(u){var Qt;if(u){var Jt="oninput"in document;if(!Jt){var ea=document.createElement("div");ea.setAttribute("oninput","return;"),Jt="function"==typeof ea.oninput}Qt=Jt}else Qt=!1;Zt=Qt&&(!document.documentMode||9<document.documentMode)}function na(){jt&&(jt.detachEvent("onpropertychange",ta),Kt=jt=null)}function ta(e){if("value"===e.propertyName&&$t(Kt)){var n=[];Ht(n,Kt,e,ke(e)),Me(Yt,n)}}function aa(e,n,t){"focusin"===e?(na(),Kt=t,(jt=n).attachEvent("onpropertychange",ta)):"focusout"===e&&na()}function oa(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return $t(Kt)}function ca(e,n){if("click"===e)return $t(n)}function ra(e,n){if("input"===e||"change"===e)return $t(n)}var ia="function"==typeof Object.is?Object.is:function(e,n){return e===n&&(0!==e||1/e==1/n)||e!=e&&n!=n};function la(e,n){if(ia(e,n))return!0;if("object"!=typeof e||null===e||"object"!=typeof n||null===n)return!1;var t=Object.keys(e),a=Object.keys(n);if(t.length!==a.length)return!1;for(a=0;a<t.length;a++){var o=t[a];if(!d.call(n,o)||!ia(e[o],n[o]))return!1}return!0}function sa(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ua(e,n){var t,a=sa(e);for(e=0;a;){if(3===a.nodeType){if(t=e+a.textContent.length,e<=n&&t>=n)return{node:a,offset:n-e};e=t}e:{for(;a;){if(a.nextSibling){a=a.nextSibling;break e}a=a.parentNode}a=void 0}a=sa(a)}}function da(e,n){return!(!e||!n)&&(e===n||(!e||3!==e.nodeType)&&(n&&3===n.nodeType?da(e,n.parentNode):"contains"in e?e.contains(n):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(n))))}function pa(){for(var e=window,n=Y();n instanceof e.HTMLIFrameElement;){try{var t="string"==typeof n.contentWindow.location.href}catch(e){t=!1}if(!t)break;n=Y((e=n.contentWindow).document)}return n}function fa(e){var n=e&&e.nodeName&&e.nodeName.toLowerCase();return n&&("input"===n&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===n||"true"===e.contentEditable)}function ma(e){var n=pa(),t=e.focusedElem,a=e.selectionRange;if(n!==t&&t&&t.ownerDocument&&da(t.ownerDocument.documentElement,t)){if(null!==a&&fa(t))if(n=a.start,void 0===(e=a.end)&&(e=n),"selectionStart"in t)t.selectionStart=n,t.selectionEnd=Math.min(e,t.value.length);else if((e=(n=t.ownerDocument||document)&&n.defaultView||window).getSelection){e=e.getSelection();var o=t.textContent.length,c=Math.min(a.start,o);a=void 0===a.end?c:Math.min(a.end,o),!e.extend&&c>a&&(o=a,a=c,c=o),o=ua(t,c);var r=ua(t,a);o&&r&&(1!==e.rangeCount||e.anchorNode!==o.node||e.anchorOffset!==o.offset||e.focusNode!==r.node||e.focusOffset!==r.offset)&&((n=n.createRange()).setStart(o.node,o.offset),e.removeAllRanges(),c>a?(e.addRange(n),e.extend(r.node,r.offset)):(n.setEnd(r.node,r.offset),e.addRange(n)))}for(n=[],e=t;e=e.parentNode;)1===e.nodeType&&n.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"==typeof t.focus&&t.focus(),t=0;t<n.length;t++)(e=n[t]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var _a=u&&"documentMode"in document&&11>=document.documentMode,ga=null,ha=null,va=null,ba=!1;function ya(e,n,t){var a=t.window===t?t.document:9===t.nodeType?t:t.ownerDocument;ba||null==ga||ga!==Y(a)||(a="selectionStart"in(a=ga)&&fa(a)?{start:a.selectionStart,end:a.selectionEnd}:{anchorNode:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset},va&&la(va,a)||(va=a,0<(a=ja(ha,"onSelect")).length&&(n=new ut("onSelect","select",null,n,t),e.push({event:n,listeners:a}),n.target=ga)))}function ka(e,n){var t={};return t[e.toLowerCase()]=n.toLowerCase(),t["Webkit"+e]="webkit"+n,t["Moz"+e]="moz"+n,t}var xa={animationend:ka("Animation","AnimationEnd"),animationiteration:ka("Animation","AnimationIteration"),animationstart:ka("Animation","AnimationStart"),transitionend:ka("Transition","TransitionEnd")},Sa={},Ea={};function Pa(e){if(Sa[e])return Sa[e];if(!xa[e])return e;var n,t=xa[e];for(n in t)if(t.hasOwnProperty(n)&&n in Ea)return Sa[e]=t[n];return e}u&&(Ea=document.createElement("div").style,"AnimationEvent"in window||(delete xa.animationend.animation,delete xa.animationiteration.animation,delete xa.animationstart.animation),"TransitionEvent"in window||delete xa.transitionend.transition);var wa=Pa("animationend"),Ca=Pa("animationiteration"),Ia=Pa("animationstart"),Ra=Pa("transitionend"),La=new Map,Ma="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Da(e,n){La.set(e,n),l(n,[e])}for(var Aa=0;Aa<Ma.length;Aa++){var Oa=Ma[Aa];Da(Oa.toLowerCase(),"on"+(Oa[0].toUpperCase()+Oa.slice(1)))}Da(wa,"onAnimationEnd"),Da(Ca,"onAnimationIteration"),Da(Ia,"onAnimationStart"),Da("dblclick","onDoubleClick"),Da("focusin","onFocus"),Da("focusout","onBlur"),Da(Ra,"onTransitionEnd"),s("onMouseEnter",["mouseout","mouseover"]),s("onMouseLeave",["mouseout","mouseover"]),s("onPointerEnter",["pointerout","pointerover"]),s("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Ba="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Ta=new Set("cancel close invalid load scroll toggle".split(" ").concat(Ba));function Fa(e,n,t){var a=e.type||"unknown-event";e.currentTarget=t,function(e,n,t,a,o,r,i,l,s){if(qe.apply(this,arguments),Te){if(!Te)throw Error(c(198));var u=Fe;Te=!1,Fe=null,Ne||(Ne=!0,ze=u)}}(a,n,void 0,e),e.currentTarget=null}function Na(e,n){n=!!(4&n);for(var t=0;t<e.length;t++){var a=e[t],o=a.event;a=a.listeners;e:{var c=void 0;if(n)for(var r=a.length-1;0<=r;r--){var i=a[r],l=i.instance,s=i.currentTarget;if(i=i.listener,l!==c&&o.isPropagationStopped())break e;Fa(o,i,s),c=l}else for(r=0;r<a.length;r++){if(l=(i=a[r]).instance,s=i.currentTarget,i=i.listener,l!==c&&o.isPropagationStopped())break e;Fa(o,i,s),c=l}}}if(Ne)throw e=ze,Ne=!1,ze=null,e}function za(e,n){var t=n[go];void 0===t&&(t=n[go]=new Set);var a=e+"__bubble";t.has(a)||(Wa(n,e,2,!1),t.add(a))}function Ga(e,n,t){var a=0;n&&(a|=4),Wa(t,e,a,n)}var qa="_reactListening"+Math.random().toString(36).slice(2);function Ua(e){if(!e[qa]){e[qa]=!0,r.forEach(function(n){"selectionchange"!==n&&(Ta.has(n)||Ga(n,!1,e),Ga(n,!0,e))});var n=9===e.nodeType?e:e.ownerDocument;null===n||n[qa]||(n[qa]=!0,Ga("selectionchange",!1,n))}}function Wa(e,n,t,a){switch(Zn(n)){case 1:var o=jn;break;case 4:o=Kn;break;default:o=Yn}t=o.bind(null,n,t,e),o=void 0,!Ae||"touchstart"!==n&&"touchmove"!==n&&"wheel"!==n||(o=!0),a?void 0!==o?e.addEventListener(n,t,{capture:!0,passive:o}):e.addEventListener(n,t,!0):void 0!==o?e.addEventListener(n,t,{passive:o}):e.addEventListener(n,t,!1)}function Va(e,n,t,a,o){var c=a;if(!(1&n||2&n||null===a))e:for(;;){if(null===a)return;var r=a.tag;if(3===r||4===r){var i=a.stateNode.containerInfo;if(i===o||8===i.nodeType&&i.parentNode===o)break;if(4===r)for(r=a.return;null!==r;){var l=r.tag;if((3===l||4===l)&&((l=r.stateNode.containerInfo)===o||8===l.nodeType&&l.parentNode===o))return;r=r.return}for(;null!==i;){if(null===(r=bo(i)))return;if(5===(l=r.tag)||6===l){a=c=r;continue e}i=i.parentNode}}a=a.return}Me(function(){var a=c,o=ke(t),r=[];e:{var i=La.get(e);if(void 0!==i){var l=ut,s=e;switch(e){case"keypress":if(0===tt(t))break e;case"keydown":case"keyup":l=Ct;break;case"focusin":s="focus",l=gt;break;case"focusout":s="blur",l=gt;break;case"beforeblur":case"afterblur":l=gt;break;case"click":if(2===t.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=mt;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=_t;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=Rt;break;case wa:case Ca:case Ia:l=ht;break;case Ra:l=Lt;break;case"scroll":l=pt;break;case"wheel":l=Dt;break;case"copy":case"cut":case"paste":l=bt;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=It}var u=!!(4&n),d=!u&&"scroll"===e,p=u?null!==i?i+"Capture":null:i;u=[];for(var f,m=a;null!==m;){var _=(f=m).stateNode;if(5===f.tag&&null!==_&&(f=_,null!==p&&null!=(_=De(m,p))&&u.push(Ha(m,_,f))),d)break;m=m.return}0<u.length&&(i=new l(i,s,null,t,o),r.push({event:i,listeners:u}))}}if(!(7&n)){if(l="mouseout"===e||"pointerout"===e,(!(i="mouseover"===e||"pointerover"===e)||t===ye||!(s=t.relatedTarget||t.fromElement)||!bo(s)&&!s[_o])&&(l||i)&&(i=o.window===o?o:(i=o.ownerDocument)?i.defaultView||i.parentWindow:window,l?(l=a,null!==(s=(s=t.relatedTarget||t.toElement)?bo(s):null)&&(s!==(d=Ue(s))||5!==s.tag&&6!==s.tag)&&(s=null)):(l=null,s=a),l!==s)){if(u=mt,_="onMouseLeave",p="onMouseEnter",m="mouse","pointerout"!==e&&"pointerover"!==e||(u=It,_="onPointerLeave",p="onPointerEnter",m="pointer"),d=null==l?i:ko(l),f=null==s?i:ko(s),(i=new u(_,m+"leave",l,t,o)).target=d,i.relatedTarget=f,_=null,bo(o)===a&&((u=new u(p,m+"enter",s,t,o)).target=f,u.relatedTarget=d,_=u),d=_,l&&s)e:{for(p=s,m=0,f=u=l;f;f=Ka(f))m++;for(f=0,_=p;_;_=Ka(_))f++;for(;0<m-f;)u=Ka(u),m--;for(;0<f-m;)p=Ka(p),f--;for(;m--;){if(u===p||null!==p&&u===p.alternate)break e;u=Ka(u),p=Ka(p)}u=null}else u=null;null!==l&&Ya(r,i,l,u,!1),null!==s&&null!==d&&Ya(r,d,s,u,!0)}if("select"===(l=(i=a?ko(a):window).nodeName&&i.nodeName.toLowerCase())||"input"===l&&"file"===i.type)var g=Xt;else if(Vt(i))if(Zt)g=ra;else{g=oa;var h=aa}else(l=i.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===i.type||"radio"===i.type)&&(g=ca);switch(g&&(g=g(e,a))?Ht(r,g,t,o):(h&&h(e,i,a),"focusout"===e&&(h=i._wrapperState)&&h.controlled&&"number"===i.type&&ee(i,"number",i.value)),h=a?ko(a):window,e){case"focusin":(Vt(h)||"true"===h.contentEditable)&&(ga=h,ha=a,va=null);break;case"focusout":va=ha=ga=null;break;case"mousedown":ba=!0;break;case"contextmenu":case"mouseup":case"dragend":ba=!1,ya(r,t,o);break;case"selectionchange":if(_a)break;case"keydown":case"keyup":ya(r,t,o)}var v;if(Ot)e:{switch(e){case"compositionstart":var b="onCompositionStart";break e;case"compositionend":b="onCompositionEnd";break e;case"compositionupdate":b="onCompositionUpdate";break e}b=void 0}else Ut?Gt(e,t)&&(b="onCompositionEnd"):"keydown"===e&&229===t.keyCode&&(b="onCompositionStart");b&&(Ft&&"ko"!==t.locale&&(Ut||"onCompositionStart"!==b?"onCompositionEnd"===b&&Ut&&(v=nt()):(Jn="value"in(Qn=o)?Qn.value:Qn.textContent,Ut=!0)),0<(h=ja(a,b)).length&&(b=new yt(b,e,null,t,o),r.push({event:b,listeners:h}),(v||null!==(v=qt(t)))&&(b.data=v))),(v=Tt?function(e,n){switch(e){case"compositionend":return qt(n);case"keypress":return 32!==n.which?null:(zt=!0,Nt);case"textInput":return(e=n.data)===Nt&&zt?null:e;default:return null}}(e,t):function(e,n){if(Ut)return"compositionend"===e||!Ot&&Gt(e,n)?(e=nt(),et=Jn=Qn=null,Ut=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(n.ctrlKey||n.altKey||n.metaKey)||n.ctrlKey&&n.altKey){if(n.char&&1<n.char.length)return n.char;if(n.which)return String.fromCharCode(n.which)}return null;case"compositionend":return Ft&&"ko"!==n.locale?null:n.data}}(e,t))&&0<(a=ja(a,"onBeforeInput")).length&&(o=new yt("onBeforeInput","beforeinput",null,t,o),r.push({event:o,listeners:a}),o.data=v)}Na(r,n)})}function Ha(e,n,t){return{instance:e,listener:n,currentTarget:t}}function ja(e,n){for(var t=n+"Capture",a=[];null!==e;){var o=e,c=o.stateNode;5===o.tag&&null!==c&&(o=c,null!=(c=De(e,t))&&a.unshift(Ha(e,c,o)),null!=(c=De(e,n))&&a.push(Ha(e,c,o))),e=e.return}return a}function Ka(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Ya(e,n,t,a,o){for(var c=n._reactName,r=[];null!==t&&t!==a;){var i=t,l=i.alternate,s=i.stateNode;if(null!==l&&l===a)break;5===i.tag&&null!==s&&(i=s,o?null!=(l=De(t,c))&&r.unshift(Ha(t,l,i)):o||null!=(l=De(t,c))&&r.push(Ha(t,l,i))),t=t.return}0!==r.length&&e.push({event:n,listeners:r})}var $a=/\r\n?/g,Xa=/\u0000|\uFFFD/g;function Za(e){return("string"==typeof e?e:""+e).replace($a,"\n").replace(Xa,"")}function Qa(e,n,t){if(n=Za(n),Za(e)!==n&&t)throw Error(c(425))}function Ja(){}var eo=null,no=null;function to(e,n){return"textarea"===e||"noscript"===e||"string"==typeof n.children||"number"==typeof n.children||"object"==typeof n.dangerouslySetInnerHTML&&null!==n.dangerouslySetInnerHTML&&null!=n.dangerouslySetInnerHTML.__html}var ao="function"==typeof setTimeout?setTimeout:void 0,oo="function"==typeof clearTimeout?clearTimeout:void 0,co="function"==typeof Promise?Promise:void 0,ro="function"==typeof queueMicrotask?queueMicrotask:void 0!==co?function(e){return co.resolve(null).then(e).catch(io)}:ao;function io(e){setTimeout(function(){throw e})}function lo(e,n){var t=n,a=0;do{var o=t.nextSibling;if(e.removeChild(t),o&&8===o.nodeType)if("/$"===(t=o.data)){if(0===a)return e.removeChild(o),void Wn(n);a--}else"$"!==t&&"$?"!==t&&"$!"!==t||a++;t=o}while(t);Wn(n)}function so(e){for(;null!=e;e=e.nextSibling){var n=e.nodeType;if(1===n||3===n)break;if(8===n){if("$"===(n=e.data)||"$!"===n||"$?"===n)break;if("/$"===n)return null}}return e}function uo(e){e=e.previousSibling;for(var n=0;e;){if(8===e.nodeType){var t=e.data;if("$"===t||"$!"===t||"$?"===t){if(0===n)return e;n--}else"/$"===t&&n++}e=e.previousSibling}return null}var po=Math.random().toString(36).slice(2),fo="__reactFiber$"+po,mo="__reactProps$"+po,_o="__reactContainer$"+po,go="__reactEvents$"+po,ho="__reactListeners$"+po,vo="__reactHandles$"+po;function bo(e){var n=e[fo];if(n)return n;for(var t=e.parentNode;t;){if(n=t[_o]||t[fo]){if(t=n.alternate,null!==n.child||null!==t&&null!==t.child)for(e=uo(e);null!==e;){if(t=e[fo])return t;e=uo(e)}return n}t=(e=t).parentNode}return null}function yo(e){return!(e=e[fo]||e[_o])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function ko(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(c(33))}function xo(e){return e[mo]||null}var So=[],Eo=-1;function Po(e){return{current:e}}function wo(e){0>Eo||(e.current=So[Eo],So[Eo]=null,Eo--)}function Co(e,n){Eo++,So[Eo]=e.current,e.current=n}var Io={},Ro=Po(Io),Lo=Po(!1),Mo=Io;function Do(e,n){var t=e.type.contextTypes;if(!t)return Io;var a=e.stateNode;if(a&&a.__reactInternalMemoizedUnmaskedChildContext===n)return a.__reactInternalMemoizedMaskedChildContext;var o,c={};for(o in t)c[o]=n[o];return a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=n,e.__reactInternalMemoizedMaskedChildContext=c),c}function Ao(e){return null!=e.childContextTypes}function Oo(){wo(Lo),wo(Ro)}function Bo(e,n,t){if(Ro.current!==Io)throw Error(c(168));Co(Ro,n),Co(Lo,t)}function To(e,n,t){var a=e.stateNode;if(n=n.childContextTypes,"function"!=typeof a.getChildContext)return t;for(var o in a=a.getChildContext())if(!(o in n))throw Error(c(108,W(e)||"Unknown",o));return F({},t,a)}function Fo(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Io,Mo=Ro.current,Co(Ro,e),Co(Lo,Lo.current),!0}function No(e,n,t){var a=e.stateNode;if(!a)throw Error(c(169));t?(e=To(e,n,Mo),a.__reactInternalMemoizedMergedChildContext=e,wo(Lo),wo(Ro),Co(Ro,e)):wo(Lo),Co(Lo,t)}var zo=null,Go=!1,qo=!1;function Uo(e){null===zo?zo=[e]:zo.push(e)}function Wo(){if(!qo&&null!==zo){qo=!0;var e=0,n=yn;try{var t=zo;for(yn=1;e<t.length;e++){var a=t[e];do{a=a(!0)}while(null!==a)}zo=null,Go=!1}catch(n){throw null!==zo&&(zo=zo.slice(e+1)),Ke(Je,Wo),n}finally{yn=n,qo=!1}}return null}var Vo=[],Ho=0,jo=null,Ko=0,Yo=[],$o=0,Xo=null,Zo=1,Qo="";function Jo(e,n){Vo[Ho++]=Ko,Vo[Ho++]=jo,jo=e,Ko=n}function ec(e,n,t){Yo[$o++]=Zo,Yo[$o++]=Qo,Yo[$o++]=Xo,Xo=e;var a=Zo;e=Qo;var o=32-rn(a)-1;a&=~(1<<o),t+=1;var c=32-rn(n)+o;if(30<c){var r=o-o%5;c=(a&(1<<r)-1).toString(32),a>>=r,o-=r,Zo=1<<32-rn(n)+o|t<<o|a,Qo=c+e}else Zo=1<<c|t<<o|a,Qo=e}function nc(e){null!==e.return&&(Jo(e,1),ec(e,1,0))}function tc(e){for(;e===jo;)jo=Vo[--Ho],Vo[Ho]=null,Ko=Vo[--Ho],Vo[Ho]=null;for(;e===Xo;)Xo=Yo[--$o],Yo[$o]=null,Qo=Yo[--$o],Yo[$o]=null,Zo=Yo[--$o],Yo[$o]=null}var ac=null,oc=null,cc=!1,rc=null;function ic(e,n){var t=Ms(5,null,null,0);t.elementType="DELETED",t.stateNode=n,t.return=e,null===(n=e.deletions)?(e.deletions=[t],e.flags|=16):n.push(t)}function lc(e,n){switch(e.tag){case 5:var t=e.type;return null!==(n=1!==n.nodeType||t.toLowerCase()!==n.nodeName.toLowerCase()?null:n)&&(e.stateNode=n,ac=e,oc=so(n.firstChild),!0);case 6:return null!==(n=""===e.pendingProps||3!==n.nodeType?null:n)&&(e.stateNode=n,ac=e,oc=null,!0);case 13:return null!==(n=8!==n.nodeType?null:n)&&(t=null!==Xo?{id:Zo,overflow:Qo}:null,e.memoizedState={dehydrated:n,treeContext:t,retryLane:1073741824},(t=Ms(18,null,null,0)).stateNode=n,t.return=e,e.child=t,ac=e,oc=null,!0);default:return!1}}function sc(e){return!(!(1&e.mode)||128&e.flags)}function uc(e){if(cc){var n=oc;if(n){var t=n;if(!lc(e,n)){if(sc(e))throw Error(c(418));n=so(t.nextSibling);var a=ac;n&&lc(e,n)?ic(a,t):(e.flags=-4097&e.flags|2,cc=!1,ac=e)}}else{if(sc(e))throw Error(c(418));e.flags=-4097&e.flags|2,cc=!1,ac=e}}}function dc(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;ac=e}function pc(e){if(e!==ac)return!1;if(!cc)return dc(e),cc=!0,!1;var n;if((n=3!==e.tag)&&!(n=5!==e.tag)&&(n="head"!==(n=e.type)&&"body"!==n&&!to(e.type,e.memoizedProps)),n&&(n=oc)){if(sc(e))throw fc(),Error(c(418));for(;n;)ic(e,n),n=so(n.nextSibling)}if(dc(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(c(317));e:{for(e=e.nextSibling,n=0;e;){if(8===e.nodeType){var t=e.data;if("/$"===t){if(0===n){oc=so(e.nextSibling);break e}n--}else"$"!==t&&"$!"!==t&&"$?"!==t||n++}e=e.nextSibling}oc=null}}else oc=ac?so(e.stateNode.nextSibling):null;return!0}function fc(){for(var e=oc;e;)e=so(e.nextSibling)}function mc(){oc=ac=null,cc=!1}function _c(e){null===rc?rc=[e]:rc.push(e)}var gc=y.ReactCurrentBatchConfig;function hc(e,n,t){if(null!==(e=t.ref)&&"function"!=typeof e&&"object"!=typeof e){if(t._owner){if(t=t._owner){if(1!==t.tag)throw Error(c(309));var a=t.stateNode}if(!a)throw Error(c(147,e));var o=a,r=""+e;return null!==n&&null!==n.ref&&"function"==typeof n.ref&&n.ref._stringRef===r?n.ref:(n=function(e){var n=o.refs;null===e?delete n[r]:n[r]=e},n._stringRef=r,n)}if("string"!=typeof e)throw Error(c(284));if(!t._owner)throw Error(c(290,e))}return e}function vc(e,n){throw e=Object.prototype.toString.call(n),Error(c(31,"[object Object]"===e?"object with keys {"+Object.keys(n).join(", ")+"}":e))}function bc(e){return(0,e._init)(e._payload)}function yc(e){function n(n,t){if(e){var a=n.deletions;null===a?(n.deletions=[t],n.flags|=16):a.push(t)}}function t(t,a){if(!e)return null;for(;null!==a;)n(t,a),a=a.sibling;return null}function a(e,n){for(e=new Map;null!==n;)null!==n.key?e.set(n.key,n):e.set(n.index,n),n=n.sibling;return e}function o(e,n){return(e=As(e,n)).index=0,e.sibling=null,e}function r(n,t,a){return n.index=a,e?null!==(a=n.alternate)?(a=a.index)<t?(n.flags|=2,t):a:(n.flags|=2,t):(n.flags|=1048576,t)}function i(n){return e&&null===n.alternate&&(n.flags|=2),n}function l(e,n,t,a){return null===n||6!==n.tag?((n=Fs(t,e.mode,a)).return=e,n):((n=o(n,t)).return=e,n)}function s(e,n,t,a){var c=t.type;return c===S?d(e,n,t.props.children,a,t.key):null!==n&&(n.elementType===c||"object"==typeof c&&null!==c&&c.$$typeof===D&&bc(c)===n.type)?((a=o(n,t.props)).ref=hc(e,n,t),a.return=e,a):((a=Os(t.type,t.key,t.props,null,e.mode,a)).ref=hc(e,n,t),a.return=e,a)}function u(e,n,t,a){return null===n||4!==n.tag||n.stateNode.containerInfo!==t.containerInfo||n.stateNode.implementation!==t.implementation?((n=Ns(t,e.mode,a)).return=e,n):((n=o(n,t.children||[])).return=e,n)}function d(e,n,t,a,c){return null===n||7!==n.tag?((n=Bs(t,e.mode,a,c)).return=e,n):((n=o(n,t)).return=e,n)}function p(e,n,t){if("string"==typeof n&&""!==n||"number"==typeof n)return(n=Fs(""+n,e.mode,t)).return=e,n;if("object"==typeof n&&null!==n){switch(n.$$typeof){case k:return(t=Os(n.type,n.key,n.props,null,e.mode,t)).ref=hc(e,null,n),t.return=e,t;case x:return(n=Ns(n,e.mode,t)).return=e,n;case D:return p(e,(0,n._init)(n._payload),t)}if(ne(n)||B(n))return(n=Bs(n,e.mode,t,null)).return=e,n;vc(e,n)}return null}function f(e,n,t,a){var o=null!==n?n.key:null;if("string"==typeof t&&""!==t||"number"==typeof t)return null!==o?null:l(e,n,""+t,a);if("object"==typeof t&&null!==t){switch(t.$$typeof){case k:return t.key===o?s(e,n,t,a):null;case x:return t.key===o?u(e,n,t,a):null;case D:return f(e,n,(o=t._init)(t._payload),a)}if(ne(t)||B(t))return null!==o?null:d(e,n,t,a,null);vc(e,t)}return null}function m(e,n,t,a,o){if("string"==typeof a&&""!==a||"number"==typeof a)return l(n,e=e.get(t)||null,""+a,o);if("object"==typeof a&&null!==a){switch(a.$$typeof){case k:return s(n,e=e.get(null===a.key?t:a.key)||null,a,o);case x:return u(n,e=e.get(null===a.key?t:a.key)||null,a,o);case D:return m(e,n,t,(0,a._init)(a._payload),o)}if(ne(a)||B(a))return d(n,e=e.get(t)||null,a,o,null);vc(n,a)}return null}function _(o,c,i,l){for(var s=null,u=null,d=c,_=c=0,g=null;null!==d&&_<i.length;_++){d.index>_?(g=d,d=null):g=d.sibling;var h=f(o,d,i[_],l);if(null===h){null===d&&(d=g);break}e&&d&&null===h.alternate&&n(o,d),c=r(h,c,_),null===u?s=h:u.sibling=h,u=h,d=g}if(_===i.length)return t(o,d),cc&&Jo(o,_),s;if(null===d){for(;_<i.length;_++)null!==(d=p(o,i[_],l))&&(c=r(d,c,_),null===u?s=d:u.sibling=d,u=d);return cc&&Jo(o,_),s}for(d=a(o,d);_<i.length;_++)null!==(g=m(d,o,_,i[_],l))&&(e&&null!==g.alternate&&d.delete(null===g.key?_:g.key),c=r(g,c,_),null===u?s=g:u.sibling=g,u=g);return e&&d.forEach(function(e){return n(o,e)}),cc&&Jo(o,_),s}function g(o,i,l,s){var u=B(l);if("function"!=typeof u)throw Error(c(150));if(null==(l=u.call(l)))throw Error(c(151));for(var d=u=null,_=i,g=i=0,h=null,v=l.next();null!==_&&!v.done;g++,v=l.next()){_.index>g?(h=_,_=null):h=_.sibling;var b=f(o,_,v.value,s);if(null===b){null===_&&(_=h);break}e&&_&&null===b.alternate&&n(o,_),i=r(b,i,g),null===d?u=b:d.sibling=b,d=b,_=h}if(v.done)return t(o,_),cc&&Jo(o,g),u;if(null===_){for(;!v.done;g++,v=l.next())null!==(v=p(o,v.value,s))&&(i=r(v,i,g),null===d?u=v:d.sibling=v,d=v);return cc&&Jo(o,g),u}for(_=a(o,_);!v.done;g++,v=l.next())null!==(v=m(_,o,g,v.value,s))&&(e&&null!==v.alternate&&_.delete(null===v.key?g:v.key),i=r(v,i,g),null===d?u=v:d.sibling=v,d=v);return e&&_.forEach(function(e){return n(o,e)}),cc&&Jo(o,g),u}return function e(a,c,r,l){if("object"==typeof r&&null!==r&&r.type===S&&null===r.key&&(r=r.props.children),"object"==typeof r&&null!==r){switch(r.$$typeof){case k:e:{for(var s=r.key,u=c;null!==u;){if(u.key===s){if((s=r.type)===S){if(7===u.tag){t(a,u.sibling),(c=o(u,r.props.children)).return=a,a=c;break e}}else if(u.elementType===s||"object"==typeof s&&null!==s&&s.$$typeof===D&&bc(s)===u.type){t(a,u.sibling),(c=o(u,r.props)).ref=hc(a,u,r),c.return=a,a=c;break e}t(a,u);break}n(a,u),u=u.sibling}r.type===S?((c=Bs(r.props.children,a.mode,l,r.key)).return=a,a=c):((l=Os(r.type,r.key,r.props,null,a.mode,l)).ref=hc(a,c,r),l.return=a,a=l)}return i(a);case x:e:{for(u=r.key;null!==c;){if(c.key===u){if(4===c.tag&&c.stateNode.containerInfo===r.containerInfo&&c.stateNode.implementation===r.implementation){t(a,c.sibling),(c=o(c,r.children||[])).return=a,a=c;break e}t(a,c);break}n(a,c),c=c.sibling}(c=Ns(r,a.mode,l)).return=a,a=c}return i(a);case D:return e(a,c,(u=r._init)(r._payload),l)}if(ne(r))return _(a,c,r,l);if(B(r))return g(a,c,r,l);vc(a,r)}return"string"==typeof r&&""!==r||"number"==typeof r?(r=""+r,null!==c&&6===c.tag?(t(a,c.sibling),(c=o(c,r)).return=a,a=c):(t(a,c),(c=Fs(r,a.mode,l)).return=a,a=c),i(a)):t(a,c)}}var kc=yc(!0),xc=yc(!1),Sc=Po(null),Ec=null,Pc=null,wc=null;function Cc(){wc=Pc=Ec=null}function Ic(e){var n=Sc.current;wo(Sc),e._currentValue=n}function Rc(e,n,t){for(;null!==e;){var a=e.alternate;if((e.childLanes&n)!==n?(e.childLanes|=n,null!==a&&(a.childLanes|=n)):null!==a&&(a.childLanes&n)!==n&&(a.childLanes|=n),e===t)break;e=e.return}}function Lc(e,n){Ec=e,wc=Pc=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&n)&&(bi=!0),e.firstContext=null)}function Mc(e){var n=e._currentValue;if(wc!==e)if(e={context:e,memoizedValue:n,next:null},null===Pc){if(null===Ec)throw Error(c(308));Pc=e,Ec.dependencies={lanes:0,firstContext:e}}else Pc=Pc.next=e;return n}var Dc=null;function Ac(e){null===Dc?Dc=[e]:Dc.push(e)}function Oc(e,n,t,a){var o=n.interleaved;return null===o?(t.next=t,Ac(n)):(t.next=o.next,o.next=t),n.interleaved=t,Bc(e,a)}function Bc(e,n){e.lanes|=n;var t=e.alternate;for(null!==t&&(t.lanes|=n),t=e,e=e.return;null!==e;)e.childLanes|=n,null!==(t=e.alternate)&&(t.childLanes|=n),t=e,e=e.return;return 3===t.tag?t.stateNode:null}var Tc=!1;function Fc(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Nc(e,n){e=e.updateQueue,n.updateQueue===e&&(n.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function zc(e,n){return{eventTime:e,lane:n,tag:0,payload:null,callback:null,next:null}}function Gc(e,n,t){var a=e.updateQueue;if(null===a)return null;if(a=a.shared,2&Il){var o=a.pending;return null===o?n.next=n:(n.next=o.next,o.next=n),a.pending=n,Bc(e,t)}return null===(o=a.interleaved)?(n.next=n,Ac(a)):(n.next=o.next,o.next=n),a.interleaved=n,Bc(e,t)}function qc(e,n,t){if(null!==(n=n.updateQueue)&&(n=n.shared,4194240&t)){var a=n.lanes;t|=a&=e.pendingLanes,n.lanes=t,bn(e,t)}}function Uc(e,n){var t=e.updateQueue,a=e.alternate;if(null!==a&&t===(a=a.updateQueue)){var o=null,c=null;if(null!==(t=t.firstBaseUpdate)){do{var r={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};null===c?o=c=r:c=c.next=r,t=t.next}while(null!==t);null===c?o=c=n:c=c.next=n}else o=c=n;return t={baseState:a.baseState,firstBaseUpdate:o,lastBaseUpdate:c,shared:a.shared,effects:a.effects},void(e.updateQueue=t)}null===(e=t.lastBaseUpdate)?t.firstBaseUpdate=n:e.next=n,t.lastBaseUpdate=n}function Wc(e,n,t,a){var o=e.updateQueue;Tc=!1;var c=o.firstBaseUpdate,r=o.lastBaseUpdate,i=o.shared.pending;if(null!==i){o.shared.pending=null;var l=i,s=l.next;l.next=null,null===r?c=s:r.next=s,r=l;var u=e.alternate;null!==u&&(i=(u=u.updateQueue).lastBaseUpdate)!==r&&(null===i?u.firstBaseUpdate=s:i.next=s,u.lastBaseUpdate=l)}if(null!==c){var d=o.baseState;for(r=0,u=s=l=null,i=c;;){var p=i.lane,f=i.eventTime;if((a&p)===p){null!==u&&(u=u.next={eventTime:f,lane:0,tag:i.tag,payload:i.payload,callback:i.callback,next:null});e:{var m=e,_=i;switch(p=n,f=t,_.tag){case 1:if("function"==typeof(m=_.payload)){d=m.call(f,d,p);break e}d=m;break e;case 3:m.flags=-65537&m.flags|128;case 0:if(null==(p="function"==typeof(m=_.payload)?m.call(f,d,p):m))break e;d=F({},d,p);break e;case 2:Tc=!0}}null!==i.callback&&0!==i.lane&&(e.flags|=64,null===(p=o.effects)?o.effects=[i]:p.push(i))}else f={eventTime:f,lane:p,tag:i.tag,payload:i.payload,callback:i.callback,next:null},null===u?(s=u=f,l=d):u=u.next=f,r|=p;if(null===(i=i.next)){if(null===(i=o.shared.pending))break;i=(p=i).next,p.next=null,o.lastBaseUpdate=p,o.shared.pending=null}}if(null===u&&(l=d),o.baseState=l,o.firstBaseUpdate=s,o.lastBaseUpdate=u,null!==(n=o.shared.interleaved)){o=n;do{r|=o.lane,o=o.next}while(o!==n)}else null===c&&(o.shared.lanes=0);Tl|=r,e.lanes=r,e.memoizedState=d}}function Vc(e,n,t){if(e=n.effects,n.effects=null,null!==e)for(n=0;n<e.length;n++){var a=e[n],o=a.callback;if(null!==o){if(a.callback=null,a=t,"function"!=typeof o)throw Error(c(191,o));o.call(a)}}}var Hc={},jc=Po(Hc),Kc=Po(Hc),Yc=Po(Hc);function $c(e){if(e===Hc)throw Error(c(174));return e}function Xc(e,n){switch(Co(Yc,n),Co(Kc,e),Co(jc,Hc),e=n.nodeType){case 9:case 11:n=(n=n.documentElement)?n.namespaceURI:le(null,"");break;default:n=le(n=(e=8===e?n.parentNode:n).namespaceURI||null,e=e.tagName)}wo(jc),Co(jc,n)}function Zc(){wo(jc),wo(Kc),wo(Yc)}function Qc(e){$c(Yc.current);var n=$c(jc.current),t=le(n,e.type);n!==t&&(Co(Kc,e),Co(jc,t))}function Jc(e){Kc.current===e&&(wo(jc),wo(Kc))}var er=Po(0);function nr(e){for(var n=e;null!==n;){if(13===n.tag){var t=n.memoizedState;if(null!==t&&(null===(t=t.dehydrated)||"$?"===t.data||"$!"===t.data))return n}else if(19===n.tag&&void 0!==n.memoizedProps.revealOrder){if(128&n.flags)return n}else if(null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break;for(;null===n.sibling;){if(null===n.return||n.return===e)return null;n=n.return}n.sibling.return=n.return,n=n.sibling}return null}var tr=[];function ar(){for(var e=0;e<tr.length;e++)tr[e]._workInProgressVersionPrimary=null;tr.length=0}var or=y.ReactCurrentDispatcher,cr=y.ReactCurrentBatchConfig,rr=0,ir=null,lr=null,sr=null,ur=!1,dr=!1,pr=0,fr=0;function mr(){throw Error(c(321))}function _r(e,n){if(null===n)return!1;for(var t=0;t<n.length&&t<e.length;t++)if(!ia(e[t],n[t]))return!1;return!0}function gr(e,n,t,a,o,r){if(rr=r,ir=n,n.memoizedState=null,n.updateQueue=null,n.lanes=0,or.current=null===e||null===e.memoizedState?Jr:ei,e=t(a,o),dr){r=0;do{if(dr=!1,pr=0,25<=r)throw Error(c(301));r+=1,sr=lr=null,n.updateQueue=null,or.current=ni,e=t(a,o)}while(dr)}if(or.current=Qr,n=null!==lr&&null!==lr.next,rr=0,sr=lr=ir=null,ur=!1,n)throw Error(c(300));return e}function hr(){var e=0!==pr;return pr=0,e}function vr(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===sr?ir.memoizedState=sr=e:sr=sr.next=e,sr}function br(){if(null===lr){var e=ir.alternate;e=null!==e?e.memoizedState:null}else e=lr.next;var n=null===sr?ir.memoizedState:sr.next;if(null!==n)sr=n,lr=e;else{if(null===e)throw Error(c(310));e={memoizedState:(lr=e).memoizedState,baseState:lr.baseState,baseQueue:lr.baseQueue,queue:lr.queue,next:null},null===sr?ir.memoizedState=sr=e:sr=sr.next=e}return sr}function yr(e,n){return"function"==typeof n?n(e):n}function kr(e){var n=br(),t=n.queue;if(null===t)throw Error(c(311));t.lastRenderedReducer=e;var a=lr,o=a.baseQueue,r=t.pending;if(null!==r){if(null!==o){var i=o.next;o.next=r.next,r.next=i}a.baseQueue=o=r,t.pending=null}if(null!==o){r=o.next,a=a.baseState;var l=i=null,s=null,u=r;do{var d=u.lane;if((rr&d)===d)null!==s&&(s=s.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),a=u.hasEagerState?u.eagerState:e(a,u.action);else{var p={lane:d,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};null===s?(l=s=p,i=a):s=s.next=p,ir.lanes|=d,Tl|=d}u=u.next}while(null!==u&&u!==r);null===s?i=a:s.next=l,ia(a,n.memoizedState)||(bi=!0),n.memoizedState=a,n.baseState=i,n.baseQueue=s,t.lastRenderedState=a}if(null!==(e=t.interleaved)){o=e;do{r=o.lane,ir.lanes|=r,Tl|=r,o=o.next}while(o!==e)}else null===o&&(t.lanes=0);return[n.memoizedState,t.dispatch]}function xr(e){var n=br(),t=n.queue;if(null===t)throw Error(c(311));t.lastRenderedReducer=e;var a=t.dispatch,o=t.pending,r=n.memoizedState;if(null!==o){t.pending=null;var i=o=o.next;do{r=e(r,i.action),i=i.next}while(i!==o);ia(r,n.memoizedState)||(bi=!0),n.memoizedState=r,null===n.baseQueue&&(n.baseState=r),t.lastRenderedState=r}return[r,a]}function Sr(){}function Er(e,n){var t=ir,a=br(),o=n(),r=!ia(a.memoizedState,o);if(r&&(a.memoizedState=o,bi=!0),a=a.queue,Tr(Cr.bind(null,t,a,e),[e]),a.getSnapshot!==n||r||null!==sr&&1&sr.memoizedState.tag){if(t.flags|=2048,Mr(9,wr.bind(null,t,a,o,n),void 0,null),null===Rl)throw Error(c(349));30&rr||Pr(t,n,o)}return o}function Pr(e,n,t){e.flags|=16384,e={getSnapshot:n,value:t},null===(n=ir.updateQueue)?(n={lastEffect:null,stores:null},ir.updateQueue=n,n.stores=[e]):null===(t=n.stores)?n.stores=[e]:t.push(e)}function wr(e,n,t,a){n.value=t,n.getSnapshot=a,Ir(n)&&Rr(e)}function Cr(e,n,t){return t(function(){Ir(n)&&Rr(e)})}function Ir(e){var n=e.getSnapshot;e=e.value;try{var t=n();return!ia(e,t)}catch(e){return!0}}function Rr(e){var n=Bc(e,1);null!==n&&ts(n,e,1,-1)}function Lr(e){var n=vr();return"function"==typeof e&&(e=e()),n.memoizedState=n.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:yr,lastRenderedState:e},n.queue=e,e=e.dispatch=Yr.bind(null,ir,e),[n.memoizedState,e]}function Mr(e,n,t,a){return e={tag:e,create:n,destroy:t,deps:a,next:null},null===(n=ir.updateQueue)?(n={lastEffect:null,stores:null},ir.updateQueue=n,n.lastEffect=e.next=e):null===(t=n.lastEffect)?n.lastEffect=e.next=e:(a=t.next,t.next=e,e.next=a,n.lastEffect=e),e}function Dr(){return br().memoizedState}function Ar(e,n,t,a){var o=vr();ir.flags|=e,o.memoizedState=Mr(1|n,t,void 0,void 0===a?null:a)}function Or(e,n,t,a){var o=br();a=void 0===a?null:a;var c=void 0;if(null!==lr){var r=lr.memoizedState;if(c=r.destroy,null!==a&&_r(a,r.deps))return void(o.memoizedState=Mr(n,t,c,a))}ir.flags|=e,o.memoizedState=Mr(1|n,t,c,a)}function Br(e,n){return Ar(8390656,8,e,n)}function Tr(e,n){return Or(2048,8,e,n)}function Fr(e,n){return Or(4,2,e,n)}function Nr(e,n){return Or(4,4,e,n)}function zr(e,n){return"function"==typeof n?(e=e(),n(e),function(){n(null)}):null!=n?(e=e(),n.current=e,function(){n.current=null}):void 0}function Gr(e,n,t){return t=null!=t?t.concat([e]):null,Or(4,4,zr.bind(null,n,e),t)}function qr(){}function Ur(e,n){var t=br();n=void 0===n?null:n;var a=t.memoizedState;return null!==a&&null!==n&&_r(n,a[1])?a[0]:(t.memoizedState=[e,n],e)}function Wr(e,n){var t=br();n=void 0===n?null:n;var a=t.memoizedState;return null!==a&&null!==n&&_r(n,a[1])?a[0]:(e=e(),t.memoizedState=[e,n],e)}function Vr(e,n,t){return 21&rr?(ia(t,n)||(t=gn(),ir.lanes|=t,Tl|=t,e.baseState=!0),n):(e.baseState&&(e.baseState=!1,bi=!0),e.memoizedState=t)}function Hr(e,n){var t=yn;yn=0!==t&&4>t?t:4,e(!0);var a=cr.transition;cr.transition={};try{e(!1),n()}finally{yn=t,cr.transition=a}}function jr(){return br().memoizedState}function Kr(e,n,t){var a=ns(e);t={lane:a,action:t,hasEagerState:!1,eagerState:null,next:null},$r(e)?Xr(n,t):null!==(t=Oc(e,n,t,a))&&(ts(t,e,a,es()),Zr(t,n,a))}function Yr(e,n,t){var a=ns(e),o={lane:a,action:t,hasEagerState:!1,eagerState:null,next:null};if($r(e))Xr(n,o);else{var c=e.alternate;if(0===e.lanes&&(null===c||0===c.lanes)&&null!==(c=n.lastRenderedReducer))try{var r=n.lastRenderedState,i=c(r,t);if(o.hasEagerState=!0,o.eagerState=i,ia(i,r)){var l=n.interleaved;return null===l?(o.next=o,Ac(n)):(o.next=l.next,l.next=o),void(n.interleaved=o)}}catch(e){}null!==(t=Oc(e,n,o,a))&&(ts(t,e,a,o=es()),Zr(t,n,a))}}function $r(e){var n=e.alternate;return e===ir||null!==n&&n===ir}function Xr(e,n){dr=ur=!0;var t=e.pending;null===t?n.next=n:(n.next=t.next,t.next=n),e.pending=n}function Zr(e,n,t){if(4194240&t){var a=n.lanes;t|=a&=e.pendingLanes,n.lanes=t,bn(e,t)}}var Qr={readContext:Mc,useCallback:mr,useContext:mr,useEffect:mr,useImperativeHandle:mr,useInsertionEffect:mr,useLayoutEffect:mr,useMemo:mr,useReducer:mr,useRef:mr,useState:mr,useDebugValue:mr,useDeferredValue:mr,useTransition:mr,useMutableSource:mr,useSyncExternalStore:mr,useId:mr,unstable_isNewReconciler:!1},Jr={readContext:Mc,useCallback:function(e,n){return vr().memoizedState=[e,void 0===n?null:n],e},useContext:Mc,useEffect:Br,useImperativeHandle:function(e,n,t){return t=null!=t?t.concat([e]):null,Ar(4194308,4,zr.bind(null,n,e),t)},useLayoutEffect:function(e,n){return Ar(4194308,4,e,n)},useInsertionEffect:function(e,n){return Ar(4,2,e,n)},useMemo:function(e,n){var t=vr();return n=void 0===n?null:n,e=e(),t.memoizedState=[e,n],e},useReducer:function(e,n,t){var a=vr();return n=void 0!==t?t(n):n,a.memoizedState=a.baseState=n,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:n},a.queue=e,e=e.dispatch=Kr.bind(null,ir,e),[a.memoizedState,e]},useRef:function(e){return e={current:e},vr().memoizedState=e},useState:Lr,useDebugValue:qr,useDeferredValue:function(e){return vr().memoizedState=e},useTransition:function(){var e=Lr(!1),n=e[0];return e=Hr.bind(null,e[1]),vr().memoizedState=e,[n,e]},useMutableSource:function(){},useSyncExternalStore:function(e,n,t){var a=ir,o=vr();if(cc){if(void 0===t)throw Error(c(407));t=t()}else{if(t=n(),null===Rl)throw Error(c(349));30&rr||Pr(a,n,t)}o.memoizedState=t;var r={value:t,getSnapshot:n};return o.queue=r,Br(Cr.bind(null,a,r,e),[e]),a.flags|=2048,Mr(9,wr.bind(null,a,r,t,n),void 0,null),t},useId:function(){var e=vr(),n=Rl.identifierPrefix;if(cc){var t=Qo;n=":"+n+"R"+(t=(Zo&~(1<<32-rn(Zo)-1)).toString(32)+t),0<(t=pr++)&&(n+="H"+t.toString(32)),n+=":"}else n=":"+n+"r"+(t=fr++).toString(32)+":";return e.memoizedState=n},unstable_isNewReconciler:!1},ei={readContext:Mc,useCallback:Ur,useContext:Mc,useEffect:Tr,useImperativeHandle:Gr,useInsertionEffect:Fr,useLayoutEffect:Nr,useMemo:Wr,useReducer:kr,useRef:Dr,useState:function(){return kr(yr)},useDebugValue:qr,useDeferredValue:function(e){return Vr(br(),lr.memoizedState,e)},useTransition:function(){return[kr(yr)[0],br().memoizedState]},useMutableSource:Sr,useSyncExternalStore:Er,useId:jr,unstable_isNewReconciler:!1},ni={readContext:Mc,useCallback:Ur,useContext:Mc,useEffect:Tr,useImperativeHandle:Gr,useInsertionEffect:Fr,useLayoutEffect:Nr,useMemo:Wr,useReducer:xr,useRef:Dr,useState:function(){return xr(yr)},useDebugValue:qr,useDeferredValue:function(e){var n=br();return null===lr?n.memoizedState=e:Vr(n,lr.memoizedState,e)},useTransition:function(){return[xr(yr)[0],br().memoizedState]},useMutableSource:Sr,useSyncExternalStore:Er,useId:jr,unstable_isNewReconciler:!1};function ti(e,n){if(e&&e.defaultProps){for(var t in n=F({},n),e=e.defaultProps)void 0===n[t]&&(n[t]=e[t]);return n}return n}function ai(e,n,t,a){t=null==(t=t(a,n=e.memoizedState))?n:F({},n,t),e.memoizedState=t,0===e.lanes&&(e.updateQueue.baseState=t)}var oi={isMounted:function(e){return!!(e=e._reactInternals)&&Ue(e)===e},enqueueSetState:function(e,n,t){e=e._reactInternals;var a=es(),o=ns(e),c=zc(a,o);c.payload=n,null!=t&&(c.callback=t),null!==(n=Gc(e,c,o))&&(ts(n,e,o,a),qc(n,e,o))},enqueueReplaceState:function(e,n,t){e=e._reactInternals;var a=es(),o=ns(e),c=zc(a,o);c.tag=1,c.payload=n,null!=t&&(c.callback=t),null!==(n=Gc(e,c,o))&&(ts(n,e,o,a),qc(n,e,o))},enqueueForceUpdate:function(e,n){e=e._reactInternals;var t=es(),a=ns(e),o=zc(t,a);o.tag=2,null!=n&&(o.callback=n),null!==(n=Gc(e,o,a))&&(ts(n,e,a,t),qc(n,e,a))}};function ci(e,n,t,a,o,c,r){return"function"==typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(a,c,r):!(n.prototype&&n.prototype.isPureReactComponent&&la(t,a)&&la(o,c))}function ri(e,n,t){var a=!1,o=Io,c=n.contextType;return"object"==typeof c&&null!==c?c=Mc(c):(o=Ao(n)?Mo:Ro.current,c=(a=null!=(a=n.contextTypes))?Do(e,o):Io),n=new n(t,c),e.memoizedState=null!==n.state&&void 0!==n.state?n.state:null,n.updater=oi,e.stateNode=n,n._reactInternals=e,a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=o,e.__reactInternalMemoizedMaskedChildContext=c),n}function ii(e,n,t,a){e=n.state,"function"==typeof n.componentWillReceiveProps&&n.componentWillReceiveProps(t,a),"function"==typeof n.UNSAFE_componentWillReceiveProps&&n.UNSAFE_componentWillReceiveProps(t,a),n.state!==e&&oi.enqueueReplaceState(n,n.state,null)}function li(e,n,t,a){var o=e.stateNode;o.props=t,o.state=e.memoizedState,o.refs={},Fc(e);var c=n.contextType;"object"==typeof c&&null!==c?o.context=Mc(c):(c=Ao(n)?Mo:Ro.current,o.context=Do(e,c)),o.state=e.memoizedState,"function"==typeof(c=n.getDerivedStateFromProps)&&(ai(e,n,c,t),o.state=e.memoizedState),"function"==typeof n.getDerivedStateFromProps||"function"==typeof o.getSnapshotBeforeUpdate||"function"!=typeof o.UNSAFE_componentWillMount&&"function"!=typeof o.componentWillMount||(n=o.state,"function"==typeof o.componentWillMount&&o.componentWillMount(),"function"==typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount(),n!==o.state&&oi.enqueueReplaceState(o,o.state,null),Wc(e,t,o,a),o.state=e.memoizedState),"function"==typeof o.componentDidMount&&(e.flags|=4194308)}function si(e,n){try{var t="",a=n;do{t+=q(a),a=a.return}while(a);var o=t}catch(e){o="\nError generating stack: "+e.message+"\n"+e.stack}return{value:e,source:n,stack:o,digest:null}}function ui(e,n,t){return{value:e,source:null,stack:null!=t?t:null,digest:null!=n?n:null}}function di(e,n){try{console.error(n.value)}catch(e){setTimeout(function(){throw e})}}var pi="function"==typeof WeakMap?WeakMap:Map;function fi(e,n,t){(t=zc(-1,t)).tag=3,t.payload={element:null};var a=n.value;return t.callback=function(){Vl||(Vl=!0,Hl=a),di(0,n)},t}function mi(e,n,t){(t=zc(-1,t)).tag=3;var a=e.type.getDerivedStateFromError;if("function"==typeof a){var o=n.value;t.payload=function(){return a(o)},t.callback=function(){di(0,n)}}var c=e.stateNode;return null!==c&&"function"==typeof c.componentDidCatch&&(t.callback=function(){di(0,n),"function"!=typeof a&&(null===jl?jl=new Set([this]):jl.add(this));var e=n.stack;this.componentDidCatch(n.value,{componentStack:null!==e?e:""})}),t}function _i(e,n,t){var a=e.pingCache;if(null===a){a=e.pingCache=new pi;var o=new Set;a.set(n,o)}else void 0===(o=a.get(n))&&(o=new Set,a.set(n,o));o.has(t)||(o.add(t),e=Ps.bind(null,e,n,t),n.then(e,e))}function gi(e){do{var n;if((n=13===e.tag)&&(n=null===(n=e.memoizedState)||null!==n.dehydrated),n)return e;e=e.return}while(null!==e);return null}function hi(e,n,t,a,o){return 1&e.mode?(e.flags|=65536,e.lanes=o,e):(e===n?e.flags|=65536:(e.flags|=128,t.flags|=131072,t.flags&=-52805,1===t.tag&&(null===t.alternate?t.tag=17:((n=zc(-1,1)).tag=2,Gc(t,n,1))),t.lanes|=1),e)}var vi=y.ReactCurrentOwner,bi=!1;function yi(e,n,t,a){n.child=null===e?xc(n,null,t,a):kc(n,e.child,t,a)}function ki(e,n,t,a,o){t=t.render;var c=n.ref;return Lc(n,o),a=gr(e,n,t,a,c,o),t=hr(),null===e||bi?(cc&&t&&nc(n),n.flags|=1,yi(e,n,a,o),n.child):(n.updateQueue=e.updateQueue,n.flags&=-2053,e.lanes&=~o,Vi(e,n,o))}function xi(e,n,t,a,o){if(null===e){var c=t.type;return"function"!=typeof c||Ds(c)||void 0!==c.defaultProps||null!==t.compare||void 0!==t.defaultProps?((e=Os(t.type,null,a,n,n.mode,o)).ref=n.ref,e.return=n,n.child=e):(n.tag=15,n.type=c,Si(e,n,c,a,o))}if(c=e.child,0===(e.lanes&o)){var r=c.memoizedProps;if((t=null!==(t=t.compare)?t:la)(r,a)&&e.ref===n.ref)return Vi(e,n,o)}return n.flags|=1,(e=As(c,a)).ref=n.ref,e.return=n,n.child=e}function Si(e,n,t,a,o){if(null!==e){var c=e.memoizedProps;if(la(c,a)&&e.ref===n.ref){if(bi=!1,n.pendingProps=a=c,0===(e.lanes&o))return n.lanes=e.lanes,Vi(e,n,o);131072&e.flags&&(bi=!0)}}return wi(e,n,t,a,o)}function Ei(e,n,t){var a=n.pendingProps,o=a.children,c=null!==e?e.memoizedState:null;if("hidden"===a.mode)if(1&n.mode){if(!(1073741824&t))return e=null!==c?c.baseLanes|t:t,n.lanes=n.childLanes=1073741824,n.memoizedState={baseLanes:e,cachePool:null,transitions:null},n.updateQueue=null,Co(Al,Dl),Dl|=e,null;n.memoizedState={baseLanes:0,cachePool:null,transitions:null},a=null!==c?c.baseLanes:t,Co(Al,Dl),Dl|=a}else n.memoizedState={baseLanes:0,cachePool:null,transitions:null},Co(Al,Dl),Dl|=t;else null!==c?(a=c.baseLanes|t,n.memoizedState=null):a=t,Co(Al,Dl),Dl|=a;return yi(e,n,o,t),n.child}function Pi(e,n){var t=n.ref;(null===e&&null!==t||null!==e&&e.ref!==t)&&(n.flags|=512,n.flags|=2097152)}function wi(e,n,t,a,o){var c=Ao(t)?Mo:Ro.current;return c=Do(n,c),Lc(n,o),t=gr(e,n,t,a,c,o),a=hr(),null===e||bi?(cc&&a&&nc(n),n.flags|=1,yi(e,n,t,o),n.child):(n.updateQueue=e.updateQueue,n.flags&=-2053,e.lanes&=~o,Vi(e,n,o))}function Ci(e,n,t,a,o){if(Ao(t)){var c=!0;Fo(n)}else c=!1;if(Lc(n,o),null===n.stateNode)Wi(e,n),ri(n,t,a),li(n,t,a,o),a=!0;else if(null===e){var r=n.stateNode,i=n.memoizedProps;r.props=i;var l=r.context,s=t.contextType;s="object"==typeof s&&null!==s?Mc(s):Do(n,s=Ao(t)?Mo:Ro.current);var u=t.getDerivedStateFromProps,d="function"==typeof u||"function"==typeof r.getSnapshotBeforeUpdate;d||"function"!=typeof r.UNSAFE_componentWillReceiveProps&&"function"!=typeof r.componentWillReceiveProps||(i!==a||l!==s)&&ii(n,r,a,s),Tc=!1;var p=n.memoizedState;r.state=p,Wc(n,a,r,o),l=n.memoizedState,i!==a||p!==l||Lo.current||Tc?("function"==typeof u&&(ai(n,t,u,a),l=n.memoizedState),(i=Tc||ci(n,t,i,a,p,l,s))?(d||"function"!=typeof r.UNSAFE_componentWillMount&&"function"!=typeof r.componentWillMount||("function"==typeof r.componentWillMount&&r.componentWillMount(),"function"==typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount()),"function"==typeof r.componentDidMount&&(n.flags|=4194308)):("function"==typeof r.componentDidMount&&(n.flags|=4194308),n.memoizedProps=a,n.memoizedState=l),r.props=a,r.state=l,r.context=s,a=i):("function"==typeof r.componentDidMount&&(n.flags|=4194308),a=!1)}else{r=n.stateNode,Nc(e,n),i=n.memoizedProps,s=n.type===n.elementType?i:ti(n.type,i),r.props=s,d=n.pendingProps,p=r.context,l="object"==typeof(l=t.contextType)&&null!==l?Mc(l):Do(n,l=Ao(t)?Mo:Ro.current);var f=t.getDerivedStateFromProps;(u="function"==typeof f||"function"==typeof r.getSnapshotBeforeUpdate)||"function"!=typeof r.UNSAFE_componentWillReceiveProps&&"function"!=typeof r.componentWillReceiveProps||(i!==d||p!==l)&&ii(n,r,a,l),Tc=!1,p=n.memoizedState,r.state=p,Wc(n,a,r,o);var m=n.memoizedState;i!==d||p!==m||Lo.current||Tc?("function"==typeof f&&(ai(n,t,f,a),m=n.memoizedState),(s=Tc||ci(n,t,s,a,p,m,l)||!1)?(u||"function"!=typeof r.UNSAFE_componentWillUpdate&&"function"!=typeof r.componentWillUpdate||("function"==typeof r.componentWillUpdate&&r.componentWillUpdate(a,m,l),"function"==typeof r.UNSAFE_componentWillUpdate&&r.UNSAFE_componentWillUpdate(a,m,l)),"function"==typeof r.componentDidUpdate&&(n.flags|=4),"function"==typeof r.getSnapshotBeforeUpdate&&(n.flags|=1024)):("function"!=typeof r.componentDidUpdate||i===e.memoizedProps&&p===e.memoizedState||(n.flags|=4),"function"!=typeof r.getSnapshotBeforeUpdate||i===e.memoizedProps&&p===e.memoizedState||(n.flags|=1024),n.memoizedProps=a,n.memoizedState=m),r.props=a,r.state=m,r.context=l,a=s):("function"!=typeof r.componentDidUpdate||i===e.memoizedProps&&p===e.memoizedState||(n.flags|=4),"function"!=typeof r.getSnapshotBeforeUpdate||i===e.memoizedProps&&p===e.memoizedState||(n.flags|=1024),a=!1)}return Ii(e,n,t,a,c,o)}function Ii(e,n,t,a,o,c){Pi(e,n);var r=!!(128&n.flags);if(!a&&!r)return o&&No(n,t,!1),Vi(e,n,c);a=n.stateNode,vi.current=n;var i=r&&"function"!=typeof t.getDerivedStateFromError?null:a.render();return n.flags|=1,null!==e&&r?(n.child=kc(n,e.child,null,c),n.child=kc(n,null,i,c)):yi(e,n,i,c),n.memoizedState=a.state,o&&No(n,t,!0),n.child}function Ri(e){var n=e.stateNode;n.pendingContext?Bo(0,n.pendingContext,n.pendingContext!==n.context):n.context&&Bo(0,n.context,!1),Xc(e,n.containerInfo)}function Li(e,n,t,a,o){return mc(),_c(o),n.flags|=256,yi(e,n,t,a),n.child}var Mi,Di,Ai,Oi,Bi={dehydrated:null,treeContext:null,retryLane:0};function Ti(e){return{baseLanes:e,cachePool:null,transitions:null}}function Fi(e,n,t){var a,o=n.pendingProps,r=er.current,i=!1,l=!!(128&n.flags);if((a=l)||(a=(null===e||null!==e.memoizedState)&&!!(2&r)),a?(i=!0,n.flags&=-129):null!==e&&null===e.memoizedState||(r|=1),Co(er,1&r),null===e)return uc(n),null!==(e=n.memoizedState)&&null!==(e=e.dehydrated)?(1&n.mode?"$!"===e.data?n.lanes=8:n.lanes=1073741824:n.lanes=1,null):(l=o.children,e=o.fallback,i?(o=n.mode,i=n.child,l={mode:"hidden",children:l},1&o||null===i?i=Ts(l,o,0,null):(i.childLanes=0,i.pendingProps=l),e=Bs(e,o,t,null),i.return=n,e.return=n,i.sibling=e,n.child=i,n.child.memoizedState=Ti(t),n.memoizedState=Bi,e):Ni(n,l));if(null!==(r=e.memoizedState)&&null!==(a=r.dehydrated))return function(e,n,t,a,o,r,i){if(t)return 256&n.flags?(n.flags&=-257,zi(e,n,i,a=ui(Error(c(422))))):null!==n.memoizedState?(n.child=e.child,n.flags|=128,null):(r=a.fallback,o=n.mode,a=Ts({mode:"visible",children:a.children},o,0,null),(r=Bs(r,o,i,null)).flags|=2,a.return=n,r.return=n,a.sibling=r,n.child=a,1&n.mode&&kc(n,e.child,null,i),n.child.memoizedState=Ti(i),n.memoizedState=Bi,r);if(!(1&n.mode))return zi(e,n,i,null);if("$!"===o.data){if(a=o.nextSibling&&o.nextSibling.dataset)var l=a.dgst;return a=l,zi(e,n,i,a=ui(r=Error(c(419)),a,void 0))}if(l=0!==(i&e.childLanes),bi||l){if(null!==(a=Rl)){switch(i&-i){case 4:o=2;break;case 16:o=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:o=32;break;case 536870912:o=268435456;break;default:o=0}0!==(o=0!==(o&(a.suspendedLanes|i))?0:o)&&o!==r.retryLane&&(r.retryLane=o,Bc(e,o),ts(a,e,o,-1))}return _s(),zi(e,n,i,a=ui(Error(c(421))))}return"$?"===o.data?(n.flags|=128,n.child=e.child,n=Cs.bind(null,e),o._reactRetry=n,null):(e=r.treeContext,oc=so(o.nextSibling),ac=n,cc=!0,rc=null,null!==e&&(Yo[$o++]=Zo,Yo[$o++]=Qo,Yo[$o++]=Xo,Zo=e.id,Qo=e.overflow,Xo=n),(n=Ni(n,a.children)).flags|=4096,n)}(e,n,l,o,a,r,t);if(i){i=o.fallback,l=n.mode,a=(r=e.child).sibling;var s={mode:"hidden",children:o.children};return 1&l||n.child===r?(o=As(r,s)).subtreeFlags=14680064&r.subtreeFlags:((o=n.child).childLanes=0,o.pendingProps=s,n.deletions=null),null!==a?i=As(a,i):(i=Bs(i,l,t,null)).flags|=2,i.return=n,o.return=n,o.sibling=i,n.child=o,o=i,i=n.child,l=null===(l=e.child.memoizedState)?Ti(t):{baseLanes:l.baseLanes|t,cachePool:null,transitions:l.transitions},i.memoizedState=l,i.childLanes=e.childLanes&~t,n.memoizedState=Bi,o}return e=(i=e.child).sibling,o=As(i,{mode:"visible",children:o.children}),!(1&n.mode)&&(o.lanes=t),o.return=n,o.sibling=null,null!==e&&(null===(t=n.deletions)?(n.deletions=[e],n.flags|=16):t.push(e)),n.child=o,n.memoizedState=null,o}function Ni(e,n){return(n=Ts({mode:"visible",children:n},e.mode,0,null)).return=e,e.child=n}function zi(e,n,t,a){return null!==a&&_c(a),kc(n,e.child,null,t),(e=Ni(n,n.pendingProps.children)).flags|=2,n.memoizedState=null,e}function Gi(e,n,t){e.lanes|=n;var a=e.alternate;null!==a&&(a.lanes|=n),Rc(e.return,n,t)}function qi(e,n,t,a,o){var c=e.memoizedState;null===c?e.memoizedState={isBackwards:n,rendering:null,renderingStartTime:0,last:a,tail:t,tailMode:o}:(c.isBackwards=n,c.rendering=null,c.renderingStartTime=0,c.last=a,c.tail=t,c.tailMode=o)}function Ui(e,n,t){var a=n.pendingProps,o=a.revealOrder,c=a.tail;if(yi(e,n,a.children,t),2&(a=er.current))a=1&a|2,n.flags|=128;else{if(null!==e&&128&e.flags)e:for(e=n.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Gi(e,t,n);else if(19===e.tag)Gi(e,t,n);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===n)break e;for(;null===e.sibling;){if(null===e.return||e.return===n)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}a&=1}if(Co(er,a),1&n.mode)switch(o){case"forwards":for(t=n.child,o=null;null!==t;)null!==(e=t.alternate)&&null===nr(e)&&(o=t),t=t.sibling;null===(t=o)?(o=n.child,n.child=null):(o=t.sibling,t.sibling=null),qi(n,!1,o,t,c);break;case"backwards":for(t=null,o=n.child,n.child=null;null!==o;){if(null!==(e=o.alternate)&&null===nr(e)){n.child=o;break}e=o.sibling,o.sibling=t,t=o,o=e}qi(n,!0,t,null,c);break;case"together":qi(n,!1,null,null,void 0);break;default:n.memoizedState=null}else n.memoizedState=null;return n.child}function Wi(e,n){!(1&n.mode)&&null!==e&&(e.alternate=null,n.alternate=null,n.flags|=2)}function Vi(e,n,t){if(null!==e&&(n.dependencies=e.dependencies),Tl|=n.lanes,0===(t&n.childLanes))return null;if(null!==e&&n.child!==e.child)throw Error(c(153));if(null!==n.child){for(t=As(e=n.child,e.pendingProps),n.child=t,t.return=n;null!==e.sibling;)e=e.sibling,(t=t.sibling=As(e,e.pendingProps)).return=n;t.sibling=null}return n.child}function Hi(e,n){if(!cc)switch(e.tailMode){case"hidden":n=e.tail;for(var t=null;null!==n;)null!==n.alternate&&(t=n),n=n.sibling;null===t?e.tail=null:t.sibling=null;break;case"collapsed":t=e.tail;for(var a=null;null!==t;)null!==t.alternate&&(a=t),t=t.sibling;null===a?n||null===e.tail?e.tail=null:e.tail.sibling=null:a.sibling=null}}function ji(e){var n=null!==e.alternate&&e.alternate.child===e.child,t=0,a=0;if(n)for(var o=e.child;null!==o;)t|=o.lanes|o.childLanes,a|=14680064&o.subtreeFlags,a|=14680064&o.flags,o.return=e,o=o.sibling;else for(o=e.child;null!==o;)t|=o.lanes|o.childLanes,a|=o.subtreeFlags,a|=o.flags,o.return=e,o=o.sibling;return e.subtreeFlags|=a,e.childLanes=t,n}function Ki(e,n,t){var a=n.pendingProps;switch(tc(n),n.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ji(n),null;case 1:case 17:return Ao(n.type)&&Oo(),ji(n),null;case 3:return a=n.stateNode,Zc(),wo(Lo),wo(Ro),ar(),a.pendingContext&&(a.context=a.pendingContext,a.pendingContext=null),null!==e&&null!==e.child||(pc(n)?n.flags|=4:null===e||e.memoizedState.isDehydrated&&!(256&n.flags)||(n.flags|=1024,null!==rc&&(rs(rc),rc=null))),Di(e,n),ji(n),null;case 5:Jc(n);var o=$c(Yc.current);if(t=n.type,null!==e&&null!=n.stateNode)Ai(e,n,t,a,o),e.ref!==n.ref&&(n.flags|=512,n.flags|=2097152);else{if(!a){if(null===n.stateNode)throw Error(c(166));return ji(n),null}if(e=$c(jc.current),pc(n)){a=n.stateNode,t=n.type;var r=n.memoizedProps;switch(a[fo]=n,a[mo]=r,e=!!(1&n.mode),t){case"dialog":za("cancel",a),za("close",a);break;case"iframe":case"object":case"embed":za("load",a);break;case"video":case"audio":for(o=0;o<Ba.length;o++)za(Ba[o],a);break;case"source":za("error",a);break;case"img":case"image":case"link":za("error",a),za("load",a);break;case"details":za("toggle",a);break;case"input":X(a,r),za("invalid",a);break;case"select":a._wrapperState={wasMultiple:!!r.multiple},za("invalid",a);break;case"textarea":oe(a,r),za("invalid",a)}for(var l in ve(t,r),o=null,r)if(r.hasOwnProperty(l)){var s=r[l];"children"===l?"string"==typeof s?a.textContent!==s&&(!0!==r.suppressHydrationWarning&&Qa(a.textContent,s,e),o=["children",s]):"number"==typeof s&&a.textContent!==""+s&&(!0!==r.suppressHydrationWarning&&Qa(a.textContent,s,e),o=["children",""+s]):i.hasOwnProperty(l)&&null!=s&&"onScroll"===l&&za("scroll",a)}switch(t){case"input":j(a),J(a,r,!0);break;case"textarea":j(a),re(a);break;case"select":case"option":break;default:"function"==typeof r.onClick&&(a.onclick=Ja)}a=o,n.updateQueue=a,null!==a&&(n.flags|=4)}else{l=9===o.nodeType?o:o.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=ie(t)),"http://www.w3.org/1999/xhtml"===e?"script"===t?((e=l.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"==typeof a.is?e=l.createElement(t,{is:a.is}):(e=l.createElement(t),"select"===t&&(l=e,a.multiple?l.multiple=!0:a.size&&(l.size=a.size))):e=l.createElementNS(e,t),e[fo]=n,e[mo]=a,Mi(e,n,!1,!1),n.stateNode=e;e:{switch(l=be(t,a),t){case"dialog":za("cancel",e),za("close",e),o=a;break;case"iframe":case"object":case"embed":za("load",e),o=a;break;case"video":case"audio":for(o=0;o<Ba.length;o++)za(Ba[o],e);o=a;break;case"source":za("error",e),o=a;break;case"img":case"image":case"link":za("error",e),za("load",e),o=a;break;case"details":za("toggle",e),o=a;break;case"input":X(e,a),o=$(e,a),za("invalid",e);break;case"option":default:o=a;break;case"select":e._wrapperState={wasMultiple:!!a.multiple},o=F({},a,{value:void 0}),za("invalid",e);break;case"textarea":oe(e,a),o=ae(e,a),za("invalid",e)}for(r in ve(t,o),s=o)if(s.hasOwnProperty(r)){var u=s[r];"style"===r?ge(e,u):"dangerouslySetInnerHTML"===r?null!=(u=u?u.__html:void 0)&&de(e,u):"children"===r?"string"==typeof u?("textarea"!==t||""!==u)&&pe(e,u):"number"==typeof u&&pe(e,""+u):"suppressContentEditableWarning"!==r&&"suppressHydrationWarning"!==r&&"autoFocus"!==r&&(i.hasOwnProperty(r)?null!=u&&"onScroll"===r&&za("scroll",e):null!=u&&b(e,r,u,l))}switch(t){case"input":j(e),J(e,a,!1);break;case"textarea":j(e),re(e);break;case"option":null!=a.value&&e.setAttribute("value",""+V(a.value));break;case"select":e.multiple=!!a.multiple,null!=(r=a.value)?te(e,!!a.multiple,r,!1):null!=a.defaultValue&&te(e,!!a.multiple,a.defaultValue,!0);break;default:"function"==typeof o.onClick&&(e.onclick=Ja)}switch(t){case"button":case"input":case"select":case"textarea":a=!!a.autoFocus;break e;case"img":a=!0;break e;default:a=!1}}a&&(n.flags|=4)}null!==n.ref&&(n.flags|=512,n.flags|=2097152)}return ji(n),null;case 6:if(e&&null!=n.stateNode)Oi(e,n,e.memoizedProps,a);else{if("string"!=typeof a&&null===n.stateNode)throw Error(c(166));if(t=$c(Yc.current),$c(jc.current),pc(n)){if(a=n.stateNode,t=n.memoizedProps,a[fo]=n,(r=a.nodeValue!==t)&&null!==(e=ac))switch(e.tag){case 3:Qa(a.nodeValue,t,!!(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Qa(a.nodeValue,t,!!(1&e.mode))}r&&(n.flags|=4)}else(a=(9===t.nodeType?t:t.ownerDocument).createTextNode(a))[fo]=n,n.stateNode=a}return ji(n),null;case 13:if(wo(er),a=n.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(cc&&null!==oc&&1&n.mode&&!(128&n.flags))fc(),mc(),n.flags|=98560,r=!1;else if(r=pc(n),null!==a&&null!==a.dehydrated){if(null===e){if(!r)throw Error(c(318));if(!(r=null!==(r=n.memoizedState)?r.dehydrated:null))throw Error(c(317));r[fo]=n}else mc(),!(128&n.flags)&&(n.memoizedState=null),n.flags|=4;ji(n),r=!1}else null!==rc&&(rs(rc),rc=null),r=!0;if(!r)return 65536&n.flags?n:null}return 128&n.flags?(n.lanes=t,n):((a=null!==a)!=(null!==e&&null!==e.memoizedState)&&a&&(n.child.flags|=8192,1&n.mode&&(null===e||1&er.current?0===Ol&&(Ol=3):_s())),null!==n.updateQueue&&(n.flags|=4),ji(n),null);case 4:return Zc(),Di(e,n),null===e&&Ua(n.stateNode.containerInfo),ji(n),null;case 10:return Ic(n.type._context),ji(n),null;case 19:if(wo(er),null===(r=n.memoizedState))return ji(n),null;if(a=!!(128&n.flags),null===(l=r.rendering))if(a)Hi(r,!1);else{if(0!==Ol||null!==e&&128&e.flags)for(e=n.child;null!==e;){if(null!==(l=nr(e))){for(n.flags|=128,Hi(r,!1),null!==(a=l.updateQueue)&&(n.updateQueue=a,n.flags|=4),n.subtreeFlags=0,a=t,t=n.child;null!==t;)e=a,(r=t).flags&=14680066,null===(l=r.alternate)?(r.childLanes=0,r.lanes=e,r.child=null,r.subtreeFlags=0,r.memoizedProps=null,r.memoizedState=null,r.updateQueue=null,r.dependencies=null,r.stateNode=null):(r.childLanes=l.childLanes,r.lanes=l.lanes,r.child=l.child,r.subtreeFlags=0,r.deletions=null,r.memoizedProps=l.memoizedProps,r.memoizedState=l.memoizedState,r.updateQueue=l.updateQueue,r.type=l.type,e=l.dependencies,r.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),t=t.sibling;return Co(er,1&er.current|2),n.child}e=e.sibling}null!==r.tail&&Ze()>Ul&&(n.flags|=128,a=!0,Hi(r,!1),n.lanes=4194304)}else{if(!a)if(null!==(e=nr(l))){if(n.flags|=128,a=!0,null!==(t=e.updateQueue)&&(n.updateQueue=t,n.flags|=4),Hi(r,!0),null===r.tail&&"hidden"===r.tailMode&&!l.alternate&&!cc)return ji(n),null}else 2*Ze()-r.renderingStartTime>Ul&&1073741824!==t&&(n.flags|=128,a=!0,Hi(r,!1),n.lanes=4194304);r.isBackwards?(l.sibling=n.child,n.child=l):(null!==(t=r.last)?t.sibling=l:n.child=l,r.last=l)}return null!==r.tail?(n=r.tail,r.rendering=n,r.tail=n.sibling,r.renderingStartTime=Ze(),n.sibling=null,t=er.current,Co(er,a?1&t|2:1&t),n):(ji(n),null);case 22:case 23:return ds(),a=null!==n.memoizedState,null!==e&&null!==e.memoizedState!==a&&(n.flags|=8192),a&&1&n.mode?!!(1073741824&Dl)&&(ji(n),6&n.subtreeFlags&&(n.flags|=8192)):ji(n),null;case 24:case 25:return null}throw Error(c(156,n.tag))}function Yi(e,n){switch(tc(n),n.tag){case 1:return Ao(n.type)&&Oo(),65536&(e=n.flags)?(n.flags=-65537&e|128,n):null;case 3:return Zc(),wo(Lo),wo(Ro),ar(),65536&(e=n.flags)&&!(128&e)?(n.flags=-65537&e|128,n):null;case 5:return Jc(n),null;case 13:if(wo(er),null!==(e=n.memoizedState)&&null!==e.dehydrated){if(null===n.alternate)throw Error(c(340));mc()}return 65536&(e=n.flags)?(n.flags=-65537&e|128,n):null;case 19:return wo(er),null;case 4:return Zc(),null;case 10:return Ic(n.type._context),null;case 22:case 23:return ds(),null;default:return null}}Mi=function(e,n){for(var t=n.child;null!==t;){if(5===t.tag||6===t.tag)e.appendChild(t.stateNode);else if(4!==t.tag&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===n)break;for(;null===t.sibling;){if(null===t.return||t.return===n)return;t=t.return}t.sibling.return=t.return,t=t.sibling}},Di=function(){},Ai=function(e,n,t,a){var o=e.memoizedProps;if(o!==a){e=n.stateNode,$c(jc.current);var c,r=null;switch(t){case"input":o=$(e,o),a=$(e,a),r=[];break;case"select":o=F({},o,{value:void 0}),a=F({},a,{value:void 0}),r=[];break;case"textarea":o=ae(e,o),a=ae(e,a),r=[];break;default:"function"!=typeof o.onClick&&"function"==typeof a.onClick&&(e.onclick=Ja)}for(u in ve(t,a),t=null,o)if(!a.hasOwnProperty(u)&&o.hasOwnProperty(u)&&null!=o[u])if("style"===u){var l=o[u];for(c in l)l.hasOwnProperty(c)&&(t||(t={}),t[c]="")}else"dangerouslySetInnerHTML"!==u&&"children"!==u&&"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&"autoFocus"!==u&&(i.hasOwnProperty(u)?r||(r=[]):(r=r||[]).push(u,null));for(u in a){var s=a[u];if(l=null!=o?o[u]:void 0,a.hasOwnProperty(u)&&s!==l&&(null!=s||null!=l))if("style"===u)if(l){for(c in l)!l.hasOwnProperty(c)||s&&s.hasOwnProperty(c)||(t||(t={}),t[c]="");for(c in s)s.hasOwnProperty(c)&&l[c]!==s[c]&&(t||(t={}),t[c]=s[c])}else t||(r||(r=[]),r.push(u,t)),t=s;else"dangerouslySetInnerHTML"===u?(s=s?s.__html:void 0,l=l?l.__html:void 0,null!=s&&l!==s&&(r=r||[]).push(u,s)):"children"===u?"string"!=typeof s&&"number"!=typeof s||(r=r||[]).push(u,""+s):"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&(i.hasOwnProperty(u)?(null!=s&&"onScroll"===u&&za("scroll",e),r||l===s||(r=[])):(r=r||[]).push(u,s))}t&&(r=r||[]).push("style",t);var u=r;(n.updateQueue=u)&&(n.flags|=4)}},Oi=function(e,n,t,a){t!==a&&(n.flags|=4)};var $i=!1,Xi=!1,Zi="function"==typeof WeakSet?WeakSet:Set,Qi=null;function Ji(e,n){var t=e.ref;if(null!==t)if("function"==typeof t)try{t(null)}catch(t){Es(e,n,t)}else t.current=null}function el(e,n,t){try{t()}catch(t){Es(e,n,t)}}var nl=!1;function tl(e,n,t){var a=n.updateQueue;if(null!==(a=null!==a?a.lastEffect:null)){var o=a=a.next;do{if((o.tag&e)===e){var c=o.destroy;o.destroy=void 0,void 0!==c&&el(n,t,c)}o=o.next}while(o!==a)}}function al(e,n){if(null!==(n=null!==(n=n.updateQueue)?n.lastEffect:null)){var t=n=n.next;do{if((t.tag&e)===e){var a=t.create;t.destroy=a()}t=t.next}while(t!==n)}}function ol(e){var n=e.ref;if(null!==n){var t=e.stateNode;e.tag,e=t,"function"==typeof n?n(e):n.current=e}}function cl(e){var n=e.alternate;null!==n&&(e.alternate=null,cl(n)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&null!==(n=e.stateNode)&&(delete n[fo],delete n[mo],delete n[go],delete n[ho],delete n[vo]),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function rl(e){return 5===e.tag||3===e.tag||4===e.tag}function il(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||rl(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function ll(e,n,t){var a=e.tag;if(5===a||6===a)e=e.stateNode,n?8===t.nodeType?t.parentNode.insertBefore(e,n):t.insertBefore(e,n):(8===t.nodeType?(n=t.parentNode).insertBefore(e,t):(n=t).appendChild(e),null!=(t=t._reactRootContainer)||null!==n.onclick||(n.onclick=Ja));else if(4!==a&&null!==(e=e.child))for(ll(e,n,t),e=e.sibling;null!==e;)ll(e,n,t),e=e.sibling}function sl(e,n,t){var a=e.tag;if(5===a||6===a)e=e.stateNode,n?t.insertBefore(e,n):t.appendChild(e);else if(4!==a&&null!==(e=e.child))for(sl(e,n,t),e=e.sibling;null!==e;)sl(e,n,t),e=e.sibling}var ul=null,dl=!1;function pl(e,n,t){for(t=t.child;null!==t;)fl(e,n,t),t=t.sibling}function fl(e,n,t){if(cn&&"function"==typeof cn.onCommitFiberUnmount)try{cn.onCommitFiberUnmount(on,t)}catch(e){}switch(t.tag){case 5:Xi||Ji(t,n);case 6:var a=ul,o=dl;ul=null,pl(e,n,t),dl=o,null!==(ul=a)&&(dl?(e=ul,t=t.stateNode,8===e.nodeType?e.parentNode.removeChild(t):e.removeChild(t)):ul.removeChild(t.stateNode));break;case 18:null!==ul&&(dl?(e=ul,t=t.stateNode,8===e.nodeType?lo(e.parentNode,t):1===e.nodeType&&lo(e,t),Wn(e)):lo(ul,t.stateNode));break;case 4:a=ul,o=dl,ul=t.stateNode.containerInfo,dl=!0,pl(e,n,t),ul=a,dl=o;break;case 0:case 11:case 14:case 15:if(!Xi&&null!==(a=t.updateQueue)&&null!==(a=a.lastEffect)){o=a=a.next;do{var c=o,r=c.destroy;c=c.tag,void 0!==r&&(2&c||4&c)&&el(t,n,r),o=o.next}while(o!==a)}pl(e,n,t);break;case 1:if(!Xi&&(Ji(t,n),"function"==typeof(a=t.stateNode).componentWillUnmount))try{a.props=t.memoizedProps,a.state=t.memoizedState,a.componentWillUnmount()}catch(e){Es(t,n,e)}pl(e,n,t);break;case 21:pl(e,n,t);break;case 22:1&t.mode?(Xi=(a=Xi)||null!==t.memoizedState,pl(e,n,t),Xi=a):pl(e,n,t);break;default:pl(e,n,t)}}function ml(e){var n=e.updateQueue;if(null!==n){e.updateQueue=null;var t=e.stateNode;null===t&&(t=e.stateNode=new Zi),n.forEach(function(n){var a=Is.bind(null,e,n);t.has(n)||(t.add(n),n.then(a,a))})}}function _l(e,n){var t=n.deletions;if(null!==t)for(var a=0;a<t.length;a++){var o=t[a];try{var r=e,i=n,l=i;e:for(;null!==l;){switch(l.tag){case 5:ul=l.stateNode,dl=!1;break e;case 3:case 4:ul=l.stateNode.containerInfo,dl=!0;break e}l=l.return}if(null===ul)throw Error(c(160));fl(r,i,o),ul=null,dl=!1;var s=o.alternate;null!==s&&(s.return=null),o.return=null}catch(e){Es(o,n,e)}}if(12854&n.subtreeFlags)for(n=n.child;null!==n;)gl(n,e),n=n.sibling}function gl(e,n){var t=e.alternate,a=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(_l(n,e),hl(e),4&a){try{tl(3,e,e.return),al(3,e)}catch(n){Es(e,e.return,n)}try{tl(5,e,e.return)}catch(n){Es(e,e.return,n)}}break;case 1:_l(n,e),hl(e),512&a&&null!==t&&Ji(t,t.return);break;case 5:if(_l(n,e),hl(e),512&a&&null!==t&&Ji(t,t.return),32&e.flags){var o=e.stateNode;try{pe(o,"")}catch(n){Es(e,e.return,n)}}if(4&a&&null!=(o=e.stateNode)){var r=e.memoizedProps,i=null!==t?t.memoizedProps:r,l=e.type,s=e.updateQueue;if(e.updateQueue=null,null!==s)try{"input"===l&&"radio"===r.type&&null!=r.name&&Z(o,r),be(l,i);var u=be(l,r);for(i=0;i<s.length;i+=2){var d=s[i],p=s[i+1];"style"===d?ge(o,p):"dangerouslySetInnerHTML"===d?de(o,p):"children"===d?pe(o,p):b(o,d,p,u)}switch(l){case"input":Q(o,r);break;case"textarea":ce(o,r);break;case"select":var f=o._wrapperState.wasMultiple;o._wrapperState.wasMultiple=!!r.multiple;var m=r.value;null!=m?te(o,!!r.multiple,m,!1):f!==!!r.multiple&&(null!=r.defaultValue?te(o,!!r.multiple,r.defaultValue,!0):te(o,!!r.multiple,r.multiple?[]:"",!1))}o[mo]=r}catch(n){Es(e,e.return,n)}}break;case 6:if(_l(n,e),hl(e),4&a){if(null===e.stateNode)throw Error(c(162));o=e.stateNode,r=e.memoizedProps;try{o.nodeValue=r}catch(n){Es(e,e.return,n)}}break;case 3:if(_l(n,e),hl(e),4&a&&null!==t&&t.memoizedState.isDehydrated)try{Wn(n.containerInfo)}catch(n){Es(e,e.return,n)}break;case 4:default:_l(n,e),hl(e);break;case 13:_l(n,e),hl(e),8192&(o=e.child).flags&&(r=null!==o.memoizedState,o.stateNode.isHidden=r,!r||null!==o.alternate&&null!==o.alternate.memoizedState||(ql=Ze())),4&a&&ml(e);break;case 22:if(d=null!==t&&null!==t.memoizedState,1&e.mode?(Xi=(u=Xi)||d,_l(n,e),Xi=u):_l(n,e),hl(e),8192&a){if(u=null!==e.memoizedState,(e.stateNode.isHidden=u)&&!d&&1&e.mode)for(Qi=e,d=e.child;null!==d;){for(p=Qi=d;null!==Qi;){switch(m=(f=Qi).child,f.tag){case 0:case 11:case 14:case 15:tl(4,f,f.return);break;case 1:Ji(f,f.return);var _=f.stateNode;if("function"==typeof _.componentWillUnmount){a=f,t=f.return;try{n=a,_.props=n.memoizedProps,_.state=n.memoizedState,_.componentWillUnmount()}catch(e){Es(a,t,e)}}break;case 5:Ji(f,f.return);break;case 22:if(null!==f.memoizedState){kl(p);continue}}null!==m?(m.return=f,Qi=m):kl(p)}d=d.sibling}e:for(d=null,p=e;;){if(5===p.tag){if(null===d){d=p;try{o=p.stateNode,u?"function"==typeof(r=o.style).setProperty?r.setProperty("display","none","important"):r.display="none":(l=p.stateNode,i=null!=(s=p.memoizedProps.style)&&s.hasOwnProperty("display")?s.display:null,l.style.display=_e("display",i))}catch(n){Es(e,e.return,n)}}}else if(6===p.tag){if(null===d)try{p.stateNode.nodeValue=u?"":p.memoizedProps}catch(n){Es(e,e.return,n)}}else if((22!==p.tag&&23!==p.tag||null===p.memoizedState||p===e)&&null!==p.child){p.child.return=p,p=p.child;continue}if(p===e)break e;for(;null===p.sibling;){if(null===p.return||p.return===e)break e;d===p&&(d=null),p=p.return}d===p&&(d=null),p.sibling.return=p.return,p=p.sibling}}break;case 19:_l(n,e),hl(e),4&a&&ml(e);case 21:}}function hl(e){var n=e.flags;if(2&n){try{e:{for(var t=e.return;null!==t;){if(rl(t)){var a=t;break e}t=t.return}throw Error(c(160))}switch(a.tag){case 5:var o=a.stateNode;32&a.flags&&(pe(o,""),a.flags&=-33),sl(e,il(e),o);break;case 3:case 4:var r=a.stateNode.containerInfo;ll(e,il(e),r);break;default:throw Error(c(161))}}catch(n){Es(e,e.return,n)}e.flags&=-3}4096&n&&(e.flags&=-4097)}function vl(e,n,t){Qi=e,bl(e,n,t)}function bl(e,n,t){for(var a=!!(1&e.mode);null!==Qi;){var o=Qi,c=o.child;if(22===o.tag&&a){var r=null!==o.memoizedState||$i;if(!r){var i=o.alternate,l=null!==i&&null!==i.memoizedState||Xi;i=$i;var s=Xi;if($i=r,(Xi=l)&&!s)for(Qi=o;null!==Qi;)l=(r=Qi).child,22===r.tag&&null!==r.memoizedState?xl(o):null!==l?(l.return=r,Qi=l):xl(o);for(;null!==c;)Qi=c,bl(c,n,t),c=c.sibling;Qi=o,$i=i,Xi=s}yl(e)}else 8772&o.subtreeFlags&&null!==c?(c.return=o,Qi=c):yl(e)}}function yl(e){for(;null!==Qi;){var n=Qi;if(8772&n.flags){var t=n.alternate;try{if(8772&n.flags)switch(n.tag){case 0:case 11:case 15:Xi||al(5,n);break;case 1:var a=n.stateNode;if(4&n.flags&&!Xi)if(null===t)a.componentDidMount();else{var o=n.elementType===n.type?t.memoizedProps:ti(n.type,t.memoizedProps);a.componentDidUpdate(o,t.memoizedState,a.__reactInternalSnapshotBeforeUpdate)}var r=n.updateQueue;null!==r&&Vc(n,r,a);break;case 3:var i=n.updateQueue;if(null!==i){if(t=null,null!==n.child)switch(n.child.tag){case 5:case 1:t=n.child.stateNode}Vc(n,i,t)}break;case 5:var l=n.stateNode;if(null===t&&4&n.flags){t=l;var s=n.memoizedProps;switch(n.type){case"button":case"input":case"select":case"textarea":s.autoFocus&&t.focus();break;case"img":s.src&&(t.src=s.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===n.memoizedState){var u=n.alternate;if(null!==u){var d=u.memoizedState;if(null!==d){var p=d.dehydrated;null!==p&&Wn(p)}}}break;default:throw Error(c(163))}Xi||512&n.flags&&ol(n)}catch(e){Es(n,n.return,e)}}if(n===e){Qi=null;break}if(null!==(t=n.sibling)){t.return=n.return,Qi=t;break}Qi=n.return}}function kl(e){for(;null!==Qi;){var n=Qi;if(n===e){Qi=null;break}var t=n.sibling;if(null!==t){t.return=n.return,Qi=t;break}Qi=n.return}}function xl(e){for(;null!==Qi;){var n=Qi;try{switch(n.tag){case 0:case 11:case 15:var t=n.return;try{al(4,n)}catch(e){Es(n,t,e)}break;case 1:var a=n.stateNode;if("function"==typeof a.componentDidMount){var o=n.return;try{a.componentDidMount()}catch(e){Es(n,o,e)}}var c=n.return;try{ol(n)}catch(e){Es(n,c,e)}break;case 5:var r=n.return;try{ol(n)}catch(e){Es(n,r,e)}}}catch(e){Es(n,n.return,e)}if(n===e){Qi=null;break}var i=n.sibling;if(null!==i){i.return=n.return,Qi=i;break}Qi=n.return}}var Sl,El=Math.ceil,Pl=y.ReactCurrentDispatcher,wl=y.ReactCurrentOwner,Cl=y.ReactCurrentBatchConfig,Il=0,Rl=null,Ll=null,Ml=0,Dl=0,Al=Po(0),Ol=0,Bl=null,Tl=0,Fl=0,Nl=0,zl=null,Gl=null,ql=0,Ul=1/0,Wl=null,Vl=!1,Hl=null,jl=null,Kl=!1,Yl=null,$l=0,Xl=0,Zl=null,Ql=-1,Jl=0;function es(){return 6&Il?Ze():-1!==Ql?Ql:Ql=Ze()}function ns(e){return 1&e.mode?2&Il&&0!==Ml?Ml&-Ml:null!==gc.transition?(0===Jl&&(Jl=gn()),Jl):0!==(e=yn)?e:e=void 0===(e=window.event)?16:Zn(e.type):1}function ts(e,n,t,a){if(50<Xl)throw Xl=0,Zl=null,Error(c(185));vn(e,t,a),2&Il&&e===Rl||(e===Rl&&(!(2&Il)&&(Fl|=t),4===Ol&&is(e,Ml)),as(e,a),1===t&&0===Il&&!(1&n.mode)&&(Ul=Ze()+500,Go&&Wo()))}function as(e,n){var t=e.callbackNode;!function(e,n){for(var t=e.suspendedLanes,a=e.pingedLanes,o=e.expirationTimes,c=e.pendingLanes;0<c;){var r=31-rn(c),i=1<<r,l=o[r];-1===l?0!==(i&t)&&0===(i&a)||(o[r]=mn(i,n)):l<=n&&(e.expiredLanes|=i),c&=~i}}(e,n);var a=fn(e,e===Rl?Ml:0);if(0===a)null!==t&&Ye(t),e.callbackNode=null,e.callbackPriority=0;else if(n=a&-a,e.callbackPriority!==n){if(null!=t&&Ye(t),1===n)0===e.tag?function(e){Go=!0,Uo(e)}(ls.bind(null,e)):Uo(ls.bind(null,e)),ro(function(){!(6&Il)&&Wo()}),t=null;else{switch(kn(a)){case 1:t=Je;break;case 4:t=en;break;case 16:default:t=nn;break;case 536870912:t=an}t=Rs(t,os.bind(null,e))}e.callbackPriority=n,e.callbackNode=t}}function os(e,n){if(Ql=-1,Jl=0,6&Il)throw Error(c(327));var t=e.callbackNode;if(xs()&&e.callbackNode!==t)return null;var a=fn(e,e===Rl?Ml:0);if(0===a)return null;if(30&a||0!==(a&e.expiredLanes)||n)n=gs(e,a);else{n=a;var o=Il;Il|=2;var r=ms();for(Rl===e&&Ml===n||(Wl=null,Ul=Ze()+500,ps(e,n));;)try{vs();break}catch(n){fs(e,n)}Cc(),Pl.current=r,Il=o,null!==Ll?n=0:(Rl=null,Ml=0,n=Ol)}if(0!==n){if(2===n&&0!==(o=_n(e))&&(a=o,n=cs(e,o)),1===n)throw t=Bl,ps(e,0),is(e,a),as(e,Ze()),t;if(6===n)is(e,a);else{if(o=e.current.alternate,!(30&a||function(e){for(var n=e;;){if(16384&n.flags){var t=n.updateQueue;if(null!==t&&null!==(t=t.stores))for(var a=0;a<t.length;a++){var o=t[a],c=o.getSnapshot;o=o.value;try{if(!ia(c(),o))return!1}catch(e){return!1}}}if(t=n.child,16384&n.subtreeFlags&&null!==t)t.return=n,n=t;else{if(n===e)break;for(;null===n.sibling;){if(null===n.return||n.return===e)return!0;n=n.return}n.sibling.return=n.return,n=n.sibling}}return!0}(o)||(n=gs(e,a),2===n&&(r=_n(e),0!==r&&(a=r,n=cs(e,r))),1!==n)))throw t=Bl,ps(e,0),is(e,a),as(e,Ze()),t;switch(e.finishedWork=o,e.finishedLanes=a,n){case 0:case 1:throw Error(c(345));case 2:case 5:ks(e,Gl,Wl);break;case 3:if(is(e,a),(130023424&a)===a&&10<(n=ql+500-Ze())){if(0!==fn(e,0))break;if(((o=e.suspendedLanes)&a)!==a){es(),e.pingedLanes|=e.suspendedLanes&o;break}e.timeoutHandle=ao(ks.bind(null,e,Gl,Wl),n);break}ks(e,Gl,Wl);break;case 4:if(is(e,a),(4194240&a)===a)break;for(n=e.eventTimes,o=-1;0<a;){var i=31-rn(a);r=1<<i,(i=n[i])>o&&(o=i),a&=~r}if(a=o,10<(a=(120>(a=Ze()-a)?120:480>a?480:1080>a?1080:1920>a?1920:3e3>a?3e3:4320>a?4320:1960*El(a/1960))-a)){e.timeoutHandle=ao(ks.bind(null,e,Gl,Wl),a);break}ks(e,Gl,Wl);break;default:throw Error(c(329))}}}return as(e,Ze()),e.callbackNode===t?os.bind(null,e):null}function cs(e,n){var t=zl;return e.current.memoizedState.isDehydrated&&(ps(e,n).flags|=256),2!==(e=gs(e,n))&&(n=Gl,Gl=t,null!==n&&rs(n)),e}function rs(e){null===Gl?Gl=e:Gl.push.apply(Gl,e)}function is(e,n){for(n&=~Nl,n&=~Fl,e.suspendedLanes|=n,e.pingedLanes&=~n,e=e.expirationTimes;0<n;){var t=31-rn(n),a=1<<t;e[t]=-1,n&=~a}}function ls(e){if(6&Il)throw Error(c(327));xs();var n=fn(e,0);if(!(1&n))return as(e,Ze()),null;var t=gs(e,n);if(0!==e.tag&&2===t){var a=_n(e);0!==a&&(n=a,t=cs(e,a))}if(1===t)throw t=Bl,ps(e,0),is(e,n),as(e,Ze()),t;if(6===t)throw Error(c(345));return e.finishedWork=e.current.alternate,e.finishedLanes=n,ks(e,Gl,Wl),as(e,Ze()),null}function ss(e,n){var t=Il;Il|=1;try{return e(n)}finally{0===(Il=t)&&(Ul=Ze()+500,Go&&Wo())}}function us(e){null!==Yl&&0===Yl.tag&&!(6&Il)&&xs();var n=Il;Il|=1;var t=Cl.transition,a=yn;try{if(Cl.transition=null,yn=1,e)return e()}finally{yn=a,Cl.transition=t,!(6&(Il=n))&&Wo()}}function ds(){Dl=Al.current,wo(Al)}function ps(e,n){e.finishedWork=null,e.finishedLanes=0;var t=e.timeoutHandle;if(-1!==t&&(e.timeoutHandle=-1,oo(t)),null!==Ll)for(t=Ll.return;null!==t;){var a=t;switch(tc(a),a.tag){case 1:null!=(a=a.type.childContextTypes)&&Oo();break;case 3:Zc(),wo(Lo),wo(Ro),ar();break;case 5:Jc(a);break;case 4:Zc();break;case 13:case 19:wo(er);break;case 10:Ic(a.type._context);break;case 22:case 23:ds()}t=t.return}if(Rl=e,Ll=e=As(e.current,null),Ml=Dl=n,Ol=0,Bl=null,Nl=Fl=Tl=0,Gl=zl=null,null!==Dc){for(n=0;n<Dc.length;n++)if(null!==(a=(t=Dc[n]).interleaved)){t.interleaved=null;var o=a.next,c=t.pending;if(null!==c){var r=c.next;c.next=o,a.next=r}t.pending=a}Dc=null}return e}function fs(e,n){for(;;){var t=Ll;try{if(Cc(),or.current=Qr,ur){for(var a=ir.memoizedState;null!==a;){var o=a.queue;null!==o&&(o.pending=null),a=a.next}ur=!1}if(rr=0,sr=lr=ir=null,dr=!1,pr=0,wl.current=null,null===t||null===t.return){Ol=1,Bl=n,Ll=null;break}e:{var r=e,i=t.return,l=t,s=n;if(n=Ml,l.flags|=32768,null!==s&&"object"==typeof s&&"function"==typeof s.then){var u=s,d=l,p=d.tag;if(!(1&d.mode||0!==p&&11!==p&&15!==p)){var f=d.alternate;f?(d.updateQueue=f.updateQueue,d.memoizedState=f.memoizedState,d.lanes=f.lanes):(d.updateQueue=null,d.memoizedState=null)}var m=gi(i);if(null!==m){m.flags&=-257,hi(m,i,l,0,n),1&m.mode&&_i(r,u,n),s=u;var _=(n=m).updateQueue;if(null===_){var g=new Set;g.add(s),n.updateQueue=g}else _.add(s);break e}if(!(1&n)){_i(r,u,n),_s();break e}s=Error(c(426))}else if(cc&&1&l.mode){var h=gi(i);if(null!==h){!(65536&h.flags)&&(h.flags|=256),hi(h,i,l,0,n),_c(si(s,l));break e}}r=s=si(s,l),4!==Ol&&(Ol=2),null===zl?zl=[r]:zl.push(r),r=i;do{switch(r.tag){case 3:r.flags|=65536,n&=-n,r.lanes|=n,Uc(r,fi(0,s,n));break e;case 1:l=s;var v=r.type,b=r.stateNode;if(!(128&r.flags||"function"!=typeof v.getDerivedStateFromError&&(null===b||"function"!=typeof b.componentDidCatch||null!==jl&&jl.has(b)))){r.flags|=65536,n&=-n,r.lanes|=n,Uc(r,mi(r,l,n));break e}}r=r.return}while(null!==r)}ys(t)}catch(e){n=e,Ll===t&&null!==t&&(Ll=t=t.return);continue}break}}function ms(){var e=Pl.current;return Pl.current=Qr,null===e?Qr:e}function _s(){0!==Ol&&3!==Ol&&2!==Ol||(Ol=4),null===Rl||!(268435455&Tl)&&!(268435455&Fl)||is(Rl,Ml)}function gs(e,n){var t=Il;Il|=2;var a=ms();for(Rl===e&&Ml===n||(Wl=null,ps(e,n));;)try{hs();break}catch(n){fs(e,n)}if(Cc(),Il=t,Pl.current=a,null!==Ll)throw Error(c(261));return Rl=null,Ml=0,Ol}function hs(){for(;null!==Ll;)bs(Ll)}function vs(){for(;null!==Ll&&!$e();)bs(Ll)}function bs(e){var n=Sl(e.alternate,e,Dl);e.memoizedProps=e.pendingProps,null===n?ys(e):Ll=n,wl.current=null}function ys(e){var n=e;do{var t=n.alternate;if(e=n.return,32768&n.flags){if(null!==(t=Yi(t,n)))return t.flags&=32767,void(Ll=t);if(null===e)return Ol=6,void(Ll=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}else if(null!==(t=Ki(t,n,Dl)))return void(Ll=t);if(null!==(n=n.sibling))return void(Ll=n);Ll=n=e}while(null!==n);0===Ol&&(Ol=5)}function ks(e,n,t){var a=yn,o=Cl.transition;try{Cl.transition=null,yn=1,function(e,n,t,a){do{xs()}while(null!==Yl);if(6&Il)throw Error(c(327));t=e.finishedWork;var o=e.finishedLanes;if(null===t)return null;if(e.finishedWork=null,e.finishedLanes=0,t===e.current)throw Error(c(177));e.callbackNode=null,e.callbackPriority=0;var r=t.lanes|t.childLanes;if(function(e,n){var t=e.pendingLanes&~n;e.pendingLanes=n,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=n,e.mutableReadLanes&=n,e.entangledLanes&=n,n=e.entanglements;var a=e.eventTimes;for(e=e.expirationTimes;0<t;){var o=31-rn(t),c=1<<o;n[o]=0,a[o]=-1,e[o]=-1,t&=~c}}(e,r),e===Rl&&(Ll=Rl=null,Ml=0),!(2064&t.subtreeFlags)&&!(2064&t.flags)||Kl||(Kl=!0,Rs(nn,function(){return xs(),null})),r=!!(15990&t.flags),15990&t.subtreeFlags||r){r=Cl.transition,Cl.transition=null;var i=yn;yn=1;var l=Il;Il|=4,wl.current=null,function(e,n){if(eo=Hn,fa(e=pa())){if("selectionStart"in e)var t={start:e.selectionStart,end:e.selectionEnd};else e:{var a=(t=(t=e.ownerDocument)&&t.defaultView||window).getSelection&&t.getSelection();if(a&&0!==a.rangeCount){t=a.anchorNode;var o=a.anchorOffset,r=a.focusNode;a=a.focusOffset;try{t.nodeType,r.nodeType}catch(e){t=null;break e}var i=0,l=-1,s=-1,u=0,d=0,p=e,f=null;n:for(;;){for(var m;p!==t||0!==o&&3!==p.nodeType||(l=i+o),p!==r||0!==a&&3!==p.nodeType||(s=i+a),3===p.nodeType&&(i+=p.nodeValue.length),null!==(m=p.firstChild);)f=p,p=m;for(;;){if(p===e)break n;if(f===t&&++u===o&&(l=i),f===r&&++d===a&&(s=i),null!==(m=p.nextSibling))break;f=(p=f).parentNode}p=m}t=-1===l||-1===s?null:{start:l,end:s}}else t=null}t=t||{start:0,end:0}}else t=null;for(no={focusedElem:e,selectionRange:t},Hn=!1,Qi=n;null!==Qi;)if(e=(n=Qi).child,1028&n.subtreeFlags&&null!==e)e.return=n,Qi=e;else for(;null!==Qi;){n=Qi;try{var _=n.alternate;if(1024&n.flags)switch(n.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==_){var g=_.memoizedProps,h=_.memoizedState,v=n.stateNode,b=v.getSnapshotBeforeUpdate(n.elementType===n.type?g:ti(n.type,g),h);v.__reactInternalSnapshotBeforeUpdate=b}break;case 3:var y=n.stateNode.containerInfo;1===y.nodeType?y.textContent="":9===y.nodeType&&y.documentElement&&y.removeChild(y.documentElement);break;default:throw Error(c(163))}}catch(e){Es(n,n.return,e)}if(null!==(e=n.sibling)){e.return=n.return,Qi=e;break}Qi=n.return}_=nl,nl=!1}(e,t),gl(t,e),ma(no),Hn=!!eo,no=eo=null,e.current=t,vl(t,e,o),Xe(),Il=l,yn=i,Cl.transition=r}else e.current=t;if(Kl&&(Kl=!1,Yl=e,$l=o),0===(r=e.pendingLanes)&&(jl=null),function(e){if(cn&&"function"==typeof cn.onCommitFiberRoot)try{cn.onCommitFiberRoot(on,e,void 0,!(128&~e.current.flags))}catch(e){}}(t.stateNode),as(e,Ze()),null!==n)for(a=e.onRecoverableError,t=0;t<n.length;t++)a((o=n[t]).value,{componentStack:o.stack,digest:o.digest});if(Vl)throw Vl=!1,e=Hl,Hl=null,e;!!(1&$l)&&0!==e.tag&&xs(),1&(r=e.pendingLanes)?e===Zl?Xl++:(Xl=0,Zl=e):Xl=0,Wo()}(e,n,t,a)}finally{Cl.transition=o,yn=a}return null}function xs(){if(null!==Yl){var e=kn($l),n=Cl.transition,t=yn;try{if(Cl.transition=null,yn=16>e?16:e,null===Yl)var a=!1;else{if(e=Yl,Yl=null,$l=0,6&Il)throw Error(c(331));var o=Il;for(Il|=4,Qi=e.current;null!==Qi;){var r=Qi,i=r.child;if(16&Qi.flags){var l=r.deletions;if(null!==l){for(var s=0;s<l.length;s++){var u=l[s];for(Qi=u;null!==Qi;){var d=Qi;switch(d.tag){case 0:case 11:case 15:tl(8,d,r)}var p=d.child;if(null!==p)p.return=d,Qi=p;else for(;null!==Qi;){var f=(d=Qi).sibling,m=d.return;if(cl(d),d===u){Qi=null;break}if(null!==f){f.return=m,Qi=f;break}Qi=m}}}var _=r.alternate;if(null!==_){var g=_.child;if(null!==g){_.child=null;do{var h=g.sibling;g.sibling=null,g=h}while(null!==g)}}Qi=r}}if(2064&r.subtreeFlags&&null!==i)i.return=r,Qi=i;else e:for(;null!==Qi;){if(2048&(r=Qi).flags)switch(r.tag){case 0:case 11:case 15:tl(9,r,r.return)}var v=r.sibling;if(null!==v){v.return=r.return,Qi=v;break e}Qi=r.return}}var b=e.current;for(Qi=b;null!==Qi;){var y=(i=Qi).child;if(2064&i.subtreeFlags&&null!==y)y.return=i,Qi=y;else e:for(i=b;null!==Qi;){if(2048&(l=Qi).flags)try{switch(l.tag){case 0:case 11:case 15:al(9,l)}}catch(e){Es(l,l.return,e)}if(l===i){Qi=null;break e}var k=l.sibling;if(null!==k){k.return=l.return,Qi=k;break e}Qi=l.return}}if(Il=o,Wo(),cn&&"function"==typeof cn.onPostCommitFiberRoot)try{cn.onPostCommitFiberRoot(on,e)}catch(e){}a=!0}return a}finally{yn=t,Cl.transition=n}}return!1}function Ss(e,n,t){e=Gc(e,n=fi(0,n=si(t,n),1),1),n=es(),null!==e&&(vn(e,1,n),as(e,n))}function Es(e,n,t){if(3===e.tag)Ss(e,e,t);else for(;null!==n;){if(3===n.tag){Ss(n,e,t);break}if(1===n.tag){var a=n.stateNode;if("function"==typeof n.type.getDerivedStateFromError||"function"==typeof a.componentDidCatch&&(null===jl||!jl.has(a))){n=Gc(n,e=mi(n,e=si(t,e),1),1),e=es(),null!==n&&(vn(n,1,e),as(n,e));break}}n=n.return}}function Ps(e,n,t){var a=e.pingCache;null!==a&&a.delete(n),n=es(),e.pingedLanes|=e.suspendedLanes&t,Rl===e&&(Ml&t)===t&&(4===Ol||3===Ol&&(130023424&Ml)===Ml&&500>Ze()-ql?ps(e,0):Nl|=t),as(e,n)}function ws(e,n){0===n&&(1&e.mode?(n=dn,!(130023424&(dn<<=1))&&(dn=4194304)):n=1);var t=es();null!==(e=Bc(e,n))&&(vn(e,n,t),as(e,t))}function Cs(e){var n=e.memoizedState,t=0;null!==n&&(t=n.retryLane),ws(e,t)}function Is(e,n){var t=0;switch(e.tag){case 13:var a=e.stateNode,o=e.memoizedState;null!==o&&(t=o.retryLane);break;case 19:a=e.stateNode;break;default:throw Error(c(314))}null!==a&&a.delete(n),ws(e,t)}function Rs(e,n){return Ke(e,n)}function Ls(e,n,t,a){this.tag=e,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=n,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ms(e,n,t,a){return new Ls(e,n,t,a)}function Ds(e){return!(!(e=e.prototype)||!e.isReactComponent)}function As(e,n){var t=e.alternate;return null===t?((t=Ms(e.tag,n,e.key,e.mode)).elementType=e.elementType,t.type=e.type,t.stateNode=e.stateNode,t.alternate=e,e.alternate=t):(t.pendingProps=n,t.type=e.type,t.flags=0,t.subtreeFlags=0,t.deletions=null),t.flags=14680064&e.flags,t.childLanes=e.childLanes,t.lanes=e.lanes,t.child=e.child,t.memoizedProps=e.memoizedProps,t.memoizedState=e.memoizedState,t.updateQueue=e.updateQueue,n=e.dependencies,t.dependencies=null===n?null:{lanes:n.lanes,firstContext:n.firstContext},t.sibling=e.sibling,t.index=e.index,t.ref=e.ref,t}function Os(e,n,t,a,o,r){var i=2;if(a=e,"function"==typeof e)Ds(e)&&(i=1);else if("string"==typeof e)i=5;else e:switch(e){case S:return Bs(t.children,o,r,n);case E:i=8,o|=8;break;case P:return(e=Ms(12,t,n,2|o)).elementType=P,e.lanes=r,e;case R:return(e=Ms(13,t,n,o)).elementType=R,e.lanes=r,e;case L:return(e=Ms(19,t,n,o)).elementType=L,e.lanes=r,e;case A:return Ts(t,o,r,n);default:if("object"==typeof e&&null!==e)switch(e.$$typeof){case w:i=10;break e;case C:i=9;break e;case I:i=11;break e;case M:i=14;break e;case D:i=16,a=null;break e}throw Error(c(130,null==e?e:typeof e,""))}return(n=Ms(i,t,n,o)).elementType=e,n.type=a,n.lanes=r,n}function Bs(e,n,t,a){return(e=Ms(7,e,a,n)).lanes=t,e}function Ts(e,n,t,a){return(e=Ms(22,e,a,n)).elementType=A,e.lanes=t,e.stateNode={isHidden:!1},e}function Fs(e,n,t){return(e=Ms(6,e,null,n)).lanes=t,e}function Ns(e,n,t){return(n=Ms(4,null!==e.children?e.children:[],e.key,n)).lanes=t,n.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},n}function zs(e,n,t,a,o){this.tag=n,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=hn(0),this.expirationTimes=hn(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=hn(0),this.identifierPrefix=a,this.onRecoverableError=o,this.mutableSourceEagerHydrationData=null}function Gs(e,n,t,a,o,c,r,i,l){return e=new zs(e,n,t,i,l),1===n?(n=1,!0===c&&(n|=8)):n=0,c=Ms(3,null,null,n),e.current=c,c.stateNode=e,c.memoizedState={element:a,isDehydrated:t,cache:null,transitions:null,pendingSuspenseBoundaries:null},Fc(c),e}function qs(e){if(!e)return Io;e:{if(Ue(e=e._reactInternals)!==e||1!==e.tag)throw Error(c(170));var n=e;do{switch(n.tag){case 3:n=n.stateNode.context;break e;case 1:if(Ao(n.type)){n=n.stateNode.__reactInternalMemoizedMergedChildContext;break e}}n=n.return}while(null!==n);throw Error(c(171))}if(1===e.tag){var t=e.type;if(Ao(t))return To(e,t,n)}return n}function Us(e,n,t,a,o,c,r,i,l){return(e=Gs(t,a,!0,e,0,c,0,i,l)).context=qs(null),t=e.current,(c=zc(a=es(),o=ns(t))).callback=null!=n?n:null,Gc(t,c,o),e.current.lanes=o,vn(e,o,a),as(e,a),e}function Ws(e,n,t,a){var o=n.current,c=es(),r=ns(o);return t=qs(t),null===n.context?n.context=t:n.pendingContext=t,(n=zc(c,r)).payload={element:e},null!==(a=void 0===a?null:a)&&(n.callback=a),null!==(e=Gc(o,n,r))&&(ts(e,o,r,c),qc(e,o,r)),r}function Vs(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Hs(e,n){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var t=e.retryLane;e.retryLane=0!==t&&t<n?t:n}}function js(e,n){Hs(e,n),(e=e.alternate)&&Hs(e,n)}Sl=function(e,n,t){if(null!==e)if(e.memoizedProps!==n.pendingProps||Lo.current)bi=!0;else{if(0===(e.lanes&t)&&!(128&n.flags))return bi=!1,function(e,n,t){switch(n.tag){case 3:Ri(n),mc();break;case 5:Qc(n);break;case 1:Ao(n.type)&&Fo(n);break;case 4:Xc(n,n.stateNode.containerInfo);break;case 10:var a=n.type._context,o=n.memoizedProps.value;Co(Sc,a._currentValue),a._currentValue=o;break;case 13:if(null!==(a=n.memoizedState))return null!==a.dehydrated?(Co(er,1&er.current),n.flags|=128,null):0!==(t&n.child.childLanes)?Fi(e,n,t):(Co(er,1&er.current),null!==(e=Vi(e,n,t))?e.sibling:null);Co(er,1&er.current);break;case 19:if(a=0!==(t&n.childLanes),128&e.flags){if(a)return Ui(e,n,t);n.flags|=128}if(null!==(o=n.memoizedState)&&(o.rendering=null,o.tail=null,o.lastEffect=null),Co(er,er.current),a)break;return null;case 22:case 23:return n.lanes=0,Ei(e,n,t)}return Vi(e,n,t)}(e,n,t);bi=!!(131072&e.flags)}else bi=!1,cc&&1048576&n.flags&&ec(n,Ko,n.index);switch(n.lanes=0,n.tag){case 2:var a=n.type;Wi(e,n),e=n.pendingProps;var o=Do(n,Ro.current);Lc(n,t),o=gr(null,n,a,e,o,t);var r=hr();return n.flags|=1,"object"==typeof o&&null!==o&&"function"==typeof o.render&&void 0===o.$$typeof?(n.tag=1,n.memoizedState=null,n.updateQueue=null,Ao(a)?(r=!0,Fo(n)):r=!1,n.memoizedState=null!==o.state&&void 0!==o.state?o.state:null,Fc(n),o.updater=oi,n.stateNode=o,o._reactInternals=n,li(n,a,e,t),n=Ii(null,n,a,!0,r,t)):(n.tag=0,cc&&r&&nc(n),yi(null,n,o,t),n=n.child),n;case 16:a=n.elementType;e:{switch(Wi(e,n),e=n.pendingProps,a=(o=a._init)(a._payload),n.type=a,o=n.tag=function(e){if("function"==typeof e)return Ds(e)?1:0;if(null!=e){if((e=e.$$typeof)===I)return 11;if(e===M)return 14}return 2}(a),e=ti(a,e),o){case 0:n=wi(null,n,a,e,t);break e;case 1:n=Ci(null,n,a,e,t);break e;case 11:n=ki(null,n,a,e,t);break e;case 14:n=xi(null,n,a,ti(a.type,e),t);break e}throw Error(c(306,a,""))}return n;case 0:return a=n.type,o=n.pendingProps,wi(e,n,a,o=n.elementType===a?o:ti(a,o),t);case 1:return a=n.type,o=n.pendingProps,Ci(e,n,a,o=n.elementType===a?o:ti(a,o),t);case 3:e:{if(Ri(n),null===e)throw Error(c(387));a=n.pendingProps,o=(r=n.memoizedState).element,Nc(e,n),Wc(n,a,null,t);var i=n.memoizedState;if(a=i.element,r.isDehydrated){if(r={element:a,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},n.updateQueue.baseState=r,n.memoizedState=r,256&n.flags){n=Li(e,n,a,t,o=si(Error(c(423)),n));break e}if(a!==o){n=Li(e,n,a,t,o=si(Error(c(424)),n));break e}for(oc=so(n.stateNode.containerInfo.firstChild),ac=n,cc=!0,rc=null,t=xc(n,null,a,t),n.child=t;t;)t.flags=-3&t.flags|4096,t=t.sibling}else{if(mc(),a===o){n=Vi(e,n,t);break e}yi(e,n,a,t)}n=n.child}return n;case 5:return Qc(n),null===e&&uc(n),a=n.type,o=n.pendingProps,r=null!==e?e.memoizedProps:null,i=o.children,to(a,o)?i=null:null!==r&&to(a,r)&&(n.flags|=32),Pi(e,n),yi(e,n,i,t),n.child;case 6:return null===e&&uc(n),null;case 13:return Fi(e,n,t);case 4:return Xc(n,n.stateNode.containerInfo),a=n.pendingProps,null===e?n.child=kc(n,null,a,t):yi(e,n,a,t),n.child;case 11:return a=n.type,o=n.pendingProps,ki(e,n,a,o=n.elementType===a?o:ti(a,o),t);case 7:return yi(e,n,n.pendingProps,t),n.child;case 8:case 12:return yi(e,n,n.pendingProps.children,t),n.child;case 10:e:{if(a=n.type._context,o=n.pendingProps,r=n.memoizedProps,i=o.value,Co(Sc,a._currentValue),a._currentValue=i,null!==r)if(ia(r.value,i)){if(r.children===o.children&&!Lo.current){n=Vi(e,n,t);break e}}else for(null!==(r=n.child)&&(r.return=n);null!==r;){var l=r.dependencies;if(null!==l){i=r.child;for(var s=l.firstContext;null!==s;){if(s.context===a){if(1===r.tag){(s=zc(-1,t&-t)).tag=2;var u=r.updateQueue;if(null!==u){var d=(u=u.shared).pending;null===d?s.next=s:(s.next=d.next,d.next=s),u.pending=s}}r.lanes|=t,null!==(s=r.alternate)&&(s.lanes|=t),Rc(r.return,t,n),l.lanes|=t;break}s=s.next}}else if(10===r.tag)i=r.type===n.type?null:r.child;else if(18===r.tag){if(null===(i=r.return))throw Error(c(341));i.lanes|=t,null!==(l=i.alternate)&&(l.lanes|=t),Rc(i,t,n),i=r.sibling}else i=r.child;if(null!==i)i.return=r;else for(i=r;null!==i;){if(i===n){i=null;break}if(null!==(r=i.sibling)){r.return=i.return,i=r;break}i=i.return}r=i}yi(e,n,o.children,t),n=n.child}return n;case 9:return o=n.type,a=n.pendingProps.children,Lc(n,t),a=a(o=Mc(o)),n.flags|=1,yi(e,n,a,t),n.child;case 14:return o=ti(a=n.type,n.pendingProps),xi(e,n,a,o=ti(a.type,o),t);case 15:return Si(e,n,n.type,n.pendingProps,t);case 17:return a=n.type,o=n.pendingProps,o=n.elementType===a?o:ti(a,o),Wi(e,n),n.tag=1,Ao(a)?(e=!0,Fo(n)):e=!1,Lc(n,t),ri(n,a,o),li(n,a,o,t),Ii(null,n,a,!0,e,t);case 19:return Ui(e,n,t);case 22:return Ei(e,n,t)}throw Error(c(156,n.tag))};var Ks="function"==typeof reportError?reportError:function(e){console.error(e)};function Ys(e){this._internalRoot=e}function $s(e){this._internalRoot=e}function Xs(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Zs(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Qs(){}function Js(e,n,t,a,o){var c=t._reactRootContainer;if(c){var r=c;if("function"==typeof o){var i=o;o=function(){var e=Vs(r);i.call(e)}}Ws(n,r,e,o)}else r=function(e,n,t,a,o){if(o){if("function"==typeof a){var c=a;a=function(){var e=Vs(r);c.call(e)}}var r=Us(n,a,e,0,null,!1,0,"",Qs);return e._reactRootContainer=r,e[_o]=r.current,Ua(8===e.nodeType?e.parentNode:e),us(),r}for(;o=e.lastChild;)e.removeChild(o);if("function"==typeof a){var i=a;a=function(){var e=Vs(l);i.call(e)}}var l=Gs(e,0,!1,null,0,!1,0,"",Qs);return e._reactRootContainer=l,e[_o]=l.current,Ua(8===e.nodeType?e.parentNode:e),us(function(){Ws(n,l,t,a)}),l}(t,n,e,o,a);return Vs(r)}$s.prototype.render=Ys.prototype.render=function(e){var n=this._internalRoot;if(null===n)throw Error(c(409));Ws(e,n,null,null)},$s.prototype.unmount=Ys.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var n=e.containerInfo;us(function(){Ws(null,e,null,null)}),n[_o]=null}},$s.prototype.unstable_scheduleHydration=function(e){if(e){var n=Pn();e={blockedOn:null,target:e,priority:n};for(var t=0;t<On.length&&0!==n&&n<On[t].priority;t++);On.splice(t,0,e),0===t&&Nn(e)}},xn=function(e){switch(e.tag){case 3:var n=e.stateNode;if(n.current.memoizedState.isDehydrated){var t=pn(n.pendingLanes);0!==t&&(bn(n,1|t),as(n,Ze()),!(6&Il)&&(Ul=Ze()+500,Wo()))}break;case 13:us(function(){var n=Bc(e,1);if(null!==n){var t=es();ts(n,e,1,t)}}),js(e,1)}},Sn=function(e){if(13===e.tag){var n=Bc(e,134217728);null!==n&&ts(n,e,134217728,es()),js(e,134217728)}},En=function(e){if(13===e.tag){var n=ns(e),t=Bc(e,n);null!==t&&ts(t,e,n,es()),js(e,n)}},Pn=function(){return yn},wn=function(e,n){var t=yn;try{return yn=e,n()}finally{yn=t}},xe=function(e,n,t){switch(n){case"input":if(Q(e,t),n=t.name,"radio"===t.type&&null!=n){for(t=e;t.parentNode;)t=t.parentNode;for(t=t.querySelectorAll("input[name="+JSON.stringify(""+n)+'][type="radio"]'),n=0;n<t.length;n++){var a=t[n];if(a!==e&&a.form===e.form){var o=xo(a);if(!o)throw Error(c(90));K(a),Q(a,o)}}}break;case"textarea":ce(e,t);break;case"select":null!=(n=t.value)&&te(e,!!t.multiple,n,!1)}},Ie=ss,Re=us;var eu={usingClientEntryPoint:!1,Events:[yo,ko,xo,we,Ce,ss]},nu={findFiberByHostInstance:bo,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},tu={bundleType:nu.bundleType,version:nu.version,rendererPackageName:nu.rendererPackageName,rendererConfig:nu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:y.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=He(e))?null:e.stateNode},findFiberByHostInstance:nu.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var au=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!au.isDisabled&&au.supportsFiber)try{on=au.inject(tu),cn=au}catch(ue){}}n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=eu,n.createPortal=function(e,n){var t=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Xs(n))throw Error(c(200));return function(e,n,t){var a=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:x,key:null==a?null:""+a,children:e,containerInfo:n,implementation:t}}(e,n,null,t)},n.createRoot=function(e,n){if(!Xs(e))throw Error(c(299));var t=!1,a="",o=Ks;return null!=n&&(!0===n.unstable_strictMode&&(t=!0),void 0!==n.identifierPrefix&&(a=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),n=Gs(e,1,!1,null,0,t,0,a,o),e[_o]=n.current,Ua(8===e.nodeType?e.parentNode:e),new Ys(n)},n.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var n=e._reactInternals;if(void 0===n){if("function"==typeof e.render)throw Error(c(188));throw e=Object.keys(e).join(","),Error(c(268,e))}return null===(e=He(n))?null:e.stateNode},n.flushSync=function(e){return us(e)},n.hydrate=function(e,n,t){if(!Zs(n))throw Error(c(200));return Js(null,e,n,!0,t)},n.hydrateRoot=function(e,n,t){if(!Xs(e))throw Error(c(405));var a=null!=t&&t.hydratedSources||null,o=!1,r="",i=Ks;if(null!=t&&(!0===t.unstable_strictMode&&(o=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onRecoverableError&&(i=t.onRecoverableError)),n=Us(n,null,e,1,null!=t?t:null,o,0,r,i),e[_o]=n.current,Ua(e),a)for(e=0;e<a.length;e++)o=(o=(t=a[e])._getVersion)(t._source),null==n.mutableSourceEagerHydrationData?n.mutableSourceEagerHydrationData=[t,o]:n.mutableSourceEagerHydrationData.push(t,o);return new $s(n)},n.render=function(e,n,t){if(!Zs(n))throw Error(c(200));return Js(null,e,n,!1,t)},n.unmountComponentAtNode=function(e){if(!Zs(e))throw Error(c(40));return!!e._reactRootContainer&&(us(function(){Js(null,null,e,!1,function(){e._reactRootContainer=null,e[_o]=null})}),!0)},n.unstable_batchedUpdates=ss,n.unstable_renderSubtreeIntoContainer=function(e,n,t,a){if(!Zs(t))throw Error(c(200));if(null==e||void 0===e._reactInternals)throw Error(c(38));return Js(e,n,t,!1,a)},n.version="18.3.1-next-f1338f8080-20240426"},601:e=>{e.exports=function(e){return e[1]}},659:e=>{var n={};e.exports=function(e,t){var a=function(e){if(void 0===n[e]){var t=document.querySelector(e);if(window.HTMLIFrameElement&&t instanceof window.HTMLIFrameElement)try{t=t.contentDocument.head}catch(e){t=null}n[e]=t}return n[e]}(e);if(!a)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");a.appendChild(t)}},825:e=>{e.exports=function(e){if("undefined"==typeof document)return{update:function(){},remove:function(){}};var n=e.insertStyleElement(e);return{update:function(t){!function(e,n,t){var a="";t.supports&&(a+="@supports (".concat(t.supports,") {")),t.media&&(a+="@media ".concat(t.media," {"));var o=void 0!==t.layer;o&&(a+="@layer".concat(t.layer.length>0?" ".concat(t.layer):""," {")),a+=t.css,o&&(a+="}"),t.media&&(a+="}"),t.supports&&(a+="}");var c=t.sourceMap;c&&"undefined"!=typeof btoa&&(a+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(c))))," */")),n.styleTagTransform(a,e,n.options)}(n,e,t)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(n)}}}},853:(e,n,t)=>{e.exports=t.p+"assets/3D_PCB2_2025-09-24.png"},961:(e,n,t)=>{!function e(){if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(e){console.error(e)}}(),e.exports=t(551)},982:(e,n,t)=>{e.exports=t(463)}},n={};function t(a){var o=n[a];if(void 0!==o)return o.exports;var c=n[a]={id:a,exports:{}};return e[a](c,c.exports,t),c.exports}t.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return t.d(n,{a:n}),n},t.d=(e,n)=>{for(var a in n)t.o(n,a)&&!t.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:n[a]})},t.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),t.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),(()=>{var e;t.g.importScripts&&(e=t.g.location+"");var n=t.g.document;if(!e&&n&&(n.currentScript&&"SCRIPT"===n.currentScript.tagName.toUpperCase()&&(e=n.currentScript.src),!e)){var a=n.getElementsByTagName("script");if(a.length)for(var o=a.length-1;o>-1&&(!e||!/^http(s?):/.test(e));)e=a[o--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/^blob:/,"").replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),t.p=e})(),t.nc=void 0;var a=t(540),o=t(338),c=t(72),r=t.n(c),i=t(825),l=t.n(i),s=t(659),u=t.n(s),d=t(56),p=t.n(d),f=t(159),m=t.n(f),_=t(113),g=t.n(_),h=t(249),v={};function b(e){return b="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},b(e)}function y(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function k(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?y(Object(t),!0).forEach(function(n){x(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):y(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function x(e,n,t){return(n=function(e){var n=function(e){if("object"!=b(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=b(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==b(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}v.styleTagTransform=g(),v.setAttributes=p(),v.insert=u().bind(null,"head"),v.domAPI=l(),v.insertStyleElement=m(),r()(h.A,v),h.A&&h.A.locals&&h.A.locals;var S={Noise:{label:"Noise Generator",desc:"Multi-type noise generator: white, pink, brown with gate control and morphing.",params:{type:"white",gain:.3,gate:1,morph:0},audioIn:[],audioOut:["out"],ctrlIn:["gain","gate","type","morph"],ctrlOut:[]},Wavetable:{label:"Oscillator",desc:"Full-featured wavetable oscillator with FM, custom waveform editor, morphing, and ADSR breakpoint control. 512-sample LUT for high quality. Use 'note' input for MIDI (pitch+gate+velocity) or 'freq' for raw frequency control.",params:{freq:440,gain:.25,gate:1,pitch_range:24,fm_amount:0,fm_tracking:!1,fm_ratio:1,fm_ratio_mode:"zones",show_fm_inputs:!1,wavetables:[],current_table:0,adsr_morph:!1,attack_table:0,decay_table:1,sustain_table:2,release_table:3,editor_settings:{table_size:512,draw_mode:"sine",current_editing:0}},audioIn:["fm"],audioOut:["L","R"],ctrlIn:["note","freq","gain","gate","morph","table_select","pitch_cv","fm_ratio_cv","fm_amount"],ctrlOut:[]},PolyOscillator:{label:"Poly Oscillator",desc:"4-voice polyphonic oscillator for pads and chords. Built-in ADSR, voice detuning, stereo spread, and self-contained 2-operator FM. Accepts MIDI note input for automatic voice allocation with voice stealing.",params:{wavetables:[],current_table:0,editor_settings:{table_size:512,draw_mode:"saw",harmonics:[]},voices:8,detune_cents:8,stereo_spread:.7,attack_ms:150,decay_ms:200,sustain:.7,release_ms:800,gain:.6,voice_stealing:"oldest",unison:!1,unison_detune:15,fm_enabled:!1,fm_ratio:1,fm_index:0,fm_mod_amount:5,fm_env_depth:1,fm_ratio_fine:0},audioIn:[],audioOut:["outL","outR"],ctrlIn:["gate","freq","note","detune","attack","decay","sustain","release","gain","wt_pos","fm_index","fm_ratio","fm_mod_amount"],ctrlOut:[]},SamplePlayer:{label:"Sample Player",desc:"Plays audio samples with sustain looping. Supports both single-voice and 6-voice polyphonic PSRAM modes.",params:{sample_name:"",base_note:60,pitch:1,gain:.8,loop:!1,polyphonic:!1,fileMin:1,fileMax:32,adsr_pitch_range:2,adsr_pitch_center:0,start_pos:0,end_pos:1,crossfade_ms:10,voice_allocation:"round_robin",max_voices:6,auto_load_samples:!0,max_voice_time:10},audioIn:[],audioOut:["outL","outR"],ctrlIn:["gate","pitch","pitch_env","sample_select","gain","start_pos","end_pos"],ctrlOut:[]},DrumDesigner4:{label:"Drum Designer",desc:"4-voice percussion synthesizer with Karplus-Strong modeling. Each voice can be enabled/disabled for CPU optimization. Mix output or individual voice outputs for flexible routing. Auto-banking: Pot=volume, Button=gate, Button hold + Pot=pitch.",params:{bank:1,voice1_enabled:!0,voice2_enabled:!0,voice3_enabled:!0,voice4_enabled:!0,show_individual_outputs:!1,selected_voice:1,voice1_pitch:60,voice1_fine_tune:0,voice1_pitch_sweep_mode:"none",voice1_ks_mode:"tonal",voice1_ks_damping:.6,voice1_ks_stretch:1,voice1_ks_excitation_type:"noise",voice1_ks_brightness:.5,voice1_ks_position:.5,voice1_ks_level:.3,voice1_sine_level:.7,voice1_sine_enabled:!0,voice1_sine_pitch_amount:2,voice1_sine_pitch_decay:.08,voice1_body_enabled:!0,voice1_body_type:"wood",voice1_body_resonance:.5,voice1_body_size:.5,voice1_amp_attack:1,voice1_amp_decay:500,voice1_amp_sustain:0,voice1_amp_release:100,voice1_velocity_sensitivity:.7,voice1_output_gain:3,voice1_volume:.8,voice1_preset:"marimba",voice2_pitch:62,voice2_fine_tune:0,voice2_pitch_sweep_mode:"none",voice2_ks_mode:"percussive",voice2_ks_damping:.5,voice2_ks_stretch:1,voice2_ks_excitation_type:"noise",voice2_ks_brightness:.6,voice2_ks_position:.5,voice2_ks_level:.4,voice2_sine_level:.6,voice2_sine_enabled:!0,voice2_sine_pitch_amount:2,voice2_sine_pitch_decay:.08,voice2_body_enabled:!0,voice2_body_type:"wood",voice2_body_resonance:.5,voice2_body_size:.5,voice2_amp_attack:1,voice2_amp_decay:400,voice2_amp_sustain:0,voice2_amp_release:100,voice2_velocity_sensitivity:.7,voice2_output_gain:3,voice2_volume:.8,voice2_preset:"snare",voice3_pitch:67,voice3_fine_tune:0,voice3_pitch_sweep_mode:"none",voice3_ks_mode:"noise",voice3_ks_damping:.3,voice3_ks_stretch:1,voice3_ks_excitation_type:"filtered",voice3_ks_brightness:.8,voice3_ks_position:.5,voice3_ks_level:.7,voice3_sine_level:.3,voice3_sine_enabled:!1,voice3_sine_pitch_amount:2,voice3_sine_pitch_decay:.08,voice3_body_enabled:!1,voice3_body_type:"metal",voice3_body_resonance:.5,voice3_body_size:.5,voice3_amp_attack:1,voice3_amp_decay:150,voice3_amp_sustain:0,voice3_amp_release:50,voice3_velocity_sensitivity:.7,voice3_output_gain:2.5,voice3_volume:.8,voice3_preset:"hihat",voice4_pitch:65,voice4_fine_tune:0,voice4_pitch_sweep_mode:"none",voice4_ks_mode:"percussive",voice4_ks_damping:.4,voice4_ks_stretch:1.01,voice4_ks_excitation_type:"noise",voice4_ks_brightness:.7,voice4_ks_position:.5,voice4_ks_level:.5,voice4_sine_level:.5,voice4_sine_enabled:!0,voice4_sine_pitch_amount:2,voice4_sine_pitch_decay:.08,voice4_body_enabled:!0,voice4_body_type:"wood",voice4_body_resonance:.6,voice4_body_size:.4,voice4_amp_attack:1,voice4_amp_decay:300,voice4_amp_sustain:0,voice4_amp_release:80,voice4_velocity_sensitivity:.7,voice4_output_gain:3,voice4_volume:.8,voice4_preset:"tom"},audioIn:[],audioOut:["mixL","mixR","voice1_outL","voice1_outR","voice2_outL","voice2_outR","voice3_outL","voice3_outR","voice4_outL","voice4_outR"],ctrlIn:["gate1","gate2","gate3","gate4","pitch1","pitch2","pitch3","pitch4"],ctrlOut:[]}},E={Filter:{label:"Filter",desc:"SVF: lowpass/bandpass/highpass/notch.",params:{mode:"lowpass",cutoff_hz:1200,resonance:.2,lfo_min_hz:100,lfo_max_hz:4e3,map:{cutMin:60,cutMax:16e3,resMin:0,resMax:1}},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["cutoff_hz","resonance","mode"],ctrlOut:[]},Distortion:{label:"Distortion",desc:"Waveshaping distortion with pre/post filtering. Presets: Clean, Overdrive, Fuzz, Speaker, Bitcrush. CV preset switching for rhythmic effects.",params:{preset:"overdrive",drive:2.5,tone:2e3,tone_q:.7,mix:.8,bypassMode:"toggle",presetCrossfade:0},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["drive","tone","mix","bypass","preset_cv"],ctrlOut:[]},VCA:{label:"VCA",desc:"Voltage Controlled Amplifier (gain 0..1).",params:{gain:.4},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["gain"],ctrlOut:[]},Delay:{label:"Delay",desc:"Stereo delay with tempo sync, ping-pong, freeze, and pitch-shift.",params:{time_ms:380,feedback:.35,mix:.3,pingpong:0,freeze:0,pitch_shift:1,division:1},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["time_ms","feedback","mix","pingpong","freeze","pitch_shift","division","tempo_hz"],ctrlOut:[]},CleanReverb:{label:"Reverb",desc:"Schroeder reverb with quality presets. Standard: ~28KB (40ms tails), High: ~100KB (140ms tails), Ultra: ~426KB (594ms tails). Choose quality based on patch complexity. OPI PSRAM required for ESP32-S3-WROOM-1-N16R8.",params:{mix:.25,size:.5,damp:.4,quality:"ultra"},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["mix","size","damp"],ctrlOut:[]},AudioMath:{label:"Audio Math",desc:"Multi-function audio processor: AM (amplitude modulation), crossfade, ring modulation, and vocoder - mode selectable.",params:{mode:"am",blend:.5,sensitivity:1},audioIn:["inA","inB"],audioOut:["out"],ctrlIn:["blend","sensitivity","mode"],ctrlOut:["env_follow"]},Limiter:{label:"Limiter",desc:"Audio limiter prevents clipping. Threshold 0-1, ratio 1:1 to :1.",params:{threshold:.8,ratio:4,attack_ms:1,release_ms:10},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["threshold","ratio"],ctrlOut:[]},Panner:{label:"Stereo Panner",desc:"Constant-power pan; width 0..1.",params:{pan:.5,width:1},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["pan","width"],ctrlOut:[]},StereoMixer4:{label:"Stereo Mixer (4ch)",desc:"4 stereo channels with volume/pan. Hardware banking uses 2 banks: Bank 1 (volume/mute): Pots=volumes, Buttons=mutes. Bank 2 (pan/solo): Pots=pans, Encoder HOLD+Buttons=solo.",params:{g1:.35,g2:.35,g3:.35,g4:.35,master:1,pan1:.5,pan2:.5,pan3:.5,pan4:.5,start_bank:1,mute1:!1,mute2:!1,mute3:!1,mute4:!1,solo_channel:0},audioIn:["1L","1R","2L","2R","3L","3R","4L","4R"],audioOut:["outL","outR"],ctrlIn:["g1","g2","g3","g4","master","pan1","pan2","pan3","pan4"],ctrlOut:[]},Matrix2x2:{label:"Matrix Mixer 22",desc:"Feedback-capable: A/B inputs  A/B outputs via 22 matrix. Hardware banking: Pots 1-4 control aa, ab, ba, bb.",params:{aa:1,ab:0,ba:0,bb:1,start_bank:1,show_control_inputs:!1},audioIn:["inAL","inAR","inBL","inBR"],audioOut:["outAL","outAR","outBL","outBR"],ctrlIn:["aa","ab","ba","bb"],ctrlOut:[]},ChorusFlangeRing:{label:"Chorus/Flange/Ring",desc:"Mod delay or ring mod; mix/feedback.",params:{mode:"chorus",rate_hz:.5,depth_ms:3,delay_ms:8,feedback:.15,mix:.35,rm_hz:40},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["rate_hz","depth_ms","delay_ms","feedback","mix","rm_hz","mode"],ctrlOut:[]},GranularSynth:{label:"Granular Synth",desc:"Experimental granular synthesis with 4 grains, variable grain size (10-200ms), and advanced controls: randomization, freeze, reverse playback, and CV pitch. Lighter CPU than Dense for stacking. 8MB PSRAM enables larger buffers.",params:{grain_density:6,grain_size_ms:50,position:.5,position_spread:.2,pitch:0,pitch_spread:.1,dry_wet:1,freeze:0,randomize:0,reverse_prob:0,envelope:"hann"},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["grain_density","grain_size_ms","position","position_spread","pitch","pitch_spread","dry_wet","freeze","randomize","reverse"],ctrlOut:[]},GranularDense:{label:"Granular Dense",desc:"Dense granular synthesis with 20 concurrent 32ms grains. Alternating grains reversed, stereo spread, cloud panning. Supports 1-4 grouped pitch CV inputs with optional grouped panning. CPU: ~76% at max density (round-robin processing + envelope table lookup).",params:{grain_density:15,position:.5,position_spread:.3,pitch:0,pitch_spread:.1,envelope:"hann",dry_wet:1,freeze:0,stereo_width:.5,cloud_pan:.5,grouped_panning:0},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["grain_density","position","pitch","dry_wet","freeze","stereo_width","cloud_pan","pitch_cv_1","pitch_cv_2","pitch_cv_3","pitch_cv_4"],ctrlOut:[]},NoiseGate:{label:"Noise Gate",desc:"Gate with threshold and sidechain. Blocks audio below threshold, with gate output for triggering.",params:{threshold:.1,attack_ms:1,release_ms:50,ratio:10},audioIn:["inL","inR","sidechainL","sidechainR"],audioOut:["outL","outR"],ctrlIn:["threshold","attack_ms","release_ms"],ctrlOut:["gate"]},EQ8:{label:"8-Band EQ",desc:"Graphic EQ (8 peaking bands).",params:{b1:0,b2:0,b3:0,b4:0,b5:0,b6:0,b7:0,b8:0},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["b1","b2","b3","b4","b5","b6","b7","b8"],ctrlOut:[]},Resonance:{label:"Resonance",desc:"Resonant object exploration: impulse response capture, FFT analysis, auto-tuning to detected frequencies. Requires v2.0 hardware (contact mic, exciter, gyroscope).",params:{mode:"discovery",fftSize:8192,impulseLength:1e3,sweepDuration:1e4,sweepStart:20,sweepEnd:1e4,threshold:-60,maxPeaks:16,objectSlot:0,autoTune:!0,hapticEnable:!1,gyroSensitivity:1,hapticIntensity:.5},audioIn:["contactMic"],audioOut:["exciter"],ctrlIn:["trigger","mode_select","object_select","sensitivity","intensity"],ctrlOut:["freq1","freq2","freq3","freq4","freq5","freq6","freq7","freq8","analysis_complete","resonance_strength"]},Looper:{label:"Looper",desc:"Advanced looper with overdubbing, Frippertronics decay, reverse, and tape speed control. Up to 20s using PSRAM.",params:{mix:1,playback_gain:1,fade_ms:10,overdub_gain:.8},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["record","decay","reverse","speed"],ctrlOut:["position","length","state","led"]},AudioRecorder:{label:"Audio Recorder",desc:"Standalone recorder/player with dedicated bank. 4-button control: Record/Play-Pause/Prev/Next. 24-bit recording, file navigation, playback modes. USES 1 BANK.",params:{bank:1,file_prefix:"rec",current_file_index:1,max_duration_sec:60,bit_depth:24,input_gain:1,playback_volume:1,playback_mode:0,playback_speed:.5,recording:!1,playing:!1,sck:12,miso:11,mosi:10,cs:9},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:[],ctrlOut:[]},BPMLooper:{label:"BPM Looper",desc:"4-slot beat-synced looper with slice randomization and pitch control. USES 2 CONSECUTIVE BANKS (e.g., Banks 1-2). Turn encoder to switch modes. Bank 1: record/mix (red/green LEDs). Bank 2: randomization/pitch (blue/cyan/yellow LEDs). ~5.6MB PSRAM.",params:{start_bank:1,slot1_length:.25,slot2_length:.5,slot3_length:2,slot4_length:4,slot1_slices_per_beat:8,slot2_slices_per_beat:8,slot3_slices_per_beat:8,slot4_slices_per_beat:8,internal_bpm:120,use_external_clock:!1,mix:1,master_gain:1,slot1_state:"empty",slot2_state:"empty",slot3_state:"empty",slot4_state:"empty",slot1_oneshot:!1,slot2_oneshot:!1,slot3_oneshot:!1,slot4_oneshot:!1,slot1_randomization:0,slot2_randomization:0,slot3_randomization:0,slot4_randomization:0,slot1_pitch:1,slot2_pitch:1,slot3_pitch:1,slot4_pitch:1,midi_mode:"off",root_note:60,show_trigger_inputs:!1},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["clock","slot1_trig","slot2_trig","slot3_trig","slot4_trig","slot1_pitch","slot2_pitch","slot3_pitch","slot4_pitch"],ctrlOut:[]}},P={LineIn:{label:"Stereo In",desc:"PCM1802 ADC stereo line input with gain control. Uses GPIO16 MCLK (required). MCP23017 GPB2/GPB3=LOW enables line input.",params:{pin_din:8,pin_mclk:16,gain:2,dc_block:!0,rate:44100},audioIn:[],audioOut:["L","R"],ctrlIn:["gain"],ctrlOut:[]},Piezo:{label:"Piezo In",desc:"Contact mic input (PCM1802 left channel, mono to stereo). Uses GPIO16 MCLK. Higher gain range for piezo sensitivity (4x-64x).",params:{pin_din:8,pin_mclk:16,gain:4,dc_block:!0,rate:44100},audioIn:[],audioOut:["L","R"],ctrlIn:["gain"],ctrlOut:[]},Coil:{label:"Coil In",desc:"Coil pickup input (PCM1802 right channel, mono to stereo, 65Hz HPF). Uses GPIO16 MCLK. Higher gain for weak coil output.",params:{pin_din:8,pin_mclk:16,gain:48,dc_block:!0,hpf_cutoff:65,rate:44100},audioIn:[],audioOut:["L","R"],ctrlIn:["gain"],ctrlOut:[]},I2SOut:{label:"Stereo Out",desc:"IS DAC output (stereo)",params:{pin_bck:15,pin_lrck:17,pin_data:18,rate:44100},audioIn:["L","R"],audioOut:[],ctrlIn:[],ctrlOut:[]},Exciter:{label:"Exciter Out",desc:"PAM8302 amplifier enable for exciter speaker (left output channel). Enables/disables amp via MCP23017 GPB6.",params:{enabled:!0},audioIn:[],audioOut:[],ctrlIn:[],ctrlOut:[]},SDPlayer:{label:"SD Player",desc:"Streams 16-bit WAV (44.1k) from /sd (SPI).",params:{sck:41,miso:14,mosi:45,cs:16,mount:"/sd",fileMin:1,fileMax:32,loop:!0,gain:.8},audioIn:[],audioOut:["L","R"],ctrlIn:["trig","stop","gain","file_index"],ctrlOut:[]}},w={ADSR:{label:"ADSR",desc:"Advanced envelope generator with ADSR and freeform modes, looping, and timescale control.",params:{attack_ms:50,decay_ms:200,sustain:.7,release_ms:300,loop_mode:"oneshot",timescale:1,trigger_mode:"gate",breakpoints:[{time:0,level:0,curve:.5},{time:.1,level:1,curve:.3},{time:.3,level:.7,curve:.7},{time:.8,level:.7,curve:.5},{time:1,level:0,curve:.8}]},audioIn:[],audioOut:[],ctrlIn:["gate","trigger","attack_ms","decay_ms","sustain","release_ms","timescale"],ctrlOut:["env"]},LFO:{label:"LFO",desc:"Low Frequency Oscillator with clock sync and configurable rate range.",params:{rate_hz:1,rate_min_hz:.01,rate_max_hz:40,wave:"sine",sync_to_clock:!1,clock_div:4,phase:0,depth:1,offset:0},audioIn:[],audioOut:[],ctrlIn:["rate_hz","wave","depth","offset","clock"],ctrlOut:["out"]},Scale:{label:"Scale",desc:"Quantise control  musical scale/tuning with CV control of scale and tuning.",params:{tuning:"12-TET",scale:"major",root_note:"C",octave_range:2,base_octave:4,snap_amount:1},audioIn:[],audioOut:[],ctrlIn:["in","tuning_cv","scale_cv"],ctrlOut:["out"]},Automation:{label:"Automation",desc:"Records and loops control automation. Long-press encoder button (>1s) to record pot/button movements. Dynamically expands inputs - connect to add more ports.",params:{buffer_size:1e3,recording:!1,playing:!1,loop:!0,num_inputs:4},audioIn:[],audioOut:[],ctrlIn:["in_1","in_2","in_3","in_4","in_5","in_6","in_7","in_8","record_trigger","mode_select","clock"],ctrlOut:["out_1","out_2","out_3","out_4","out_5","out_6","out_7","out_8"]},Modulation:{label:"Modulation (4LFO)",desc:"4 LFOs; map rates or keep static.",params:{rate1_hz:1,rate2_hz:.5,rate3_hz:2,rate4_hz:4,rate1_min_hz:.01,rate1_max_hz:20,rate2_min_hz:.01,rate2_max_hz:20,rate3_min_hz:.01,rate3_max_hz:20,rate4_min_hz:.01,rate4_max_hz:20},audioIn:[],audioOut:[],ctrlIn:["rate1","rate2","rate3","rate4"],ctrlOut:["lfo1","lfo2","lfo3","lfo4"]},Clock:{label:"Clock (8-out)",desc:"8-output clock divider/multiplier like Pamela's NEW Workout. Algorithmic sequencing.",params:{bpm:120,swing:0,follow_midi:!0,bpm_min:30,bpm_max:600,output_select:1,division_select:1,running:!0,bank:0,use_outputs_5_8:!1,show_advanced_outputs:!1,rate1:1,rate2:.5,rate3:.25,rate4:.125,rate5:2,rate6:4,rate7:8,rate8:16,euclid1:1,euclid2:1,euclid3:1,euclid4:1,euclid5:1,euclid6:1,euclid7:1,euclid8:1,gate_mode1:!0,gate_mode2:!0,gate_mode3:!0,gate_mode4:!0,gate_mode5:!1,gate_mode6:!1,gate_mode7:!1,gate_mode8:!1,prob1:1,prob2:1,prob3:1,prob4:1,prob5:1,prob6:1,prob7:1,prob8:1},audioIn:[],audioOut:[],ctrlIn:["bpm_input","output_select","division_select","start_stop"],ctrlOut:["out1","out2","out3","out4","out5","out6","out7","out8","master_phase","master_pulse","tick24","tick96","start","stop"]},HarmonicSequencer:{label:"Harmonic Sequencer",desc:"4-step hardware sequencer with banking integration and melodic patterns.",params:{start_bank:1,running:!1,current_step:0,loop_start:0,loop_end:3,loop_active:!1,bpm:120,clock_div:4,swing:0,gate_length:.7,steps:[{pitch:0,velocity:.8,duration:1,muted:!1,active:!0,pattern:"octave",interval:12,probability:1,patternProbability:1,chordIntervals:[0,12],chordDiatonic:!0},{pitch:.25,velocity:.8,duration:1,muted:!1,active:!0,pattern:"up_down",interval:3,probability:1,patternProbability:1,chordIntervals:[0,4,7],chordDiatonic:!0},{pitch:.5,velocity:.8,duration:1,muted:!1,active:!0,pattern:"chord",interval:4,probability:1,patternProbability:1,chordIntervals:[0,4,7,11],chordDiatonic:!0},{pitch:.75,velocity:.8,duration:1,muted:!1,active:!0,pattern:"static",interval:1,probability:1,patternProbability:1,chordIntervals:[0,7],chordDiatonic:!1}],hardware_pots:[1,2,3,4],hardware_btns:[1,2,3,4],scale_connected:!1,scale_root:"C",scale_type:"major",octave_center:4,show_individual_outputs:!1,sum_output_enabled:!0,individual_outputs_enabled:!1,playback_mode:"iteration",harmonic_linking:!1,harmonic_follow_steps:[-1,-1,-1,-1],harmonic_intervals:[7,7,7,7],pattern_enabled:!1},audioIn:[],audioOut:[],ctrlIn:["clock","start_stop","gate","swing","gate_length","bpm","clock_div"],ctrlOut:["note","pitch_sum","gate_sum","velocity_sum","pitch_hz","pitch_step1","gate_step1","velocity_step1","pitch_step1_hz","pitch_step2","gate_step2","velocity_step2","pitch_step2_hz","pitch_step3","gate_step3","velocity_step3","pitch_step3_hz","pitch_step4","gate_step4","velocity_step4","pitch_step4_hz","current_step_cv","current_bank_cv","running","loop_active"]},GateGen:{label:"Gate Generator",desc:"Clock-triggered gate with built-in Sample & Hold and optional gate input for manual control.",params:{gate_length:.8,retrigger:!0,self_clock_bpm:120,use_self_clock:!0,probability:1,sh_enabled:!0,gate_control:!1,bpm_min:40,bpm_max:180,led_flash_ms:0},audioIn:[],audioOut:[],ctrlIn:["clock","gate_input","gate_length","self_clock_bpm","probability","sh_input"],ctrlOut:["gate","sh_output","rate"]},Invert:{label:"Invert",desc:"Inverts control signals (1-x). Useful for inverting gates, envelopes, LFOs, etc.",params:{offset:0,scale:1},audioIn:[],audioOut:[],ctrlIn:["in","offset","scale"],ctrlOut:["out"]}},C={Pot:{label:"Pot",desc:"Analog pot (0..1). Banked; smoothing kills jitter.",params:{pin:7,bank:1,index:1,locked:!1,smooth:.2,avgN:4,debug:!1},audioIn:[],audioOut:[],ctrlIn:[],ctrlOut:["value"]},LEDButton:{label:"Button",desc:"Momentary + LED. Debounced, banked.",params:{pin:0,ledPin:6,bank:1,index:1,locked:!1,debug:!1,mode:"latching",toggleValues:[100,50],sampleHold:!1},audioIn:[],audioOut:[],ctrlIn:["led","sampleIn"],ctrlOut:["press","gate","value","sampleOut"]},GateIn:{label:"Gate In",desc:"External gate/trigger input via LTV816 optoisolator. Select Gate In 1 or 2.",params:{index:1,debounce_ms:5,mode:"trigger",locked:!1},audioIn:[],audioOut:[],ctrlIn:[],ctrlOut:["gate","trigger"]},MIDIIn:{label:"MIDI In",desc:"UART MIDI input via TLP2361. Outputs: note, gate, velocity, clock (24 PPQ), transport.",params:{channel:0},audioIn:[],audioOut:[],ctrlIn:[],ctrlOut:["note","gate","velocity","clock_tick","start","stop","running"]},MIDIOut:{label:"MIDI Out",desc:"UART MIDI output. Note, CC, clock (24 PPQ) and transport. TX=GPIO43.",params:{channel:1,num_cc:1,cc_numbers:[1,2,3,4,5,6,7,8]},audioIn:[],audioOut:[],ctrlIn:["note","gate","velocity","clock","start","stop","cc_1","cc_2","cc_3","cc_4","cc_5","cc_6","cc_7","cc_8"],ctrlOut:[]},USBMIDIIn:{label:"USB MIDI In",desc:"USB MIDI input (class-compliant, GPIO19/20). Outputs: note (0-1 CV), gate, velocity. Low latency ~1-3ms. Channel 1-16 or 0 for omni.",params:{channel:1},audioIn:[],audioOut:[],ctrlIn:[],ctrlOut:["note","gate","velocity"]},USBMIDIOut:{label:"USB MIDI Out",desc:"USB MIDI output with multi-channel routing. Each note/CC output can target different MIDI channels. Dynamically expands ports like Automation module.",params:{num_outputs:1,ch_1:1,ch_2:2,ch_3:3,ch_4:4,ch_5:5,ch_6:6,ch_7:7,ch_8:8,cc_1:1,cc_2:2,cc_3:3,cc_4:4,cc_5:5,cc_6:6,cc_7:7,cc_8:8},audioIn:[],audioOut:[],ctrlIn:["note_1","gate_1","velocity_1","cc_1","note_2","gate_2","velocity_2","cc_2","note_3","gate_3","velocity_3","cc_3","note_4","gate_4","velocity_4","cc_4","note_5","gate_5","velocity_5","cc_5","note_6","gate_6","velocity_6","cc_6","note_7","gate_7","velocity_7","cc_7","note_8","gate_8","velocity_8","cc_8"],ctrlOut:[]},BLEMIDIIn:{label:"BLE MIDI In",desc:"Bluetooth LE MIDI input. Connects to wireless MIDI devices (keyboards, controllers). Enter device name to auto-connect. ~10-20ms latency.",params:{device_name:"FP-10",channel:0,auto_reconnect:!0},audioIn:[],audioOut:[],ctrlIn:[],ctrlOut:["note","gate","velocity"]}},I={Panner:E.Panner,StereoMixer4:E.StereoMixer4,Matrix2x2:E.Matrix2x2},R={GranularSynth:E.GranularSynth,GranularDense:E.GranularDense,Looper:E.Looper,BPMLooper:E.BPMLooper,AudioRecorder:E.AudioRecorder},L={Clock:w.Clock,HarmonicSequencer:w.HarmonicSequencer,GateGen:w.GateGen},M={Filter:E.Filter,Distortion:E.Distortion,VCA:E.VCA,Delay:E.Delay,CleanReverb:E.CleanReverb,AudioMath:E.AudioMath,Limiter:E.Limiter,ChorusFlangeRing:E.ChorusFlangeRing,NoiseGate:E.NoiseGate,EQ8:E.EQ8,Resonance:E.Resonance},D={Arpeggiator:{label:"Arpeggiator",desc:"Breaks incoming chords into arpeggiated sequences. Patterns: up, down, up-down, down-up, random, as-played. Syncs to Clock or MIDI Clock. Hold mode latches notes.",params:{pattern:"up",octaves:1,gate_length:.5,rate_mode:"free",clock_div:4,rate_hz:4,swing:0,hold:!1,note_select_mode:"all",note_select_index:0,note_select_random:0,velocity_mode:"original",fixed_velocity:100,accent_amount:1.3,midi_channel:0,held_notes:[]},audioIn:[],audioOut:[],ctrlIn:["note","gate","velocity","rate","pattern","length","hold","clock","reset"],ctrlOut:["note_out","gate_out","velocity_out"]},MIDILooper:{label:"MIDI Looper",desc:"Records and loops MIDI with key detection. Auto-mapped: Btn1=state+clear, Btn2=scale-lock. Pot1=velocity, Pot2=transpose, Pot3=timing rand, Pot4=pitch rand.",params:{bank:1,loop_bars:4,count_in_bars:1,quantize:"1/16",transpose:0,scale_lock:!1,auto_key_detect:!0,detected_key:"C",detected_scale:"major",key_confidence:0,pitch_random:0,timing_random:0,scan_position:0,max_voices:8,pass_through:!0},audioIn:[],audioOut:[],ctrlIn:["note","gate","velocity","clock"],ctrlOut:["note_out","gate_out","velocity_out","playing","recording","beat"]}},A=k(k(k({},S),E),P),O=k(k(k(k({},A),w),C),D),B=["Pot","LEDButton","GateIn","GateOut","MIDIIn","MIDIOut","Encoder"],T=["LineIn","I2SOut","Exciter"],F={EXAMPLES:[{name:"Audio Recorder Patch",description:"LineIn  AudioRecorder  I2SOut with recording/playback controls",patch:{version:"1.0",modules:[{id:"LineIn1",type:"LineIn",x:100,y:200,params:{pin_din:8,pin_mclk:16,gain:2,dc_block:!0,rate:44100}},{id:"AudioRecorder1",type:"AudioRecorder",x:350,y:200,params:{bank:1,file_prefix:"rec",current_file_index:1,max_duration_sec:60,bit_depth:24,input_gain:1,playback_volume:1,playback_mode:0,playback_speed:.5,recording:!1,playing:!1,sck:12,miso:11,mosi:10,cs:9}},{id:"I2SOut1",type:"I2SOut",x:600,y:200,params:{pin_bck:15,pin_lrck:17,pin_data:18,rate:44100}}],connections:[{from:{id:"LineIn1:L",port:"L",kind:"audio"},to:{id:"AudioRecorder1:inL",port:"inL",kind:"audio"}},{from:{id:"LineIn1:R",port:"R",kind:"audio"},to:{id:"AudioRecorder1:inR",port:"inR",kind:"audio"}},{from:{id:"AudioRecorder1:outL",port:"outL",kind:"audio"},to:{id:"I2SOut1:L",port:"L",kind:"audio"}},{from:{id:"AudioRecorder1:outR",port:"outR",kind:"audio"},to:{id:"I2SOut1:R",port:"R",kind:"audio"}}]}},{name:"FM Synthesis",description:"Two oscillators with FM modulation, ratio control, and LFO depth modulation. Pot1=FM ratio, Pot2=Freq, Pot3=LFO rate, Pot4=LFO depth",patch:{version:"1.0",modules:[{id:"Wavetable1",type:"Wavetable",x:100,y:150,params:{freq:220,gain:.25,gate:1,pitch_range:24,fm_amount:0,fm_tracking:!0,fm_ratio:1,fm_ratio_mode:"zones",wavetables:[],current_table:0,adsr_morph:!1,attack_table:0,decay_table:1,sustain_table:2,release_table:3,editor_settings:{table_size:512,draw_mode:"sine",current_editing:0}}},{id:"Wavetable2",type:"Wavetable",x:350,y:150,params:{freq:220,gain:.25,gate:1,pitch_range:24,fm_amount:.5,fm_tracking:!1,fm_ratio:1,fm_ratio_mode:"zones",wavetables:[],current_table:0,adsr_morph:!1,attack_table:0,decay_table:1,sustain_table:2,release_table:3,editor_settings:{table_size:512,draw_mode:"sine",current_editing:0}}},{id:"I2SOut1",type:"I2SOut",x:600,y:150,params:{pin_bck:15,pin_lrck:17,pin_data:18,rate:44100}},{id:"LFO1",type:"LFO",x:200,y:300,params:{rate_hz:1,rate_min_hz:.1,rate_max_hz:10,wave:"sine",depth:1,offset:0}},{id:"Pot1",type:"Pot",x:50,y:450,params:{pin:4,index:1,bank:1,smooth:.1}},{id:"Pot2",type:"Pot",x:200,y:450,params:{pin:5,index:2,bank:1,smooth:.1}},{id:"Pot3",type:"Pot",x:350,y:450,params:{pin:6,index:3,bank:1,smooth:.1}},{id:"Pot4",type:"Pot",x:500,y:450,params:{pin:7,index:4,bank:1,smooth:.1}}],connections:[{from:{id:"Wavetable1:R",port:"R",kind:"audio"},to:{id:"Wavetable2:fm",port:"fm",kind:"audio"}},{from:{id:"Wavetable2:L",port:"L",kind:"audio"},to:{id:"I2SOut1:L",port:"L",kind:"audio"}},{from:{id:"Wavetable2:R",port:"R",kind:"audio"},to:{id:"I2SOut1:R",port:"R",kind:"audio"}},{from:{id:"Pot1:value",port:"value",kind:"ctrl"},to:{id:"Wavetable1:fm_ratio_cv",port:"fm_ratio_cv",kind:"ctrl"}},{from:{id:"Pot2:value",port:"value",kind:"ctrl"},to:{id:"Wavetable2:freq",port:"freq",kind:"ctrl"}},{from:{id:"Pot3:value",port:"value",kind:"ctrl"},to:{id:"LFO1:rate_hz",port:"rate_hz",kind:"ctrl"}},{from:{id:"LFO1:out",port:"out",kind:"ctrl"},to:{id:"Wavetable2:fm_amount",port:"fm_amount",kind:"ctrl"}},{from:{id:"Pot4:value",port:"value",kind:"ctrl"},to:{id:"LFO1:depth",port:"depth",kind:"ctrl"}}]}},{name:"MicroLooper",description:"Simple 4-slot BPM looper - Stereo In  BPM Looper  Stereo Out",patch:{version:"1.0",modules:[{id:"LineIn1",type:"LineIn",x:100,y:250,params:{pin_din:8,pin_mclk:16,gain:2,dc_block:!0,rate:44100}},{id:"BPMLooper1",type:"BPMLooper",x:400,y:250,params:{start_bank:1,slot1_length:.25,slot2_length:.5,slot3_length:2,slot4_length:4,slot1_slices_per_beat:8,slot2_slices_per_beat:8,slot3_slices_per_beat:8,slot4_slices_per_beat:8,internal_bpm:120,use_external_clock:!1,mix:1,master_gain:1}},{id:"I2SOut1",type:"I2SOut",x:700,y:250,params:{pin_bclk:15,pin_lrck:17,pin_data:18,master_gain:1,rate:44100}}],connections:[{from:{id:"LineIn1:L",port:"L",kind:"audio"},to:{id:"BPMLooper1:inL",port:"inL",kind:"audio"}},{from:{id:"LineIn1:R",port:"R",kind:"audio"},to:{id:"BPMLooper1:inR",port:"inR",kind:"audio"}},{from:{id:"BPMLooper1:outL",port:"outL",kind:"audio"},to:{id:"I2SOut1:L",port:"L",kind:"audio"}},{from:{id:"BPMLooper1:outR",port:"outR",kind:"audio"},to:{id:"I2SOut1:R",port:"R",kind:"audio"}}]}}],AUDIO_SOURCES:Object.keys(S),MIXERS:Object.keys(I),AUDIO_PROCESSORS:Object.keys(M),GRANULAR_LOOPING:Object.keys(R),SEQUENCERS:Object.keys(L),MIDI_EFFECTS:Object.keys(D),AUDIO_IO:Object.keys(P).filter(function(e){return!T.includes(e)}),CTRL:Object.keys(w),HW:Object.keys(C).filter(function(e){return!B.includes(e)})},N=["I2SOut"],z=["StereoMixer4","Matrix2x2","DrumDesigner4","AudioRecorder","BPMLooper","Clock","HarmonicSequencer","MIDILooper"],G=function(e){var n,t=e.type,a=e.params||{};if(!z.includes(t))return[];var o=1;switch(t){case"StereoMixer4":case"Matrix2x2":case"HarmonicSequencer":n=a.start_bank||1,o=1;break;case"DrumDesigner4":case"AudioRecorder":case"MIDILooper":n=a.bank||1,o=1;break;case"BPMLooper":n=a.start_bank||1,o=2;break;case"Clock":n=a.bank||1,o=a.use_outputs_5_8?2:1;break;default:return[]}for(var c=[],r=0;r<o;r++)c.push(n+r);return c},q=function(e){var n=new Set;return e.forEach(function(e){var t,a;G(e).forEach(function(e){return n.add(e)}),"Pot"!==e.type&&"LEDButton"!==e.type||null!==(t=e.params)&&void 0!==t&&t.locked||n.add((null===(a=e.params)||void 0===a?void 0:a.bank)||1)}),n},U=function(e,n){for(var t=q(n),a=2===e?5:6,o=1;o<=a;o++){for(var c=!0,r=0;r<e;r++)if(t.has(o+r)){c=!1;break}if(c)return o}return 2===e?3:2},W=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(!O[e])throw new Error("Unknown module type: ".concat(e));if(!function(e,n){return!N.includes(e)||!n.some(function(n){return n.type===e})}(e,a))throw new Error("Only one ".concat(e," module allowed"));var o=JSON.parse(JSON.stringify(O[e].params)),c=H(e,a),r=null!==n&&null!==t?{x:n,y:t}:function(e,n){var t=O[e];if(!t)return{x:100,y:100};var a,o,c=140,r=0===t.audioIn.length&&t.audioOut.length>0,i=t.audioIn.length>0&&0===t.audioOut.length,l=t.audioIn.length>0&&t.audioOut.length>0,s=t.ctrlOut.length>0&&0===t.audioOut.length,u="Pot"===e||"LEDButton"===e||"Encoder"===e||"MIDIIn"===e,d=n.filter(function(e){var n=O[e.type];return n&&0===n.audioIn.length&&n.audioOut.length>0}).length,p=n.filter(function(e){var n=O[e.type];return n&&n.audioIn.length>0&&n.audioOut.length>0}).length,f=n.filter(function(e){var n=O[e.type];return n&&n.audioIn.length>0&&0===n.audioOut.length}).length,m=n.filter(function(e){var n=O[e.type];return n&&n.ctrlOut.length>0&&0===n.audioOut.length}).length,_=n.filter(function(e){return"Pot"===e.type||"LEDButton"===e.type||"Encoder"===e.type||"MIDIIn"===e.type}).length;if(u){console.log("Positioning hardware ".concat(e,", existing hardware count: ").concat(_)),console.log("Existing nodes:",n.map(function(e){return"".concat(e.type,"(").concat(e.x,",").concat(e.y,")")}));for(var g=!1,h=function(){var t=b[v];if(!n.some(function(e){return Math.abs(e.x-t.x)<80&&Math.abs(e.y-t.y)<80}))return a=t.x,o=t.y,g=!0,console.log("Hardware positioning: ".concat(e," found open spot at (").concat(a,", ").concat(o,")")),1},v=0,b=[{x:50,y:200},{x:50,y:300},{x:150,y:50},{x:400,y:50},{x:450,y:100},{x:600,y:100},{x:700,y:100},{x:450,y:300},{x:600,y:300},{x:150,y:400},{x:350,y:400},{x:550,y:400}];v<b.length&&!h();v++);g||(a=800+_%3*150,o=100+120*Math.floor(_/3),console.log("Hardware positioning: ".concat(e," using fallback at (").concat(a,", ").concat(o,")")))}else r?(a=100,o=80+d*c):l?(a=540,o=80+p*c):i?(a=980,o=80+f*c):s?(a=320,o=80+m*c):(a=760,o=80+n.length*c);return{x:a,y:o}}(e,a);if("Pot"===e||"LEDButton"===e){var i=a.filter(function(n){return n.type===e}),l=V(i,e,a);o.index=l.index,o.bank=l.bank}if("HarmonicSequencer"!==e&&"StereoMixer4"!==e&&"Matrix2x2"!==e||(o.start_bank=U(1,a)),"DrumDesigner4"!==e&&"AudioRecorder"!==e&&"MIDILooper"!==e||(o.bank=U(1,a)),"BPMLooper"===e&&(o.start_bank=U(2,a)),"Clock"===e){var s=o.use_outputs_5_8||!1;o.bank=U(s?2:1,a)}return{id:c,type:e,x:r.x,y:r.y,params:o}},V=function(e,n,t){for(var a=q(t),o={},c=1;c<=4;c++)o[c]=[];var r=new Set;if(e.forEach(function(e){var n,t,a,c=(null===(n=e.params)||void 0===n?void 0:n.index)||1,i=(null===(t=e.params)||void 0===t?void 0:t.bank)||1,l=(null===(a=e.params)||void 0===a?void 0:a.locked)||!1;c>=1&&c<=4&&(l?r.add(c):o[c].push(i))}),e.length>=24)throw new Error("Cannot create more ".concat(n," modules. Hardware limit reached: ").concat(24," virtual ").concat(n,"s maximum (").concat(4," physical  ").concat(6," banks)"));for(var i=1;i<=6;i++)if(!a.has(i))for(var l=1;l<=4;l++)if(!r.has(l)&&!o[l].includes(i))return{index:l,bank:i};for(var s=1;s<=6;s++)for(var u=1;u<=4;u++)if(!r.has(u)&&!o[u].includes(s))return{index:u,bank:s};throw new Error("Internal error: No available hardware slot found for ".concat(n))},H=function(e,n){var t=n.filter(function(n){return n.type===e}).reduce(function(n,t){var a=t.id.match(new RegExp("^".concat(e,"(\\d+)$"))),o=a?parseInt(a[1]):0;return Math.max(n,o)},0);return"".concat(e).concat(t+1)},j=function(e){var n,t,a,o,c=O[e.type];if(!c)return{left:[],right:[]};var r=c.audioIn,i=c.audioOut,l=c.ctrlIn,s=c.ctrlOut;if("Clock"===e.type){var u,d,p=(null===(u=e.params)||void 0===u?void 0:u.use_outputs_5_8)||!1,f=(null===(d=e.params)||void 0===d?void 0:d.show_advanced_outputs)||!1;s=s.filter(function(e){return"out1"===e||"out2"===e||"out3"===e||"out4"===e||("out5"===e||"out6"===e||"out7"===e||"out8"===e?p:"master_phase"!==e&&"master_pulse"!==e||f)})}if("HarmonicSequencer"!==e.type||null!==(n=e.params)&&void 0!==n&&n.show_individual_outputs||(s=s.filter(function(e){return"pitch_sum"===e||"pitch_hz"===e||"gate_sum"===e||"current_step"===e||"current_bank"===e})),"DrumDesigner4"!==e.type||null!==(t=e.params)&&void 0!==t&&t.show_individual_outputs||(i=i.filter(function(e){return"mixL"===e||"mixR"===e})),"Matrix2x2"!==e.type||null!==(a=e.params)&&void 0!==a&&a.show_control_inputs||(l=[]),"BPMLooper"!==e.type||null!==(o=e.params)&&void 0!==o&&o.show_trigger_inputs||(l=l.filter(function(e){return"clock"===e})),"Automation"===e.type){var m,_=(null===(m=e.params)||void 0===m?void 0:m.num_inputs)||1;l=l.filter(function(e,n){return"record_trigger"===e||parseInt(e.split("_")[1])<=_}),s=s.filter(function(e){return parseInt(e.split("_")[1])<=_})}if("MIDIOut"===e.type){var g,h=(null===(g=e.params)||void 0===g?void 0:g.num_cc)||1;l=l.filter(function(e){return"note"===e||"gate"===e||"velocity"===e||!e.startsWith("cc_")||parseInt(e.split("_")[1])<=h})}if("USBMIDIOut"===e.type){var v,b=(null===(v=e.params)||void 0===v?void 0:v.num_outputs)||1;l=l.filter(function(e){var n=e.match(/^(note|gate|velocity|cc)_(\d+)$/);return!!n&&parseInt(n[2])<=b})}var y=Math.max(80,20*Math.max(r.length+l.length,i.length+s.length)+40),k=[],x=[],S=e.y+25+10,E=e.y+25+10;r.forEach(function(n){k.push({kind:"audio",side:"left",id:"".concat(e.id,":").concat(n),port:n,x:e.x,y:S}),S+=18}),l.forEach(function(n){k.push({kind:"ctrl",side:"left",id:"".concat(e.id,":").concat(n),port:n,x:e.x,y:S}),S+=18});var P=e.x+140;return i.forEach(function(n){x.push({kind:"audio",side:"right",id:"".concat(e.id,":").concat(n),port:n,x:P,y:E}),E+=18}),s.forEach(function(n){x.push({kind:"ctrl",side:"right",id:"".concat(e.id,":").concat(n),port:n,x:P,y:E}),E+=18}),{left:k,right:x,width:140,height:y,head:25}},K=function(e,n,t){for(var a=n,o=[],c=function(e){var n=t.filter(function(n){var t;return("Pot"===n.type||"LEDButton"===n.type)&&((null===(t=n.params)||void 0===t?void 0:t.bank)||1)===e});n.length>0&&o.push({bank:e,modules:n})},r=n;r<=a;r++)c(r);return{banksRequired:1,endBank:a,conflicts:o,isValid:a<=6&&0===o.length}},Y=function(e){var n=[],t=new Map;return e.forEach(function(e){var n=e.type,a=e.params||{};if("Pot"===n||"LEDButton"===n){var o=a.bank||1;t.has(o)||t.set(o,[]),t.get(o).push({module:e.id,type:n,usage:"".concat(n," (hardware pin ").concat(a.pin||a.index||"?",")")})}if(z.includes(n)){var c=G(e),r=c.length>1?"banks ".concat(c[0],"-").concat(c[c.length-1]):"bank ".concat(c[0]);c.forEach(function(a){t.has(a)||t.set(a,[]),t.get(a).push({module:e.id,type:n,usage:"".concat(n," (uses ").concat(r,")")})})}}),t.forEach(function(e,t){if(e.length>1){var a=e.some(function(e){return z.includes(e.type)}),o=e.some(function(e){return["Pot","LEDButton"].includes(e.type)});a&&o?n.push({bank:t,modules:e,severity:"error",message:"Bank ".concat(t," conflict: Auto-banking module and hardware assignments overlap")}):e.filter(function(e){return z.includes(e.type)}).length>1&&n.push({bank:t,modules:e,severity:"error",message:"Bank ".concat(t," conflict: Multiple auto-banking modules assigned to same bank")})}}),{isValid:0===n.length,conflicts:n,bankUsage:Object.fromEntries(t)}},$={metadata:{label:"Looper",desc:"Advanced looper with overdubbing, Frippertronics decay, reverse, and tape speed control. Up to 20s using PSRAM.",params:{mix:1,playback_gain:1,fade_ms:10,overdub_gain:.8},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["record","decay","reverse","speed"],ctrlOut:["position","length","state","led"]},generateClass:function(e,n){return"\nclass Looper_".concat(e," {\nprivate:\n  static constexpr int MAX_LOOP_SAMPLES = ").concat(882e3,";\n  \n  // Simple looper state\n  float* bufferL = nullptr;\n  float* bufferR = nullptr;\n  int bufferSize = 0;        // Actual allocated buffer size \n  int length = 0;            // Recorded loop length\n  int writePos = 0;          // Current write position\n  float readPosFloat = 0.0f; // Current read position (float for smooth playback)\n  \n  enum State { EMPTY, RECORDING, PLAYING, OVERDUBBING, MUTED } state = EMPTY;\n\n  // Parameters\n  float mix = ").concat((n.mix||1).toFixed(1),"f;\n  float playbackGain = ").concat((n.playback_gain||2).toFixed(1),"f;\n  float overdubGain = ").concat((n.overdub_gain||.8).toFixed(1),'f;\n\n  // Control inputs\n  float recordButton = 0.0f;\n  float lastRecordButton = 0.0f;\n  float decayControl = 1.0f;      // 0.0-1.0: decay rate (1.0 = no decay, 0.0 = fast decay)\n  float reverseControl = 0.0f;    // 0.0 = forward, 1.0 = reverse\n  float speedControl = 0.5f;      // 0.0-1.0: maps to speed range (0.5 = 1.0x normal speed)\n\n  // Playback direction\n  float playbackDirection = 1.0f; // 1.0 = forward, -1.0 = reverse\n\n  // Button timing for long-press clear detection\n  unsigned long buttonPressTime = 0;\n  bool longPressHandled = false;\n  \npublic:\n  float outL = 0.0f;\n  float outR = 0.0f;\n  float positionOut = 0.0f;\n  float lengthOut = 0.0f;\n  float stateOut = 0.0f;\n  float ledOut = 0.0f;  // LED control output\n\n  void init() {\n    // Try to allocate PSRAM buffer\n    bufferL = (float*)ps_malloc(MAX_LOOP_SAMPLES * sizeof(float));\n    bufferR = (float*)ps_malloc(MAX_LOOP_SAMPLES * sizeof(float));\n    \n    if (!bufferL || !bufferR) {\n      Serial.println("Looper_').concat(e,': PSRAM allocation failed, using smaller SRAM fallback");\n      // Fall back to smaller SRAM buffer\n      if (bufferL) { free(bufferL); bufferL = nullptr; }\n      if (bufferR) { free(bufferR); bufferR = nullptr; }\n      \n      int fallbackSize = 44100; // 1 second\n      bufferL = (float*)malloc(fallbackSize * sizeof(float));\n      bufferR = (float*)malloc(fallbackSize * sizeof(float));\n      bufferSize = fallbackSize;\n    } else {\n      bufferSize = MAX_LOOP_SAMPLES;\n      Serial.printf("Looper_').concat(e,': Allocated %.1f seconds of PSRAM\\n", (float)bufferSize / 44100.0);\n    }\n    \n    // Clear buffers\n    if (bufferL && bufferR) {\n      memset(bufferL, 0, bufferSize * sizeof(float));\n      memset(bufferR, 0, bufferSize * sizeof(float));\n    }\n  }\n\n  void setControl(int index, float value) {\n    switch(index) {\n      case 0: // record button\n        recordButton = value;\n        break;\n      case 1: // decay control\n        decayControl = constrain(value, 0.0f, 1.0f);\n        break;\n      case 2: // reverse control\n        reverseControl = constrain(value, 0.0f, 1.0f);\n        break;\n      case 3: // speed control\n        speedControl = constrain(value, 0.0f, 1.0f);\n        break;\n    }\n  }\n\n  void process(float inL, float inR) {\n    // Simple tap-to-record/tap-to-play behavior\n    \n    // Debug button state periodically\n    static unsigned long lastDebug = 0;\n    static float lastRecordButtonDebug = -1;\n    if (recordButton != lastRecordButtonDebug || millis() - lastDebug > 2000) {\n      lastDebug = millis();\n      lastRecordButtonDebug = recordButton;\n      Serial.print("LOOPER DEBUG - recordButton: ");\n      Serial.print(recordButton);\n      Serial.print(", state: ");\n      Serial.println(state == EMPTY ? "EMPTY" : (state == RECORDING ? "RECORDING" : (state == PLAYING ? "PLAYING" : (state == OVERDUBBING ? "OVERDUBBING" : "MUTED"))));\n    }\n    \n    // Handle button press events - detect rising edge to prevent multiple triggers per buffer\n    bool buttonPressed = (recordButton > 0.5f && lastRecordButton <= 0.5f);  // Rising edge only\n    bool buttonReleased = (recordButton <= 0.5f && lastRecordButton > 0.5f); // Falling edge\n\n    // Track button press/release for long-press detection\n    if (buttonPressed) {\n      buttonPressTime = millis();\n      longPressHandled = false;\n      Serial.println("LOOPER: Button pressed");\n    }\n\n    // Long press detection (>1000ms) - Clear loop on RELEASE after long press\n    if (buttonReleased && !longPressHandled && (millis() - buttonPressTime > 1000)) {\n      Serial.println("LOOPER: Long press released - clearing loop");\n      state = EMPTY;\n      length = 0;\n      writePos = 0;\n      readPosFloat = 0.0f;\n      longPressHandled = true;\n    }\n\n    // Short press state machine - trigger on button PRESS (for tap-to-toggle)\n    // But check on RELEASE that it wasn\'t a long press\n    if (buttonReleased && (millis() - buttonPressTime <= 1000)) {\n      Serial.println("LOOPER: Short press detected");\n\n      // State machine: EMPTY  RECORDING  PLAYING  OVERDUBBING  PLAYING  MUTED  PLAYING\n      if (state == EMPTY) {\n        // Start recording\n        state = RECORDING;\n        writePos = 0;\n        length = 0;\n        Serial.println("LOOPER: Starting recording");\n      } else if (state == RECORDING) {\n        // Stop recording, start playing\n        state = PLAYING;\n        length = writePos;\n        readPosFloat = 0.0f;\n        Serial.printf("LOOPER: Stopping recording, recorded %d samples (%.1fs), starting playback\\n",\n                     length, (float)length / 44100.0);\n      } else if (state == PLAYING) {\n        // Enter overdub mode\n        state = OVERDUBBING;\n        writePos = (int)readPosFloat; // Sync write position to current playback position\n        Serial.println("LOOPER: Entering overdub mode");\n      } else if (state == OVERDUBBING) {\n        // Exit overdub, return to playing\n        state = PLAYING;\n        Serial.println("LOOPER: Exiting overdub mode, returning to playback");\n      } else if (state == MUTED) {\n        // Unmute playback\n        state = PLAYING;\n        readPosFloat = 0.0f; // Restart from beginning\n        Serial.println("LOOPER: Unmuting playback");\n      }\n    }\n\n    lastRecordButton = recordButton;\n\n    float wetL = 0.0f;\n    float wetR = 0.0f;\n\n    // Recording - auto-stop at buffer limit\n    if (state == RECORDING && bufferL && bufferR) {\n      if (writePos < bufferSize) {\n        bufferL[writePos] = inL;\n        bufferR[writePos] = inR;\n        writePos++;\n      } else {\n        // Buffer full - auto-stop and start playing\n        state = PLAYING;\n        length = writePos;\n        readPosFloat = 0.0f;\n        Serial.printf("LOOPER: Buffer full at %d samples (%.1fs), auto-stopping and starting playback\\n",\n                     length, (float)length / 44100.0);\n      }\n    }\n\n    // Overdubbing - add new audio to existing loop\n    if (state == OVERDUBBING && bufferL && bufferR && length > 0) {\n      // Sync write position to read position\n      writePos = (int)readPosFloat;\n\n      if (writePos < length) {\n        // Add incoming audio to buffer (overdub) with gain control\n        bufferL[writePos] += inL * overdubGain;\n        bufferR[writePos] += inR * overdubGain;\n      }\n    }\n    \n    // Calculate playback speed with octave detents\n    // Map speedControl (0.0-1.0) to speed range:\n    // 0.0 = 0.25x (-2 octaves), 0.25 = 0.5x (-1 octave), 0.5 = 1.0x (normal), 0.75 = 2.0x (+1 octave), 1.0 = 4.0x (+2 octaves)\n    float targetSpeed = 1.0f;\n    if (speedControl < 0.5f) {\n      // Range 0.0-0.5 maps to 0.25x-1.0x\n      targetSpeed = 0.25f + (speedControl * 2.0f) * 0.75f;\n    } else {\n      // Range 0.5-1.0 maps to 1.0x-4.0x\n      targetSpeed = 1.0f + ((speedControl - 0.5f) * 2.0f) * 3.0f;\n    }\n\n    // Apply detents (snap zones) around key ratios\n    const float detentStrength = 0.05f; // 5% snap zone\n    float detents[] = {0.25f, 0.5f, 1.0f, 2.0f, 4.0f};\n    for (int i = 0; i < 5; i++) {\n      if (fabs(targetSpeed - detents[i]) < detents[i] * detentStrength) {\n        targetSpeed = detents[i];\n        break;\n      }\n    }\n\n    // Determine playback direction\n    playbackDirection = (reverseControl > 0.5f) ? -1.0f : 1.0f;\n\n    // Playback with speed and direction control (PLAYING or OVERDUBBING)\n    if ((state == PLAYING || state == OVERDUBBING) && length > 0 && bufferL && bufferR) {\n      // Linear interpolation for smooth speed changes\n      int idx0 = (int)readPosFloat;\n      int idx1 = (idx0 + 1) % length;\n      float frac = readPosFloat - idx0;\n\n      // Ensure indices are within bounds\n      if (idx0 >= 0 && idx0 < length && idx1 >= 0 && idx1 < length) {\n        wetL = bufferL[idx0] * (1.0f - frac) + bufferL[idx1] * frac;\n        wetR = bufferR[idx0] * (1.0f - frac) + bufferR[idx1] * frac;\n      }\n\n      // Advance read position with speed and direction\n      readPosFloat += targetSpeed * playbackDirection;\n\n      // Handle looping with direction\n      if (readPosFloat >= length) {\n        readPosFloat = fmodf(readPosFloat, length); // Wrap to start\n\n        // Apply Frippertronics decay on loop wrap (forward direction)\n        if (playbackDirection > 0 && decayControl < 1.0f) {\n          // Map decayControl (0.0-1.0) to decay factor (0.8-1.0)\n          // 1.0 = no decay, 0.0 = heavy decay (20% fade per loop)\n          float decayFactor = 0.8f + (decayControl * 0.2f);\n          for (int i = 0; i < length; i++) {\n            bufferL[i] *= decayFactor;\n            bufferR[i] *= decayFactor;\n          }\n        }\n      } else if (readPosFloat < 0.0f) {\n        readPosFloat = length + fmodf(readPosFloat, length); // Wrap to end\n\n        // Apply decay on reverse loop wrap\n        if (playbackDirection < 0 && decayControl < 1.0f) {\n          float decayFactor = 0.8f + (decayControl * 0.2f);\n          for (int i = 0; i < length; i++) {\n            bufferL[i] *= decayFactor;\n            bufferR[i] *= decayFactor;\n          }\n        }\n      }\n    }\n    \n    // When muted, keep loop position frozen but don\'t output audio\n    if (state == MUTED && length > 0) {\n      wetL = 0.0f;\n      wetR = 0.0f;\n      // readPosFloat stays frozen at current position\n    }\n    \n    // Guitar pedal style mixing: dry signal always passes through + wet signal added with playback gain\n    // Use soft clipping (tanh) to prevent harsh digital clipping when overdubbing\n    float mixedL = inL + wetL * mix * playbackGain;\n    float mixedR = inR + wetR * mix * playbackGain;\n\n    // Soft saturation using tanh() - prevents clipping, adds warmth\n    outL = tanhf(mixedL * 0.9f);  // Scale down slightly before saturation\n    outR = tanhf(mixedR * 0.9f);\n    \n    // Update control outputs\n    positionOut = length > 0 ? readPosFloat / length : 0.0f;\n    lengthOut = (float)length / bufferSize;\n    stateOut = (state == RECORDING) ? 1.0f : ((state == PLAYING) ? 0.5f : ((state == MUTED) ? 0.25f : 0.0f));\n    \n    // LED control output (encoded state for NeoPixel rendering)\n    // 0.0 = EMPTY (pulsing red - ready to record)\n    // 1.0 = RECORDING (solid red)\n    // 2.0 = PLAYING (solid green - looping)\n    // 3.0 = MUTED (off/dim)\n    // 4.0 = OVERDUBBING (solid orange - layering audio)\n    if (state == EMPTY) {\n      ledOut = 0.0f;  // EMPTY = pulsing red\n    } else if (state == RECORDING) {\n      ledOut = 1.0f;  // RECORDING = solid red\n    } else if (state == PLAYING) {\n      ledOut = 2.0f;  // PLAYING = solid green\n    } else if (state == MUTED) {\n      ledOut = 3.0f;  // MUTED = off\n    } else if (state == OVERDUBBING) {\n      ledOut = 4.0f;  // OVERDUBBING = solid orange\n    }\n  }\n};\n')},generateIncludes:function(){return"#include <cstring>  // For memset\n#include <cmath>     // For tanhf (soft clipping)"}},X={metadata:{label:"BPM Looper",desc:"4-slot beat-synced looper with slice randomization and pitch control. 2-bank system: Bank 1 (record/mix), Bank 2 (randomization/pitch). CV inputs auto-detect mode. ~5.6MB PSRAM (4 slots  4 beats @ 120 BPM).",params:{start_bank:1,slot1_length:.25,slot2_length:.5,slot3_length:2,slot4_length:4,slot1_slices_per_beat:8,slot2_slices_per_beat:8,slot3_slices_per_beat:8,slot4_slices_per_beat:8,internal_bpm:120,use_external_clock:!1,mix:1,master_gain:1,slot1_state:0,slot2_state:0,slot3_state:0,slot4_state:0,slot1_oneshot:!1,slot2_oneshot:!1,slot3_oneshot:!1,slot4_oneshot:!1,slot1_randomization:0,slot2_randomization:0,slot3_randomization:0,slot4_randomization:0,slot1_pitch:1,slot2_pitch:1,slot3_pitch:1,slot4_pitch:1},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["clock","slot1_trig","slot2_trig","slot3_trig","slot4_trig","slot1_pitch","slot2_pitch","slot3_pitch","slot4_pitch"],ctrlOut:[]},generateClass:function(e,n){var t=n.internal_bpm||120,a=n.use_external_clock||!1,o=60/t*4,c=Math.ceil(44100*o),r=n.slot1_length||.25,i=n.slot2_length||.5,l=n.slot3_length||2,s=n.slot4_length||4,u=n.slot1_slices_per_beat||8,d=n.slot2_slices_per_beat||8,p=n.slot3_slices_per_beat||8,f=n.slot4_slices_per_beat||8,m=Math.max(Math.ceil(r*u),Math.ceil(i*d),Math.ceil(l*p),Math.ceil(s*f),128);return"\nclass BPMLooper_".concat(e," {\nprivate:\n  static constexpr int MAX_SAMPLES_PER_SLOT = ").concat(c,";\n  static constexpr int NUM_SLOTS = 4;\n\n  // PSRAM buffers for 4 slots\n  float* bufferL[NUM_SLOTS] = {nullptr, nullptr, nullptr, nullptr};\n  float* bufferR[NUM_SLOTS] = {nullptr, nullptr, nullptr, nullptr};\n\n  // Slot configuration (in beats)\n  float slotLengthBeats[NUM_SLOTS] = {").concat(r.toFixed(2),"f, ").concat(i.toFixed(2),"f, ").concat(l.toFixed(2),"f, ").concat(s.toFixed(2),"f};\n  int slotLengthSamples[NUM_SLOTS] = {0, 0, 0, 0};\n\n  // Slice randomization configuration\n  static constexpr int MAX_SLICES = ").concat(m,";\n  int slotSlicesPerBeat[NUM_SLOTS] = {").concat(u,", ").concat(d,", ").concat(p,", ").concat(f,"};\n  int slotNumSlices[NUM_SLOTS] = {0, 0, 0, 0}; // Calculated: slotLengthBeats * slicesPerBeat\n  uint8_t* slotShuffleMap[NUM_SLOTS] = {nullptr, nullptr, nullptr, nullptr}; // Dynamic shuffle maps\n  float lastRandomization[NUM_SLOTS] = {-1.0f, -1.0f, -1.0f, -1.0f}; // Track changes for regen\n\n  // Slot state\n  enum State { EMPTY, RECORDING, PLAYING, MUTED } slotState[NUM_SLOTS] = {EMPTY, EMPTY, EMPTY, EMPTY};\n  int writePos[NUM_SLOTS] = {0, 0, 0, 0};\n  float readPos[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};           // Main playback position (advances at 1.0x for time-locking)\n  float sliceReadPos[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};     // Position within current slice (advances at pitch speed)\n  int recordedLength[NUM_SLOTS] = {0, 0, 0, 0};\n  bool slotReversed[NUM_SLOTS] = {false, false, false, false};\n  float slotOffset[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f}; // Loop offset in samples\n  float slotPhase[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f}; // Per-slot phase (0-1) for LED pulse\n\n  // One-shot mode (plays loop once when triggered)\n  bool slotOneshot[NUM_SLOTS] = {false, false, false, false};\n  bool slotOneshotTriggered[NUM_SLOTS] = {false, false, false, false};\n\n  // Gate mode (CV trigger inputs control playback - HIGH=play, LOW=stop)\n  bool slotGateActive[NUM_SLOTS] = {false, false, false, false};\n  float lastTrigger[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n  unsigned long triggerHighStartTime[NUM_SLOTS] = {0, 0, 0, 0}; // Track how long trigger has been HIGH\n\n  // CV activity detection (detect if external CV is controlling this slot)\n  bool slotCvActive[NUM_SLOTS] = {false, false, false, false};\n  unsigned long lastCvActivityTime[NUM_SLOTS] = {0, 0, 0, 0};\n  static constexpr unsigned long CV_TIMEOUT_MS = 2000; // 2 seconds without CV = revert to button control\n  static constexpr unsigned long GATE_THRESHOLD_MS = 50; // If trigger HIGH >50ms, it's gate mode (not one-shot pulse)\n\n  // Clock/tempo\n  float internalBpm = ").concat(t.toFixed(1),"f;\n  float beatPhase = 0.0f; // 0.0-1.0 phase within current beat\n  float lastClockInput = 0.0f;\n  unsigned long lastClockTime = 0;\n  float externalBpm = ").concat(t.toFixed(1),"f;\n  bool useExternalClock = ").concat(a?"true":"false",";\n\n  // Button control\n  float buttonInputs[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n  float lastButtonInputs[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n  unsigned long buttonPressTime[NUM_SLOTS] = {0, 0, 0, 0}; // Track press duration\n  bool buttonLongHoldHandled[NUM_SLOTS] = {false, false, false, false}; // Prevent repeat clear\n  bool encoderButtonPressed = false; // For reverse toggle\n\n  // Bank 2 pot values (private - button state is public)\n  // Initialize to 0.0 (no randomization at startup)\n  float bank2PotValue[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n\n  // Parameters\n  float mix = ").concat((n.mix||1).toFixed(2),"f;\n  float masterGain = ").concat((n.master_gain||1).toFixed(2),'f;\n\n  // Control inputs\n  float clockInput = 0.0f;\n  float triggerInputs[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n  float pitchInputs[NUM_SLOTS] = {0.333f, 0.333f, 0.333f, 0.333f}; // 0.333 = 1.0x speed (0.5 + 0.333*1.5 = 1.0)\n\n  // Pot control (volumes or loop start when encoder held)\n  float slotVolume[NUM_SLOTS] = {1.0f, 1.0f, 1.0f, 1.0f}; // Volume per slot (0-1)\n\n  // Crossfade state for click-free loop transitions\n  static constexpr int CROSSFADE_SAMPLES = 64; // ~1.45ms at 44.1kHz (micro-fade)\n  float lastReadPos[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f}; // Track position for wrap detection\n\npublic:\n  float outL = 0.0f;\n  float outR = 0.0f;\n  float ledOutputs[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n\n  // Public access for LED control\n  float slotRandomization[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n  float slotPitch[NUM_SLOTS] = {1.0f, 1.0f, 1.0f, 1.0f};\n  bool bank2ButtonPressed[NUM_SLOTS] = {false, false, false, false};\n\n  void init() {\n    // Calculate sample lengths for each slot based on BPM\n    float secondsPerBeat = 60.0f / internalBpm;\n    for (int s = 0; s < NUM_SLOTS; s++) {\n      slotLengthSamples[s] = (int)(slotLengthBeats[s] * secondsPerBeat * 44100.0f);\n\n      // Calculate number of slices for this slot\n      slotNumSlices[s] = max(1, (int)(slotLengthBeats[s] * slotSlicesPerBeat[s]));\n\n      // Allocate shuffle map\n      slotShuffleMap[s] = new uint8_t[slotNumSlices[s]];\n      if (slotShuffleMap[s]) {\n        // Initialize to sequential order\n        for (int i = 0; i < slotNumSlices[s]; i++) {\n          slotShuffleMap[s][i] = i;\n        }\n      }\n    }\n\n    // Allocate PSRAM buffers for all 4 slots\n    for (int s = 0; s < NUM_SLOTS; s++) {\n      bufferL[s] = (float*)ps_malloc(MAX_SAMPLES_PER_SLOT * sizeof(float));\n      bufferR[s] = (float*)ps_malloc(MAX_SAMPLES_PER_SLOT * sizeof(float));\n\n      if (!bufferL[s] || !bufferR[s]) {\n        Serial.printf("BPMLooper_').concat(e,': PSRAM allocation failed for slot %d\\n", s);\n      } else {\n        memset(bufferL[s], 0, MAX_SAMPLES_PER_SLOT * sizeof(float));\n        memset(bufferR[s], 0, MAX_SAMPLES_PER_SLOT * sizeof(float));\n        Serial.printf("BPMLooper_').concat(e,': Allocated slot %d (%.1f beats, %.2fs, %d samples, %d slices)\\n",\n                     s, slotLengthBeats[s], slotLengthBeats[s] * secondsPerBeat, slotLengthSamples[s], slotNumSlices[s]);\n      }\n    }\n\n    float totalMB = (4 * 2 * MAX_SAMPLES_PER_SLOT * sizeof(float)) / (1024.0f * 1024.0f);\n    float shuffleKB = (4 * MAX_SLICES) / 1024.0f;\n    Serial.printf("BPMLooper_').concat(e,': Total PSRAM allocated: %.2f MB + shuffle maps: %.2f KB\\n", totalMB, shuffleKB);\n  }\n\n  void setControl(int index, float value) {\n    if (index == 0) {\n      clockInput = value;\n    } else if (index >= 1 && index <= 4) {\n      // Trigger inputs (slot1_trig, slot2_trig, etc.)\n      triggerInputs[index - 1] = value;\n    } else if (index >= 5 && index <= 8) {\n      // Pitch inputs (slot1_pitch, slot2_pitch, etc.)\n      pitchInputs[index - 5] = constrain(value, 0.0f, 1.0f);\n    }\n  }\n\n  void setButtonState(int slotIndex, float buttonValue, bool encoderButton) {\n    if (slotIndex >= 0 && slotIndex < NUM_SLOTS) {\n      buttonInputs[slotIndex] = buttonValue;\n    }\n    encoderButtonPressed = encoderButton;\n  }\n\n  void setLoopOffset(int slotIndex, float offsetDelta) {\n    if (slotIndex >= 0 && slotIndex < NUM_SLOTS && recordedLength[slotIndex] > 0) {\n      slotOffset[slotIndex] += offsetDelta;\n      // Wrap offset to valid range\n      while (slotOffset[slotIndex] < 0) slotOffset[slotIndex] += recordedLength[slotIndex];\n      while (slotOffset[slotIndex] >= recordedLength[slotIndex]) slotOffset[slotIndex] -= recordedLength[slotIndex];\n    }\n  }\n\n  void setPotValue(int potIndex, float value) {\n    if (potIndex >= 0 && potIndex < NUM_SLOTS) {\n      if (encoderButtonPressed && recordedLength[potIndex] > 0) {\n        // Encoder held: Set loop start offset (0.0-1.0  0 to recordedLength)\n        slotOffset[potIndex] = value * recordedLength[potIndex];\n      } else {\n        // Normal mode: Set volume (0.0-1.0)\n        slotVolume[potIndex] = value;\n      }\n    }\n  }\n\n  // Bank 2 control methods\n  void setBank2PotValue(int slotIndex, float value) {\n    if (slotIndex >= 0 && slotIndex < NUM_SLOTS) {\n      bank2PotValue[slotIndex] = constrain(value, 0.0f, 1.0f);\n    }\n  }\n\n  void setBank2ButtonState(int slotIndex, bool pressed) {\n    if (slotIndex >= 0 && slotIndex < NUM_SLOTS) {\n      bank2ButtonPressed[slotIndex] = pressed;\n    }\n  }\n\n  // Update randomization and pitch from Bank 2 controls\n  void updateBank2Controls() {\n    for (int s = 0; s < NUM_SLOTS; s++) {\n      if (bank2ButtonPressed[s]) {\n        // Button held: Pot controls PITCH (chromatic 1 octave = 12 semitones)\n        // Map pot (0.0-1.0) to semitones (-12 to +12)\n        float semitones = (bank2PotValue[s] - 0.5f) * 24.0f;  // -12 to +12 semitones\n        // Convert semitones to pitch multiplier: pitch = 2^(semitones/12)\n        slotPitch[s] = powf(2.0f, semitones / 12.0f);  // Chromatic pitch control\n      } else {\n        // Button released: Pitch PERSISTS at last set value, pot now controls RANDOMIZATION\n        slotRandomization[s] = bank2PotValue[s];\n\n        // Regenerate shuffle map if randomization changed significantly\n        if (fabsf(slotRandomization[s] - lastRandomization[s]) > 0.05f) {\n          generateShuffleMap(s);\n          lastRandomization[s] = slotRandomization[s];\n        }\n      }\n    }\n  }\n\n  // Generate shuffle map with controlled randomization (Fisher-Yates shuffle)\n  void generateShuffleMap(int slotIndex) {\n    if (!slotShuffleMap[slotIndex] || slotNumSlices[slotIndex] <= 1) return;\n\n    int numSlices = slotNumSlices[slotIndex];\n    float randomAmt = slotRandomization[slotIndex];\n\n    // Start with sequential order\n    for (int i = 0; i < numSlices; i++) {\n      slotShuffleMap[slotIndex][i] = i;\n    }\n\n    if (randomAmt < 0.01f) return; // No shuffling needed\n\n    // Fisher-Yates shuffle with probability based on randomization amount\n    for (int i = numSlices - 1; i > 0; i--) {\n      // Probability increases with randomAmt (0% = no swaps, 100% = all swaps)\n      float swapChance = (float)random(1000) / 1000.0f;\n      if (swapChance < randomAmt) {\n        int j = random(i + 1);\n        // Swap slices i and j\n        uint8_t temp = slotShuffleMap[slotIndex][i];\n        slotShuffleMap[slotIndex][i] = slotShuffleMap[slotIndex][j];\n        slotShuffleMap[slotIndex][j] = temp;\n      }\n    }\n\n    Serial.printf("BPMLooper_').concat(e,': Slot %d shuffle regenerated (%.0f%% random)\\n", slotIndex, randomAmt * 100.0f);\n  }\n\n  void process(float inL, float inR) {\n    // Update Bank 2 controls (randomization/pitch)\n    updateBank2Controls();\n\n    // Update clock/tempo\n    updateClock();\n\n    // Process button events for each slot\n    unsigned long now = millis();\n    for (int s = 0; s < NUM_SLOTS; s++) {\n      // Check if CV is actively controlling this slot\n      bool cvControlling = slotCvActive[s];\n\n      bool buttonHeld = (buttonInputs[s] > 0.5f);\n      bool buttonPressed = (buttonHeld && lastButtonInputs[s] <= 0.5f); // Rising edge\n      bool buttonReleased = (!buttonHeld && lastButtonInputs[s] > 0.5f); // Falling edge\n\n      // Only process button input if CV is NOT actively controlling this slot\n      if (!cvControlling) {\n        // Track button press time\n        if (buttonPressed) {\n          buttonPressTime[s] = now;\n          buttonLongHoldHandled[s] = false;\n        }\n\n        // Long hold detection (1500ms) - clear/delete slot\n        if (buttonHeld && !buttonLongHoldHandled[s]) {\n          unsigned long holdDuration = now - buttonPressTime[s];\n          if (holdDuration > 1500) {\n            clearSlot(s);\n            buttonLongHoldHandled[s] = true; // Prevent repeat clear\n          }\n        }\n\n        // Normal button press handling (on release, if not long-held)\n        if (buttonReleased && !buttonLongHoldHandled[s]) {\n          if (encoderButtonPressed && slotState[s] == PLAYING) {\n            // Encoder + button = reverse toggle\n            slotReversed[s] = !slotReversed[s];\n            Serial.printf("BPMLooper_').concat(e,': Slot %d reverse = %s\\n", s, slotReversed[s] ? "true" : "false");\n          } else {\n            // Normal button press: state machine\n            handleSlotButton(s);\n          }\n        }\n      }\n\n      lastButtonInputs[s] = buttonInputs[s];\n    }\n\n    // Mix all slots\n    float mixL = 0.0f;\n    float mixR = 0.0f;\n\n    for (int s = 0; s < NUM_SLOTS; s++) {\n      float slotL = 0.0f;\n      float slotR = 0.0f;\n\n      processSlot(s, inL, inR, slotL, slotR);\n\n      mixL += slotL;\n      mixR += slotR;\n    }\n\n    // Soft clipping function (tanh approximation)\n    auto softClip = [](float x) -> float {\n      float absX = fabsf(x);\n      if (absX <= 1.0f) return x;\n      if (absX >= 2.0f) return (x > 0.0f) ? 1.0f : -1.0f;\n      float x2 = x * x;\n      return x * (27.0f + x2) / (27.0f + 9.0f * x2);\n    };\n\n    // Seamless looper mixing - NO DUCKING:\n    // Both input and loops stay at full volume during recording and playback\n    // Soft clipping prevents harsh distortion if levels exceed headroom\n\n    float inputGain = 1.0f;\n    float loopGain = mix * masterGain;\n\n    float mixedL = (inL * inputGain) + (mixL * loopGain);\n    float mixedR = (inR * inputGain) + (mixR * loopGain);\n\n    outL = softClip(mixedL);\n    outR = softClip(mixedR);\n  }\n\nprivate:\n  void updateClock() {\n    if (useExternalClock) {\n      // External clock input (rising edge detection)\n      if (clockInput > 0.5f && lastClockInput <= 0.5f) {\n        unsigned long now = millis();\n        if (lastClockTime > 0) {\n          float intervalMs = now - lastClockTime;\n          externalBpm = 60000.0f / intervalMs;\n          externalBpm = constrain(externalBpm, 40.0f, 300.0f);\n        }\n        lastClockTime = now;\n        beatPhase = 0.0f; // Reset phase on clock pulse\n      }\n      lastClockInput = clockInput;\n\n      // Advance phase based on external BPM\n      float samplesPerBeat = (60.0f / externalBpm) * 44100.0f;\n      beatPhase += 1.0f / samplesPerBeat;\n      if (beatPhase >= 1.0f) beatPhase -= 1.0f;\n    } else {\n      // Internal clock\n      float samplesPerBeat = (60.0f / internalBpm) * 44100.0f;\n      beatPhase += 1.0f / samplesPerBeat;\n      if (beatPhase >= 1.0f) beatPhase -= 1.0f;\n    }\n  }\n\n  void handleSlotButton(int s) {\n    switch (slotState[s]) {\n      case EMPTY:\n        // Start recording on next beat\n        startRecording(s);\n        break;\n      case RECORDING:\n        // Stop recording, start playing\n        stopRecording(s);\n        break;\n      case PLAYING:\n        // Mute\n        slotState[s] = MUTED;\n        Serial.printf("BPMLooper_').concat(e,': Slot %d muted\\n", s);\n        break;\n      case MUTED:\n        // Unmute\n        slotState[s] = PLAYING;\n        readPos[s] = 0.0f;\n        Serial.printf("BPMLooper_').concat(e,': Slot %d unmuted\\n", s);\n        break;\n    }\n  }\n\n  void startRecording(int s) {\n    slotState[s] = RECORDING;\n    writePos[s] = 0;\n    recordedLength[s] = 0;\n    slotOffset[s] = 0.0f;\n    Serial.printf("BPMLooper_').concat(e,': Slot %d recording started\\n", s);\n  }\n\n  void stopRecording(int s) {\n    slotState[s] = PLAYING;\n    recordedLength[s] = writePos[s];\n    readPos[s] = 0.0f;\n    Serial.printf("BPMLooper_').concat(e,': Slot %d recorded %d samples (%.2fs)\\n",\n                 s, recordedLength[s], (float)recordedLength[s] / 44100.0f);\n  }\n\n  void clearSlot(int s) {\n    slotState[s] = EMPTY;\n    writePos[s] = 0;\n    readPos[s] = 0.0f;\n    recordedLength[s] = 0;\n    slotOffset[s] = 0.0f;\n    slotReversed[s] = false;\n    slotOneshot[s] = false;\n    slotOneshotTriggered[s] = false;\n    slotPhase[s] = 0.0f;\n    slotVolume[s] = 1.0f; // Reset volume to full\n\n    // Reset Bank 2 parameters (pitch and randomization)\n    slotPitch[s] = 1.0f;           // Reset pitch to 1.0x (no pitch shift)\n    slotRandomization[s] = 0.0f;   // Reset randomization to 0%\n    bank2PotValue[s] = 0.0f;       // Reset pot to 0 (no randomization)\n    lastRandomization[s] = -1.0f;  // Force shuffle regen on next use\n\n    // Reset shuffle map to sequential\n    if (slotShuffleMap[s]) {\n      for (int i = 0; i < slotNumSlices[s]; i++) {\n        slotShuffleMap[s][i] = i;\n      }\n    }\n\n    // Clear buffer memory\n    if (bufferL[s]) memset(bufferL[s], 0, MAX_SAMPLES_PER_SLOT * sizeof(float));\n    if (bufferR[s]) memset(bufferR[s], 0, MAX_SAMPLES_PER_SLOT * sizeof(float));\n    Serial.printf("BPMLooper_').concat(e,": Slot %d cleared (Bank 2 params reset)\\n\", s);\n  }\n\n  void processSlot(int s, float inL, float inR, float &outL, float &outR) {\n    if (!bufferL[s] || !bufferR[s]) return;\n\n    unsigned long now = millis();\n    bool triggerHigh = (triggerInputs[s] > 0.5f);\n    bool triggerRisingEdge = (triggerHigh && lastTrigger[s] <= 0.5f);\n    bool triggerFallingEdge = (!triggerHigh && lastTrigger[s] > 0.5f);\n\n    // CV activity detection: Any edge or level change = CV is active\n    if (triggerRisingEdge || triggerFallingEdge) {\n      slotCvActive[s] = true;\n      lastCvActivityTime[s] = now;\n    }\n\n    // CV timeout: If no CV activity for CV_TIMEOUT_MS, revert to button control\n    if (slotCvActive[s] && (now - lastCvActivityTime[s] > CV_TIMEOUT_MS)) {\n      slotCvActive[s] = false;\n      slotGateActive[s] = false;\n      slotOneshot[s] = false;\n      slotOneshotTriggered[s] = false;\n    }\n\n    // Process CV trigger input (only if CV is active)\n    if (slotCvActive[s] && recordedLength[s] > 0) {\n      // Track rising edge timing\n      if (triggerRisingEdge) {\n        triggerHighStartTime[s] = now;\n      }\n\n      // Auto-detect mode: Gate vs One-shot\n      // If trigger stays HIGH for >GATE_THRESHOLD_MS, it's gate mode\n      // If trigger pulses briefly, it's one-shot mode\n      if (triggerHigh) {\n        unsigned long highDuration = now - triggerHighStartTime[s];\n\n        if (highDuration > GATE_THRESHOLD_MS) {\n          // Gate mode: HIGH = play\n          if (!slotGateActive[s]) {\n            slotGateActive[s] = true;\n            readPos[s] = 0.0f;\n            Serial.printf(\"BPMLooper_").concat(e,': Slot %d gate mode activated\\n", s);\n          }\n        } else if (triggerRisingEdge) {\n          // One-shot mode: Rising edge triggers playback\n          slotOneshot[s] = true;\n          slotOneshotTriggered[s] = true;\n          readPos[s] = 0.0f;\n          Serial.printf("BPMLooper_').concat(e,': Slot %d one-shot triggered\\n", s);\n        }\n      } else {\n        // Trigger LOW\n        if (slotGateActive[s]) {\n          // Gate mode: LOW = stop\n          slotGateActive[s] = false;\n          Serial.printf("BPMLooper_').concat(e,": Slot %d gate stopped\\n\", s);\n        }\n      }\n    }\n\n    lastTrigger[s] = triggerInputs[s];\n\n    // Recording\n    if (slotState[s] == RECORDING) {\n      if (writePos[s] < slotLengthSamples[s] && writePos[s] < MAX_SAMPLES_PER_SLOT) {\n        bufferL[s][writePos[s]] = inL;\n        bufferR[s][writePos[s]] = inR;\n        writePos[s]++;\n      } else {\n        // Recording complete at configured length\n        stopRecording(s);\n      }\n    }\n\n    // Playback (includes normal PLAYING state, one-shot mode, and gate mode)\n    if ((slotState[s] == PLAYING || slotOneshot[s] || slotGateActive[s]) && recordedLength[s] > 0) {\n      // Calculate playback speed:\n      // Priority: slotPitch (from Bank 2) overrides pitchInputs (CV)\n      // If slotPitch != 1.0, use it; otherwise use CV pitch\n      float speed;\n      if (fabsf(slotPitch[s] - 1.0f) > 0.01f) {\n        // Using Bank 2 pitch control\n        speed = slotPitch[s];\n      } else {\n        // Using CV pitch input (map 0.0-1.0 to 0.5x-2.0x)\n        speed = 0.5f + pitchInputs[s] * 1.5f;\n      }\n\n      // Apply direction\n      float direction = slotReversed[s] ? -1.0f : 1.0f;\n\n      // TIME-LOCKED GRANULAR PLAYBACK:\n      // Main readPos advances at 1.0x (time-locked to beat grid)\n      // sliceReadPos advances at pitch speed within each slice\n\n      // Calculate slice parameters\n      int sliceLength = recordedLength[s] / slotNumSlices[s];\n      int currentLogicalSlice = ((int)readPos[s] / sliceLength) % slotNumSlices[s];\n      int currentSliceStart = currentLogicalSlice * sliceLength;\n\n      // Apply slice randomization if enabled\n      int physicalSlice = currentLogicalSlice;\n      if (slotRandomization[s] > 0.01f && slotShuffleMap[s] && slotNumSlices[s] > 1) {\n        // Map to physical slice via shuffle map\n        physicalSlice = slotShuffleMap[s][currentLogicalSlice];\n      }\n      int physicalSliceStart = physicalSlice * sliceLength;\n\n      // Advance slice-local read position at pitched speed\n      sliceReadPos[s] += speed * direction;\n\n      // Wrap within slice boundaries (creates granular effect)\n      // Pitched up (2x): wraps/repeats content within the slice (plays slice twice)\n      // Pitched down (0.5x): gets cut off mid-content when next slice starts\n      while (sliceReadPos[s] >= sliceLength) {\n        sliceReadPos[s] -= sliceLength; // Wrap to slice start\n      }\n      while (sliceReadPos[s] < 0) {\n        sliceReadPos[s] += sliceLength; // Wrap to slice end\n      }\n\n      // Calculate final buffer read position\n      float bufferReadPos = physicalSliceStart + sliceReadPos[s];\n\n      // Apply offset\n      float readPosWithOffset = bufferReadPos + slotOffset[s];\n      while (readPosWithOffset >= recordedLength[s]) readPosWithOffset -= recordedLength[s];\n      while (readPosWithOffset < 0) readPosWithOffset += recordedLength[s];\n\n      // Crossfade detection: check if we're near loop boundary\n      // Apply micro-fade in last and first CROSSFADE_SAMPLES of loop to eliminate clicks\n      float crossfadeGain = 1.0f;\n      float distanceToEnd = recordedLength[s] - readPosWithOffset;\n      float distanceFromStart = readPosWithOffset;\n\n      if (distanceToEnd < CROSSFADE_SAMPLES && direction > 0) {\n        // Approaching end (forward playback) - fade out\n        crossfadeGain = distanceToEnd / (float)CROSSFADE_SAMPLES;\n      } else if (distanceFromStart < CROSSFADE_SAMPLES && direction > 0) {\n        // Just wrapped (forward playback) - fade in\n        crossfadeGain = distanceFromStart / (float)CROSSFADE_SAMPLES;\n      } else if (distanceFromStart < CROSSFADE_SAMPLES && direction < 0) {\n        // Approaching start (reverse playback) - fade out\n        crossfadeGain = distanceFromStart / (float)CROSSFADE_SAMPLES;\n      } else if (distanceToEnd < CROSSFADE_SAMPLES && direction < 0) {\n        // Just wrapped (reverse playback) - fade in\n        crossfadeGain = distanceToEnd / (float)CROSSFADE_SAMPLES;\n      }\n\n      // Linear interpolation\n      int idx0 = (int)readPosWithOffset;\n      int idx1 = (idx0 + 1) % recordedLength[s];\n      float frac = readPosWithOffset - idx0;\n\n      if (idx0 >= 0 && idx0 < recordedLength[s] && idx1 >= 0 && idx1 < recordedLength[s]) {\n        outL = (bufferL[s][idx0] * (1.0f - frac) + bufferL[s][idx1] * frac) * slotVolume[s] * crossfadeGain;\n        outR = (bufferR[s][idx0] * (1.0f - frac) + bufferR[s][idx1] * frac) * slotVolume[s] * crossfadeGain;\n      }\n\n      // Store previous position for wrap detection and slice boundary detection\n      int prevLogicalSlice = ((int)lastReadPos[s] / sliceLength) % slotNumSlices[s];\n      lastReadPos[s] = readPos[s];\n\n      // TIME-LOCKED: Advance main readPos at 1.0x speed (locked to beat grid)\n      readPos[s] += 1.0f * direction;\n\n      // Detect slice boundary crossing - reset sliceReadPos when entering new slice\n      int newLogicalSlice = ((int)readPos[s] / sliceLength) % slotNumSlices[s];\n      if (newLogicalSlice != prevLogicalSlice) {\n        sliceReadPos[s] = 0.0f; // Reset slice-local position at slice boundaries\n      }\n\n      // Update per-slot phase for LED pulse (based on slot's BEAT LENGTH, not loop position)\n      // Phase advances at normal playback rate (1.0x speed) regardless of pitch CV\n      // This keeps LED pulse synced to beat interval even when pitch is modulated\n      float phaseIncrement = 1.0f / (float)slotLengthSamples[s];\n      slotPhase[s] += phaseIncrement;\n\n      // Wrap phase at 1.0 (one beat cycle)\n      if (slotPhase[s] >= 1.0f) slotPhase[s] -= 1.0f;\n\n      // Handle looping\n      if (slotOneshot[s]) {\n        // One-shot mode: stop at end\n        if ((direction > 0 && readPos[s] >= recordedLength[s]) ||\n            (direction < 0 && readPos[s] < 0)) {\n          slotOneshot[s] = false;\n          slotOneshotTriggered[s] = false;\n          readPos[s] = 0.0f;\n          sliceReadPos[s] = 0.0f; // Reset slice position too\n          outL = 0.0f;\n          outR = 0.0f;\n        }\n      } else {\n        // Loop mode\n        if (readPos[s] >= recordedLength[s]) {\n          readPos[s] = fmodf(readPos[s], recordedLength[s]);\n          sliceReadPos[s] = 0.0f; // Reset on loop wrap\n        } else if (readPos[s] < 0) {\n          readPos[s] = recordedLength[s] + fmodf(readPos[s], recordedLength[s]);\n          sliceReadPos[s] = 0.0f; // Reset on loop wrap\n        }\n      }\n    }\n\n    // Phase tracking for recording and empty states\n    if (slotState[s] == RECORDING && slotLengthSamples[s] > 0) {\n      // Phase tracks recording progress\n      slotPhase[s] = (float)writePos[s] / (float)slotLengthSamples[s];\n    } else if (slotState[s] == EMPTY && slotLengthSamples[s] > 0) {\n      // Phase advances at beat rate even when empty (for per-slot arm pulsing)\n      float phaseIncrement = 1.0f / (float)slotLengthSamples[s];\n      slotPhase[s] += phaseIncrement;\n      if (slotPhase[s] >= 1.0f) slotPhase[s] -= 1.0f;\n    }\n\n    // Calculate LED output (state-based with slot-specific beat sync)\n    float led = 0.0f;\n    if (slotState[s] == EMPTY) {\n      // EMPTY state: Pulsing at slot's beat rate (ready to record)\n      // Each slot pulses according to its configured beat interval\n      float pulse = (sinf(slotPhase[s] * 3.14159f * 2.0f) + 1.0f) * 0.5f; // 0.0-1.0 sine wave\n      led = -pulse; // Negative = red pulsing in NeoPixel code\n    } else if (slotState[s] == RECORDING) {\n      led = -1.0f; // Negative = solid red\n    } else if (slotState[s] == PLAYING || slotOneshot[s] || slotGateActive[s]) {\n      // PLAYING state (including one-shot and gate modes): Green with beat pulse\n      // Each slot pulses according to its own loop length\n      float brightness = 200.0f - (slotPhase[s] * 50.0f); // 200 at loop start  150 at loop end\n      led = brightness / 255.0f; // Normalize to 0.0-1.0 (positive = green)\n    } else if (slotState[s] == MUTED) {\n      led = 0.0f; // Off\n    }\n    ledOutputs[s] = led;\n  }\n};\n")},generateIncludes:function(){return"#include <cstring>  // For memset\n#include <cmath>     // For fmodf, powf"}},Z={I2S_BCLK:15,I2S_LRCK:17,I2S_DATA:18,I2C_SDA:1,I2C_SCL:2,ANALOG_PINS:[4,5,6,7],ENCODER_A:21,ENCODER_B:47,ENCODER_BTN:48,NEOPIXEL_PIN:46,NEOPIXEL_COUNT:8,NEOPIXEL_MAP:{BTN:[3,2,1,0],POT:[7,6,5,4]},BANK_COLORS:[{r:255,g:0,b:0},{r:0,g:255,b:0},{r:0,g:0,b:255},{r:255,g:200,b:0},{r:0,g:255,b:255},{r:255,g:0,b:255}],AUTOMATION_RECORD_COLOR:{r:255,g:0,b:0},NEOPIXEL_BRIGHTNESS:50,GATE_IN_PINS:[42,41],GATE_OUT_PINS:[40,39],SD_CS:14,SD_MOSI:10,SD_MISO:11,SD_SCK:9,MIDI_RX:44,MIDI_TX:43,USB_DM:19,USB_DP:20,SAMPLE_RATE:44100,BUFFER_SIZE:256},Q={BUTTONS:[2,1,0,3],MIDI_OUT_LED:4,MIDI_IN_LED:5,GATE_LEDS:[7,6],GATE_LEDS_B:[8,9]};function J(e){return J="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},J(e)}function ee(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}function ne(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,te(a.key),a)}}function te(e){var n=function(e){if("object"!=J(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=J(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==J(n)?n:n+""}var ae=function(){return e=function e(n,t){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.modules=n,this.connections=t},n=[{key:"resolveAudioChain",value:function(){var e=this,n=this.modules.find(function(e){return"I2SOut"===e.type}),t=[];return n&&(t=this.traceBackToSource(n,"audio")),this.connections.filter(function(e){return"audio"===e.kind}).forEach(function(n){var a=n.from.id.split(":")[0],o=e.modules.find(function(e){return e.id===a});o&&!t.some(function(e){return e.id===o.id})&&t.push(o)}),this.sortByFPUSafety(t)}},{key:"sortByFPUSafety",value:function(e){var n=this,t={Sample:1,Oscillator:2,Wavetable:3,Noise:10,NoiseGenerator:10,VCA:20,Distortion:25,CleanReverb:26,Filter:30,Delay:35,Matrix2x2:37,StereoMixer4:40,I2SOut:100},a=new Map;return e.forEach(function(e){var t;if("Wavetable"===e.type&&null!==(t=e.params)&&void 0!==t&&t.fm_tracking){var o=n.connections.find(function(n){var t,a,o=null!==(t=n.from)&&void 0!==t&&t.id?n.from.id.split(":")[0]:n.from,c=null!==(a=n.to)&&void 0!==a&&a.id?n.to.id.split(":")[1]:n.toPort;return o===e.id&&"fm"===c});if(o){var c,r=null!==(c=o.to)&&void 0!==c&&c.id?o.to.id.split(":")[0]:o.to;a.set(e.id,r)}}}),e.sort(function(e,n){var o=t[e.type]||50,c=t[n.type]||50;return a.has(e.id)&&a.get(e.id)===n.id?1:a.has(n.id)&&a.get(n.id)===e.id?-1:o-c})}},{key:"traceBackToSource",value:function(e,n){var t=this,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;if(a.has(e.id))return[];var o=[e];return a.add(e.id),this.connections.filter(function(t){var a,o;if(t.to&&"string"==typeof t.to)a=t.to,o=t.toPort;else{if(!t.to||!t.to.id)return!1;a=t.to.id.split(":")[0],o=t.to.id.split(":")[1]}var c="audio"===t.type||["L","R","inL","inR","outL","outR","fm","pitch_cv"].includes(o)||o.includes("L")||o.includes("R");return a===e.id&&("audio"===n&&c||"control"===n&&!c)}).forEach(function(e){var c;if(e.from&&"string"==typeof e.from)c=e.from;else{if(!e.from||!e.from.id)return;c=e.from.id.split(":")[0]}var r=t.modules.find(function(e){return e.id===c});if(r&&!a.has(r.id)){var i=t.traceBackToSource(r,n,a);o.unshift.apply(o,function(e){return function(e){if(Array.isArray(e))return ee(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,n){if(e){if("string"==typeof e)return ee(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?ee(e,n):void 0}}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}(i))}}),o}},{key:"findConnectionsToModule",value:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return this.connections.filter(function(t){var a,o;if(t.to&&"string"==typeof t.to)a=t.to,o=t.toPort;else{if(!t.to||!t.to.id)return!1;a=t.to.id.split(":")[0],o=t.to.id.split(":")[1]}if(a!==e)return!1;if(n){var c="audio"===t.type||["L","R","inL","inR","outL","outR","fm","pitch_cv"].includes(o)||o.includes("L")||o.includes("R");return"audio"===n&&c||"control"===n&&!c}return!0})}},{key:"findConnectionsFromModule",value:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return this.connections.filter(function(t){var a,o;if(t.from&&"string"==typeof t.from)a=t.from,o=t.fromPort;else{if(!t.from||!t.from.id)return!1;a=t.from.id.split(":")[0],o=t.from.id.split(":")[1]}if(a!==e)return!1;if(n){var c="audio"===t.type||["L","R","inL","inR","outL","outR","fm","pitch_cv"].includes(o)||o.includes("L")||o.includes("R");return"audio"===n&&c||"control"===n&&!c}return!0})}}],n&&ne(e.prototype,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function oe(e){return oe="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},oe(e)}function ce(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,re(a.key),a)}}function re(e){var n=function(e){if("object"!=oe(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=oe(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==oe(n)?n:n+""}var ie=function(){return e=function e(){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e)},n=[{key:"getAnalogPin",value:function(e){return Z.ANALOG_PINS[e%Z.ANALOG_PINS.length]}},{key:"getGateOutPin",value:function(e){return Z.GATE_OUT_PINS[e%Z.GATE_OUT_PINS.length]}},{key:"getGateInPin",value:function(e){return Z.GATE_IN_PINS[e%Z.GATE_IN_PINS.length]}},{key:"getMCPButtonPin",value:function(e){return Q.BUTTONS[e%Q.BUTTONS.length]}},{key:"getMCPButtonLEDPin",value:function(e){return this.getNeoPixelIndex("button",e)}},{key:"getMCPGateLEDPin",value:function(e){return e<2?Q.GATE_LEDS[e]:Q.GATE_LEDS_B[e-2]}},{key:"getMCPMIDIInLEDPin",value:function(){return Q.MIDI_IN_LED}},{key:"getMCPMIDIOutLEDPin",value:function(){return Q.MIDI_OUT_LED}},{key:"getNeoPixelPin",value:function(){return Z.NEOPIXEL_PIN}},{key:"getNeoPixelIndex",value:function(e,n){return"button"===e?Z.NEOPIXEL_MAP.BTN[n%4]:"pot"===e?Z.NEOPIXEL_MAP.POT[n%4]:0}},{key:"getEncoderPins",value:function(){return{A:Z.ENCODER_A,B:Z.ENCODER_B,BTN:Z.ENCODER_BTN}}},{key:"getI2SPins",value:function(){return{BCLK:Z.I2S_BCLK,LRCK:Z.I2S_LRCK,DATA:Z.I2S_DATA}}},{key:"getSDPins",value:function(){return{CS:Z.SD_CS,MOSI:Z.SD_MOSI,MISO:Z.SD_MISO,SCK:Z.SD_SCK}}},{key:"getI2CPins",value:function(){return{SDA:Z.I2C_SDA,SCL:Z.I2C_SCL}}},{key:"getMIDILEDPins",value:function(){return{IN:Q.MIDI_IN_LED,OUT:Q.MIDI_OUT_LED}}}],null&&ce(e.prototype,null),n&&ce(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function le(e){return le="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},le(e)}function se(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,ue(a.key),a)}}function ue(e){var n=function(e){if("object"!=le(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=le(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==le(n)?n:n+""}var de=function(){return e=function e(){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e)},n=[{key:"generateDriverCode",value:function(){return"\n// ============================================================================\n// Inline WS2812B NeoPixel Driver (ESP-IDF 5.x RMT API)\n// Replaces Adafruit_NeoPixel library - no external dependencies\n// Hardware: ".concat(Z.NEOPIXEL_COUNT," LEDs on GPIO").concat(Z.NEOPIXEL_PIN,'\n// ============================================================================\n\n#include "driver/rmt_tx.h"\n#include "driver/rmt_encoder.h"\n\n#define NEOPIXEL_PIN     ').concat(Z.NEOPIXEL_PIN,"\n#define NEOPIXEL_COUNT   ").concat(Z.NEOPIXEL_COUNT,"\n\n// WS2812B timing (10MHz resolution = 100ns per tick)\n#define WS2812_T0H_TICKS  3   // 300ns\n#define WS2812_T0L_TICKS  9   // 900ns\n#define WS2812_T1H_TICKS  9   // 900ns\n#define WS2812_T1L_TICKS  3   // 300ns\n#define WS2812_RESET_US   280 // Reset pulse\n\n// Pixel buffer and state\nstatic uint8_t neopixel_buffer[NEOPIXEL_COUNT * 3]; // GRB format\nstatic uint8_t neopixel_brightness = ").concat(Z.NEOPIXEL_BRIGHTNESS,';\nstatic rmt_channel_handle_t neopixel_rmt_channel = NULL;\nstatic rmt_encoder_handle_t neopixel_encoder = NULL;\n\n// Simple NeoPixel class matching Adafruit API\nclass NeoPixelStrip {\nprivate:\n    bool initialized = false;\n\npublic:\n    void begin() {\n        // Configure RMT TX channel\n        rmt_tx_channel_config_t tx_config = {\n            .gpio_num = (gpio_num_t)NEOPIXEL_PIN,\n            .clk_src = RMT_CLK_SRC_DEFAULT,\n            .resolution_hz = 10000000, // 10MHz = 100ns resolution\n            .mem_block_symbols = 64,\n            .trans_queue_depth = 4,\n            .flags = { .invert_out = false, .with_dma = false }\n        };\n\n        if (rmt_new_tx_channel(&tx_config, &neopixel_rmt_channel) != ESP_OK) {\n            Serial.println("RMT channel creation failed");\n            return;\n        }\n\n        // Configure bytes encoder for WS2812 timing\n        rmt_bytes_encoder_config_t bytes_config = {\n            .bit0 = { .duration0 = WS2812_T0H_TICKS, .level0 = 1, .duration1 = WS2812_T0L_TICKS, .level1 = 0 },\n            .bit1 = { .duration0 = WS2812_T1H_TICKS, .level0 = 1, .duration1 = WS2812_T1L_TICKS, .level1 = 0 },\n            .flags = { .msb_first = true }\n        };\n\n        if (rmt_new_bytes_encoder(&bytes_config, &neopixel_encoder) != ESP_OK) {\n            Serial.println("RMT encoder creation failed");\n            return;\n        }\n\n        rmt_enable(neopixel_rmt_channel);\n        memset(neopixel_buffer, 0, sizeof(neopixel_buffer));\n        initialized = true;\n        show(); // Clear LEDs\n    }\n\n    void setBrightness(uint8_t b) {\n        neopixel_brightness = b;\n    }\n\n    void clear() {\n        memset(neopixel_buffer, 0, sizeof(neopixel_buffer));\n    }\n\n    static uint32_t Color(uint8_t r, uint8_t g, uint8_t b) {\n        return ((uint32_t)r << 16) | ((uint32_t)g << 8) | b;\n    }\n\n    void setPixelColor(uint16_t n, uint32_t color) {\n        if (n >= NEOPIXEL_COUNT) return;\n        // Store in GRB order with brightness applied\n        uint8_t r = ((color >> 16) & 0xFF) * neopixel_brightness / 255;\n        uint8_t g = ((color >> 8) & 0xFF) * neopixel_brightness / 255;\n        uint8_t b = (color & 0xFF) * neopixel_brightness / 255;\n        neopixel_buffer[n * 3 + 0] = g;\n        neopixel_buffer[n * 3 + 1] = r;\n        neopixel_buffer[n * 3 + 2] = b;\n    }\n\n    void show() {\n        if (!initialized || !neopixel_rmt_channel) return;\n\n        rmt_transmit_config_t tx_config = {\n            .loop_count = 0,\n            .flags = { .eot_level = 0 }\n        };\n\n        rmt_transmit(neopixel_rmt_channel, neopixel_encoder, neopixel_buffer,\n                     sizeof(neopixel_buffer), &tx_config);\n        rmt_tx_wait_all_done(neopixel_rmt_channel, pdMS_TO_TICKS(100));\n    }\n\n    uint16_t numPixels() const { return NEOPIXEL_COUNT; }\n};\n\n// Global NeoPixel instance\nNeoPixelStrip neoPixels;\n')}},{key:"generateInclude",value:function(){return"#include <driver/rmt.h>"}}],null&&se(e.prototype,null),n&&se(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function pe(e){return pe="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},pe(e)}function fe(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,me(a.key),a)}}function me(e){var n=function(e){if("object"!=pe(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=pe(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==pe(n)?n:n+""}var _e=function(){return e=function e(){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e)},n=[{key:"generateDriverCode",value:function(){return"\n// ============================================================================\n// Inline MCP23017 I2C GPIO Expander Driver\n// Replaces Adafruit_MCP23X17 library - no external dependencies\n// Hardware: Address 0x20, I2C on GPIO".concat(Z.I2C_SDA,"/").concat(Z.I2C_SCL,"\n// ============================================================================\n\n// MCP23017 I2C address\n#define MCP23017_ADDR 0x20\n\n// MCP23017 Register addresses (IOCON.BANK = 0, default)\n#define MCP23017_IODIRA   0x00  // I/O direction A (1=input, 0=output)\n#define MCP23017_IODIRB   0x01  // I/O direction B\n#define MCP23017_IPOLA    0x02  // Input polarity A\n#define MCP23017_IPOLB    0x03  // Input polarity B\n#define MCP23017_GPINTENA 0x04  // Interrupt-on-change A\n#define MCP23017_GPINTENB 0x05  // Interrupt-on-change B\n#define MCP23017_DEFVALA  0x06  // Default compare value A\n#define MCP23017_DEFVALB  0x07  // Default compare value B\n#define MCP23017_INTCONA  0x08  // Interrupt control A\n#define MCP23017_INTCONB  0x09  // Interrupt control B\n#define MCP23017_IOCON    0x0A  // Configuration register\n#define MCP23017_GPPUA    0x0C  // Pull-up resistor A (1=enabled)\n#define MCP23017_GPPUB    0x0D  // Pull-up resistor B\n#define MCP23017_INTFA    0x0E  // Interrupt flag A\n#define MCP23017_INTFB    0x0F  // Interrupt flag B\n#define MCP23017_INTCAPA  0x10  // Interrupt capture A\n#define MCP23017_INTCAPB  0x11  // Interrupt capture B\n#define MCP23017_GPIOA    0x12  // GPIO port A\n#define MCP23017_GPIOB    0x13  // GPIO port B\n#define MCP23017_OLATA    0x14  // Output latch A\n#define MCP23017_OLATB    0x15  // Output latch B\n\n// Use Arduino's built-in constants: INPUT (0x01), OUTPUT (0x03), INPUT_PULLUP (0x05)\n\n// Internal state tracking\nstatic uint8_t mcp_iodirA = 0xFF;  // Default: all inputs\nstatic uint8_t mcp_iodirB = 0xFF;\nstatic uint8_t mcp_gpuA = 0x00;    // Default: no pull-ups\nstatic uint8_t mcp_gpuB = 0x00;\nstatic uint8_t mcp_olatA = 0x00;   // Output latch state\nstatic uint8_t mcp_olatB = 0x00;\nstatic bool mcp_initialized = false;\n\n// Simple MCP23017 class matching Adafruit API\nclass MCP23017 {\nprivate:\n    // Write single register\n    void writeRegister(uint8_t reg, uint8_t value) {\n        Wire.beginTransmission(MCP23017_ADDR);\n        Wire.write(reg);\n        Wire.write(value);\n        Wire.endTransmission();\n    }\n\n    // Read single register\n    uint8_t readRegister(uint8_t reg) {\n        Wire.beginTransmission(MCP23017_ADDR);\n        Wire.write(reg);\n        Wire.endTransmission();\n        Wire.requestFrom((uint8_t)MCP23017_ADDR, (uint8_t)1);\n        return Wire.available() ? Wire.read() : 0;\n    }\n\npublic:\n    // Initialize MCP23017 at I2C address\n    bool begin_I2C(uint8_t addr = MCP23017_ADDR) {\n        // Check if device responds\n        Wire.beginTransmission(addr);\n        if (Wire.endTransmission() != 0) {\n            return false;\n        }\n\n        // Set all pins as inputs initially (safe default)\n        mcp_iodirA = 0xFF;\n        mcp_iodirB = 0xFF;\n        writeRegister(MCP23017_IODIRA, mcp_iodirA);\n        writeRegister(MCP23017_IODIRB, mcp_iodirB);\n\n        // Disable all pull-ups initially\n        mcp_gpuA = 0x00;\n        mcp_gpuB = 0x00;\n        writeRegister(MCP23017_GPPUA, mcp_gpuA);\n        writeRegister(MCP23017_GPPUB, mcp_gpuB);\n\n        // Clear output latches\n        mcp_olatA = 0x00;\n        mcp_olatB = 0x00;\n        writeRegister(MCP23017_OLATA, mcp_olatA);\n        writeRegister(MCP23017_OLATB, mcp_olatB);\n\n        mcp_initialized = true;\n        return true;\n    }\n\n    // Set pin mode (0-7 = Port A, 8-15 = Port B)\n    // Uses Arduino constants: OUTPUT (0x03), INPUT (0x01), INPUT_PULLUP (0x05)\n    void pinMode(uint8_t pin, uint8_t mode) {\n        if (pin > 15) return;\n\n        bool isPortB = (pin >= 8);\n        uint8_t bit = isPortB ? (pin - 8) : pin;\n        uint8_t mask = (1 << bit);\n        bool isOutput = (mode == OUTPUT);  // Arduino OUTPUT = 0x03\n        bool hasPullup = (mode == INPUT_PULLUP);  // Arduino INPUT_PULLUP = 0x05\n\n        if (isPortB) {\n            if (isOutput) {\n                mcp_iodirB &= ~mask;  // Clear bit = output\n                mcp_gpuB &= ~mask;    // Disable pull-up\n            } else {\n                mcp_iodirB |= mask;   // Set bit = input\n                if (hasPullup) {\n                    mcp_gpuB |= mask; // Enable pull-up\n                } else {\n                    mcp_gpuB &= ~mask;\n                }\n            }\n            writeRegister(MCP23017_IODIRB, mcp_iodirB);\n            writeRegister(MCP23017_GPPUB, mcp_gpuB);\n        } else {\n            if (isOutput) {\n                mcp_iodirA &= ~mask;\n                mcp_gpuA &= ~mask;\n            } else {\n                mcp_iodirA |= mask;\n                if (hasPullup) {\n                    mcp_gpuA |= mask;\n                } else {\n                    mcp_gpuA &= ~mask;\n                }\n            }\n            writeRegister(MCP23017_IODIRA, mcp_iodirA);\n            writeRegister(MCP23017_GPPUA, mcp_gpuA);\n        }\n    }\n\n    // Write to output pin\n    void digitalWrite(uint8_t pin, uint8_t value) {\n        if (pin > 15) return;\n\n        bool isPortB = (pin >= 8);\n        uint8_t bit = isPortB ? (pin - 8) : pin;\n        uint8_t mask = (1 << bit);\n\n        if (isPortB) {\n            if (value) {\n                mcp_olatB |= mask;\n            } else {\n                mcp_olatB &= ~mask;\n            }\n            writeRegister(MCP23017_OLATB, mcp_olatB);\n        } else {\n            if (value) {\n                mcp_olatA |= mask;\n            } else {\n                mcp_olatA &= ~mask;\n            }\n            writeRegister(MCP23017_OLATA, mcp_olatA);\n        }\n    }\n\n    // Read single pin\n    uint8_t digitalRead(uint8_t pin) {\n        if (pin > 15) return 0;\n\n        bool isPortB = (pin >= 8);\n        uint8_t bit = isPortB ? (pin - 8) : pin;\n\n        uint8_t gpio = isPortB ? readRegister(MCP23017_GPIOB) : readRegister(MCP23017_GPIOA);\n        return (gpio >> bit) & 0x01;\n    }\n\n    // Read both ports as 16-bit value (Port A = low byte, Port B = high byte)\n    uint16_t readGPIOAB() {\n        // Read both GPIO registers in sequence\n        uint8_t a = readRegister(MCP23017_GPIOA);\n        uint8_t b = readRegister(MCP23017_GPIOB);\n        return ((uint16_t)b << 8) | a;\n    }\n\n    // Write both ports from 16-bit value\n    void writeGPIOAB(uint16_t value) {\n        mcp_olatA = value & 0xFF;\n        mcp_olatB = (value >> 8) & 0xFF;\n        writeRegister(MCP23017_OLATA, mcp_olatA);\n        writeRegister(MCP23017_OLATB, mcp_olatB);\n    }\n};\n\n// Global MCP23017 instance\nMCP23017 mcp;\n")}},{key:"generateInclude",value:function(){return""}}],null&&fe(e.prototype,null),n&&fe(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function ge(e){return ge="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},ge(e)}function he(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,ve(a.key),a)}}function ve(e){var n=function(e){if("object"!=ge(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=ge(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==ge(n)?n:n+""}var be=function(){return e=function e(){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e)},n=[{key:"generateIncludes",value:function(){var e=new Set;return e.add("#include <Wire.h>"),e.add("#include <driver/i2s.h>"),e.add("#include <time.h>"),e.add("#include <sys/time.h>"),e.add("#include <SD.h>"),e.add("#include <FS.h>"),e.add("#include <SPI.h>"),Array.from(e)}},{key:"generateI2SSetup",value:function(){return"\n// I2S Audio Output Configuration (PCM5102A DAC)\ni2s_config_t i2s_config = {\n    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX),\n    .sample_rate = ".concat(Z.SAMPLE_RATE,",\n    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,\n    .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\n    .communication_format = I2S_COMM_FORMAT_I2S,\n    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n    .dma_buf_count = 8,\n    .dma_buf_len = ").concat(Z.BUFFER_SIZE,",\n    .use_apll = false,\n    .tx_desc_auto_clear = true,\n    .fixed_mclk = 0\n};\n\ni2s_pin_config_t pin_config = {\n    .bck_io_num = ").concat(Z.I2S_BCLK,",      // BCK (Bit Clock)\n    .ws_io_num = ").concat(Z.I2S_LRCK,",       // LRCK/WS (Word Select)\n    .data_out_num = ").concat(Z.I2S_DATA,",    // DIN (Audio Data)\n    .data_in_num = I2S_PIN_NO_CHANGE\n};\n\n// Initialize I2S\ni2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);\ni2s_set_pin(I2S_NUM_0, &pin_config);\ni2s_zero_dma_buffer(I2S_NUM_0);\n")}},{key:"generateMCP23017Setup",value:function(){return'\n// Initialize MCP23017 I/O expander\nif (!mcp.begin_I2C(0x20)) {\n    Serial.println("Error initializing MCP23017");\n    while (1);\n}\n\n// Configure MCP23017 pins (GPA0-3: buttons, GPA4-5: gate in, GPA6-7: button LEDs)\nmcp.pinMode(0, INPUT_PULLUP);  // Button 1\nmcp.pinMode(1, INPUT_PULLUP);  // Button 2\nmcp.pinMode(2, INPUT_PULLUP);  // Button 3\nmcp.pinMode(3, INPUT_PULLUP);  // Button 4\nmcp.pinMode(4, INPUT_PULLUP);  // Gate IN 1\nmcp.pinMode(5, INPUT_PULLUP);  // Gate IN 2\nmcp.pinMode(6, OUTPUT);        // Button 1 LED\nmcp.pinMode(7, OUTPUT);        // Button 2 LED\n\n// Configure Port B (GPB0-1: button LEDs 3-4, GPB2-5: gate LEDs)\nmcp.pinMode(8, OUTPUT);        // Button 3 LED\nmcp.pinMode(9, OUTPUT);        // Button 4 LED\nmcp.pinMode(10, OUTPUT);       // Gate 1 LED\nmcp.pinMode(11, OUTPUT);       // Gate 2 LED\nmcp.pinMode(12, OUTPUT);       // Gate 3 LED\nmcp.pinMode(13, OUTPUT);       // Gate 4 LED\n'}},{key:"generateNeoPixelSetup",value:function(){return"\n// Initialize NeoPixel LEDs\nneoPixels.begin();\nneoPixels.setBrightness(".concat(Z.NEOPIXEL_BRIGHTNESS,');\nneoPixels.clear();\nneoPixels.show();\nSerial.println("NeoPixels initialized (8 LEDs, GPIO46)");\n')}},{key:"generateGlobalVariables",value:function(){var e=de.generateDriverCode(),n=_e.generateDriverCode();return"\n// Global audio buffers\nint16_t audioBufferL[".concat(Z.BUFFER_SIZE,"];\nint16_t audioBufferR[").concat(Z.BUFFER_SIZE,"];\nfloat tempBufferL[").concat(Z.BUFFER_SIZE,"];\nfloat tempBufferR[").concat(Z.BUFFER_SIZE,"];\n\n").concat(n,"\n\n").concat(e,"\n\nuint8_t currentBank = 0; // Current bank (0-5 for 6 banks)\n\n// Timing\nunsigned long lastMillis = 0;\nunsigned long mcpReadTime = 0;\nconst unsigned long MCP_READ_INTERVAL = 20; // Read MCP every 20ms\nunsigned long neoPixelUpdateTime = 0;\nconst unsigned long NEOPIXEL_UPDATE_INTERVAL = 100; // Update NeoPixels every 100ms\n")}},{key:"generateNeoPixelUpdateCode",value:function(){var e=Z.BANK_COLORS.map(function(e,n){return"  {".concat(e.r,", ").concat(e.g,", ").concat(e.b,"}").concat(n<Z.BANK_COLORS.length-1?",":" "," // Bank ").concat(n+1)}).join("\n");return Z.AUTOMATION_RECORD_COLOR,"\n// Bank colors (RGB)\nstruct BankColor {\n  uint8_t r, g, b;\n};\n\nconst BankColor bankColors[6] = {\n".concat(e,"\n};\n\nvoid updateNeoPixels() {\n  // Get current bank color (currentBank is 1-based, array is 0-based)\n  BankColor color = bankColors[(currentBank - 1) % 6];\n\n  // Update button LEDs (indices ").concat(Z.NEOPIXEL_MAP.BTN.join(", "),")\n  for (int i = 0; i < 4; i++) {\n    uint8_t ledIndex = 0;\n    switch(i) {\n      case 0: ledIndex = ").concat(Z.NEOPIXEL_MAP.BTN[0],"; break;\n      case 1: ledIndex = ").concat(Z.NEOPIXEL_MAP.BTN[1],"; break;\n      case 2: ledIndex = ").concat(Z.NEOPIXEL_MAP.BTN[2],"; break;\n      case 3: ledIndex = ").concat(Z.NEOPIXEL_MAP.BTN[3],"; break;\n    }\n\n    // Check if button is held for automation record (override with red)\n    // Button gates are stored in btn1_gate through btn4_gate (1-indexed)\n    bool isRecording = false;\n\n    // AUTOMATION_RECORD_CHECK_PLACEHOLDER will be replaced by actual automation checks\n    // Format: isRecording = isRecording || (btn1_gate && automation1_record_trigger);\n    // AUTOMATION_RECORD_CHECK_PLACEHOLDER\n\n    if (isRecording) {\n      // Override with red for automation record\n      neoPixels.setPixelColor(ledIndex, neoPixels.Color(").concat(Z.AUTOMATION_RECORD_COLOR.r,", ").concat(Z.AUTOMATION_RECORD_COLOR.g,", ").concat(Z.AUTOMATION_RECORD_COLOR.b,"));\n    } else {\n      // Use bank color\n      neoPixels.setPixelColor(ledIndex, neoPixels.Color(color.r, color.g, color.b));\n    }\n  }\n\n  // Update pot LEDs (indices ").concat(Z.NEOPIXEL_MAP.POT.join(", "),")\n  for (int i = 0; i < 4; i++) {\n    uint8_t ledIndex = 0;\n    switch(i) {\n      case 0: ledIndex = ").concat(Z.NEOPIXEL_MAP.POT[0],"; break;\n      case 1: ledIndex = ").concat(Z.NEOPIXEL_MAP.POT[1],"; break;\n      case 2: ledIndex = ").concat(Z.NEOPIXEL_MAP.POT[2],"; break;\n      case 3: ledIndex = ").concat(Z.NEOPIXEL_MAP.POT[3],"; break;\n    }\n    neoPixels.setPixelColor(ledIndex, neoPixels.Color(color.r, color.g, color.b));\n  }\n\n  neoPixels.show();\n}\n")}},{key:"generateMainLoop",value:function(){return"\nvoid loop() {\n    // Audio processing happens here\n    processAudioBuffer();\n\n    // Control rate updates (every 20ms to avoid I2C interference)\n    if (millis() - mcpReadTime > MCP_READ_INTERVAL) {\n        mcpReadTime = millis();\n        readControls();\n    }\n\n    // Update NeoPixels (every 100ms)\n    if (millis() - neoPixelUpdateTime > NEOPIXEL_UPDATE_INTERVAL) {\n        neoPixelUpdateTime = millis();\n        updateNeoPixels();\n    }\n}\n"}}],null&&he(e.prototype,null),n&&he(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function ye(e){return ye="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},ye(e)}function ke(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,c,r,i=[],l=!0,s=!1;try{if(c=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=c.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(r=t.return(),Object(r)!==r))return}finally{if(s)throw o}}return i}}(e,n)||function(e,n){if(e){if("string"==typeof e)return xe(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?xe(e,n):void 0}}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function xe(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}function Se(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,Ee(a.key),a)}}function Ee(e){var n=function(e){if("object"!=ye(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=ye(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==ye(n)?n:n+""}var Pe=function(){return e=function e(n){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.connectionResolver=n},(n=[{key:"getPotReference",value:function(e,n){var t=e.params.index||1;return"pot".concat(t,"_value")}},{key:"generateBankAwareAssignment",value:function(e,n){if(!e||"Pot"!==e.type)return"        // WARNING: Invalid pot reference\n";var t=e.params.bank||1;return e.params.locked?"        ".concat(n,"\n"):"        if (currentBank == ".concat(t,") {\n            ").concat(n,"\n        }\n")}},{key:"getOscWaveTypeIndex",value:function(e){if("number"==typeof e)return e;if("string"!=typeof e)return 0;switch(e.toLowerCase()){case"sine":default:return 0;case"triangle":case"tri":return 1;case"sawtooth":case"saw":return 2;case"square":return 3}}},{key:"getNoiseTypeIndex",value:function(e){if("number"==typeof e)return e;if("string"!=typeof e)return 0;switch(e.toLowerCase()){case"white":default:return 0;case"pink":return 1;case"brown":case"brownian":return 2}}},{key:"getAudioMathModeIndex",value:function(e){if("number"==typeof e)return e;if("string"!=typeof e)return 0;switch(e.toLowerCase()){case"am":case"amplitude_modulation":default:return 0;case"crossfade":case"cross":return 1;case"ring":case"ring_modulation":return 2;case"vocoder":return 3}}},{key:"generateIncludes",value:function(e){var n=[];switch(e){case"Oscillator":case"Wavetable":case"Filter":case"GranularSynth":case"KickDrum":case"SnareDrum":case"Percussion":n.push("#include <math.h>"),n.push("#include <SD.h>"),n.push("#include <FS.h>"),n.push("#include <freertos/FreeRTOS.h>"),n.push("#include <freertos/task.h>"),n.push("#include <freertos/semphr.h>");break;case"Noise":case"CleanReverb":case"AudioMath":case"Panner":case"ChorusFlangeRing":case"Limiter":case"NoiseGate":case"EQ8":case"Wavetable":case"GranularDense":case"SamplePlayer":n.push("#include <math.h>");break;case"Resonance":n.push("#include <math.h>"),n.push("#include <esp_dsp.h>"),n.push("#include <Wire.h>"),n.push("#include <SD.h>"),n.push("#include <freertos/FreeRTOS.h>"),n.push("#include <freertos/task.h>")}return n}},{key:"generateModuleClasses",value:function(){return'\n// WAV File Header Structure\nstruct WAVHeader {\n    char riff[4];           // "RIFF"\n    uint32_t fileSize;      // File size minus 8 bytes\n    char wave[4];           // "WAVE"\n    char fmt[4];            // "fmt "\n    uint32_t fmtSize;       // Format chunk size\n    uint16_t audioFormat;   // Audio format (1 = PCM)\n    uint16_t numChannels;   // Number of channels\n    uint32_t sampleRate;    // Sample rate\n    uint32_t byteRate;      // Byte rate\n    uint16_t blockAlign;    // Block alignment\n    uint16_t bitsPerSample; // Bits per sample\n    char data[4];           // "data"\n    uint32_t dataSize;      // Data size\n};\n\n#define CHUNK_SIZE 4096  // Buffer size in bytes (1024 samples * 2 channels * 2 bytes)\n#define CHUNK_SAMPLES (CHUNK_SIZE / 4) // 1024 samples for stereo 16-bit\n\nclass MinimalWAVPlayer {\nprivate:\n    File wavFile;\n    WAVHeader header;\n\n    // Double buffering for seamless playback\n    int16_t* bufferA;\n    int16_t* bufferB;\n    int16_t* playingBuffer;       // Currently being played\n    int16_t* loadingBuffer;       // Currently being loaded\n    bool bufferAReady;\n    bool bufferBReady;\n\n    // Playback state\n    int playPosition;\n    int bufferPosition;\n    bool isPlaying;\n    float playbackSpeed;\n    float startPosition;\n    float endPosition;\n\n    // Background loading\n    SemaphoreHandle_t bufferMutex;\n    TaskHandle_t loadingTask;\n\npublic:\n    MinimalWAVPlayer();\n    bool loadFile(const String& filename);\n    void play();\n    void stop();\n    bool playing();\n    void setPlaybackSpeed(float speed);\n    void setStartPosition(float pos);\n    void setEndPosition(float pos);\n    int16_t getNextSample();\n\n    ~MinimalWAVPlayer() {\n        stop();\n        if (bufferA) free(bufferA);\n        if (bufferB) free(bufferB);\n        if (bufferMutex) vSemaphoreDelete(bufferMutex);\n    }\n};\n'}},{key:"generateGlobalVariables",value:function(e,n,t){switch(e.type){case"Oscillator":return"\n// ".concat(t.label," ").concat(n,"\nfloat osc").concat(n,"_phase = 0.0;\nfloat osc").concat(n,"_freq = ").concat(e.params.freq||440,";\nfloat osc").concat(n,"_gate = ").concat(e.params.gate||1,";\nint osc").concat(n,"_waveform = ").concat(this.getOscWaveTypeIndex(e.params.waveform),"; // 0=sine, 1=triangle, 2=saw, 3=square\nfloat osc").concat(n,"_morph = ").concat(e.params.morph||0,"; // Wave morphing parameter (0-1)\nfloat osc").concat(n,"_fm_amount = ").concat(e.params.fm_amount||0,"; // FM amount (0-1)\nfloat osc").concat(n,"_pitch_amount = ").concat(e.params.pitch_amount||e.params.pitch_range||24,"; // Pitch CV amount in semitones (+24=upward sweep, -24=downward kick drop)\nfloat osc").concat(n,"_pitch_smooth = 0.5; // Smoothed pitch CV to prevent artifacts (0-1)\nfloat osc").concat(n,"_outputL = 0.0;\nfloat osc").concat(n,"_outputR = 0.0;\nfloat osc").concat(n,"_amplitude = ").concat(e.params.amplitude||.8,";\nint osc").concat(n,"_debug_counter = 0;\n");case"PolyOscillator":return this.generatePolyOscillatorVariables(e,n,t);case"Filter":return"\n// ".concat(t.label," ").concat(n," - State Variable Filter\nfloat filter").concat(n,"_cutoff = ").concat(e.params.cutoff_hz||2e3,";\nfloat filter").concat(n,"_resonance = ").concat(e.params.resonance||.3,";\nfloat filter").concat(n,"_lfo_min_hz = ").concat(e.params.lfo_min_hz||100,";\nfloat filter").concat(n,"_lfo_max_hz = ").concat(e.params.lfo_max_hz||4e3,";\n// SVF state variables (per channel)\nfloat filter").concat(n,"_lowL = 0.0, filter").concat(n,"_bandL = 0.0; // Left channel\nfloat filter").concat(n,"_lowR = 0.0, filter").concat(n,"_bandR = 0.0; // Right channel\nfloat filter").concat(n,"_inputL = 0.0;\nfloat filter").concat(n,"_inputR = 0.0;\nfloat filter").concat(n,"_outputL = 0.0;\nfloat filter").concat(n,"_outputR = 0.0;\n");case"Distortion":return this.generateDistortionVariables(e,n,t);case"VCA":return"\n// ".concat(t.label," ").concat(n,"\nfloat vca").concat(n,"_gain = ").concat(e.params.gain||1,";\nfloat vca").concat(n,"_inputL = 0.0;\nfloat vca").concat(n,"_inputR = 0.0;\nfloat vca").concat(n,"_outputL = 0.0;\nfloat vca").concat(n,"_outputR = 0.0;\nfloat vca").concat(n,"_lastGain = 0.0; // For gain smoothing to prevent clicking\n");case"Noise":return"\n// ".concat(t.label," ").concat(n," - Multi-type Noise Generator\nint noise").concat(n,"_type = ").concat(this.getNoiseTypeIndex(e.params.type),"; // 0=white, 1=pink, 2=brown\nfloat noise").concat(n,"_gain = ").concat(e.params.gain||.3,";\nfloat noise").concat(n,"_gate = ").concat(e.params.gate||1,";\nfloat noise").concat(n,"_morph = ").concat(e.params.morph||0,"; // Morphing between noise types\nfloat noise").concat(n,"_output = 0.0;\n// Pink noise filter state (for pink noise generation)\nfloat noise").concat(n,"_pink_b0 = 0.0, noise").concat(n,"_pink_b1 = 0.0, noise").concat(n,"_pink_b2 = 0.0;\nfloat noise").concat(n,"_pink_b3 = 0.0, noise").concat(n,"_pink_b4 = 0.0, noise").concat(n,"_pink_b5 = 0.0, noise").concat(n,"_pink_b6 = 0.0;\n// Brown noise filter state\nfloat noise").concat(n,"_brown_last = 0.0;\n// LCG seed for deterministic noise generation (avoids ESP32 random() interference)\nuint32_t noise").concat(n,"_lcg_seed = ").concat(12345+7*n,"; // Different seed per instance\nint noise").concat(n,"_debug_counter = 0;\n");case"CleanReverb":var a,o,c,r=e.params.quality||"ultra";switch(r){case"standard":a={comb1:1051,comb2:1297,comb3:1531,comb4:1723,ap1:347,ap2:113,predelay:882},o="~28KB",c="Standard quality (40ms max decay)";break;case"high":a={comb1:3500,comb2:4300,comb3:5100,comb4:5700,ap1:1150,ap2:375,predelay:2940},o="~100KB",c="High quality (140ms max decay)";break;default:a={comb1:16e3,comb2:19700,comb3:23300,comb4:26200,ap1:2800,ap2:900,predelay:17640},o="~426KB",c="Ultra quality (594ms max decay)"}return"\n// ".concat(t.label," ").concat(n," - Schroeder Reverb (").concat(c,')\n// Quality preset: "').concat(r,'" (').concat(o," PSRAM per instance)\n// Comb filter delay sizes for 44.1kHz sample rate\n#define CLEANREVERB").concat(n,"_COMB1_SIZE ").concat(a.comb1,"   // ~").concat(Math.round(a.comb1/44.1),"ms\n#define CLEANREVERB").concat(n,"_COMB2_SIZE ").concat(a.comb2,"   // ~").concat(Math.round(a.comb2/44.1),"ms\n#define CLEANREVERB").concat(n,"_COMB3_SIZE ").concat(a.comb3,"   // ~").concat(Math.round(a.comb3/44.1),"ms\n#define CLEANREVERB").concat(n,"_COMB4_SIZE ").concat(a.comb4,"   // ~").concat(Math.round(a.comb4/44.1),"ms\n\n// Allpass filter delay sizes\n#define CLEANREVERB").concat(n,"_AP1_SIZE ").concat(a.ap1,"      // ~").concat(Math.round(a.ap1/44.1),"ms\n#define CLEANREVERB").concat(n,"_AP2_SIZE ").concat(a.ap2,"       // ~").concat(Math.round(a.ap2/44.1),"ms\n\n// Predelay for early reflections\n#define CLEANREVERB").concat(n,"_PREDELAY_SIZE ").concat(a.predelay," // ~").concat(Math.round(a.predelay/44.1),"ms\n\n// Delay line arrays (allocated dynamically from PSRAM at runtime)\n// Using pointers + ps_malloc() to explicitly allocate from PSRAM\nfloat* cleanreverb").concat(n,"_comb1 = nullptr;\nfloat* cleanreverb").concat(n,"_comb2 = nullptr;\nfloat* cleanreverb").concat(n,"_comb3 = nullptr;\nfloat* cleanreverb").concat(n,"_comb4 = nullptr;\n\nfloat* cleanreverb").concat(n,"_ap1 = nullptr;\nfloat* cleanreverb").concat(n,"_ap2 = nullptr;\n\n// Per-comb LPF states (damping inside feedback path) - small, can stay in DRAM\nfloat cleanreverb").concat(n,"_comb1_lpf = 0.0f;\nfloat cleanreverb").concat(n,"_comb2_lpf = 0.0f;\nfloat cleanreverb").concat(n,"_comb3_lpf = 0.0f;\nfloat cleanreverb").concat(n,"_comb4_lpf = 0.0f;\n\n// Predelay buffer (allocated dynamically from PSRAM at runtime)\nfloat* cleanreverb").concat(n,"_predelay = nullptr;\nint cleanreverb").concat(n,"_predelay_pos = 0;\n\n// Position counters\nint cleanreverb").concat(n,"_comb1_pos = 0, cleanreverb").concat(n,"_comb2_pos = 0;\nint cleanreverb").concat(n,"_comb3_pos = 0, cleanreverb").concat(n,"_comb4_pos = 0;\nint cleanreverb").concat(n,"_ap1_pos = 0, cleanreverb").concat(n,"_ap2_pos = 0;\n\n// Parameters\nfloat cleanreverb").concat(n,"_mix = ").concat(e.params.mix||.4,";\nfloat cleanreverb").concat(n,"_size = ").concat(e.params.size||.6,";\nfloat cleanreverb").concat(n,"_damp = ").concat(e.params.damp||.3,";\n\n// Smoothed params to avoid zippering\nfloat cleanreverb").concat(n,"_mix_z = cleanreverb").concat(n,"_mix;\nfloat cleanreverb").concat(n,"_size_z = cleanreverb").concat(n,"_size;\nfloat cleanreverb").concat(n,"_damp_z = cleanreverb").concat(n,"_damp;\n\n// Input variables (standard connection system)\nfloat cleanreverb").concat(n,"_inputL = 0.0;\nfloat cleanreverb").concat(n,"_inputR = 0.0;\n\n// Output\nfloat cleanreverb").concat(n,"_outputL = 0.0;\nfloat cleanreverb").concat(n,"_outputR = 0.0;\n\n// Allocate and initialize delay buffers from PSRAM (critical for ESP32-S3)\nvoid initCleanReverb").concat(n,'() {\n    Serial.println("Allocating CleanReverb').concat(n,' buffers from PSRAM...");\n\n    // Allocate buffers from PSRAM using ps_malloc (PSRAM-specific allocator)\n    cleanreverb').concat(n,"_comb1 = (float*)ps_malloc(CLEANREVERB").concat(n,"_COMB1_SIZE * sizeof(float));\n    cleanreverb").concat(n,"_comb2 = (float*)ps_malloc(CLEANREVERB").concat(n,"_COMB2_SIZE * sizeof(float));\n    cleanreverb").concat(n,"_comb3 = (float*)ps_malloc(CLEANREVERB").concat(n,"_COMB3_SIZE * sizeof(float));\n    cleanreverb").concat(n,"_comb4 = (float*)ps_malloc(CLEANREVERB").concat(n,"_COMB4_SIZE * sizeof(float));\n    cleanreverb").concat(n,"_ap1 = (float*)ps_malloc(CLEANREVERB").concat(n,"_AP1_SIZE * sizeof(float));\n    cleanreverb").concat(n,"_ap2 = (float*)ps_malloc(CLEANREVERB").concat(n,"_AP2_SIZE * sizeof(float));\n    cleanreverb").concat(n,"_predelay = (float*)ps_malloc(CLEANREVERB").concat(n,"_PREDELAY_SIZE * sizeof(float));\n\n    // Check allocation success\n    if (!cleanreverb").concat(n,"_comb1 || !cleanreverb").concat(n,"_comb2 || !cleanreverb").concat(n,"_comb3 ||\n        !cleanreverb").concat(n,"_comb4 || !cleanreverb").concat(n,"_ap1 || !cleanreverb").concat(n,"_ap2 ||\n        !cleanreverb").concat(n,'_predelay) {\n        Serial.println("ERROR: Failed to allocate CleanReverb').concat(n,' buffers from PSRAM!");\n        Serial.printf("Free PSRAM: %d bytes\\n", ESP.getFreePsram());\n        while(1); // Halt - cannot continue without reverb buffers\n    }\n\n    Serial.printf("CleanReverb').concat(n," allocated ").concat(o,' from PSRAM\\n");\n    Serial.printf("Free PSRAM remaining: %d bytes\\n", ESP.getFreePsram());\n\n    // Zero-initialize all buffers\n    memset(cleanreverb').concat(n,"_comb1, 0, CLEANREVERB").concat(n,"_COMB1_SIZE * sizeof(float));\n    memset(cleanreverb").concat(n,"_comb2, 0, CLEANREVERB").concat(n,"_COMB2_SIZE * sizeof(float));\n    memset(cleanreverb").concat(n,"_comb3, 0, CLEANREVERB").concat(n,"_COMB3_SIZE * sizeof(float));\n    memset(cleanreverb").concat(n,"_comb4, 0, CLEANREVERB").concat(n,"_COMB4_SIZE * sizeof(float));\n    memset(cleanreverb").concat(n,"_ap1, 0, CLEANREVERB").concat(n,"_AP1_SIZE * sizeof(float));\n    memset(cleanreverb").concat(n,"_ap2, 0, CLEANREVERB").concat(n,"_AP2_SIZE * sizeof(float));\n    memset(cleanreverb").concat(n,"_predelay, 0, CLEANREVERB").concat(n,"_PREDELAY_SIZE * sizeof(float));\n\n    // Initialize LPF states and parameters\n    cleanreverb").concat(n,"_comb1_lpf = cleanreverb").concat(n,"_comb2_lpf = 0.0f;\n    cleanreverb").concat(n,"_comb3_lpf = cleanreverb").concat(n,"_comb4_lpf = 0.0f;\n    cleanreverb").concat(n,"_predelay_pos = 0;\n    cleanreverb").concat(n,"_mix_z = cleanreverb").concat(n,"_mix;\n    cleanreverb").concat(n,"_size_z = cleanreverb").concat(n,"_size;\n    cleanreverb").concat(n,"_damp_z = cleanreverb").concat(n,"_damp;\n}\n");case"GranularSynth":return"\n// ".concat(t.label," ").concat(n," - Granular Synthesis Engine (PSRAM)\nint granular").concat(n,"_buffer_size; // Set dynamically based on available memory\nfloat* granular").concat(n,"_buffer_L; // PSRAM allocation\nfloat* granular").concat(n,"_buffer_R; // PSRAM allocation\nint granular").concat(n,"_write_pos = 0;\nfloat granular").concat(n,"_grain_density = ").concat(e.params.grain_density||8,";\nfloat granular").concat(n,"_grain_size_ms = ").concat(e.params.grain_size_ms||50,";\nfloat granular").concat(n,"_position = ").concat(e.params.position||.5,";\nfloat granular").concat(n,"_position_spread = ").concat(e.params.position_spread||.2,";\nfloat granular").concat(n,"_pitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(n,"_pitch_spread = ").concat(e.params.pitch_spread||.1,";\nfloat granular").concat(n,"_dry_wet = ").concat(e.params.dry_wet||1,";\nfloat granular").concat(n,"_outputL = 0.0;\nfloat granular").concat(n,"_outputR = 0.0;\n\n// 4 concurrent grain players for richer textures\nstruct Grain").concat(n," {\n    bool active;\n    float position;\n    float pitch_ratio;\n    float amplitude;\n    int samples_remaining;\n    int grain_size_samples;\n} granular").concat(n,"_grains[4];\n\nunsigned long granular").concat(n,"_last_grain_trigger = 0;\nfloat granular").concat(n,"_grain_interval_ms = 125.0; // 8 grains/sec default\n");case"KickDrum":return"\n// ".concat(t.label," ").concat(n," - Multi-Layer Drum Synthesizer (Sample + Oscillator + Noise)\n\n// Sample layer (integrated from Sample Player)\nMinimalWAVPlayer kick").concat(n,"_player;\nfloat kick").concat(n,"_sample_gain = ").concat(e.params.sample_gain||1,";\nfloat kick").concat(n,"_sample_pitch = ").concat(e.params.sample_pitch||1,";\nbool kick").concat(n,"_sample_loop = ").concat(e.params.sample_loop||!1,";\nint kick").concat(n,"_currentFile = ").concat(e.params.sample_file||1,";\nString kick").concat(n,'_currentFileName = "";\nfloat kick').concat(n,"_sample_outputL = 0.0;\nfloat kick").concat(n,"_sample_outputR = 0.0;\nint kick").concat(n,"_lastLoadedFile = -1;\n\n// Oscillator layer (existing implementation)\nfloat kick").concat(n,"_osc_phase = 0.0;\nfloat kick").concat(n,"_osc_freq = ").concat(e.params.osc_frequency||e.params.osc_freq||60,";\nfloat kick").concat(n,"_osc_level = ").concat(e.params.osc_level||.7,";\nfloat kick").concat(n,"_osc_distortion = ").concat(e.params.osc_distortion||0,";\nfloat kick").concat(n,"_osc_pitch_env = 0.0;\nfloat kick").concat(n,"_osc_pitch_amount = ").concat(e.params.osc_pitch_amount||1,";\n// Pitch envelope ADSR parameters\nfloat kick").concat(n,"_pitch_env_attack = ").concat((e.params.pitch_env_attack_ms||3)/1e3,";\nfloat kick").concat(n,"_pitch_env_decay = ").concat((e.params.pitch_env_decay_ms||80)/1e3,";\nfloat kick").concat(n,"_pitch_env_sustain = ").concat(e.params.pitch_env_sustain||0,";\nfloat kick").concat(n,"_pitch_env_release = ").concat((e.params.pitch_env_release_ms||20)/1e3,";\nfloat kick").concat(n,"_pitch_env_amount = ").concat(e.params.pitch_env_amount||2,";\nint kick").concat(n,"_pitch_env_stage = 0;\nfloat kick").concat(n,"_pitch_env_time = 0.0;\nbool kick").concat(n,"_osc_mute = ").concat(e.params.osc_mute||!1,";\n// Oscillator amplitude envelope\nfloat kick").concat(n,"_osc_amp_env = 0.0;\nfloat kick").concat(n,"_osc_amp_attack = ").concat((e.params.osc_amp_attack_ms||1)/1e3,";\nfloat kick").concat(n,"_osc_amp_decay = ").concat((e.params.osc_amp_decay_ms||150)/1e3,";\nfloat kick").concat(n,"_osc_amp_sustain = ").concat(e.params.osc_amp_sustain||.1,";\nfloat kick").concat(n,"_osc_amp_release = ").concat((e.params.osc_amp_release_ms||200)/1e3,";\nint kick").concat(n,"_osc_amp_stage = 0;\nfloat kick").concat(n,"_osc_amp_time = 0.0;\nfloat kick").concat(n,"_osc_outputL = 0.0;\nfloat kick").concat(n,"_osc_outputR = 0.0;\n\n// Noise layer (FPU-safe implementation)\nint kick").concat(n,"_noise_type = ").concat(e.params.noise_type||0,"; // 0=white, 1=pink, 2=brown\nfloat kick").concat(n,"_noise_gain = ").concat(e.params.noise_gain||.3,";\nfloat kick").concat(n,"_noise_morph = ").concat(e.params.noise_morph||0,";\nfloat kick").concat(n,"_noise_outputL = 0.0;\nfloat kick").concat(n,"_noise_outputR = 0.0;\n// Noise envelope\nfloat kick").concat(n,"_noise_amp_env = 0.0;\nfloat kick").concat(n,"_noise_amp_attack = ").concat((e.params.noise_amp_attack_ms||5)/1e3,";\nfloat kick").concat(n,"_noise_amp_decay = ").concat((e.params.noise_amp_decay_ms||80)/1e3,";\nfloat kick").concat(n,"_noise_amp_sustain = ").concat(e.params.noise_amp_sustain||0,";\nfloat kick").concat(n,"_noise_amp_release = ").concat((e.params.noise_amp_release_ms||50)/1e3,";\nint kick").concat(n,"_noise_amp_stage = 0;\nfloat kick").concat(n,"_noise_amp_time = 0.0;\n// Noise filtering state variables\nfloat kick").concat(n,"_noise_pink_b0 = 0.0, kick").concat(n,"_noise_pink_b1 = 0.0, kick").concat(n,"_noise_pink_b2 = 0.0;\nfloat kick").concat(n,"_noise_pink_b3 = 0.0, kick").concat(n,"_noise_pink_b4 = 0.0, kick").concat(n,"_noise_pink_b5 = 0.0, kick").concat(n,"_noise_pink_b6 = 0.0;\nfloat kick").concat(n,"_noise_brown_last = 0.0;\nuint32_t kick").concat(n,"_noise_lcg_seed = ").concat(12345+13*n,"; // Unique seed per instance\n\n// Master output and control\nfloat kick").concat(n,"_outputL = 0.0;\nfloat kick").concat(n,"_outputR = 0.0;\nbool kick").concat(n,"_triggered = false;\n");case"SnareDrum":return"\n// ".concat(t.label," ").concat(n," - Layered Snare Drum Synthesizer\n// Oscillator layer parameters\nfloat snare").concat(n,"_osc_freq = ").concat(e.params.osc_freq||200,";\nfloat snare").concat(n,"_osc_level = ").concat(e.params.osc_level||.4,";\nfloat snare").concat(n,"_osc_phase = 0.0;\n\n// Noise layer parameters\nfloat snare").concat(n,"_noise_level = ").concat(e.params.noise_level||.6,";\nint snare").concat(n,"_noise_type = ").concat(this.getNoiseTypeIndex(e.params.noise_type)||0,"; // 0=white\nfloat snare").concat(n,"_noise_state = 0.0; // Pink/brown filter state\n\n// Sample layer parameters (optional)\nfloat snare").concat(n,"_sample_level = ").concat(e.params.sample_level||0,";\n\n// Amplitude envelope (main drum envelope)\nfloat snare").concat(n,"_amp_attack = ").concat((e.params.amp_attack_ms||1)/1e3,";\nfloat snare").concat(n,"_amp_decay = ").concat((e.params.amp_decay_ms||120)/1e3,";\nfloat snare").concat(n,"_amp_sustain = ").concat(e.params.amp_sustain||0,";\nfloat snare").concat(n,"_amp_release = ").concat((e.params.amp_release_ms||150)/1e3,";\nfloat snare").concat(n,"_amp_env = 0.0;\nint snare").concat(n,"_amp_stage = 0; // 0=idle, 1=attack, 2=decay, 3=sustain, 4=release\nfloat snare").concat(n,"_amp_time = 0.0;\n\n// Pitch envelope (for pitch sweep effect)\nfloat snare").concat(n,"_pitch_attack = ").concat((e.params.pitch_attack_ms||.5)/1e3,";\nfloat snare").concat(n,"_pitch_decay = ").concat((e.params.pitch_decay_ms||30)/1e3,";\nfloat snare").concat(n,"_pitch_sustain = ").concat(e.params.pitch_sustain||0,";\nfloat snare").concat(n,"_pitch_release = ").concat((e.params.pitch_release_ms||50)/1e3,";\nfloat snare").concat(n,"_pitch_env = 0.0;\nfloat snare").concat(n,"_pitch_env_amount = ").concat(e.params.pitch_env_amount||.5,"; // Pitch bend in octaves\nint snare").concat(n,"_pitch_stage = 0;\nfloat snare").concat(n,"_pitch_time = 0.0;\n\n// Noise envelope (separate envelope for noise component)\nfloat snare").concat(n,"_noise_attack = ").concat((e.params.noise_attack_ms||2)/1e3,";\nfloat snare").concat(n,"_noise_decay = ").concat((e.params.noise_decay_ms||100)/1e3,";\nfloat snare").concat(n,"_noise_sustain = ").concat(e.params.noise_sustain||.1,";\nfloat snare").concat(n,"_noise_release = ").concat((e.params.noise_release_ms||200)/1e3,";\nfloat snare").concat(n,"_noise_env = 0.0;\nint snare").concat(n,"_noise_stage = 0;\nfloat snare").concat(n,"_noise_time = 0.0;\n\n// Output and control\nfloat snare").concat(n,"_outputL = 0.0;\nfloat snare").concat(n,"_outputR = 0.0;\nbool snare").concat(n,"_triggered = false;\n");case"AudioMath":return"\n// ".concat(t.label," ").concat(n," - Multi-Function Audio Processor\nint audioMath").concat(n,"_mode = ").concat(this.getAudioMathModeIndex(e.params.mode||"am"),"; // 0=am, 1=crossfade, 2=ring, 3=vocoder\nfloat audioMath").concat(n,"_amount = ").concat(e.params.amount||.5,"; // Mix/modulation amount\nfloat audioMath").concat(n,"_offset = ").concat(e.params.offset||0,"; // DC offset for modulation\nfloat audioMath").concat(n,"_inputA = 0.0; // First audio input\nfloat audioMath").concat(n,"_inputB = 0.0; // Second audio input\nfloat audioMath").concat(n,"_modInput = 0.0; // Modulation control input\nfloat audioMath").concat(n,"_output = 0.0; // Audio output\n\n// Vocoder-specific variables (simplified implementation)\nfloat audioMath").concat(n,"_vocoder_env = 0.0; // Envelope follower for carrier\nfloat audioMath").concat(n,"_vocoder_attack = 0.01; // Envelope attack time\nfloat audioMath").concat(n,"_vocoder_release = 0.1; // Envelope release time\n");case"Panner":return"\n// ".concat(t.label," ").concat(n," - Stereo Panner with Width Control\nfloat panner").concat(n,"_pan = ").concat(e.params.pan||.5,"; // Pan position (0.0=left, 0.5=center, 1.0=right)\nfloat panner").concat(n,"_width = ").concat(e.params.width||1,"; // Stereo width (0.0=mono, 1.0=full stereo)\nfloat panner").concat(n,"_inputL = 0.0; // Left audio input\nfloat panner").concat(n,"_inputR = 0.0; // Right audio input\nfloat panner").concat(n,"_outputL = 0.0; // Left audio output\nfloat panner").concat(n,"_outputR = 0.0; // Right audio output\n");case"StereoMixer4":return"\n// ".concat(t.label," ").concat(n," - 4-Channel Stereo Mixer\n// Channel 1\nfloat stereoMixer4_").concat(n,"_input1L = 0.0;\nfloat stereoMixer4_").concat(n,"_input1R = 0.0;\nfloat stereoMixer4_").concat(n,"_gain1 = ").concat(e.params.g1||.8,";\n\n// Channel 2\nfloat stereoMixer4_").concat(n,"_input2L = 0.0;\nfloat stereoMixer4_").concat(n,"_input2R = 0.0;\nfloat stereoMixer4_").concat(n,"_gain2 = ").concat(e.params.g2||.8,";\n\n// Channel 3\nfloat stereoMixer4_").concat(n,"_input3L = 0.0;\nfloat stereoMixer4_").concat(n,"_input3R = 0.0;\nfloat stereoMixer4_").concat(n,"_gain3 = ").concat(e.params.g3||.8,";\n\n// Channel 4\nfloat stereoMixer4_").concat(n,"_input4L = 0.0;\nfloat stereoMixer4_").concat(n,"_input4R = 0.0;\nfloat stereoMixer4_").concat(n,"_gain4 = ").concat(e.params.g4||.8,";\n\n// Master output\nfloat stereoMixer4_").concat(n,"_master = ").concat(e.params.master||1,";\nfloat stereoMixer4_").concat(n,"_outputL = 0.0;\nfloat stereoMixer4_").concat(n,"_outputR = 0.0;\n\n// Banking controls (Banks ").concat(e.params.start_bank||2," and ").concat((e.params.start_bank||2)+1,")\n// Bank 1: Volume/Mute\nfloat stereoMixer4_").concat(n,"_smoothed_pot[4] = {").concat(e.params.g1||.35,", ").concat(e.params.g2||.35,", ").concat(e.params.g3||.35,", ").concat(e.params.g4||.35,"};\nfloat stereoMixer4_").concat(n,"_pot_smooth_factor = 0.95; // Pot smoothing (higher = more smoothing)\nbool stereoMixer4_").concat(n,"_mute[4] = {").concat(e.params.mute1?"true":"false",", ").concat(e.params.mute2?"true":"false",", ").concat(e.params.mute3?"true":"false",", ").concat(e.params.mute4?"true":"false","};\nbool stereoMixer4_").concat(n,"_btn_last[4] = {false, false, false, false}; // Button state for debouncing\n\n// Soft takeover for volume (Bank 1)\nfloat stereoMixer4_").concat(n,"_vol_physical[4] = {").concat(e.params.g1||.35,", ").concat(e.params.g2||.35,", ").concat(e.params.g3||.35,", ").concat(e.params.g4||.35,"};\nfloat stereoMixer4_").concat(n,"_vol_target[4] = {").concat(e.params.g1||.35,", ").concat(e.params.g2||.35,", ").concat(e.params.g3||.35,", ").concat(e.params.g4||.35,"};\nfloat stereoMixer4_").concat(n,"_vol_saved[4] = {").concat(e.params.g1||.35,", ").concat(e.params.g2||.35,", ").concat(e.params.g3||.35,", ").concat(e.params.g4||.35,"}; // Per-bank value storage\nbool stereoMixer4_").concat(n,"_vol_taken_over[4] = {false, false, false, false}; // Start as NOT taken over (require soft takeover)\n\n// Bank 2: Pan/Solo\nfloat stereoMixer4_").concat(n,"_pan[4] = {").concat(e.params.pan1||.5,", ").concat(e.params.pan2||.5,", ").concat(e.params.pan3||.5,", ").concat(e.params.pan4||.5,"}; // 0.0=left, 0.5=center, 1.0=right\nfloat stereoMixer4_").concat(n,"_smoothed_pan[4] = {").concat(e.params.pan1||.5,", ").concat(e.params.pan2||.5,", ").concat(e.params.pan3||.5,", ").concat(e.params.pan4||.5,"};\nint stereoMixer4_").concat(n,"_solo_channel = ").concat(e.params.solo_channel||0,"; // 0 = none, 1-4 = channel soloed\n\n// Soft takeover for pan (Bank 2)\nfloat stereoMixer4_").concat(n,"_pan_physical[4] = {").concat(e.params.pan1||.5,", ").concat(e.params.pan2||.5,", ").concat(e.params.pan3||.5,", ").concat(e.params.pan4||.5,"};\nfloat stereoMixer4_").concat(n,"_pan_target[4] = {").concat(e.params.pan1||.5,", ").concat(e.params.pan2||.5,", ").concat(e.params.pan3||.5,", ").concat(e.params.pan4||.5,"};\nfloat stereoMixer4_").concat(n,"_pan_saved[4] = {").concat(e.params.pan1||.5,", ").concat(e.params.pan2||.5,", ").concat(e.params.pan3||.5,", ").concat(e.params.pan4||.5,"}; // Per-bank value storage\nbool stereoMixer4_").concat(n,"_pan_taken_over[4] = {false, false, false, false}; // Start as NOT taken over (require soft takeover)\n\n// Bank tracking\nint stereoMixer4_").concat(n,"_last_bank = -1; // Track which mixer bank was last active (-1 = none, 0 = vol bank, 1 = pan bank)\n\n// Pre-calculated pan coefficients (updated at control rate, used at audio rate)\nfloat stereoMixer4_").concat(n,"_panL[4] = {0.707, 0.707, 0.707, 0.707}; // Left channel gains\nfloat stereoMixer4_").concat(n,"_panR[4] = {0.707, 0.707, 0.707, 0.707}; // Right channel gains\n");case"Matrix2x2":return"\n// ".concat(t.label," ").concat(n," - 2x2 Audio Matrix Mixer with Feedback\n// Input A (stereo)\nfloat matrix").concat(n,"_inputAL = 0.0;\nfloat matrix").concat(n,"_inputAR = 0.0;\n\n// Input B (stereo)\nfloat matrix").concat(n,"_inputBL = 0.0;\nfloat matrix").concat(n,"_inputBR = 0.0;\n\n// Matrix coefficients (control the routing) - range -1.0 to +1.0\nfloat matrix").concat(n,"_aa = ").concat(e.params.aa||1,"; // Input A  Output A gain\nfloat matrix").concat(n,"_ab = ").concat(e.params.ab||0,"; // Input A  Output B gain\nfloat matrix").concat(n,"_ba = ").concat(e.params.ba||0,"; // Input B  Output A gain\nfloat matrix").concat(n,"_bb = ").concat(e.params.bb||1,"; // Input B  Output B gain\n\n// Output A (stereo)\nfloat matrix").concat(n,"_outputAL = 0.0;\nfloat matrix").concat(n,"_outputAR = 0.0;\n\n// Output B (stereo)\nfloat matrix").concat(n,"_outputBL = 0.0;\nfloat matrix").concat(n,"_outputBR = 0.0;\n\n// Hardware banking (single bank with 4 pots)\nfloat matrix").concat(n,"_smoothed_pot[4] = {0.5, 0.5, 0.5, 0.5}; // Smoothed pot values (0.0-1.0)\nfloat matrix").concat(n,"_pot_smooth_factor = 0.95; // Pot smoothing (higher = more smoothing)\n\n// Soft takeover for hardware pots\nfloat matrix").concat(n,"_physical[4] = {0.5, 0.5, 0.5, 0.5}; // Physical pot positions\nfloat matrix").concat(n,"_target[4] = {0.5, 0.5, 0.5, 0.5}; // Target values (saved when switching banks)\nfloat matrix").concat(n,"_saved[4] = {0.5, 0.5, 0.5, 0.5}; // Per-bank value storage\nbool matrix").concat(n,"_taken_over[4] = {false, false, false, false}; // Soft takeover state\n\n// Bank tracking\nint matrix").concat(n,"_last_bank = -1; // Track which bank was last active (-1 = none, 0 = this module's bank)\n");case"Delay":var i=Math.round(44.1*(e.params.time_ms||380)*1.5);return"\n// ".concat(t.label," ").concat(n,"\n#define DELAY").concat(n,"_BUFFER_SIZE ").concat(i,"\nfloat* delay").concat(n,"_bufferL; // PSRAM allocation\nfloat* delay").concat(n,"_bufferR; // PSRAM allocation\nint delay").concat(n,"_writePos = 0;\nfloat delay").concat(n,"_readPosFloat = 0.0; // For pitch shifting\nfloat delay").concat(n,"_time_ms = ").concat(e.params.time_ms||380,";\nfloat delay").concat(n,"_feedback = ").concat(e.params.feedback||.35,";\nfloat delay").concat(n,"_mix = ").concat(e.params.mix||.3,";\nfloat delay").concat(n,"_pingpong = ").concat(e.params.pingpong||0,";\nfloat delay").concat(n,"_freeze = ").concat(e.params.freeze||0,";\nfloat delay").concat(n,"_pitch_shift = ").concat(e.params.pitch_shift||1,";\nfloat delay").concat(n,"_division = ").concat(e.params.division||1,";\nfloat delay").concat(n,"_tempo_hz = 0.0; // Set by tempo sync connection\nfloat delay").concat(n,"_outputL = 0.0;\nfloat delay").concat(n,"_outputR = 0.0;\nfloat delay").concat(n,"_inputL = 0.0;\nfloat delay").concat(n,"_inputR = 0.0;\n\n// Feedback damping filters for stability and warmth\nfloat delay").concat(n,"_feedback_lpf_L = 0.0f;\nfloat delay").concat(n,"_feedback_lpf_R = 0.0f;\n");case"I2SOut":return"\n// ".concat(t.label," ").concat(n," - I2S Audio Output\nfloat i2sout").concat(n,"_inputL = 0.0;\nfloat i2sout").concat(n,"_inputR = 0.0;\nfloat i2sout").concat(n,"_volume = ").concat(e.params.volume||.8,";\nint i2sout").concat(n,"_debug_counter = 0;\n");case"LineIn":return"\n// ".concat(t.label," ").concat(n," - PCM1802 ADC Stereo Line Input\nfloat linein").concat(n,"_outputL = 0.0;\nfloat linein").concat(n,"_outputR = 0.0;\nfloat linein").concat(n,"_gain = ").concat(e.params.gain||2,";\n").concat(e.params.dc_block?"\n// DC blocking filter state (HPF ~3.5Hz at 44.1kHz)\nfloat linein".concat(n,"_dc_x_prev_L = 0.0f;\nfloat linein").concat(n,"_dc_y_prev_L = 0.0f;\nfloat linein").concat(n,"_dc_x_prev_R = 0.0f;\nfloat linein").concat(n,"_dc_y_prev_R = 0.0f;\nconst float linein").concat(n,"_dc_coeff = 0.995f;"):"","\n");case"AudioRecorder":var l=e.params.bank||1,s=e.params.max_duration_sec||60;return Math.floor(44100*s),"\n// AudioRecorder ".concat(n," - Standalone Recorder/Player with Banking\n// USES BANK ").concat(l," - Buttons: Record/Play-Pause, Pots: Input Gain/Volume\n\n// Banking\nconst int rec").concat(n,"_bank = ").concat(l,";\n\n// Recording state - Async SD write with ring buffer\nFile rec").concat(n,"_recFile;\nbool rec").concat(n,"_recording = false;\nbool rec").concat(n,"_finalizePending = false;  // True when waiting for SD writer to finish\nint rec").concat(n,"_currentFileIndex = 1;      // Next file to record to\nint rec").concat(n,"_lastRecordedFileIndex = 0; // Last file that was recorded (0 = none yet)\nuint32_t rec").concat(n,"_samplesRecorded = 0;\n\n// Ring buffer for async SD writing (glitch-free recording)\n#define REC").concat(n,"_BLOCK_SIZE 4092      // 4092 bytes = 682 samples exactly (MUST match PLAY_BLOCK_SIZE for alignment!)\n#define REC").concat(n,"_BLOCK_COUNT 128      // 128 blocks = ~512KB ring buffer (~2 seconds @ 44.1kHz stereo 24-bit)\nuint8_t* rec").concat(n,"_ringBuffer = nullptr;  // Allocated in PSRAM\nvolatile size_t rec").concat(n,"_writeIdx = 0;   // Audio thread writes here\nvolatile size_t rec").concat(n,"_readIdx = 0;    // SD task reads here\nvolatile size_t rec").concat(n,"_buffered = 0;   // Number of filled blocks\nSemaphoreHandle_t rec").concat(n,"_bufferMutex = nullptr;\nTaskHandle_t rec").concat(n,"_sdWriterTask = nullptr;\n\n// Current block being filled (audio thread local)\nuint8_t rec").concat(n,"_currentBlock[REC").concat(n,"_BLOCK_SIZE];\nsize_t rec").concat(n,"_currentBlockPos = 0;\n\n// Playback state - Async SD read with ring buffer (streaming playback)\nFile rec").concat(n,"_playFile;\nbool rec").concat(n,"_playing = false;\nbool rec").concat(n,"_paused = false;\nuint32_t rec").concat(n,"_totalSamples = 0;        // Total samples in file\nuint32_t rec").concat(n,"_samplesPlayed = 0;       // Samples played so far (can increment or decrement based on speed/direction)\nuint8_t rec").concat(n,"_channels = 2;             // 1=mono, 2=stereo\nbool rec").concat(n,"_playReverse = false;         // True when playing backwards (reverse mode or ping-pong reverse phase)\nfloat rec").concat(n,"_sampleAccumulator = 0.0f;   // Fractional sample counter for variable speed playback\n\n// Ring buffer for async SD reading (glitch-free streaming playback)\n#define PLAY").concat(n,"_BLOCK_SIZE 4092          // 4092 bytes = 682 samples exactly (4092  6 = 682, perfect alignment!)\n#define PLAY").concat(n,"_BLOCK_COUNT 64           // 64 blocks = ~256KB ring buffer (~1.4s @ 44.1kHz)\nuint8_t* play").concat(n,"_ringBuffer = nullptr;   // Allocated in PSRAM\nvolatile size_t play").concat(n,"_writeIdx = 0;    // SD reader task writes here\nvolatile size_t play").concat(n,"_readIdx = 0;     // Audio thread reads here\nvolatile size_t play").concat(n,"_buffered = 0;    // Number of filled blocks\nvolatile bool play").concat(n,"_eofReached = false; // SD reader hit end of file\nSemaphoreHandle_t play").concat(n,"_bufferMutex = nullptr;\nTaskHandle_t play").concat(n,"_sdReaderTask = nullptr;\n\n// Current block being read (audio thread local)\nuint8_t play").concat(n,"_currentBlock[PLAY").concat(n,"_BLOCK_SIZE];\nsize_t play").concat(n,"_currentBlockPos = 0;\nsize_t play").concat(n,"_currentBlockSize = 0;  // Actual size of current block (may be < BLOCK_SIZE at EOF)\n\n// Button state (banking system)\nbool rec").concat(n,"_btn1_state = false;  // Record button\nbool rec").concat(n,"_btn2_state = false;  // Play/Pause button\nbool rec").concat(n,"_btn3_state = false;  // Previous track / Rewind button\nbool rec").concat(n,"_btn4_state = false;  // Next track / Fast forward button\nbool rec").concat(n,"_btn1_last = false;\nbool rec").concat(n,"_btn2_last = false;\nbool rec").concat(n,"_btn3_last = false;\nbool rec").concat(n,"_btn4_last = false;\n\n// Long press detection (500ms threshold)\nunsigned long rec").concat(n,"_btn3_pressStart = 0;\nunsigned long rec").concat(n,"_btn4_pressStart = 0;\nconst unsigned long rec").concat(n,"_longPressThreshold = 500;  // 500ms for long press\nbool rec").concat(n,"_btn3_longHandled = false;\nbool rec").concat(n,"_btn4_longHandled = false;\n\n// Pot values\nfloat rec").concat(n,"_inputGain = 1.0f;  // Start at unity gain until pot is read\nfloat rec").concat(n,"_playbackVol = 1.0f;\nint rec").concat(n,"_playMode = 0;        // 0=normal, 1=loop, 2=reverse, 3=ping-pong\nfloat rec").concat(n,"_playSpeed = 1.0f;  // Playback speed (0.25x to 2.0x)\n\n// Cached file existence (avoid SD.exists() in audio thread)\nbool rec").concat(n,"_fileAvailable = false;\n\n// Hardware read throttling (prevent MCP23017 I2C blocking audio)\nint rec").concat(n,"_hwReadCounter = 0;\nconst int rec").concat(n,"_hwReadInterval = 4;  // Read hardware every 4 buffers = 1024 samples (~23ms @ 44.1kHz)\n\n// Button debounce (prevent double-triggering from bounce/timing races)\nbool rec").concat(n,"_armedForEdge = true;  // Must release button before next toggle allowed\nunsigned long rec").concat(n,"_lastToggleMs = 0;\nconst unsigned long rec").concat(n,"_toggleDebounceMs = 100;  // 100ms minimum between toggles\n\n// LED state (for feedback)\nfloat rec").concat(n,"_led1 = 0.0;  // Record LED\nfloat rec").concat(n,"_led2 = 0.0;  // Play LED\n\n// Output\nfloat rec").concat(n,"_outputL = 0.0;\nfloat rec").concat(n,"_outputR = 0.0;\n");case"ChorusFlangeRing":return"\n// ".concat(t.label," ").concat(n," - Modulation Effects (Chorus/Flange/Ring)\nint cfr").concat(n,"_mode = ").concat(e.params.mode||0,"; // 0=chorus, 1=flange, 2=ring\nfloat cfr").concat(n,"_depth = ").concat(e.params.depth||.5,";\nfloat cfr").concat(n,"_rate = ").concat(e.params.rate||1,";\nfloat cfr").concat(n,"_feedback = ").concat(e.params.feedback||.3,";\nfloat cfr").concat(n,"_mix = ").concat(e.params.mix||.5,";\nfloat cfr").concat(n,"_phase = 0.0;\nfloat cfr").concat(n,"_outputL = 0.0;\nfloat cfr").concat(n,"_outputR = 0.0;\n// Simple delay buffer for chorus/flange\n#define CFR").concat(n,"_BUFFER_SIZE 2048\nfloat cfr").concat(n,"_buffer[CFR").concat(n,"_BUFFER_SIZE];\nint cfr").concat(n,"_writePos = 0;\n");case"Limiter":return"\n// ".concat(t.label," ").concat(n," - Audio Limiter\nfloat limiter").concat(n,"_threshold = ").concat(e.params.threshold||.8,";\nfloat limiter").concat(n,"_ratio = ").concat(e.params.ratio||10,";\nfloat limiter").concat(n,"_attack = ").concat(e.params.attack_ms||1," / 1000.0;\nfloat limiter").concat(n,"_release = ").concat(e.params.release_ms||100," / 1000.0;\nfloat limiter").concat(n,"_makeup = ").concat(e.params.makeup||1,";\nfloat limiter").concat(n,"_envelope = 0.0;\nfloat limiter").concat(n,"_outputL = 0.0;\nfloat limiter").concat(n,"_outputR = 0.0;\n");case"NoiseGate":return"\n// ".concat(t.label," ").concat(n," - Noise Gate\nfloat noiseGate").concat(n,"_threshold = ").concat(e.params.threshold||.1,";\nfloat noiseGate").concat(n,"_attack = ").concat(e.params.attack_ms||1," / 1000.0;\nfloat noiseGate").concat(n,"_release = ").concat(e.params.release_ms||50," / 1000.0;\nfloat noiseGate").concat(n,"_ratio = ").concat(e.params.ratio||100,";\nfloat noiseGate").concat(n,"_envelope = 0.0;\nbool noiseGate").concat(n,"_gateOpen = false;\nfloat noiseGate").concat(n,"_outputL = 0.0;\nfloat noiseGate").concat(n,"_outputR = 0.0;\n");case"EQ8":return"\n// ".concat(t.label," ").concat(n," - 8-Band Graphic EQ\nfloat eq").concat(n,"_b1 = ").concat(e.params.b1||0,"; // 60Hz\nfloat eq").concat(n,"_b2 = ").concat(e.params.b2||0,"; // 170Hz\nfloat eq").concat(n,"_b3 = ").concat(e.params.b3||0,"; // 350Hz\nfloat eq").concat(n,"_b4 = ").concat(e.params.b4||0,"; // 1kHz\nfloat eq").concat(n,"_b5 = ").concat(e.params.b5||0,"; // 3kHz\nfloat eq").concat(n,"_b6 = ").concat(e.params.b6||0,"; // 6kHz\nfloat eq").concat(n,"_b7 = ").concat(e.params.b7||0,"; // 12kHz\nfloat eq").concat(n,"_b8 = ").concat(e.params.b8||0,"; // 14kHz\nfloat eq").concat(n,"_outputL = 0.0;\nfloat eq").concat(n,"_outputR = 0.0;\n// Filter state variables for each band\nfloat eq").concat(n,"_state[8][4] = {{0}}; // [band][state] for biquad filters\n");case"Resonance":return"\n// ".concat(t.label," ").concat(n," - Resonant Object Exploration System\n// Mode: 0=discovery, 1=performance, 2=exploration\nint resonance").concat(n,"_mode = ").concat("discovery"===e.params.mode?0:"performance"===e.params.mode?1:2,";\nint resonance").concat(n,"_fftSize = ").concat(e.params.fftSize||8192,";\nfloat resonance").concat(n,"_impulseLength = ").concat(e.params.impulseLength||1e3,"; // ms\nfloat resonance").concat(n,"_sweepDuration = ").concat(e.params.sweepDuration||1e4,"; // ms\nfloat resonance").concat(n,"_sweepStart = ").concat(e.params.sweepStart||20,"; // Hz\nfloat resonance").concat(n,"_sweepEnd = ").concat(e.params.sweepEnd||1e4,"; // Hz\nfloat resonance").concat(n,"_threshold = ").concat(e.params.threshold||-60,"; // dB\nint resonance").concat(n,"_maxPeaks = ").concat(e.params.maxPeaks||16,";\nint resonance").concat(n,"_objectSlot = ").concat(e.params.objectSlot||0,"; // 0-39\nbool resonance").concat(n,"_autoTune = ").concat(e.params.autoTune?"true":"false",";\nbool resonance").concat(n,"_hapticEnable = ").concat(e.params.hapticEnable?"true":"false",";\nfloat resonance").concat(n,"_gyroSensitivity = ").concat(e.params.gyroSensitivity||1,";\nfloat resonance").concat(n,"_hapticIntensity = ").concat(e.params.hapticIntensity||.5,";\n\n// Control inputs\nfloat resonance").concat(n,"_trigger = 0.0;\nfloat resonance").concat(n,"_mode_select = 0.0;\nfloat resonance").concat(n,"_object_select = 0.0;\nfloat resonance").concat(n,"_sensitivity = ").concat(e.params.gyroSensitivity||1,";\nfloat resonance").concat(n,"_intensity = ").concat(e.params.hapticIntensity||.5,";\n\n// Audio I/O\nfloat resonance").concat(n,"_contactMicInput = 0.0;\nfloat resonance").concat(n,"_exciterOutput = 0.0;\n\n// Control outputs (detected resonant frequencies)\nfloat resonance").concat(n,"_freq1 = 0.0;\nfloat resonance").concat(n,"_freq2 = 0.0;\nfloat resonance").concat(n,"_freq3 = 0.0;\nfloat resonance").concat(n,"_freq4 = 0.0;\nfloat resonance").concat(n,"_freq5 = 0.0;\nfloat resonance").concat(n,"_freq6 = 0.0;\nfloat resonance").concat(n,"_freq7 = 0.0;\nfloat resonance").concat(n,"_freq8 = 0.0;\nfloat resonance").concat(n,"_analysis_complete = 0.0;\nfloat resonance").concat(n,"_resonance_strength = 0.0;\n\n// FFT buffers (allocated in PSRAM)\nfloat* resonance").concat(n,"_fft_input = nullptr;\nfloat* resonance").concat(n,"_fft_output = nullptr;\nfloat* resonance").concat(n,"_window = nullptr;\n\n// State variables\nbool resonance").concat(n,"_analyzing = false;\nunsigned long resonance").concat(n,"_sweepStartTime = 0;\nfloat resonance").concat(n,"_currentSweepFreq = ").concat(e.params.sweepStart||20,";\nfloat resonance").concat(n,"_sweepPhase = 0.0;\n\n// FreeRTOS task handle for FFT analysis on Core 0\nTaskHandle_t resonance").concat(n,"_fftTask = nullptr;\nSemaphoreHandle_t resonance").concat(n,"_fftMutex = nullptr;\n\n// Detected resonant peaks storage\nstruct ResonantPeak {\n    float frequency;\n    float magnitude;\n    float q_factor;\n};\nResonantPeak resonance").concat(n,"_peaks[16] = {{0}};\nint resonance").concat(n,"_peakCount = 0;\n\n// Object library (40 slots in SPIFFS/SD)\nString resonance").concat(n,'_objectLibraryPath = "/resonance/objects/";\n');case"Percussion":return"\n// ".concat(t.label," ").concat(n," - Chromatic Percussion with Triple ADSR\nfloat perc").concat(n,"_freq = ").concat(e.params.freq||440,";\nfloat perc").concat(n,"_gain = ").concat(e.params.gain||.8,";\nfloat perc").concat(n,"_decay = ").concat(e.params.decay||.5,";\nfloat perc").concat(n,"_brightness = ").concat(e.params.brightness||.3,";\nfloat perc").concat(n,"_metallic = ").concat(e.params.metallic||0,";\n// Triple ADSR envelopes\nfloat perc").concat(n,"_env1 = 0.0, perc").concat(n,"_env2 = 0.0, perc").concat(n,"_env3 = 0.0;\nint perc").concat(n,"_stage1 = 0, perc").concat(n,"_stage2 = 0, perc").concat(n,"_stage3 = 0;\nfloat perc").concat(n,"_time1 = 0.0, perc").concat(n,"_time2 = 0.0, perc").concat(n,"_time3 = 0.0;\nbool perc").concat(n,"_triggered = false;\nfloat perc").concat(n,"_outputL = 0.0;\nfloat perc").concat(n,"_outputR = 0.0;\n");case"Wavetable":return this.generateWavetableVariables(e,n,t);case"GranularDense":return"\n// ".concat(t.label," ").concat(n," - Dense Granular Synthesis with 20 Grains\nint granular").concat(n,"_buffer_size; // Set dynamically based on available memory\nfloat* granular").concat(n,"_buffer_L; // PSRAM allocation\nfloat* granular").concat(n,"_buffer_R; // PSRAM allocation\nint granular").concat(n,"_write_pos = 0;\nfloat granular").concat(n,"_grain_density = ").concat(e.params.grain_density||15,";\nfloat granular").concat(n,"_position = ").concat(e.params.position||.5,";\nfloat granular").concat(n,"_position_spread = ").concat(e.params.position_spread||.3,";\nfloat granular").concat(n,"_pitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(n,"_pitch_spread = ").concat(e.params.pitch_spread||.1,";\nfloat granular").concat(n,"_dry_wet = ").concat(e.params.dry_wet||1,";\nfloat granular").concat(n,"_freeze = ").concat(e.params.freeze||0,";\nfloat granular").concat(n,"_stereo_width = ").concat(e.params.stereo_width||.5,";\nfloat granular").concat(n,"_cloud_pan = ").concat(e.params.cloud_pan||.5,";\nfloat granular").concat(n,"_grouped_panning = ").concat(e.params.grouped_panning||0,";\n\n// Dense grain structure - 20 concurrent 32ms grains with stereo panning\nstruct DenseGrain").concat(n," {\n    bool active;\n    float position;\n    float pitch_ratio;\n    float envelope_pos;\n    float envelope_inc;\n    int samples_remaining;\n    float pan;  // Stereo pan position (0=left, 1=right)\n};\n\n// Pre-calculated Hann window envelope (256 entries) for fast grain shaping\n// Replaces expensive cos() calculation with table lookup (~15% CPU reduction)\nconst float granular").concat(n,"_envelopeTable[256] = {\n    0.0000, 0.0015, 0.0061, 0.0138, 0.0245, 0.0381, 0.0548, 0.0743,\n    0.0968, 0.1221, 0.1502, 0.1810, 0.2145, 0.2506, 0.2891, 0.3301,\n    0.3735, 0.4191, 0.4669, 0.5168, 0.5688, 0.6226, 0.6782, 0.7355,\n    0.7944, 0.8549, 0.9168, 0.9799, 1.0000, 0.9799, 0.9168, 0.8549,\n    0.7944, 0.7355, 0.6782, 0.6226, 0.5688, 0.5168, 0.4669, 0.4191,\n    0.3735, 0.3301, 0.2891, 0.2506, 0.2145, 0.1810, 0.1502, 0.1221,\n    0.0968, 0.0743, 0.0548, 0.0381, 0.0245, 0.0138, 0.0061, 0.0015,\n    0.0000, 0.0015, 0.0061, 0.0138, 0.0245, 0.0381, 0.0548, 0.0743,\n    0.0968, 0.1221, 0.1502, 0.1810, 0.2145, 0.2506, 0.2891, 0.3301,\n    0.3735, 0.4191, 0.4669, 0.5168, 0.5688, 0.6226, 0.6782, 0.7355,\n    0.7944, 0.8549, 0.9168, 0.9799, 1.0000, 0.9799, 0.9168, 0.8549,\n    0.7944, 0.7355, 0.6782, 0.6226, 0.5688, 0.5168, 0.4669, 0.4191,\n    0.3735, 0.3301, 0.2891, 0.2506, 0.2145, 0.1810, 0.1502, 0.1221,\n    0.0968, 0.0743, 0.0548, 0.0381, 0.0245, 0.0138, 0.0061, 0.0015,\n    0.0000, 0.0015, 0.0061, 0.0138, 0.0245, 0.0381, 0.0548, 0.0743,\n    0.0968, 0.1221, 0.1502, 0.1810, 0.2145, 0.2506, 0.2891, 0.3301,\n    0.3735, 0.4191, 0.4669, 0.5168, 0.5688, 0.6226, 0.6782, 0.7355,\n    0.7944, 0.8549, 0.9168, 0.9799, 1.0000, 0.9799, 0.9168, 0.8549,\n    0.7944, 0.7355, 0.6782, 0.6226, 0.5688, 0.5168, 0.4669, 0.4191,\n    0.3735, 0.3301, 0.2891, 0.2506, 0.2145, 0.1810, 0.1502, 0.1221,\n    0.0968, 0.0743, 0.0548, 0.0381, 0.0245, 0.0138, 0.0061, 0.0015,\n    0.0000, 0.0015, 0.0061, 0.0138, 0.0245, 0.0381, 0.0548, 0.0743,\n    0.0968, 0.1221, 0.1502, 0.1810, 0.2145, 0.2506, 0.2891, 0.3301,\n    0.3735, 0.4191, 0.4669, 0.5168, 0.5688, 0.6226, 0.6782, 0.7355,\n    0.7944, 0.8549, 0.9168, 0.9799, 1.0000, 0.9799, 0.9168, 0.8549,\n    0.7944, 0.7355, 0.6782, 0.6226, 0.5688, 0.5168, 0.4669, 0.4191,\n    0.3735, 0.3301, 0.2891, 0.2506, 0.2145, 0.1810, 0.1502, 0.1221,\n    0.0968, 0.0743, 0.0548, 0.0381, 0.0245, 0.0138, 0.0061, 0.0015,\n    0.0000, 0.0015, 0.0061, 0.0138, 0.0245, 0.0381, 0.0548, 0.0743,\n    0.0968, 0.1221, 0.1502, 0.1810, 0.2145, 0.2506, 0.2891, 0.3301,\n    0.3735, 0.4191, 0.4669, 0.5168, 0.5688, 0.6226, 0.6782, 0.7355,\n    0.7944, 0.8549, 0.9168, 0.9799, 1.0000, 0.9799, 0.9168, 0.8549\n};\n\nDenseGrain").concat(n," granular").concat(n,"_grains[20]; // 20 concurrent grains\nfloat granular").concat(n,"_outputL = 0.0;\nfloat granular").concat(n,"_outputR = 0.0;\nint granular").concat(n,"_samples_since_grain = 0;\nbool granular").concat(n,"_process_even = true; // Round-robin: alternate processing even/odd grains\n\n// Runtime variables for control and audio processing\nfloat granular").concat(n,"_inputL = 0.0;\nfloat granular").concat(n,"_inputR = 0.0;\nfloat granular").concat(n,"_currentDensity = ").concat(e.params.grain_density||15,";\nfloat granular").concat(n,"_currentPosition = ").concat(e.params.position||.5,";\nfloat granular").concat(n,"_currentPitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(n,"_currentDryWet = ").concat(e.params.dry_wet||1,";\nfloat granular").concat(n,"_currentFreeze = ").concat(e.params.freeze||0,";\nfloat granular").concat(n,"_currentStereoWidth = ").concat(e.params.stereo_width||.5,";\nfloat granular").concat(n,"_currentCloudPan = ").concat(e.params.cloud_pan||.5,";\nfloat granular").concat(n,"_currentPitchCV1 = 0.0;\nfloat granular").concat(n,"_currentPitchCV2 = 0.0;\nfloat granular").concat(n,"_currentPitchCV3 = 0.0;\nfloat granular").concat(n,"_currentPitchCV4 = 0.0;\n");case"SamplePlayer":return null;case"SamplePlayer_OLD_DISABLED":return e.params.polyphonic?"\n// ".concat(t.label," ").concat(n," - Polyphonic Sample Player with PSRAM (6 voices)\n#define SP").concat(n,"_VOICES 6\n#define SP").concat(n,"_BUFFER_SIZE 1572864  // 1.5MB PSRAM buffer per voice\n\nstruct SampleVoice").concat(n," {\n    int16_t* psramData;              // PSRAM sample data\n    uint32_t sampleLength;           // Length in samples\n    uint32_t playPosition;           // Current play position\n    float pitch;                     // Playback speed multiplier\n    float gain;                      // Voice gain\n    bool active;                     // Voice active state\n    int midiNote;                    // MIDI note for this voice\n    unsigned long noteOnTime;        // Note on timestamp\n    bool gateOpen;                   // Gate state\n    float fractionalPos;             // Fractional position for pitch control\n};\n\nSampleVoice").concat(n," sp").concat(n,"_voices[SP").concat(n,"_VOICES];\nint sp").concat(n,"_nextVoice = 0;        // Round-robin voice allocation\nint sp").concat(n,"_currentSample = ").concat(e.params.fileMin||1,";  // Current sample number\nfloat sp").concat(n,"_masterGain = ").concat(e.params.gain||.8,";\nfloat sp").concat(n,"_outputL = 0.0;\nfloat sp").concat(n,"_outputR = 0.0;\n\n// Sample metadata\nString sp").concat(n,'_currentFile = "";\nbool sp').concat(n,"_samplesLoaded = false;\nint sp").concat(n,"_sampleCount = 0;\n\n// Polyphonic control\nint sp").concat(n,"_baseNote = ").concat(e.params.base_note||60,"; // Middle C\nfloat sp").concat(n,"_adsrPitchRange = ").concat(e.params.adsr_pitch_range||2,";\nfloat sp").concat(n,"_adsrPitchCenter = ").concat(e.params.adsr_pitch_center||0,";\n"):"\n// ".concat(t.label," ").concat(n," - Single-Voice Sample Player (legacy mode)\nMinimalWAVPlayer sp").concat(n,"_player;\nfloat sp").concat(n,"_gain = ").concat(e.params.gain||.8,";\nfloat sp").concat(n,"_pitch = ").concat(e.params.pitch||1,";\nbool sp").concat(n,"_loop = ").concat(e.params.loop||!1,";\nbool sp").concat(n,"_playing = false;\nint sp").concat(n,"_currentFile = ").concat(e.params.fileMin||1,";\nint sp").concat(n,"_sampleCount = 0;\nString sp").concat(n,'_currentFileName = "";\nfloat sp').concat(n,"_triggerThreshold = 0.5;\nbool sp").concat(n,"_lastTrigger = false;\nfloat sp").concat(n,"_outputL = 0.0;\nfloat sp").concat(n,"_outputR = 0.0;\nint sp").concat(n,"_lastLoadedFile = -1;\n\n// File transfer variables\nbool fileTransferActive").concat(n," = false;\nString transferFilename").concat(n,' = "";\nFile transferFile').concat(n,";\nuint32_t expectedFileSize").concat(n," = 0;\nuint32_t receivedBytes").concat(n," = 0;\n\n// Ring buffer for file transfers\nuint8_t* ringBuffer").concat(n," = NULL;\nvolatile int ringWritePos").concat(n," = 0;\nvolatile int ringReadPos").concat(n," = 0;\nvolatile int ringBufferCount").concat(n," = 0;\nconst int ringBufferSize").concat(n," = 65536;\nportMUX_TYPE ringBufferMux").concat(n," = portMUX_INITIALIZER_UNLOCKED;\n");default:return""}}},{key:"generateOscillatorProcessingCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"freq"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"morph"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"fm"===n.to.port}),i=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"wave"===n.to.port}),l=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch_cv"===n.to.port}),s="osc".concat(n,"_gate"),u="osc".concat(n,"_freq"),d="osc".concat(n,"_morph"),p="0.0",f="osc".concat(n,"_waveform"),m="0.5";if(a){var _=a.from.id.split(":")[0],g=this.connectionResolver.modules.find(function(e){return e.id===_});if(g){var h,v=(null===(h=_.match(/\d+$/))||void 0===h?void 0:h[0])||"1";s="ADSR"===g.type?"(adsr".concat(v,"_output > 0.1)"):"osc".concat(n,"_gate")}}if(o){var b=o.from.id.split(":")[0],y=this.connectionResolver.modules.find(function(e){return e.id===b});if(y){var k,x="Pot"===y.type?y.params.index:(null===(k=b.match(/\d+$/))||void 0===k?void 0:k[0])||"1";switch(y.type){case"Scale":u="scale".concat(x,"_output");break;case"Pot":var S=y.params.index||1;u="(pot".concat(S,"_value * 19980.0 + 20.0)");break;case"LFO":u="lfo".concat(x,"_output");break;case"ADSR":u="(adsr".concat(x,"_output * 1000.0 + ").concat(e.params.freq||440,")")}}}if(c){var E=c.from.id.split(":")[0],P=this.connectionResolver.modules.find(function(e){return e.id===E});if(P){var w,C=(null===(w=E.match(/\d+$/))||void 0===w?void 0:w[0])||"1";switch(P.type){case"LFO":d="lfo".concat(C,"_output");break;case"Pot":var I=P.params.index||1;d="pot".concat(I,"_value");break;case"ADSR":d="adsr".concat(C,"_output")}}}if(r){var R=r.from.id.split(":")[0],L=this.connectionResolver.modules.find(function(e){return e.id===R});if(L){var M,D=(null===(M=R.match(/\d+$/))||void 0===M?void 0:M[0])||"1";switch(L.type){case"Oscillator":p="osc".concat(D,"_outputL");break;case"LFO":p="lfo".concat(D,"_output");break;case"ADSR":p="adsr".concat(D,"_output");break;case"Pot":var A=L.params.index||1;p="pot".concat(A,"_value")}}}if(i){var O=i.from.id.split(":")[0],B=this.connectionResolver.modules.find(function(e){return e.id===O});if(B){var T,F=(null===(T=O.match(/\d+$/))||void 0===T?void 0:T[0])||"1";switch(B.type){case"Pot":var N=B.params.index||1;f="(int)(pot".concat(N,"_value * 3.99)");break;case"LFO":f="(int)(abs(lfo".concat(F,"_output) * 3.99)")}}}if(l){var z=l.from.id.split(":")[0],G=this.connectionResolver.modules.find(function(e){return e.id===z});if(G){var q,U=(null===(q=z.match(/\d+$/))||void 0===q?void 0:q[0])||"1";switch(G.type){case"ADSR":m="adsr".concat(U,"_output");break;case"LFO":m="lfo".concat(U,"_output");break;case"Pot":var W=G.params.index||1;m="pot".concat(W,"_value")}}}return"\n        // Oscillator ".concat(n," processing\n        // DEBUG: Gate source = ").concat(s,", connection from ").concat(a?a.from.id:"none","\n        if (").concat(s," > 0.1) {\n            float freq = ").concat(u,";\n            float morph = constrain(").concat(d,", 0.0, 1.0);\n            float fm_input = ").concat(p,";\n\n            // Exponential pitch CV modulation (semitones, like KickDrum pitch envelope)\n            // pitch_amount: +24 = upward sweep, -24 = downward kick pitch drop\n            float pitch_cv = ").concat(m,";\n\n            // Smooth pitch CV to prevent artifacts from rapid ADSR changes\n            // One-pole lowpass: coefficient 0.3 = gentle smoothing without losing responsiveness\n            osc").concat(n,"_pitch_smooth = osc").concat(n,"_pitch_smooth * 0.7 + pitch_cv * 0.3;\n\n            float pitch_offset_semitones = (osc").concat(n,"_pitch_smooth - 0.5) * osc").concat(n,"_pitch_amount;\n            float pitch_multiplier = pow(2.0, pitch_offset_semitones / 12.0);\n            freq = freq * pitch_multiplier;\n\n            // FM synthesis: modulate frequency with FM input and amount\n            float fm_freq_offset = fm_input * osc").concat(n,"_fm_amount * freq; // FM amount as ratio of base frequency\n            float effective_freq = freq + fm_freq_offset;\n\n            // Constrain to reasonable frequency range\n            effective_freq = constrain(effective_freq, 1.0, 20000.0);\n\n            osc").concat(n,"_phase += (2.0 * M_PI * effective_freq) / 44100.0;\n            if (osc").concat(n,"_phase >= 2.0 * M_PI) {\n                osc").concat(n,"_phase -= 2.0 * M_PI;\n            }\n\n            float sample = 0.0;\n\n            // Dynamic wave selection with morphing - only compute needed waveforms (CPU optimization)\n            int current_wave = ").concat(f,";\n            current_wave = constrain(current_wave, 0, 3); // Ensure valid range\n\n            if (current_wave == 0) {\n                // Sine base - morph towards triangle\n                float sine_wave = sin(osc").concat(n,"_phase);\n                if (morph > 0.001) {\n                    float triangle_wave = (2.0 / M_PI) * asin(sine_wave); // Reuse sine_wave to avoid double sin()\n                    sample = sine_wave * (1.0 - morph) + triangle_wave * morph;\n                } else {\n                    sample = sine_wave; // Pure sine - skip expensive asin()\n                }\n            } else if (current_wave == 1) {\n                // Triangle base - morph towards saw\n                float triangle_wave = (2.0 / M_PI) * asin(sin(osc").concat(n,"_phase));\n                if (morph > 0.001) {\n                    float saw_wave = (2.0 / M_PI) * (osc").concat(n,"_phase - M_PI);\n                    sample = triangle_wave * (1.0 - morph) + saw_wave * morph;\n                } else {\n                    sample = triangle_wave; // Pure triangle\n                }\n            } else if (current_wave == 2) {\n                // Saw base - morph towards square\n                float saw_wave = (2.0 / M_PI) * (osc").concat(n,"_phase - M_PI);\n                if (morph > 0.001) {\n                    float square_wave = (osc").concat(n,"_phase < M_PI) ? 1.0 : -1.0;\n                    sample = saw_wave * (1.0 - morph) + square_wave * morph;\n                } else {\n                    sample = saw_wave; // Pure saw\n                }\n            } else if (current_wave == 3) {\n                // Square base - morph towards sine (wrap around)\n                float square_wave = (osc").concat(n,"_phase < M_PI) ? 1.0 : -1.0;\n                if (morph > 0.001) {\n                    float sine_wave = sin(osc").concat(n,"_phase);\n                    sample = square_wave * (1.0 - morph) + sine_wave * morph;\n                } else {\n                    sample = square_wave; // Pure square - skip expensive sin()\n                }\n            }\n\n            osc").concat(n,"_outputL = sample * osc").concat(n,"_amplitude;\n            osc").concat(n,"_outputR = osc").concat(n,"_outputL;\n\n            // DEBUG: Print oscillator output every 500ms\n            static unsigned long oscDebugTime_").concat(n," = 0;\n            if (millis() - oscDebugTime_").concat(n," > 500) {\n                oscDebugTime_").concat(n,' = millis();\n                Serial.print("Osc').concat(n,' - freq=");\n                Serial.print(osc').concat(n,'_freq);\n                Serial.print(", gate=");\n                Serial.print(osc').concat(n,'_gate);\n                Serial.print(", amp=");\n                Serial.print(osc').concat(n,'_amplitude);\n                Serial.print(", out=");\n                Serial.println(osc').concat(n,"_outputL);\n            }\n        } else {\n            osc").concat(n,"_outputL = 0.0;\n            osc").concat(n,"_outputR = 0.0;\n        }\n")}},{key:"generateFilterCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"cutoff_hz"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"resonance"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&("inL"===n.to.port||"in"===n.to.port)}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port}),i="filter".concat(n,"_cutoff"),l="filter".concat(n,"_resonance"),s="0.0",u="0.0";if(a){var d=a.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"ADSR":i="(filter".concat(n,"_cutoff * adsr").concat(m,"_output)");break;case"LFO":i="(filter".concat(n,"_lfo_min_hz + lfo").concat(m,"_output * (filter").concat(n,"_lfo_max_hz - filter").concat(n,"_lfo_min_hz))");break;case"Pot":i="filter".concat(n,"_cutoff")}}}if(o){var _=o.from.id.split(":")[0],g=this.connectionResolver.modules.find(function(e){return e.id===_});if(g){var h,v=(null===(h=_.match(/\d+$/))||void 0===h?void 0:h[0])||"1";switch(g.type){case"Pot":l="filter".concat(n,"_resonance");break;case"LFO":l="lfo".concat(v,"_output");break;case"ADSR":l="adsr".concat(v,"_output")}}}if(c){var b=c.from.id.split(":")[0],y=this.connectionResolver.modules.find(function(e){return e.id===b});if(y){var k,x=(null===(k=b.match(/\d+$/))||void 0===k?void 0:k[0])||"1";switch(y.type){case"Oscillator":s="osc".concat(x,"_outputL");break;case"PolyOscillator":s="polyosc".concat(x,"_outputL");break;case"VCA":s="vca".concat(x,"_outputL");break;case"Filter":s="filter".concat(x,"_outputL");break;case"Noise":s="noise".concat(x,"_output");break;case"AudioMath":s="audioMath".concat(x,"_output");break;case"Delay":s="delay".concat(x,"_outputL");break;case"CleanReverb":s="cleanreverb".concat(x,"_outputL");break;case"Panner":s="panner".concat(x,"_outputL");break;case"StereoMixer4":s="stereoMixer4_".concat(x,"_outputL");break;case"Matrix2x2":s="matrix".concat(x,"_outputAL")}}}if(r){var S=r.from.id.split(":")[0],E=this.connectionResolver.modules.find(function(e){return e.id===S});if(E){var P,w=(null===(P=S.match(/\d+$/))||void 0===P?void 0:P[0])||"1";switch(E.type){case"Oscillator":u="osc".concat(w,"_outputR");break;case"PolyOscillator":u="polyosc".concat(w,"_outputR");break;case"VCA":u="vca".concat(w,"_outputR");break;case"Filter":u="filter".concat(w,"_outputR");break;case"Noise":u="noise".concat(w,"_output");break;case"AudioMath":u="audioMath".concat(w,"_output");break;case"Delay":u="delay".concat(w,"_outputR");break;case"CleanReverb":u="cleanreverb".concat(w,"_outputR");break;case"Panner":u="panner".concat(w,"_outputR");break;case"StereoMixer4":u="stereoMixer4_".concat(w,"_outputR");break;case"Matrix2x2":u="matrix".concat(w,"_outputAR")}}}var C="highpass"===e.params.mode?1:"bandpass"===e.params.mode?2:"notch"===e.params.mode?3:0;return"\n        // Filter ".concat(n," processing - Optimized SVF (mode: ").concat(e.params.mode||"lowpass",")\n        {\n            float inputL = ").concat(s,";\n            float inputR = ").concat(u,";\n\n            // Update coefficients only when cutoff/resonance change significantly (every 64 samples)\n            static float filter").concat(n,"_f = 0.1f;\n            static float filter").concat(n,"_q = 0.5f;\n            static int filter").concat(n,"_updateCounter = 0;\n\n            if (++filter").concat(n,"_updateCounter >= 64) {\n                filter").concat(n,"_updateCounter = 0;\n                float cutoff = ").concat(i,";\n                cutoff = cutoff < 20.0f ? 20.0f : (cutoff > 18000.0f ? 18000.0f : cutoff);\n                float resonance = ").concat(l,";\n                resonance = resonance < 0.0f ? 0.0f : (resonance > 0.95f ? 0.95f : resonance);\n\n                // Fast sin approximation for SVF: f  2 * pi * fc / fs (valid for fc << fs/4)\n                filter").concat(n,"_f = cutoff * 0.0001424f; // 2 * pi / 44100  0.0001424\n                filter").concat(n,"_f = filter").concat(n,"_f > 0.9f ? 0.9f : filter").concat(n,"_f; // Stability\n                filter").concat(n,"_q = 1.0f - resonance;\n            }\n\n            float f = filter").concat(n,"_f;\n            float q = filter").concat(n,"_q;\n\n            // Process LEFT channel - inline SVF\n            float high_L = inputL - filter").concat(n,"_lowL - (q * filter").concat(n,"_bandL);\n            filter").concat(n,"_bandL += f * high_L;\n            filter").concat(n,"_lowL += f * filter").concat(n,"_bandL;\n\n            // Process RIGHT channel - inline SVF\n            float high_R = inputR - filter").concat(n,"_lowR - (q * filter").concat(n,"_bandR);\n            filter").concat(n,"_bandR += f * high_R;\n            filter").concat(n,"_lowR += f * filter").concat(n,"_bandR;\n\n            // Output selection (compile-time constant - no branching)\n            #define FILTER").concat(n,"_MODE ").concat(C,"\n            #if FILTER").concat(n,"_MODE == 0\n            filter").concat(n,"_outputL = filter").concat(n,"_lowL;\n            filter").concat(n,"_outputR = filter").concat(n,"_lowR;\n            #elif FILTER").concat(n,"_MODE == 1\n            filter").concat(n,"_outputL = high_L;\n            filter").concat(n,"_outputR = high_R;\n            #elif FILTER").concat(n,"_MODE == 2\n            filter").concat(n,"_outputL = filter").concat(n,"_bandL;\n            filter").concat(n,"_outputR = filter").concat(n,"_bandR;\n            #else\n            filter").concat(n,"_outputL = filter").concat(n,"_lowL + high_L;\n            filter").concat(n,"_outputR = filter").concat(n,"_lowR + high_R;\n            #endif\n            #undef FILTER").concat(n,"_MODE\n\n            // Fast soft clip only if needed (high resonance)\n            if (q < 0.2f) {\n                float outL = filter").concat(n,"_outputL;\n                float outR = filter").concat(n,"_outputR;\n                // Polynomial approximation of tanh for small values\n                if (outL > 1.0f) outL = 1.0f; else if (outL < -1.0f) outL = -1.0f;\n                if (outR > 1.0f) outR = 1.0f; else if (outR < -1.0f) outR = -1.0f;\n                filter").concat(n,"_outputL = outL;\n                filter").concat(n,"_outputR = outR;\n            }\n        }\n")}},{key:"generateDistortionCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"drive"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"tone"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"mix"===n.to.port}),r="dist".concat(n,"_drive"),i="dist".concat(n,"_tone"),l="dist".concat(n,"_mix");if(a){var s=a.from.id.split(":")[0],u=this.connectionResolver.modules.find(function(e){return e.id===s});if(u){var d,p=(null===(d=s.match(/\d+$/))||void 0===d?void 0:d[0])||"1";switch(u.type){case"Pot":var f=u.params.index||p;r="(pot".concat(f,"_value * 10.0)");break;case"LFO":r="(lfo".concat(p,"_output * 10.0)")}}}if(o){var m=o.from.id.split(":")[0],_=this.connectionResolver.modules.find(function(e){return e.id===m});if(_){var g,h=(null===(g=m.match(/\d+$/))||void 0===g?void 0:g[0])||"1";switch(_.type){case"Pot":var v=_.params.index||h;i="(500.0 + pot".concat(v,"_value * 7500.0)");break;case"LFO":i="(500.0 + lfo".concat(h,"_output * 7500.0)")}}}if(c){var b=c.from.id.split(":")[0],y=this.connectionResolver.modules.find(function(e){return e.id===b});if(y){var k,x=(null===(k=b.match(/\d+$/))||void 0===k?void 0:k[0])||"1";switch(y.type){case"Pot":var S=y.params.index||x;l="pot".concat(S,"_value");break;case"LFO":l="lfo".concat(x,"_output")}}}var E=e.params.bypassMode||"toggle";return"\n        // Distortion ".concat(n," processing - CPU cost: ~20 units\n        {\n            float inputL = dist").concat(n,"_inputL;\n            float inputR = dist").concat(n,"_inputR;\n\n            // Handle bypass control (").concat(E," mode)\n            bool bypassTrigger = (dist").concat(n,"_bypass > 0.5);\n            ").concat("toggle"===E?"\n            // Toggle mode: button press switches bypass on/off\n            if (bypassTrigger && !dist".concat(n,"_lastBypassTrigger) {\n                dist").concat(n,"_bypassState = !dist").concat(n,"_bypassState;  // Toggle on rising edge\n            }\n            dist").concat(n,"_lastBypassTrigger = bypassTrigger;\n            bool isBypassed = dist").concat(n,"_bypassState;\n            "):"\n            // Gate mode: bypassed only while button is held\n            bool isBypassed = bypassTrigger;\n            ","\n\n            if (isBypassed) {\n                // Bypass: pass audio through unprocessed\n                dist").concat(n,"_outputL = inputL;\n                dist").concat(n,"_outputR = inputR;\n            } else {\n                // Active: process distortion\n                float drive = constrain(").concat(r,", 0.1, 10.0);\n                float tone_freq = constrain(").concat(i,", 500.0, 8000.0);\n                float mix = constrain(").concat(l,", 0.0, 1.0);\n\n                // Save dry signal for blending\n                float dryL = inputL;\n                float dryR = inputR;\n\n                // Apply drive (pre-gain)\n                float wetL = inputL * drive;\n                float wetR = inputR * drive;\n\n                // CV-controlled preset selection (for rhythmic preset switching)\n                // Map 0-1 CV to preset index 0-5\n                int presetIdx = constrain((int)(dist").concat(n,"_preset_cv * 5.999), 0, 5);\n\n                // Select active waveshaping table based on CV\n                const float* activeTable = nullptr;\n                switch(presetIdx) {\n                    case 0: activeTable = dist").concat(n,"_table_clean; break;\n                    case 1: activeTable = dist").concat(n,"_table_overdrive; break;\n                    case 2: activeTable = dist").concat(n,"_table_fuzz; break;\n                    case 3: activeTable = dist").concat(n,"_table_speaker; break;\n                    case 4: activeTable = dist").concat(n,"_table_bitcrush; break;\n                    case 5: activeTable = dist").concat(n,"_table_saturatorlive; break;\n                    default: activeTable = dist").concat(n,"_table_overdrive; break;\n                }\n\n                // Waveshaping lookup with linear interpolation\n                // Map -drive..+drive to 0..255 table index\n                float indexL = constrain((wetL + drive) / (2.0 * drive), 0.0, 0.9999) * 256.0;\n                float indexR = constrain((wetR + drive) / (2.0 * drive), 0.0, 0.9999) * 256.0;\n\n                int idxL = (int)indexL;\n                int idxR = (int)indexR;\n                float fracL = indexL - idxL;\n                float fracR = indexR - idxR;\n\n                // Apply waveshaping with selected preset table\n                wetL = activeTable[idxL] * (1.0 - fracL) + activeTable[idxL + 1] * fracL;\n                wetR = activeTable[idxR] * (1.0 - fracR) + activeTable[idxR + 1] * fracR;\n\n                // Optional crossfade between presets (for smooth transitions)\n                if (dist").concat(n,"_presetCrossfade > 0.0 && presetIdx < 5) {\n                    // Crossfade with next preset\n                    const float* nextTable = nullptr;\n                    switch(presetIdx + 1) {\n                        case 1: nextTable = dist").concat(n,"_table_overdrive; break;\n                        case 2: nextTable = dist").concat(n,"_table_fuzz; break;\n                        case 3: nextTable = dist").concat(n,"_table_speaker; break;\n                        case 4: nextTable = dist").concat(n,"_table_bitcrush; break;\n                        case 5: nextTable = dist").concat(n,"_table_saturatorlive; break;\n                        default: nextTable = dist").concat(n,"_table_overdrive; break;\n                    }\n\n                    float nextWetL = nextTable[idxL] * (1.0 - fracL) + nextTable[idxL + 1] * fracL;\n                    float nextWetR = nextTable[idxR] * (1.0 - fracR) + nextTable[idxR + 1] * fracR;\n\n                    // Crossfade amount determined by preset_cv fractional part\n                    float cvFrac = (dist").concat(n,"_preset_cv * 5.999) - presetIdx;\n                    float blend = cvFrac * dist").concat(n,"_presetCrossfade;\n\n                    wetL = wetL * (1.0 - blend) + nextWetL * blend;\n                    wetR = wetR * (1.0 - blend) + nextWetR * blend;\n                }\n\n                // Post-filter (tone control) - simple one-pole lowpass\n                float alpha = 2.0 * M_PI * tone_freq / 44100.0;\n                alpha = constrain(alpha, 0.001, 0.99);\n\n                dist").concat(n,"_filterL = dist").concat(n,"_filterL + alpha * (wetL - dist").concat(n,"_filterL);\n                dist").concat(n,"_filterR = dist").concat(n,"_filterR + alpha * (wetR - dist").concat(n,"_filterR);\n\n                wetL = dist").concat(n,"_filterL;\n                wetR = dist").concat(n,"_filterR;\n\n                // Dry/wet mix\n                dist").concat(n,"_outputL = dryL * (1.0 - mix) + wetL * mix;\n                dist").concat(n,"_outputR = dryR * (1.0 - mix) + wetR * mix;\n\n                // Prevent denormals\n                if (fabsf(dist").concat(n,"_outputL) < 1e-10f) dist").concat(n,"_outputL = 0.0f;\n                if (fabsf(dist").concat(n,"_outputR) < 1e-10f) dist").concat(n,"_outputR = 0.0f;\n            }\n        }\n")}},{key:"generateDistortionVariables",value:function(e,n,t){var a=function(e){for(var n=[],t=0;t<257;t++){var a=t/256*2-1,o=0;switch(e){case"clean":o=a/(1+.3*Math.abs(a));break;case"overdrive":o=Math.abs(a)<.33?2*a:Math.abs(a)<.67?(3-Math.pow(2-3*Math.abs(a),2))/3*Math.sign(a):Math.sign(a);break;case"fuzz":o=a>.4?.8:a<-.5?-1:1.5*a,o=Math.max(-1,Math.min(1,o));break;case"speaker":o=2/(1+Math.exp(-2.5*a))-1;break;case"bitcrush":o=Math.round(8*a)/8,o=Math.max(-1,Math.min(1,o));break;case"saturatorlive":o=[-.5,-.485011,-.470211,-.455768,-.44181,-.428413,-.415592,-.403298,-.391425,-.379822,-.368306,-.356685,-.344776,-.332427,-.319533,-.30605,-.292008,-.277512,-.262746,-.24796,-.233464,-.219603,-.206738,-.195211,-.185318,-.177271,-.171167,-.166964,-.164459,-.16329,-.162946,-.162797,-.16215,-.16031,-.156661,-.150747,-.14235,-.131551,-.118765,-.10475,-.090565,-.077504,-.066979,-.060387,-.05896,-.063616,-.074827,-.092535,-.116102,-.144337,-.175575,-.207814,-.238899,-.266735,-.289493,-.305807,-.314911,-.31673,-.311878,-.30159,-.287577,-.271825,-.256365,-.243043,-.233302,-.22803,-.227474,-.231236,-.238352,-.247446,-.256933,-.26525,-.271078,-.273524,-.272247,-.267498,-.260081,-.251229,-.242417,-.235149,-.230725,-.230052,-.233502,-.240853,-.251316,-.263649,-.276342,-.287843,-.296795,-.302252,-.303831,-.301792,-.297011,-.290866,-.285038,-.28126,-.281052,-.285472,-.294933,-.309108,-.326945,-.346798,-.366647,-.384398,-.398201,-.40676,-.40957,-.407054,-.400564,-.392246,-.384772,-.380967,-.383379,-.393858,-.413175,-.440766,-.474627,-.511389,-.546569,-.574987,-.591303,-.590604,-.568986,-.524057,-.45529,-.364195,-.254262,-.130705,0,.130705,.254262,.364195,.45529,.524057,.568986,.590604,.591303,.574987,.546569,.511389,.474627,.440766,.413175,.393858,.383379,.380967,.384772,.392246,.400564,.407054,.40957,.40676,.398201,.384398,.366647,.346798,.326945,.309108,.294933,.285472,.281052,.28126,.285038,.290866,.297011,.301792,.303831,.302252,.296795,.287843,.276342,.263649,.251316,.240853,.233502,.230052,.230725,.235149,.242417,.251229,.260081,.267498,.272247,.273524,.271078,.26525,.256933,.247446,.238352,.231236,.227474,.22803,.233302,.243043,.256365,.271825,.287577,.30159,.311878,.31673,.314911,.305807,.289493,.266735,.238899,.207814,.175575,.144337,.116102,.092535,.074827,.063616,.05896,.060387,.066979,.077504,.090565,.10475,.118765,.131551,.14235,.150747,.156661,.16031,.16215,.162797,.162946,.16329,.164459,.166964,.171167,.177271,.185318,.195211,.206738,.219603,.233464,.24796,.262746,.277512,.292008,.30605,.319533,.332427,.344776,.356685,.368306,.379822,.391425,.403298,.415592,.428413,.44181,.455768,.470211,.485011,.5][t];break;default:o=a}n.push(o.toFixed(6))}return n.join(", ")};return"\n// ".concat(t.label," ").concat(n," - Waveshaping Distortion with CV Preset Switching\n// All preset waveshaping tables (6KB total, 0.04% of ESP32-S3 16MB flash)\nconst float dist").concat(n,"_table_clean[257] = {").concat(a("clean"),"};\nconst float dist").concat(n,"_table_overdrive[257] = {").concat(a("overdrive"),"};\nconst float dist").concat(n,"_table_fuzz[257] = {").concat(a("fuzz"),"};\nconst float dist").concat(n,"_table_speaker[257] = {").concat(a("speaker"),"};\nconst float dist").concat(n,"_table_bitcrush[257] = {").concat(a("bitcrush"),"};\nconst float dist").concat(n,"_table_saturatorlive[257] = {").concat(a("saturatorlive"),"};\n\n// Filter state for tone control\nfloat dist").concat(n,"_filterL = 0.0;\nfloat dist").concat(n,"_filterR = 0.0;\n\n// I/O variables\nfloat dist").concat(n,"_inputL = 0.0;\nfloat dist").concat(n,"_inputR = 0.0;\nfloat dist").concat(n,"_outputL = 0.0;\nfloat dist").concat(n,"_outputR = 0.0;\n\n// Bypass control\nfloat dist").concat(n,"_bypass = 0.0;  // Control input (0 = active, 1 = bypassed)\nbool dist").concat(n,"_bypassState = false;  // Toggle state\nbool dist").concat(n,"_lastBypassTrigger = false;  // For toggle detection\n\n// Preset CV control\nfloat dist").concat(n,"_preset_cv = 0.0;  // 0-1 CV input for preset selection (0=clean ... 1=saturatorlive)\nint dist").concat(n,"_currentPreset = ").concat(["clean","overdrive","fuzz","speaker","bitcrush","saturatorlive"].indexOf(e.params.preset||"overdrive"),";  // Current preset index (0-5)\nfloat dist").concat(n,"_presetCrossfade = ").concat(e.params.presetCrossfade||0,";  // Crossfade amount (0=instant, 1=full blend)\n\n// Parameters\nfloat dist").concat(n,"_drive = ").concat(e.params.drive||2.5,";\nfloat dist").concat(n,"_tone = ").concat(e.params.tone||2e3,";\nfloat dist").concat(n,"_mix = ").concat(e.params.mix||.8,";\n")}},{key:"generatePolyOscillatorVariables",value:function(e,n,t){for(var a=e.params.voices||4,o=e.params.detune_cents||8,c=e.params.stereo_spread||.7,r=e.params.attack_ms||150,i=e.params.decay_ms||200,l=e.params.sustain||.7,s=e.params.release_ms||800,u=e.params.gain||.6,d=e.params.unison||!1,p=e.params.unison_detune||15,f=e.params.wavetables||[],m=512,_="",g=0;g<4;g++){var h=f[g];if(h&&h.length>0)_+="\n// Wavetable ".concat(g," data (").concat(h.length," samples)\nfloat polyosc").concat(n,"_table").concat(g,"[").concat(m,"] = {\n    ").concat(Array.from(h).map(function(e,n){var t=e.toFixed(6)+"f";return n%8==0&&n>0?"\n    "+t:t}).join(", "),"\n};");else{var v=void 0,b=void 0;switch(g){case 0:v=Array.from({length:m},function(e,n){return Math.sin(n/m*2*Math.PI)}),b="sine wave - default";break;case 1:v=Array.from({length:m},function(e,n){return n/m*2-1}),b="sawtooth wave - default";break;case 2:v=Array.from({length:m},function(e,n){return n<256?1:-1}),b="square wave - default";break;case 3:v=Array.from({length:m},function(e,n){var t=n/m;return t<.5?4*t-1:3-4*t}),b="triangle wave - default"}_+="\n// Wavetable ".concat(g," data (").concat(b,")\nfloat polyosc").concat(n,"_table").concat(g,"[").concat(m,"] = {\n    ").concat(v.map(function(e,n){var t=e.toFixed(6)+"f";return n%8==0&&n>0?"\n    "+t:t}).join(", "),"\n};")}}return"\n// ".concat(t.label," ").concat(n," - 4-Voice Polyphonic Oscillator for Pads\n#define POLYOSC").concat(n,"_VOICES ").concat(a,"\n#define POLYOSC").concat(n,"_TABLE_SIZE ").concat(m,"\n").concat(_,"\n\n// Wavetable morphing position (0.0 = table0, 1.0 = table1, 2.0 = table2, 3.0 = table3)\nfloat polyosc").concat(n,"_wtPos = ").concat(e.params.wt_pos||0,";\n\n// Voice state arrays\nfloat polyosc").concat(n,"_phase[POLYOSC").concat(n,"_VOICES] = {0};\nfloat polyosc").concat(n,"_phaseInc[POLYOSC").concat(n,"_VOICES] = {0}; // Precomputed phase increment (freq/samplerate)\nfloat polyosc").concat(n,"_freq[POLYOSC").concat(n,"_VOICES] = {0};\nfloat polyosc").concat(n,"_targetFreq[POLYOSC").concat(n,"_VOICES] = {0};\nbool polyosc").concat(n,"_active[POLYOSC").concat(n,"_VOICES] = {false};\nbool polyosc").concat(n,"_releasing[POLYOSC").concat(n,"_VOICES] = {false};\nuint8_t polyosc").concat(n,"_note[POLYOSC").concat(n,"_VOICES] = {0};\nuint32_t polyosc").concat(n,"_startTime[POLYOSC").concat(n,"_VOICES] = {0}; // For voice stealing\n\n// ADSR envelope per voice\nfloat polyosc").concat(n,"_env[POLYOSC").concat(n,"_VOICES] = {0};\nint polyosc").concat(n,"_envStage[POLYOSC").concat(n,"_VOICES] = {0}; // 0=idle, 1=attack, 2=decay, 3=sustain, 4=release\nfloat polyosc").concat(n,"_velocity[POLYOSC").concat(n,"_VOICES] = {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}; // Velocity per voice (0-1)\n\n// ADSR parameters (shared by all voices)\nfloat polyosc").concat(n,"_attack = ").concat((r/1e3).toFixed(4),"; // seconds\nfloat polyosc").concat(n,"_decay = ").concat((i/1e3).toFixed(4),"; // seconds\nfloat polyosc").concat(n,"_sustain = ").concat(l.toFixed(3),";\nfloat polyosc").concat(n,"_release = ").concat((s/1e3).toFixed(4),"; // seconds\n\n// Voice parameters\nfloat polyosc").concat(n,"_detune = ").concat(o.toFixed(1),"; // cents\nfloat polyosc").concat(n,"_stereoSpread = ").concat(c.toFixed(2),";\nfloat polyosc").concat(n,"_gain = ").concat(u.toFixed(3),";\nbool polyosc").concat(n,"_unison = ").concat(d,";\nfloat polyosc").concat(n,"_unisonDetune = ").concat(p.toFixed(1),"; // cents\n\n// Voice allocation\nint polyosc").concat(n,"_nextVoice = 0;\nint polyosc").concat(n,"_voiceCount = 0;\n\n// Control inputs\nfloat polyosc").concat(n,"_gateIn = 0.0;\nfloat polyosc").concat(n,"_freqIn = 440.0;\nfloat polyosc").concat(n,"_noteIn = 60.0; // MIDI note number\nbool polyosc").concat(n,"_lastGate = false;\nint polyosc").concat(n,"_currentVoice = 0; // Track which voice is currently triggered (for overlapping releases)\n\n// Output\nfloat polyosc").concat(n,"_outputL = 0.0;\nfloat polyosc").concat(n,"_outputR = 0.0;\n\n// Precomputed panning for each voice (spread across stereo field)\nfloat polyosc").concat(n,"_panL[POLYOSC").concat(n,"_VOICES];\nfloat polyosc").concat(n,"_panR[POLYOSC").concat(n,"_VOICES];\nbool polyosc").concat(n,"_pansInitialized = false;\n\n// Voice-to-note mapping for true polyphony\nuint8_t polyosc").concat(n,"_voiceNote[POLYOSC").concat(n,"_VOICES] = {255, 255, 255, 255, 255, 255, 255, 255}; // 255 = no note assigned\n\n// Self-contained 2-operator FM synthesis (per-voice modulator)\n#define POLYOSC").concat(n,"_FM_ENABLED ").concat(e.params.fm_enabled?1:0,"\nfloat polyosc").concat(n,"_modPhase[POLYOSC").concat(n,"_VOICES] = {0};  // Per-voice modulator phase\nfloat polyosc").concat(n,"_fmRatio = ").concat((e.params.fm_ratio||1).toFixed(3),"f;      // Modulator:Carrier ratio\nfloat polyosc").concat(n,"_fmIndex = ").concat((e.params.fm_index||0).toFixed(3),"f;      // Base modulation index (always applied)\nfloat polyosc").concat(n,"_fmModAmount = ").concat((e.params.fm_mod_amount||5).toFixed(3),"f; // CV modulation amount (scales input)\nfloat polyosc").concat(n,"_fmModInput = 0.0f;  // CV input value (0-1 from ADSR/LFO/etc)\nfloat polyosc").concat(n,"_fmEnvDepth = ").concat((e.params.fm_env_depth||1).toFixed(3),"f; // Envelope to modulator amount\nfloat polyosc").concat(n,"_fmRatioFine = ").concat((e.params.fm_ratio_fine||0).toFixed(4),"f; // Fine ratio detune\n")}},{key:"generatePolyOscillatorProcessingCode",value:function(e,n,t){var a=this,o=t.find(function(n){return n.to.id==="".concat(e.id,":gate")}),c=t.find(function(n){return n.to.id==="".concat(e.id,":freq")}),r=t.find(function(n){return n.to.id==="".concat(e.id,":note")}),i="0.0",l=null;if(o){var s=o.from.id.split(":")[0],u=this.connectionResolver.modules.find(function(e){return e.id===s});if(u){var d,p=(null===(d=s.match(/\d+$/))||void 0===d?void 0:d[0])||"1";switch(u.type){case"MIDIIn":i="midiin".concat(p,"_gate");break;case"LEDButton":var f=u.params.index||p;i="btn".concat(f,"_gate");break;case"Scale":i="scale".concat(p,"_gate");break;case"Clock":var m=o.from.port||"out1";i="clock".concat(p,"_").concat(m);break;case"Arpeggiator":i="arp".concat(p,"_out_gate");break;case"MIDILooper":i="midiloop".concat(p,"_out_gate")}}}var _="polyosc"+n+"_freqIn",g=!1;if(r){var h=r.from.id.split(":")[0],v=this.connectionResolver.modules.find(function(e){return e.id===h});if(v){var b,y=(null===(b=h.match(/\d+$/))||void 0===b?void 0:b[0])||"1";switch(v.type){case"MIDIIn":_="midiin".concat(y,"_note"),g=!0,l=y;break;case"Scale":_="scale".concat(y,"_output"),g=!1;break;case"Arpeggiator":_="(arp".concat(y,"_out_note * 48.0f + 48.0f)"),g=!0,l=null;break;case"MIDILooper":_="(midiloop".concat(y,"_out_note * 48.0f + 48.0f)"),g=!0,l=null}}}else if(c){var k=c.from.id.split(":")[0],x=this.connectionResolver.modules.find(function(e){return e.id===k});if(x){var S,E=(null===(S=k.match(/\d+$/))||void 0===S?void 0:S[0])||"1";switch(x.type){case"Scale":_="scale".concat(E,"_output");break;case"MIDIIn":_="midiin".concat(E,"_note"),g=!0;break;case"Pot":var P=x.params.index||E;_="(pot".concat(P,"_value * 880.0 + 110.0)")}}}e.params.voices;var w=t.find(function(n){return n.to.id==="".concat(e.id,":attack")}),C=t.find(function(n){return n.to.id==="".concat(e.id,":decay")}),I=t.find(function(n){return n.to.id==="".concat(e.id,":sustain")}),R=t.find(function(n){return n.to.id==="".concat(e.id,":release")}),L=t.find(function(n){return n.to.id==="".concat(e.id,":gain")}),M=t.find(function(n){return n.to.id==="".concat(e.id,":fm_index")}),D=t.find(function(n){return n.to.id==="".concat(e.id,":fm_ratio")}),A=t.find(function(n){return n.to.id==="".concat(e.id,":fm_mod_amount")}),O=t.find(function(n){return n.to.id==="".concat(e.id,":wt_pos")}),B=function(e,n,t,o){if(!e)return null;var c=e.from.id.split(":")[0],r=a.connectionResolver.modules.find(function(e){return e.id===c});if(r&&"Pot"===r.type){var i,l=r.params.index||(null===(i=c.match(/\d+$/))||void 0===i?void 0:i[0])||"1",s=e.from.bank||1,u=(o-t).toFixed(3),d=t.toFixed(3);return{expr:"pot".concat(l,"_value * ").concat(u,"f + ").concat(d,"f"),bank:s}}return null},T=B(w,0,.005,2),F=B(C,0,.005,2),N=B(I,0,0,1),z=B(R,0,.01,4),G=null,q=null;if(M){var U=M.from.id.split(":")[0],W=this.connectionResolver.modules.find(function(e){return e.id===U});if(W){var V,H=(null===(V=U.match(/\d+$/))||void 0===V?void 0:V[0])||"1";switch(W.type){case"LFO":G="((lfo".concat(H,"_output + 1.0f) * 0.5f)");break;case"ADSR":G="adsr".concat(H,"_output");break;case"MIDIIn":G="midiin".concat(H,"_velocity");break;case"Pot":q=B(M,0,0,10)}}}var j=null,K=null;if(D){var Y=D.from.id.split(":")[0],$=this.connectionResolver.modules.find(function(e){return e.id===Y});if($){var X,Z=(null===(X=Y.match(/\d+$/))||void 0===X?void 0:X[0])||"1";switch($.type){case"LFO":j="((lfo".concat(Z,"_output + 1.0f) * 3.75f + 0.5f)");break;case"ADSR":j="(adsr".concat(Z,"_output * 7.5f + 0.5f)");break;case"Pot":K=B(D,0,.5,8)}}}var Q=null,J=null;if(A){var ee=A.from.id.split(":")[0],ne=this.connectionResolver.modules.find(function(e){return e.id===ee});if(ne){var te,ae=(null===(te=ee.match(/\d+$/))||void 0===te?void 0:te[0])||"1";switch(ne.type){case"LFO":Q="((lfo".concat(ae,"_output + 1.0f) * 5.0f)");break;case"ADSR":Q="(adsr".concat(ae,"_output * 10.0f)");break;case"MIDIIn":Q="(midiin".concat(ae,"_velocity * 10.0f)");break;case"Pot":J=B(A,0,0,10)}}}var oe=null;if(L){var ce=L.from.id.split(":")[0],re=this.connectionResolver.modules.find(function(e){return e.id===ce});if(re){var ie,le=(null===(ie=ce.match(/\d+$/))||void 0===ie?void 0:ie[0])||"1";switch(re.type){case"LFO":oe="((lfo".concat(le,"_output + 1.0f) * 0.5f)");break;case"ADSR":oe="adsr".concat(le,"_output");break;case"Pot":var se=re.params.index||le;oe="pot".concat(se,"_value")}}}var ue=null,de=null;if(O){var pe=O.from.id.split(":")[0],fe=this.connectionResolver.modules.find(function(e){return e.id===pe});if(fe){var me,_e=(null===(me=pe.match(/\d+$/))||void 0===me?void 0:me[0])||"1";switch(fe.type){case"LFO":ue="((lfo".concat(_e,"_output + 1.0f) * 1.5f)");break;case"ADSR":ue="(adsr".concat(_e,"_output * 3.0f)");break;case"Pot":de=B(O,0,0,3);break;case"MIDIIn":ue="(midiin".concat(_e,"_cc1 * 3.0f)")}}}var ge="1.0",he=null,ve=null;if(r){var be=r.from.id.split(":")[0],ye=this.connectionResolver.modules.find(function(e){return e.id===be});if(ye){var ke,xe=(null===(ke=be.match(/\d+$/))||void 0===ke?void 0:ke[0])||"1";"Arpeggiator"===ye.type?he=xe:"MIDILooper"===ye.type&&(ve=xe)}}l?("0.0"===i&&(i="midiin".concat(l,"_gate")),ge="midiin".concat(l,"_velocity")):he?("0.0"===i&&(i="arp".concat(he,"_out_gate")),ge="arp".concat(he,"_out_velocity")):ve&&("0.0"===i&&(i="midiloop".concat(ve,"_out_gate")),ge="midiloop".concat(ve,"_out_velocity"));var Se=null!==l;return"\n        // PolyOscillator ".concat(n," - 4-Voice Polyphonic Pad Synthesizer (TRUE POLYPHONY)\n        {\n            // === BUFFER-RATE CODE (runs once per 256 samples) ===\n\n            // Initialize panning once (first buffer only)\n            if (!polyosc").concat(n,"_pansInitialized) {\n                for (int v = 0; v < POLYOSC").concat(n,"_VOICES; v++) {\n                    float pan = (float)v / (POLYOSC").concat(n,"_VOICES - 1) * polyosc").concat(n,"_stereoSpread;\n                    pan = pan - polyosc").concat(n,"_stereoSpread * 0.5 + 0.5;\n                    polyosc").concat(n,"_panL[v] = cosf(pan * M_PI * 0.5f);\n                    polyosc").concat(n,"_panR[v] = sinf(pan * M_PI * 0.5f);\n                }\n                polyosc").concat(n,"_pansInitialized = true;\n            }\n\n            ").concat(Se?"\n            // Process MIDI event queue for true polyphony\n            while (midiin".concat(l,"_eventTail != midiin").concat(l,"_eventHead) {\n                MidiEvent").concat(l,"& evt = midiin").concat(l,"_eventQueue[midiin").concat(l,"_eventTail];\n                midiin").concat(l,"_eventTail = (midiin").concat(l,"_eventTail + 1) % MIDIIN").concat(l,"_EVENT_QUEUE_SIZE;\n\n                if (evt.isNoteOn) {\n                    // Find free voice or steal oldest\n                    int voiceToUse = -1;\n                    uint32_t oldestTime = UINT32_MAX;\n                    int oldestVoice = 0;\n\n                    for (int v = 0; v < POLYOSC").concat(n,"_VOICES; v++) {\n                        if (!polyosc").concat(n,"_active[v] && polyosc").concat(n,"_envStage[v] == 0) {\n                            voiceToUse = v;\n                            break;\n                        }\n                        if (polyosc").concat(n,"_startTime[v] < oldestTime) {\n                            oldestTime = polyosc").concat(n,"_startTime[v];\n                            oldestVoice = v;\n                        }\n                    }\n                    if (voiceToUse < 0) voiceToUse = oldestVoice;\n\n                    // Convert MIDI note to frequency\n                    float semitones = (float)evt.note - 69.0f;\n                    float baseFreq = 440.0f * powf(2.0f, semitones * 0.0833333f);\n\n                    // Apply voice detune\n                    float detuneOffset = ((float)voiceToUse / (POLYOSC").concat(n,"_VOICES - 1) - 0.5f) * polyosc").concat(n,"_detune;\n                    float voiceFreq = baseFreq * (1.0f + detuneOffset * 0.000578f);\n\n                    // Activate voice\n                    polyosc").concat(n,"_freq[voiceToUse] = voiceFreq;\n                    polyosc").concat(n,"_phaseInc[voiceToUse] = voiceFreq / (float)SAMPLE_RATE;\n                    polyosc").concat(n,"_velocity[voiceToUse] = evt.velocity / 127.0f;\n                    polyosc").concat(n,"_active[voiceToUse] = true;\n                    polyosc").concat(n,"_releasing[voiceToUse] = false;\n                    polyosc").concat(n,"_envStage[voiceToUse] = 1;\n                    polyosc").concat(n,"_startTime[voiceToUse] = millis();\n                    polyosc").concat(n,"_voiceNote[voiceToUse] = evt.note; // Track which note this voice plays\n                } else {\n                    // Note Off: find voice playing this note and release it\n                    for (int v = 0; v < POLYOSC").concat(n,"_VOICES; v++) {\n                        if (polyosc").concat(n,"_active[v] && !polyosc").concat(n,"_releasing[v] &&\n                            polyosc").concat(n,"_voiceNote[v] == evt.note) {\n                            polyosc").concat(n,"_releasing[v] = true;\n                            polyosc").concat(n,"_envStage[v] = 4;\n                            polyosc").concat(n,"_voiceNote[v] = 255; // Clear note assignment\n                            break; // Only release one voice per note-off\n                        }\n                    }\n                }\n            }"):"\n            // Gate mode with voice tracking (for Arpeggiator/mono sources with overlapping releases)\n            float currentGate = ".concat(i,";\n            float currentVelocity = ").concat(ge,";\n            ").concat(g?"\n            float midiNote = ".concat(_,";\n            float semitones = midiNote - 69.0f;\n            float currentFreq = 440.0f * powf(2.0f, semitones * 0.0833333f);"):"float currentFreq = ".concat(_,";"),"\n\n            bool gateOn = currentGate > 0.5f;\n            bool gateRising = gateOn && !polyosc").concat(n,"_lastGate;\n            bool gateFalling = !gateOn && polyosc").concat(n,"_lastGate;\n            polyosc").concat(n,"_lastGate = gateOn;\n\n            if (gateRising) {\n                // Find free voice (in release or idle) or steal oldest\n                int voiceToUse = -1;\n                uint32_t oldestTime = UINT32_MAX;\n                int oldestVoice = 0;\n\n                // First look for completely free voices\n                for (int v = 0; v < POLYOSC").concat(n,"_VOICES; v++) {\n                    if (!polyosc").concat(n,"_active[v] && polyosc").concat(n,"_envStage[v] == 0) {\n                        voiceToUse = v;\n                        break;\n                    }\n                    if (polyosc").concat(n,"_startTime[v] < oldestTime) {\n                        oldestTime = polyosc").concat(n,"_startTime[v];\n                        oldestVoice = v;\n                    }\n                }\n                // If no free voice, steal oldest\n                if (voiceToUse < 0) voiceToUse = oldestVoice;\n\n                float detuneOffset = ((float)voiceToUse / (POLYOSC").concat(n,"_VOICES - 1) - 0.5f) * polyosc").concat(n,"_detune;\n                float voiceFreq = currentFreq * (1.0f + detuneOffset * 0.000578f);\n                polyosc").concat(n,"_freq[voiceToUse] = voiceFreq;\n                polyosc").concat(n,"_phaseInc[voiceToUse] = voiceFreq / (float)SAMPLE_RATE;\n                polyosc").concat(n,"_velocity[voiceToUse] = currentVelocity;\n                polyosc").concat(n,"_active[voiceToUse] = true;\n                polyosc").concat(n,"_releasing[voiceToUse] = false;\n                polyosc").concat(n,"_envStage[voiceToUse] = 1;\n                polyosc").concat(n,"_startTime[voiceToUse] = millis();\n                polyosc").concat(n,"_currentVoice = voiceToUse; // Track which voice we just triggered\n            }\n            if (gateFalling) {\n                // Only release the voice we're currently playing, not all voices\n                // This allows overlapping releases for arpeggiator-style playing\n                int v = polyosc").concat(n,"_currentVoice;\n                if (v >= 0 && v < POLYOSC").concat(n,"_VOICES && polyosc").concat(n,"_active[v] && !polyosc").concat(n,"_releasing[v]) {\n                    polyosc").concat(n,"_releasing[v] = true;\n                    polyosc").concat(n,"_envStage[v] = 4; // Enter release stage\n                }\n            }"),"\n\n            // Update ADSR from connected pots (if any) - only when in correct bank\n            ").concat(T?"if (currentBank == ".concat(T.bank,") polyosc").concat(n,"_attack = ").concat(T.expr,";"):"","\n            ").concat(F?"if (currentBank == ".concat(F.bank,") polyosc").concat(n,"_decay = ").concat(F.expr,";"):"","\n            ").concat(N?"if (currentBank == ".concat(N.bank,") polyosc").concat(n,"_sustain = ").concat(N.expr,";"):"","\n            ").concat(z?"if (currentBank == ".concat(z.bank,") polyosc").concat(n,"_release = ").concat(z.expr,";"):"","\n\n            // Update self-contained FM parameters (only when FM is enabled)\n            #if POLYOSC").concat(n,"_FM_ENABLED\n            // FM modulation input (0-1 from ADSR/LFO/velocity) - scales by fm_mod_amount and adds to base\n            ").concat(G?"polyosc".concat(n,"_fmModInput = ").concat(G,";"):"","\n            // Pot directly sets fm_index base value\n            ").concat(q?"if (currentBank == ".concat(q.bank,") polyosc").concat(n,"_fmIndex = ").concat(q.expr,";"):"","\n            // FM Ratio modulation\n            ").concat(j?"polyosc".concat(n,"_fmRatio = ").concat(j,";"):"","\n            ").concat(K?"if (currentBank == ".concat(K.bank,") polyosc").concat(n,"_fmRatio = ").concat(K.expr,";"):"","\n            // FM Mod Amount modulation (scales how much CV adds to base fm_index)\n            // NOTE: Pot control has NO bank restriction - always active for real-time tweaking\n            ").concat(Q?"polyosc".concat(n,"_fmModAmount = ").concat(Q,";"):"","\n            ").concat(J?"polyosc".concat(n,"_fmModAmount = ").concat(J.expr,";"):"","\n            #endif\n\n            // Update wavetable position for morphing (0-3 range)\n            ").concat(ue?"polyosc".concat(n,"_wtPos = ").concat(ue,";"):"","\n            ").concat(de?"if (currentBank == ".concat(de.bank,") polyosc").concat(n,"_wtPos = ").concat(de.expr,";"):"","\n\n            // Precompute envelope rates (once per buffer, not per sample)\n            const float envDt = 1.0f / (float)SAMPLE_RATE;\n            const float attackRate = envDt / fmaxf(polyosc").concat(n,"_attack, 0.001f);\n            const float decayRate = envDt / fmaxf(polyosc").concat(n,"_decay, 0.001f) * (1.0f - polyosc").concat(n,"_sustain);\n            const float releaseRate = envDt / fmaxf(polyosc").concat(n,"_release, 0.001f);\n            const float sustainLevel = polyosc").concat(n,"_sustain;\n\n            // === SAMPLE-RATE CODE (inner loop - runs 256 times) ===\n            float mixL = 0.0f;\n            float mixR = 0.0f;\n\n            for (int v = 0; v < POLYOSC").concat(n,"_VOICES; v++) {\n                if (polyosc").concat(n,"_envStage[v] == 0) continue;\n\n                float env = polyosc").concat(n,"_env[v];\n\n                // Simplified ADSR with precomputed rates\n                switch (polyosc").concat(n,"_envStage[v]) {\n                    case 1: // Attack\n                        env += attackRate;\n                        if (env >= 1.0f) { env = 1.0f; polyosc").concat(n,"_envStage[v] = 2; }\n                        break;\n                    case 2: // Decay\n                        env -= decayRate;\n                        if (env <= sustainLevel) { env = sustainLevel; polyosc").concat(n,"_envStage[v] = 3; }\n                        break;\n                    case 3: // Sustain - no change needed\n                        break;\n                    case 4: // Release\n                        env -= releaseRate;\n                        if (env <= 0.0f) {\n                            env = 0.0f;\n                            polyosc").concat(n,"_envStage[v] = 0;\n                            polyosc").concat(n,"_active[v] = false;\n                            polyosc").concat(n,"_releasing[v] = false;\n                        }\n                        break;\n                }\n                polyosc").concat(n,"_env[v] = env;\n\n                if (env < 0.001f) continue;\n\n                // Carrier phase increment (base frequency)\n                float basePhaseInc = polyosc").concat(n,"_phaseInc[v];\n\n                #if POLYOSC").concat(n,"_FM_ENABLED\n                // === Self-contained 2-operator FM synthesis ===\n                // Each voice has its own modulator that tracks carrier frequency  ratio\n                // This gives consistent timbre across the keyboard (unlike single global modulator)\n\n                // Modulator frequency = carrier frequency  (ratio + fine detune)\n                float modRatio = polyosc").concat(n,"_fmRatio + polyosc").concat(n,"_fmRatioFine;\n                float modPhaseInc = basePhaseInc * modRatio;\n\n                // Update modulator phase\n                float modPhase = polyosc").concat(n,"_modPhase[v];\n                modPhase += modPhaseInc;\n                if (modPhase >= 1.0f) modPhase -= 1.0f;\n                polyosc").concat(n,"_modPhase[v] = modPhase;\n\n                // Fast sine approximation for modulator (parabolic, ~3% THD, very CPU efficient)\n                // sin(2*pi*x)  4x(1-x) for x in [0,1], scaled and shifted\n                float modNorm = modPhase * 2.0f - 1.0f;  // -1 to +1\n                float modSine = modNorm * (1.0f - fabsf(modNorm)) * 4.0f;  // Parabolic approximation\n\n                // Apply envelope to modulator (envelope depth controls how much env affects mod amplitude)\n                // At envDepth=1, modulator follows carrier envelope (classic DX-style)\n                // At envDepth=0, modulator is constant amplitude (sustained FM)\n                float modEnv = 1.0f - polyosc").concat(n,"_fmEnvDepth + (polyosc").concat(n,"_fmEnvDepth * env);\n                float modSignal = modSine * modEnv;\n\n                // Calculate effective FM index: base + (modulation input  mod amount)\n                // This allows setting a base FM amount and using CV to add more on top\n                float effectiveFmIndex = polyosc").concat(n,"_fmIndex + (polyosc").concat(n,"_fmModInput * polyosc").concat(n,"_fmModAmount);\n                if (effectiveFmIndex > 10.0f) effectiveFmIndex = 10.0f;  // Clamp to max\n\n                // Apply FM: phase modulation scaled by effective index\n                float fmOffset = modSignal * effectiveFmIndex * basePhaseInc;\n                float effectivePhaseInc = basePhaseInc + fmOffset;\n\n                // Constrain to prevent aliasing (max ~20kHz at 44.1kHz sample rate)\n                if (effectivePhaseInc > 0.45f) effectivePhaseInc = 0.45f;\n                if (effectivePhaseInc < 0.0f) effectivePhaseInc = 0.0f;\n                #else\n                // FM disabled - no modulation overhead\n                float effectivePhaseInc = basePhaseInc;\n                #endif\n\n                // Carrier phase accumulator\n                float phase = polyosc").concat(n,"_phase[v];\n                phase += effectivePhaseInc;\n                if (phase >= 1.0f) phase -= 1.0f;\n                polyosc").concat(n,"_phase[v] = phase;\n\n                // Wavetable morphing lookup with linear interpolation\n                // wtPos: 0-3 range, morphs smoothly between 4 wavetables\n                float wtPos = polyosc").concat(n,"_wtPos;\n                if (wtPos < 0.0f) wtPos = 0.0f;\n                if (wtPos > 3.0f) wtPos = 3.0f;\n\n                int tableA = (int)wtPos;          // Lower table index (0-3)\n                int tableB = tableA + 1;           // Upper table index\n                if (tableB > 3) tableB = 3;        // Clamp to last table\n                float tableMix = wtPos - (float)tableA; // Interpolation factor (0-1)\n\n                // Phase position within table\n                float tablePos = phase * (float)POLYOSC").concat(n,"_TABLE_SIZE;\n                int idx1 = (int)tablePos;\n                float frac = tablePos - (float)idx1;\n                int idx2 = (idx1 + 1) & (POLYOSC").concat(n,"_TABLE_SIZE - 1); // Fast modulo for power-of-2\n\n                // Sample from table A with linear interpolation\n                float sampleA;\n                switch (tableA) {\n                    case 0: sampleA = polyosc").concat(n,"_table0[idx1] + (polyosc").concat(n,"_table0[idx2] - polyosc").concat(n,"_table0[idx1]) * frac; break;\n                    case 1: sampleA = polyosc").concat(n,"_table1[idx1] + (polyosc").concat(n,"_table1[idx2] - polyosc").concat(n,"_table1[idx1]) * frac; break;\n                    case 2: sampleA = polyosc").concat(n,"_table2[idx1] + (polyosc").concat(n,"_table2[idx2] - polyosc").concat(n,"_table2[idx1]) * frac; break;\n                    default: sampleA = polyosc").concat(n,"_table3[idx1] + (polyosc").concat(n,"_table3[idx2] - polyosc").concat(n,"_table3[idx1]) * frac; break;\n                }\n\n                // Sample from table B with linear interpolation\n                float sampleB;\n                switch (tableB) {\n                    case 0: sampleB = polyosc").concat(n,"_table0[idx1] + (polyosc").concat(n,"_table0[idx2] - polyosc").concat(n,"_table0[idx1]) * frac; break;\n                    case 1: sampleB = polyosc").concat(n,"_table1[idx1] + (polyosc").concat(n,"_table1[idx2] - polyosc").concat(n,"_table1[idx1]) * frac; break;\n                    case 2: sampleB = polyosc").concat(n,"_table2[idx1] + (polyosc").concat(n,"_table2[idx2] - polyosc").concat(n,"_table2[idx1]) * frac; break;\n                    default: sampleB = polyosc").concat(n,"_table3[idx1] + (polyosc").concat(n,"_table3[idx2] - polyosc").concat(n,"_table3[idx1]) * frac; break;\n                }\n\n                // Crossfade between tables\n                float sample = sampleA + (sampleB - sampleA) * tableMix;\n\n                // Apply envelope, velocity and pan\n                float voiceOut = sample * env * polyosc").concat(n,"_velocity[v];\n                mixL += voiceOut * polyosc").concat(n,"_panL[v];\n                mixR += voiceOut * polyosc").concat(n,"_panR[v];\n            }\n\n            // Apply master gain ").concat(oe?"with modulation from LFO/ADSR":"","\n            float finalGain = polyosc").concat(n,"_gain").concat(oe?" * ".concat(oe):"",";\n            polyosc").concat(n,"_outputL = mixL * finalGain;\n            polyosc").concat(n,"_outputR = mixR * finalGain;\n        }\n")}},{key:"generateVCACode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gain"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&("inL"===n.to.port||"in"===n.to.port)}),c="vca".concat(n,"_gain"),r="0.0";if(a){var i=a.from.id.split(":")[0],l=this.connectionResolver.modules.find(function(e){return e.id===i});if(l){var s,u=(null===(s=i.match(/\d+$/))||void 0===s?void 0:s[0])||"1";switch(l.type){case"ADSR":c="adsr".concat(u,"_output");break;case"Pot":var d=l.params.index||u;c="pot".concat(d,"_value");break;case"LFO":c="lfo".concat(u,"_output");break;case"Scale":c="scale".concat(u,"_output");break;case"Modulation":c="modulation".concat(u,"_output");break;default:c="1.0"}}}if(o){var p=o.from.id.split(":")[0],f=this.connectionResolver.modules.find(function(e){return e.id===p});if(f){var m,_=(null===(m=p.match(/\d+$/))||void 0===m?void 0:m[0])||"1";switch(f.type){case"Oscillator":r="osc".concat(_,"_outputL");break;case"Filter":r="filter".concat(_,"_outputL");break;case"VCA":r="vca".concat(_,"_outputL");break;case"AudioMath":r="audioMath".concat(_,"_outputL");break;case"Noise":r="noise".concat(_,"_output");break;case"Delay":r="delay".concat(_,"_outputL");break;case"CleanReverb":r="cleanreverb".concat(_,"_outputL");break;case"Panner":r="panner".concat(_,"_outputL");break;case"StereoMixer4":r="stereoMixer4_".concat(_,"_outputL");break;case"Matrix2x2":r="matrix2x2_".concat(_,"_outputL");break;case"SamplePlayer":r="samplePlayer".concat(_,"_outputL");break;case"KickDrum":r="kickDrum".concat(_,"_output");break;case"SnareDrum":r="snareDrum".concat(_,"_output");break;case"Wavetable":r="wavetable".concat(_,"_outputL");break;case"GranularDense":r="granularDense".concat(_,"_outputL");break;case"ChorusFlangeRing":r="chorusFlangeRing".concat(_,"_outputL");break;case"Limiter":r="limiter".concat(_,"_outputL");break;case"NoiseGate":r="noiseGate".concat(_,"_outputL");break;case"EQ8":r="eq8_".concat(_,"_outputL");break;case"Percussion":r="percussion".concat(_,"_output");break;default:r="0.0"}}}return"\n        // VCA ".concat(n," processing\n        {\n            float gain = ").concat(a?"".concat(c," * vca").concat(n,"_gain"):c,";\n            // CRITICAL FIX: Read from input variables set by connection system\n            // OLD BROKEN: float inputL = ").concat(r,"; // Bypassed connections!\n            float inputL = vca").concat(n,"_inputL;\n            float inputR = vca").concat(n,"_inputR;\n\n            // Smooth gain changes to prevent clicking (10% per sample smoothing)\n            vca").concat(n,"_lastGain = vca").concat(n,"_lastGain * 0.9 + gain * 0.1;\n\n            vca").concat(n,"_outputL = inputL * vca").concat(n,"_lastGain;\n            vca").concat(n,"_outputR = inputR * vca").concat(n,"_lastGain;\n        }\n")}},{key:"generateI2SOutCode",value:function(e,n,t){var a=t.find(function(n){return n.to===e.id&&("L"===n.toPort||"inL"===n.toPort)}),o=t.find(function(n){return n.to===e.id&&("R"===n.toPort||"inR"===n.toPort)}),c="0.0",r="0.0";if(a){var i=a.from,l=this.connectionResolver.modules.find(function(e){return e.id===i});if(l){var s,u=(null===(s=i.match(/\d+$/))||void 0===s?void 0:s[0])||"1";switch(l.type){case"VCA":c="vca".concat(u,"_outputL");break;case"Filter":c="filter".concat(u,"_outputL");break;case"Oscillator":c="osc".concat(u,"_outputL");break;case"Delay":c="delay".concat(u,"_outputL");break;case"AudioMath":c="audioMath".concat(u,"_outputL");break;case"Noise":c="noise".concat(u,"_output");break;case"Panner":c="panner".concat(u,"_outputL");break;case"StereoMixer4":c="stereoMixer4_".concat(u,"_outputL");break;case"Matrix2x2":c="matrix2x2_".concat(u,"_outputL");break;case"SamplePlayer":c="samplePlayer".concat(u,"_outputL");break;case"KickDrum":c="kickDrum".concat(u,"_output");break;case"SnareDrum":c="snareDrum".concat(u,"_output");break;case"Wavetable":c="wavetable".concat(u,"_outputL");break;case"GranularDense":c="granular".concat(u,"_outputL");break;case"ChorusFlangeRing":c="chorusFlangeRing".concat(u,"_outputL");break;case"Limiter":c="limiter".concat(u,"_outputL");break;case"NoiseGate":c="noiseGate".concat(u,"_outputL");break;case"EQ8":c="eq8_".concat(u,"_outputL");break;case"Percussion":c="percussion".concat(u,"_output");break;default:c="0.0"}}}if(o){var d=o.from,p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"VCA":r="vca".concat(m,"_outputR");break;case"Filter":r="filter".concat(m,"_outputR");break;case"Oscillator":r="osc".concat(m,"_outputR");break;case"Delay":r="delay".concat(m,"_outputR");break;case"AudioMath":r="audioMath".concat(m,"_outputR");break;case"Noise":r="noise".concat(m,"_output");break;case"CleanReverb":r="cleanreverb".concat(m,"_outputR");break;case"Panner":r="panner".concat(m,"_outputR");break;case"StereoMixer4":r="stereoMixer4_".concat(m,"_outputR");break;case"Matrix2x2":r="matrix2x2_".concat(m,"_outputR");break;case"SamplePlayer":r="samplePlayer".concat(m,"_outputR");break;case"KickDrum":r="kickDrum".concat(m,"_output");break;case"SnareDrum":r="snareDrum".concat(m,"_output");break;case"Wavetable":r="wavetable".concat(m,"_outputR");break;case"GranularDense":r="granular".concat(m,"_outputR");break;case"ChorusFlangeRing":r="chorusFlangeRing".concat(m,"_outputR");break;case"Limiter":r="limiter".concat(m,"_outputR");break;case"NoiseGate":r="noiseGate".concat(m,"_outputR");break;case"EQ8":r="eq8_".concat(m,"_outputR");break;case"Percussion":r="percussion".concat(m,"_output");break;default:r="0.0"}}}return"\n        // I2S Output ".concat(n," - Send to DAC\n        {\n            float inputL = ").concat(c,";\n            float inputR = ").concat(r,";\n\n            i2sout").concat(n,"_inputL = inputL * i2sout").concat(n,"_volume;\n            i2sout").concat(n,"_inputR = inputR * i2sout").concat(n,"_volume;\n\n            // DEBUG: Print I2S input signals every 500ms\n            static unsigned long i2sDebugTime_").concat(n," = 0;\n            if (i == 0 && millis() - i2sDebugTime_").concat(n," > 500) { // Only print once per buffer\n                i2sDebugTime_").concat(n,' = millis();\n                Serial.print("I2S').concat(n,' - inputL=");\n                Serial.print(inputL);\n                Serial.print(", inputR=");\n                Serial.print(inputR);\n                Serial.print(", vol=");\n                Serial.print(i2sout').concat(n,'_volume);\n                Serial.print(", outL=");\n                Serial.println(i2sout').concat(n,"_inputL);\n            }\n\n            // Convert to 16-bit signed integers and add to main audio buffers\n            leftBuffer[i] = i2sout").concat(n,"_inputL;\n            rightBuffer[i] = i2sout").concat(n,"_inputR;\n        }\n")}},{key:"generateWavetableCode",value:function(e,n,t){t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"freq"===n.to.port});var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"note"===n.to.port}),o=(t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"morph"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"table_select"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"fm"===n.to.port})),c=!!a;return"\n        // Wavetable ".concat(n," processing\n        {\n            // Control processing\n            ").concat(this.generateWavetableControlProcessing(e,n,t),"\n\n            // Audio generation\n            if (wt").concat(n,"_gate > 0.5) {\n                // FM synthesis: modulate frequency with audio-rate input\n                float wt").concat(n,"_fm_input = 0.0;\n                ").concat(o?this.generateWavetableFMConnection(o,n):"","\n\n                // FM ratio mapping with musical detent zones (applied to fm_amount)\n                float cv = wt").concat(n,"_fm_ratio_cv;\n                float computed_ratio;\n                if (cv < 0.1) {\n                    computed_ratio = 0.5; // 1:2 (octave below)\n                } else if (cv < 0.15) {\n                    computed_ratio = 0.5 + (cv - 0.1) * 3.34; // Smooth to 0.667\n                } else if (cv < 0.25) {\n                    computed_ratio = 0.667; // 2:3 (perfect fifth down)\n                } else if (cv < 0.3) {\n                    computed_ratio = 0.667 + (cv - 0.25) * 6.66; // Smooth to 1.0\n                } else if (cv < 0.4) {\n                    computed_ratio = 1.0; // 1:1 (unison)\n                } else if (cv < 0.45) {\n                    computed_ratio = 1.0 + (cv - 0.4) * 10.0; // Smooth to 1.5\n                } else if (cv < 0.55) {\n                    computed_ratio = 1.5; // 3:2 (perfect fifth)\n                } else if (cv < 0.6) {\n                    computed_ratio = 1.5 + (cv - 0.55) * 10.0; // Smooth to 2.0\n                } else if (cv < 0.7) {\n                    computed_ratio = 2.0; // 2:1 (octave)\n                } else if (cv < 0.75) {\n                    computed_ratio = 2.0 + (cv - 0.7) * 20.0; // Smooth to 3.0\n                } else if (cv < 0.85) {\n                    computed_ratio = 3.0; // 3:1\n                } else if (cv < 0.9) {\n                    computed_ratio = 3.0 + (cv - 0.85) * 20.0; // Smooth to 4.0\n                } else {\n                    computed_ratio = 4.0; // 4:1 (two octaves)\n                }\n\n                // FM modulation (classic FM: fm_amount controls depth, ratio controls frequency)\n                float fm_freq_offset = wt").concat(n,"_fm_input * wt").concat(n,"_fm_amount * wt").concat(n,"_freq;\n                float effective_freq = wt").concat(n,"_freq + fm_freq_offset;\n                effective_freq = constrain(effective_freq, 1.0, 20000.0);\n\n                // Phase increment calculation with FM\n                float phaseIncrement = (effective_freq * WT").concat(n,"_TABLE_SIZE) / SAMPLE_RATE;\n                wt").concat(n,"_phase += phaseIncrement;\n\n                // Keep phase in range [0, TABLE_SIZE) - OPTIMIZED: Single if instead of while loop\n                if (wt").concat(n,"_phase >= WT").concat(n,"_TABLE_SIZE) {\n                    wt").concat(n,"_phase -= WT").concat(n,"_TABLE_SIZE;\n                }\n\n                // Linear interpolation for smooth playback\n                int index1 = (int)wt").concat(n,"_phase;\n                int index2 = (index1 + 1) % WT").concat(n,"_TABLE_SIZE;\n                float frac = wt").concat(n,"_phase - index1;\n\n                // Select wavetable based on current table or morphing\n                float* currentTable;\n                float sample = 0.0;\n\n                if (wt").concat(n,"_morph <= 0.0) {\n                    // Use table 0\n                    currentTable = wt").concat(n,"_table0;\n                    sample = currentTable[index1] * (1.0 - frac) + currentTable[index2] * frac;\n                } else if (wt").concat(n,"_morph < 1.0) {\n                    // Morph between table 0 and table 1\n                    float sample0 = wt").concat(n,"_table0[index1] * (1.0 - frac) + wt").concat(n,"_table0[index2] * frac;\n                    float sample1 = wt").concat(n,"_table1[index1] * (1.0 - frac) + wt").concat(n,"_table1[index2] * frac;\n                    sample = sample0 * (1.0 - wt").concat(n,"_morph) + sample1 * wt").concat(n,"_morph;\n                } else if (wt").concat(n,"_morph < 2.0) {\n                    // Morph between table 1 and table 2\n                    float morphFrac = wt").concat(n,"_morph - 1.0;\n                    float sample1 = wt").concat(n,"_table1[index1] * (1.0 - frac) + wt").concat(n,"_table1[index2] * frac;\n                    float sample2 = wt").concat(n,"_table2[index1] * (1.0 - frac) + wt").concat(n,"_table2[index2] * frac;\n                    sample = sample1 * (1.0 - morphFrac) + sample2 * morphFrac;\n                } else {\n                    // Morph between table 2 and table 3\n                    float morphFrac = constrain(wt").concat(n,"_morph - 2.0, 0.0, 1.0);\n                    float sample2 = wt").concat(n,"_table2[index1] * (1.0 - frac) + wt").concat(n,"_table2[index2] * frac;\n                    float sample3 = wt").concat(n,"_table3[index1] * (1.0 - frac) + wt").concat(n,"_table3[index2] * frac;\n                    sample = sample2 * (1.0 - morphFrac) + sample3 * morphFrac;\n                }\n\n                // Apply gain").concat(c?" and velocity":"","\n                wt").concat(n,"_outputL = sample * wt").concat(n,"_gain").concat(c?" * wt"+n+"_velocity":"",";\n                wt").concat(n,"_outputR = wt").concat(n,"_outputL; // Mono for now\n            } else {\n                wt").concat(n,"_outputL = 0.0;\n                wt").concat(n,"_outputR = 0.0;\n            }\n        }\n")}},{key:"generateGranularCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"grain_density"===n.to.port}),r=(t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"grain_size_ms"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"position"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"dry_wet"===n.to.port}),"0.0"),i="0.0",l="granular".concat(n,"_grain_density"),s="granular".concat(n,"_grain_size_ms"),u="granular".concat(n,"_position"),d="granular".concat(n,"_pitch"),p="granular".concat(n,"_dry_wet");if(a){var f=a.from.id.split(":")[0],m=this.connectionResolver.modules.find(function(e){return e.id===f});if(m){var _,g=(null===(_=f.match(/\d+$/))||void 0===_?void 0:_[0])||"1";switch(m.type){case"Oscillator":r="osc".concat(g,"_outputL");break;case"VCA":r="vca".concat(g,"_outputL")}}}if(o){var h=o.from.id.split(":")[0],v=this.connectionResolver.modules.find(function(e){return e.id===h});if(v){var b,y=(null===(b=h.match(/\d+$/))||void 0===b?void 0:b[0])||"1";switch(v.type){case"Oscillator":i="osc".concat(y,"_outputR");break;case"VCA":i="vca".concat(y,"_outputR")}}}if(c){var k=c.from.id.split(":")[0],x=this.connectionResolver.modules.find(function(e){return e.id===k});if(x){var S,E=(null===(S=k.match(/\d+$/))||void 0===S?void 0:S[0])||"1";"Pot"===x.type&&(l="(pot".concat(E,"_value * 32.0 + 0.5)"))}}return"\n        // GranularSynth ".concat(n," processing\n        {\n            float inputL = ").concat(r,";\n            float inputR = ").concat(i,";\n            float density = ").concat(l,";\n            float grain_size = ").concat(s,";\n            float position = ").concat(u,";\n            float pitch = ").concat(d,";\n            float dry_wet = ").concat(p,";\n\n            // Write input to circular buffer\n            granular").concat(n,"_buffer_L[granular").concat(n,"_write_pos] = inputL;\n            granular").concat(n,"_buffer_R[granular").concat(n,"_write_pos] = inputR;\n            granular").concat(n,"_write_pos = (granular").concat(n,"_write_pos + 1) % granular").concat(n,"_buffer_size;\n\n            // Update grain interval based on density\n            granular").concat(n,"_grain_interval_ms = 1000.0 / density;\n\n            // Trigger new grains based on density\n            unsigned long currentTime = millis();\n            if (currentTime - granular").concat(n,"_last_grain_trigger >= granular").concat(n,"_grain_interval_ms) {\n                // Find inactive grain slot\n                for (int g = 0; g < 4; g++) {\n                    if (!granular").concat(n,"_grains[g].active) {\n                        // Activate new grain\n                        granular").concat(n,"_grains[g].active = true;\n                        granular").concat(n,"_grains[g].position = position + ((random(-100, 100) / 100.0) * granular").concat(n,"_position_spread);\n                        granular").concat(n,"_grains[g].pitch_ratio = 1.0 + pitch + ((random(-100, 100) / 100.0) * granular").concat(n,"_pitch_spread);\n                        granular").concat(n,"_grains[g].amplitude = 0.25; // 1/4 volume per grain for 4 concurrent grains\n                        granular").concat(n,"_grains[g].grain_size_samples = (int)(grain_size * 44.1); // ms to samples\n                        granular").concat(n,"_grains[g].samples_remaining = granular").concat(n,"_grains[g].grain_size_samples;\n                        break;\n                    }\n                }\n                granular").concat(n,"_last_grain_trigger = currentTime;\n            }\n\n            // Process all active grains\n            float outputL = 0.0;\n            float outputR = 0.0;\n\n            for (int g = 0; g < 4; g++) {\n                if (granular").concat(n,"_grains[g].active) {\n                    // Calculate buffer position for this grain\n                    float bufferPos = granular").concat(n,"_grains[g].position * granular").concat(n,"_buffer_size;\n                    int pos = (int)bufferPos % granular").concat(n,"_buffer_size;\n\n                    // Apply envelope (simple triangular)\n                    float envelope = 1.0;\n                    float progress = (float)(granular").concat(n,"_grains[g].grain_size_samples - granular").concat(n,"_grains[g].samples_remaining) / granular").concat(n,"_grains[g].grain_size_samples;\n                    if (progress < 0.5) {\n                        envelope = progress * 2.0; // Attack\n                    } else {\n                        envelope = 2.0 - (progress * 2.0); // Release\n                    }\n\n                    // Read from buffer and apply grain\n                    outputL += granular").concat(n,"_buffer_L[pos] * granular").concat(n,"_grains[g].amplitude * envelope;\n                    outputR += granular").concat(n,"_buffer_R[pos] * granular").concat(n,"_grains[g].amplitude * envelope;\n\n                    // Update grain state\n                    granular").concat(n,"_grains[g].samples_remaining--;\n                    if (granular").concat(n,"_grains[g].samples_remaining <= 0) {\n                        granular").concat(n,"_grains[g].active = false;\n                    }\n\n                    // Update position based on pitch\n                    granular").concat(n,"_grains[g].position += granular").concat(n,"_grains[g].pitch_ratio / granular").concat(n,"_buffer_size;\n                    if (granular").concat(n,"_grains[g].position >= 1.0) {\n                        granular").concat(n,"_grains[g].position -= 1.0;\n                    }\n                }\n            }\n\n            // Mix dry and processed signals\n            granular").concat(n,"_outputL = (inputL * (1.0 - dry_wet)) + (outputL * dry_wet);\n            granular").concat(n,"_outputR = (inputR * (1.0 - dry_wet)) + (outputR * dry_wet);\n        }\n")}},{key:"generateKickDrumCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"trigger"===n.to.port}),o="false";if(a){var c=a.from.id.split(":")[0],r=this.connectionResolver.modules.find(function(e){return e.id===c});if(r){var i,l=(null===(i=c.match(/\d+$/))||void 0===i?void 0:i[0])||"1";switch(r.type){case"LEDButton":var s=r.params.index||1;o="btn".concat(s,"_pressed");break;case"Clock":o="clock".concat(l,"_output")}}}return"\n        // KickDrum ".concat(n," - Multi-Layer Drum Synthesizer (Sample + Oscillator + Noise)\n        {\n            bool trigger = ").concat(o,";\n\n            // Trigger all layers on rising edge\n            static bool kick").concat(n,"_lastTrigger = false;\n            if (trigger && !kick").concat(n,"_lastTrigger) {\n                // Sample layer trigger\n                if (kick").concat(n,"_lastLoadedFile != kick").concat(n,'_currentFile) {\n                    String filename = "/kick0" + String(kick').concat(n,'_currentFile) + ".wav";\n                    if (SD.exists(filename)) {\n                        kick').concat(n,"_player.loadFile(filename);\n                        kick").concat(n,"_lastLoadedFile = kick").concat(n,"_currentFile;\n                        kick").concat(n,"_currentFileName = filename;\n                    }\n                }\n                kick").concat(n,"_player.setPlaybackSpeed(kick").concat(n,"_sample_pitch);\n                kick").concat(n,"_player.play();\n\n                // Oscillator layer trigger\n                kick").concat(n,"_osc_amp_stage = 1; // Start attack\n                kick").concat(n,"_osc_amp_time = 0.0;\n\n                // Pitch envelope trigger\n                kick").concat(n,"_pitch_env_stage = 1; // Start attack\n                kick").concat(n,"_pitch_env_time = 0.0;\n                kick").concat(n,"_osc_pitch_env = 0.0; // Start at zero, build up to amount\n\n                // Noise layer trigger\n                kick").concat(n,"_noise_amp_stage = 1; // Start noise attack\n                kick").concat(n,"_noise_amp_time = 0.0;\n\n                kick").concat(n,"_triggered = true;\n            }\n            kick").concat(n,"_lastTrigger = trigger;\n\n            // === SAMPLE LAYER PROCESSING ===\n            if (kick").concat(n,"_player.playing()) {\n                int16_t sample = kick").concat(n,"_player.getNextSample();\n                float sampleFloat = (float)sample / 32767.0f;\n                kick").concat(n,"_sample_outputL = sampleFloat * kick").concat(n,"_sample_gain;\n                kick").concat(n,"_sample_outputR = kick").concat(n,"_sample_outputL;\n            } else {\n                kick").concat(n,"_sample_outputL = 0.0;\n                kick").concat(n,"_sample_outputR = 0.0;\n            }\n\n            // === OSCILLATOR LAYER PROCESSING ===\n            kick").concat(n,"_osc_outputL = 0.0;\n            kick").concat(n,"_osc_outputR = 0.0;\n\n            if (kick").concat(n,"_osc_amp_stage > 0) {\n                float sampleTime = 1.0 / SAMPLE_RATE;\n                kick").concat(n,"_osc_amp_time += sampleTime;\n\n                // Oscillator amplitude envelope\n                switch (kick").concat(n,"_osc_amp_stage) {\n                    case 1: // Attack\n                        if (kick").concat(n,"_osc_amp_time >= kick").concat(n,"_osc_amp_attack) {\n                            kick").concat(n,"_osc_amp_stage = 2;\n                            kick").concat(n,"_osc_amp_time = 0.0;\n                            kick").concat(n,"_osc_amp_env = 1.0;\n                        } else {\n                            kick").concat(n,"_osc_amp_env = kick").concat(n,"_osc_amp_time / kick").concat(n,"_osc_amp_attack;\n                        }\n                        break;\n\n                    case 2: // Decay\n                        if (kick").concat(n,"_osc_amp_time >= kick").concat(n,"_osc_amp_decay) {\n                            kick").concat(n,"_osc_amp_stage = 3;\n                            kick").concat(n,"_osc_amp_time = 0.0;\n                        } else {\n                            float progress = kick").concat(n,"_osc_amp_time / kick").concat(n,"_osc_amp_decay;\n                            kick").concat(n,"_osc_amp_env = 1.0 - progress * (1.0 - kick").concat(n,"_osc_amp_sustain);\n                        }\n                        break;\n\n                    case 3: // Sustain\n                        kick").concat(n,"_osc_amp_env = kick").concat(n,"_osc_amp_sustain;\n                        if (!trigger) {\n                            kick").concat(n,"_osc_amp_stage = 4; // Release\n                            kick").concat(n,"_osc_amp_time = 0.0;\n                        }\n                        break;\n\n                    case 4: // Release\n                        if (kick").concat(n,"_osc_amp_time >= kick").concat(n,"_osc_amp_release) {\n                            kick").concat(n,"_osc_amp_stage = 0; // Idle\n                            kick").concat(n,"_osc_amp_env = 0.0;\n                        } else {\n                            float progress = kick").concat(n,"_osc_amp_time / kick").concat(n,"_osc_amp_release;\n                            kick").concat(n,"_osc_amp_env = kick").concat(n,"_osc_amp_sustain * (1.0 - progress);\n                        }\n                        break;\n                }\n\n                // Pitch envelope ADSR processing\n                if (kick").concat(n,"_pitch_env_stage > 0) {\n                    kick").concat(n,"_pitch_env_time += sampleTime;\n\n                    switch (kick").concat(n,"_pitch_env_stage) {\n                        case 1: // Attack\n                            if (kick").concat(n,"_pitch_env_time >= kick").concat(n,"_pitch_env_attack) {\n                                kick").concat(n,"_pitch_env_stage = 2;\n                                kick").concat(n,"_pitch_env_time = 0.0;\n                                kick").concat(n,"_osc_pitch_env = kick").concat(n,"_pitch_env_amount;\n                            } else {\n                                kick").concat(n,"_osc_pitch_env = (kick").concat(n,"_pitch_env_time / kick").concat(n,"_pitch_env_attack) * kick").concat(n,"_pitch_env_amount;\n                            }\n                            break;\n\n                        case 2: // Decay\n                            if (kick").concat(n,"_pitch_env_time >= kick").concat(n,"_pitch_env_decay) {\n                                kick").concat(n,"_pitch_env_stage = 3;\n                                kick").concat(n,"_pitch_env_time = 0.0;\n                                kick").concat(n,"_osc_pitch_env = kick").concat(n,"_pitch_env_amount * kick").concat(n,"_pitch_env_sustain;\n                            } else {\n                                float progress = kick").concat(n,"_pitch_env_time / kick").concat(n,"_pitch_env_decay;\n                                kick").concat(n,"_osc_pitch_env = kick").concat(n,"_pitch_env_amount * (1.0 - progress * (1.0 - kick").concat(n,"_pitch_env_sustain));\n                            }\n                            break;\n\n                        case 3: // Sustain\n                            kick").concat(n,"_osc_pitch_env = kick").concat(n,"_pitch_env_amount * kick").concat(n,"_pitch_env_sustain;\n                            if (!trigger) {\n                                kick").concat(n,"_pitch_env_stage = 4; // Release\n                                kick").concat(n,"_pitch_env_time = 0.0;\n                            }\n                            break;\n\n                        case 4: // Release\n                            if (kick").concat(n,"_pitch_env_time >= kick").concat(n,"_pitch_env_release) {\n                                kick").concat(n,"_pitch_env_stage = 0; // Idle\n                                kick").concat(n,"_osc_pitch_env = 0.0;\n                            } else {\n                                float progress = kick").concat(n,"_pitch_env_time / kick").concat(n,"_pitch_env_release;\n                                kick").concat(n,"_osc_pitch_env = (kick").concat(n,"_pitch_env_amount * kick").concat(n,"_pitch_env_sustain) * (1.0 - progress);\n                            }\n                            break;\n                    }\n                }\n\n                // Generate oscillator with pitch modulation\n                if (!kick").concat(n,"_osc_mute && kick").concat(n,"_osc_amp_env > 0.001) {\n                    float pitchMod = pow(2.0, kick").concat(n,"_osc_pitch_env);\n                    float oscFreq = kick").concat(n,"_osc_freq * pitchMod;\n                    kick").concat(n,"_osc_phase += 2.0 * PI * oscFreq / SAMPLE_RATE;\n                    if (kick").concat(n,"_osc_phase >= 2.0 * PI) kick").concat(n,"_osc_phase -= 2.0 * PI;\n\n                    float osc_sample = sin(kick").concat(n,"_osc_phase);\n\n                    // Apply distortion if enabled\n                    if (kick").concat(n,"_osc_distortion > 0.0) {\n                        float drive = 1.0 + kick").concat(n,"_osc_distortion; // 1-11 range\n                        osc_sample *= drive;\n                        osc_sample = tanh(osc_sample); // Soft saturation\n                    }\n\n                    osc_sample *= kick").concat(n,"_osc_level * kick").concat(n,"_osc_amp_env;\n                    kick").concat(n,"_osc_outputL = osc_sample;\n                    kick").concat(n,"_osc_outputR = osc_sample;\n                } else if (kick").concat(n,"_osc_amp_stage == 0) {\n                    // Reset phase when envelope is idle to prevent artifacts on retrigger\n                    kick").concat(n,"_osc_phase = 0.0;\n                }\n            }\n\n            // === NOISE LAYER PROCESSING ===\n            kick").concat(n,"_noise_outputL = 0.0;\n            kick").concat(n,"_noise_outputR = 0.0;\n\n            if (kick").concat(n,"_noise_amp_stage > 0) {\n                float sampleTime = 1.0 / SAMPLE_RATE;\n                kick").concat(n,"_noise_amp_time += sampleTime;\n\n                // Noise amplitude envelope\n                switch (kick").concat(n,"_noise_amp_stage) {\n                    case 1: // Attack\n                        if (kick").concat(n,"_noise_amp_time >= kick").concat(n,"_noise_amp_attack) {\n                            kick").concat(n,"_noise_amp_stage = 2;\n                            kick").concat(n,"_noise_amp_time = 0.0;\n                            kick").concat(n,"_noise_amp_env = 1.0;\n                        } else {\n                            kick").concat(n,"_noise_amp_env = kick").concat(n,"_noise_amp_time / kick").concat(n,"_noise_amp_attack;\n                        }\n                        break;\n\n                    case 2: // Decay\n                        if (kick").concat(n,"_noise_amp_time >= kick").concat(n,"_noise_amp_decay) {\n                            kick").concat(n,"_noise_amp_stage = 3;\n                            kick").concat(n,"_noise_amp_time = 0.0;\n                        } else {\n                            float progress = kick").concat(n,"_noise_amp_time / kick").concat(n,"_noise_amp_decay;\n                            kick").concat(n,"_noise_amp_env = 1.0 - progress * (1.0 - kick").concat(n,"_noise_amp_sustain);\n                        }\n                        break;\n\n                    case 3: // Sustain\n                        kick").concat(n,"_noise_amp_env = kick").concat(n,"_noise_amp_sustain;\n                        if (!trigger) {\n                            kick").concat(n,"_noise_amp_stage = 4; // Release\n                            kick").concat(n,"_noise_amp_time = 0.0;\n                        }\n                        break;\n\n                    case 4: // Release\n                        if (kick").concat(n,"_noise_amp_time >= kick").concat(n,"_noise_amp_release) {\n                            kick").concat(n,"_noise_amp_stage = 0; // Idle\n                            kick").concat(n,"_noise_amp_env = 0.0;\n                        } else {\n                            float progress = kick").concat(n,"_noise_amp_time / kick").concat(n,"_noise_amp_release;\n                            kick").concat(n,"_noise_amp_env = kick").concat(n,"_noise_amp_sustain * (1.0 - progress);\n                        }\n                        break;\n                }\n\n                // Generate noise with FPU-safe implementation\n                if (kick").concat(n,"_noise_amp_env > 0.001) {\n                    float white_noise = 0.0;\n                    float pink_noise = 0.0;\n                    float brown_noise = 0.0;\n\n                    // FPU-safe LCG noise generation (isolated from oscillator)\n                    uint32_t temp_seed = kick").concat(n,"_noise_lcg_seed;\n                    temp_seed = (temp_seed * 1103515245U + 12345U) & 0x7FFFFFFFU;\n                    kick").concat(n,"_noise_lcg_seed = temp_seed;\n                    int32_t noise_int = (int32_t)(temp_seed & 0xFFFF) - 32768;\n                    white_noise = (float)noise_int * (1.0f / 32768.0f);\n\n                    // Simple noise approximations (FPU-safe for now)\n                    pink_noise = white_noise * 0.5; // Scaled approximation\n                    brown_noise = white_noise * 0.3; // Scaled approximation\n\n                    // Mix noise types based on current type and morph\n                    float noise_output = 0.0;\n                    if (kick").concat(n,"_noise_type == 0) {\n                        // White noise base - morph towards pink\n                        noise_output = white_noise * (1.0 - kick").concat(n,"_noise_morph) + pink_noise * kick").concat(n,"_noise_morph;\n                    } else if (kick").concat(n,"_noise_type == 1) {\n                        // Pink noise base - morph towards brown\n                        noise_output = pink_noise * (1.0 - kick").concat(n,"_noise_morph) + brown_noise * kick").concat(n,"_noise_morph;\n                    } else if (kick").concat(n,"_noise_type == 2) {\n                        // Brown noise base - morph towards white\n                        noise_output = brown_noise * (1.0 - kick").concat(n,"_noise_morph) + white_noise * kick").concat(n,"_noise_morph;\n                    }\n\n                    float final_noise = noise_output * kick").concat(n,"_noise_gain * kick").concat(n,"_noise_amp_env;\n                    kick").concat(n,"_noise_outputL = final_noise;\n                    kick").concat(n,"_noise_outputR = final_noise;\n                }\n            }\n\n            // === LAYER MIXING ===\n            // Mix all active layers to master output\n            kick").concat(n,"_outputL = kick").concat(n,"_sample_outputL + kick").concat(n,"_osc_outputL + kick").concat(n,"_noise_outputL;\n            kick").concat(n,"_outputR = kick").concat(n,"_sample_outputR + kick").concat(n,"_osc_outputR + kick").concat(n,"_noise_outputR;\n        }\n")}},{key:"generateDrumDesignerCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"velocity"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch"===n.to.port}),r=(t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"damping"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"body_resonance"===n.to.port}),"false"),i="ks".concat(n,"_velocityInput"),l="ks".concat(n,"_pitch"),s="ks".concat(n,"_damping"),u="ks".concat(n,"_bodyResonance");if(a){var d=a.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d}),f=a.from.port;if(p){var m,_=(null===(m=d.match(/\d+$/))||void 0===m?void 0:m[0])||"1";switch(p.type){case"LEDButton":var g=p.params.index||1;r="btn".concat(g,"_gate");break;case"MIDIIn":r="midiin".concat(_,"_gate");break;case"GateGen":r="gate".concat(_,"_output");break;case"Clock":var h=f.replace("out","");r="clock".concat(_,"_out").concat(h)}}}if(o){var v=o.from.id.split(":")[0],b=this.connectionResolver.modules.find(function(e){return e.id===v});if(b){var y,k=(null===(y=v.match(/\d+$/))||void 0===y?void 0:y[0])||"1";"MIDIIn"===b.type&&(i="midiin".concat(k,"_velocity"))}}if(c){var x=c.from.id.split(":")[0],S=this.connectionResolver.modules.find(function(e){return e.id===x}),E=c.from.port;if(console.log("DrumDesigner".concat(n," pitch connection: fromId=").concat(x,", fromModule=").concat(S?S.type:"NOT FOUND",", fromPort=").concat(E)),S){var P,w=(null===(P=x.match(/\d+$/))||void 0===P?void 0:P[0])||"1";switch(console.log("  Extracted fromIndex=".concat(w," from ").concat(x)),S.type){case"MIDIIn":l="midiin".concat(w,"_note");break;case"LEDButton":var C=S.params.index||1;"sampleOut"===E&&(l="(btn".concat(C,"_sampleOut * 72.0 + 24.0)"));break;case"Pot":l="(pot".concat(w,"_value * 72.0 + 24.0)"),console.log("  Generated pitchSource: ".concat(l))}}}return"\n        // DrumDesigner ".concat(n," - Karplus-Strong Physical Modeling Synthesizer\n        {\n            // === CONTROL INPUT PROCESSING (100Hz control rate) ===\n            static unsigned long ks").concat(n,"_lastControlUpdate = 0;\n            if (currentTime - ks").concat(n,"_lastControlUpdate >= 10) { // 100Hz control rate\n                ks").concat(n,"_lastControlUpdate = currentTime;\n\n                ks").concat(n,"_velocityInput = ").concat(i,";\n                float currentPitch = ").concat(l,";\n                ks").concat(n,"_damping = ").concat(s,";\n                ks").concat(n,"_bodyResonance = ").concat(u,";\n\n                // Pre-calculate frequency from pitch at control rate (expensive powf!)\n                // frequency = 440 * 2^((note - 69) / 12)\n                float noteOffset = (currentPitch - 69.0f) + (ks").concat(n,"_fineTune / 100.0f);\n                ks").concat(n,"_currentFreq = 440.0f * powf(2.0f, noteOffset / 12.0f);\n\n                // Pre-calculate base sine frequency for sine oscillator\n                ks").concat(n,"_baseSineFreq = ks").concat(n,"_currentFreq;\n            }\n\n            // Gate input is audio-rate for accurate trigger timing\n            ks").concat(n,"_gateInput = ").concat(r,";\n\n            // === TRIGGER DETECTION ===\n            // Detect rising edge on gate input\n            bool trigger = (ks").concat(n,"_gateInput > 0.5f && !ks").concat(n,"_lastGate);\n            bool release = (ks").concat(n,"_gateInput < 0.5f && ks").concat(n,"_lastGate);\n\n            if (trigger) {\n                // Use pre-calculated frequency from control rate\n                ks").concat(n,"_delayLength = (int)(44100.0f / ks").concat(n,"_currentFreq);\n\n                // Clamp delay length to valid range\n                if (ks").concat(n,"_delayLength < 10) ks").concat(n,"_delayLength = 10;\n                if (ks").concat(n,"_delayLength > KS_MAX_DELAY_").concat(n,") ks").concat(n,"_delayLength = KS_MAX_DELAY_").concat(n,";\n\n                // Calculate pitch-dependent gain compensation for consistent amplitude\n                // Higher pitches (shorter delays) need more gain\n                // Reference pitch: MIDI 60 (C4, ~262Hz, delay ~168 samples)\n                float refDelayLength = 168.0f;\n                ks").concat(n,"_pitchGainComp = sqrtf((float)ks").concat(n,"_delayLength / refDelayLength);\n                // Clamp to prevent clipping on low pitches and excessive attenuation on high pitches\n                if (ks").concat(n,"_pitchGainComp > 1.5f) ks").concat(n,"_pitchGainComp = 1.5f;  // Max 1.5x gain\n                if (ks").concat(n,"_pitchGainComp < 0.7f) ks").concat(n,"_pitchGainComp = 0.7f;  // Min 0.7x gain\n\n                // Initialize delay line with excitation signal (FAST version using pre-generated noise)\n                // Fast copy from pre-generated noise buffer (100x faster than per-sample random())\n                memcpy(ks").concat(n,"_delayLine, ks").concat(n,"_noiseBuffer, ks").concat(n,"_delayLength * sizeof(float));\n\n                // Pitch-dependent excitation filtering for better bass response\n                // Low pitches (long delays) need heavily filtered excitation to emphasize fundamental\n                // High pitches (short delays) sound better with brighter excitation\n                float pitchFilterAmount = 0.0f;\n                if (ks").concat(n,"_delayLength > 512) {\n                    // Long delay (low pitch) - apply progressively more lowpass filtering\n                    // delayLength 512 (86 Hz) = no filter\n                    // delayLength 2048 (22 Hz) = heavy filter\n                    // delayLength 8192 (5 Hz) = very heavy filter\n                    pitchFilterAmount = (float)(ks").concat(n,"_delayLength - 512) / (float)(KS_MAX_DELAY_").concat(n," - 512);\n                    pitchFilterAmount = pitchFilterAmount * 0.9f; // Scale to 0.0-0.9 range\n                }\n\n                // Mode-dependent post-processing (optional filtering)\n                if (strcmp(ks").concat(n,'_mode, "tonal") == 0) {\n                    // TONAL MODE: Apply pitch-dependent filtering for bass response\n                    if (pitchFilterAmount > 0.01f) {\n                        // Low pitch detected - apply aggressive lowpass to excitation for bass emphasis\n                        // Multi-pass filtering for very low frequencies (each pass removes more highs)\n                        int numPasses = 1 + (int)(pitchFilterAmount * 3.0f); // 1-4 passes based on pitch\n                        float alpha = 0.1f + (pitchFilterAmount * 0.05f); // 0.1-0.15 (very aggressive lowpass)\n\n                        for (int pass = 0; pass < numPasses; pass++) {\n                            ks').concat(n,"_prevSample = 0.0f;\n                            for (int i = 0; i < ks").concat(n,"_delayLength; i++) {\n                                float excitation = ks").concat(n,"_delayLine[i];\n                                // Very aggressive lowpass (alpha 0.1 = 90% of previous sample)\n                                excitation = alpha * excitation + (1.0f - alpha) * ks").concat(n,"_prevSample;\n                                ks").concat(n,"_prevSample = excitation;\n                                ks").concat(n,"_delayLine[i] = excitation;\n                            }\n                        }\n\n                        // Compensate for energy loss from heavy filtering\n                        float gainBoost = 1.5f + (pitchFilterAmount * 2.0f); // 1.5x-3.5x gain for low freqs\n                        for (int i = 0; i < ks").concat(n,"_delayLength; i++) {\n                            ks").concat(n,"_delayLine[i] *= gainBoost;\n                        }\n                    }\n                    // High pitches use unfiltered noise for brightness\n\n                } else if (strcmp(ks").concat(n,'_mode, "percussive") == 0) {\n                    // PERCUSSIVE MODE: Apply brightness and position filtering for marimba-like sounds\n                    ks').concat(n,"_prevSample = 0.0f;\n                    for (int i = 0; i < ks").concat(n,"_delayLength; i++) {\n                        float excitation = ks").concat(n,"_delayLine[i];\n\n                        // Apply brightness filter (simple 1-pole lowpass)\n                        float alpha = ks").concat(n,"_brightness;\n                        excitation = alpha * excitation + (1.0f - alpha) * ks").concat(n,"_prevSample;\n                        ks").concat(n,"_prevSample = excitation;\n\n                        // Apply strike position (comb filtering effect)\n                        float positionPhase = (float)i / (float)ks").concat(n,"_delayLength;\n                        float positionMod = 1.0f - fabsf(positionPhase - ks").concat(n,"_position) * 0.5f;\n                        excitation *= positionMod;\n\n                        ks").concat(n,'_delayLine[i] = excitation;\n                    }\n\n                } else {  // "noise" mode\n                    // NOISE MODE: Heavy lowpass filtering for short, noisy hits\n                    ks').concat(n,"_prevSample = 0.0f;\n                    float alpha = 0.3f;\n                    for (int i = 0; i < ks").concat(n,"_delayLength; i++) {\n                        float excitation = ks").concat(n,"_delayLine[i];\n                        excitation = alpha * excitation + (1.0f - alpha) * ks").concat(n,"_prevSample;\n                        ks").concat(n,"_prevSample = excitation;\n                        ks").concat(n,"_delayLine[i] = excitation;\n                    }\n                }\n\n                // CRITICAL FIX: Set writePos to delayLength so readPos points to start of initialized data\n                // readPos = (writePos - delayLength + MAX) % MAX = (delayLength - delayLength + MAX) % MAX = 0\n                ks").concat(n,"_writePos = ks").concat(n,"_delayLength;\n\n                // Trigger amplitude envelope\n                ks").concat(n,"_ampStage = 1; // Attack\n                ks").concat(n,"_ampTime = 0.0f;\n                ks").concat(n,"_triggered = true;\n\n                // Initialize pitch sweep (sine or delay mode)\n                if (strcmp(ks").concat(n,'_pitchSweepMode, "sine") == 0) {\n                    // Sine oscillator pitch envelope (808 style)\n                    ks').concat(n,"_sinePitchStage = 1; // Attack (instant)\n                    ks").concat(n,"_sinePitchTime = 0.0f;\n                    ks").concat(n,"_sinePhase = 0.0f; // Reset phase for clean attack\n                } else if (strcmp(ks").concat(n,'_pitchSweepMode, "delay") == 0) {\n                    // K-S delay sweep (Boss delay feedback style)\n                    ks').concat(n,"_delayTarget = (float)ks").concat(n,"_delayLength;  // Store target delay\n                    ks").concat(n,"_delayCurrent = ks").concat(n,"_delayTarget * 0.1f; // Start at 10% (high pitch)\n                    ks").concat(n,"_delaySweepTime = 0.0f;\n                    ks").concat(n,"_delayLength = (int)ks").concat(n,"_delayCurrent;   // Use short delay initially\n                }\n            }\n\n            if (release && ks").concat(n,"_ampStage > 0 && ks").concat(n,"_ampStage < 4) {\n                // Gate released during attack/decay/sustain - enter release stage\n                ks").concat(n,"_ampStage = 4;\n                ks").concat(n,"_ampTime = 0.0f;\n            }\n\n            ks").concat(n,"_lastGate = (ks").concat(n,"_gateInput > 0.5f);\n\n            // Time step for all envelope/modulation calculations\n            const float dt = 1.0f / 44100.0f;\n\n            // === DELAY SWEEP (Boss delay pitch-drop effect) ===\n            if (strcmp(ks").concat(n,'_pitchSweepMode, "delay") == 0 && ks').concat(n,"_ampStage > 0) {\n                ks").concat(n,"_delaySweepTime += dt;\n\n                // Exponential sweep from short to long delay (high to low pitch)\n                if (ks").concat(n,"_delaySweepTime < ks").concat(n,"_sinePitchDecay) {\n                    float t = ks").concat(n,"_delaySweepTime / ks").concat(n,"_sinePitchDecay;\n                    float sweepEnv = 1.0f - expf(-4.0f * t);  // 0  1 exponential curve\n\n                    // Interpolate from 10% to 100% of target delay\n                    ks").concat(n,"_delayCurrent = (ks").concat(n,"_delayTarget * 0.1f) +\n                                             (sweepEnv * ks").concat(n,"_delayTarget * 0.9f);\n                    ks").concat(n,"_delayLength = (int)ks").concat(n,"_delayCurrent;\n\n                    // Clamp to valid range\n                    if (ks").concat(n,"_delayLength < 10) ks").concat(n,"_delayLength = 10;\n                    if (ks").concat(n,"_delayLength > KS_MAX_DELAY_").concat(n,") ks").concat(n,"_delayLength = KS_MAX_DELAY_").concat(n,";\n                } else {\n                    // Sweep complete - stay at target delay\n                    ks").concat(n,"_delayLength = (int)ks").concat(n,"_delayTarget;\n                }\n            }\n\n            // === KARPLUS-STRONG SYNTHESIS ===\n            float ksSample = 0.0f;\n\n            if (ks").concat(n,"_ampStage > 0) {\n                // Read from delay line (optimized wraparound, no modulo!)\n                int readPos = ks").concat(n,"_writePos - ks").concat(n,"_delayLength;\n                if (readPos < 0) readPos += KS_MAX_DELAY_").concat(n,";\n                float delaySample = ks").concat(n,"_delayLine[readPos];\n\n                // Mode-dependent damping filter\n                float filteredSample;\n\n                if (strcmp(ks").concat(n,'_mode, "tonal") == 0) {\n                    // TONAL MODE (Teensy-style): Fixed damping coefficient for guitar-like decay\n                    // 0.9973  (32686 + 32686) / 65536 from Teensy implementation\n                    // Creates very slow, tonal decay similar to acoustic guitar/bass\n                    float dampingCoeff = 0.9973f;\n                    filteredSample = dampingCoeff * delaySample + (1.0f - dampingCoeff) * ks').concat(n,"_prevSample;\n\n                } else if (strcmp(ks").concat(n,'_mode, "percussive") == 0) {\n                    // PERCUSSIVE MODE: Variable damping for marimba/xylophone-like sounds\n                    // Higher damping = faster decay, more high-frequency loss\n                    float dampingCoeff = 0.5f + (ks').concat(n,"_damping * 0.499f); // Range: 0.5 to 0.999\n                    filteredSample = dampingCoeff * delaySample + (1.0f - dampingCoeff) * ks").concat(n,'_prevSample;\n\n                } else {  // "noise" mode\n                    // NOISE MODE: Very short decay for drum hits / noise bursts\n                    float dampingCoeff = 0.3f + (ks').concat(n,"_damping * 0.3f);  // Range: 0.3 to 0.6 (fast decay)\n                    filteredSample = dampingCoeff * delaySample + (1.0f - dampingCoeff) * ks").concat(n,"_prevSample;\n                }\n\n                // Apply stretch/inharmonicity (slightly detunes overtones for bell-like sounds)\n                // stretch > 1.0 makes delay length frequency-dependent\n                float stretchedSample = filteredSample * ks").concat(n,"_stretch;\n\n                // Write back to delay line (feedback loop)\n                ks").concat(n,"_delayLine[ks").concat(n,"_writePos] = stretchedSample;\n                ks").concat(n,"_prevSample = filteredSample;\n\n                // Advance write position (optimized wraparound, no modulo!)\n                ks").concat(n,"_writePos++;\n                if (ks").concat(n,"_writePos >= KS_MAX_DELAY_").concat(n,") ks").concat(n,"_writePos = 0;\n\n                ksSample = filteredSample;\n            }\n\n            // === BODY CHARACTER (Simple lowpass filter) ===\n            // Replaces heavy comb filters with lightweight lowpass for warmth/character\n            // CPU cost: ~0.1% vs 211% for comb filters!\n            float bodySample = ksSample;\n\n            if (ks").concat(n,"_bodyEnabled && ks").concat(n,"_ampStage > 0) {\n                // Simple one-pole lowpass filter for body warmth\n                // Cutoff determined by body_size (smaller = darker/warmer sound)\n                float cutoffFactor = 0.3f + (ks").concat(n,"_bodySize * 0.6f);  // 0.3-0.9 range\n                float alpha = 1.0f - cutoffFactor;  // Filter coefficient\n\n                // Apply lowpass with resonance feedback\n                float filtered = ksSample * (1.0f - alpha) + ks").concat(n,"_bodyLpf * alpha;\n\n                // Add slight resonance boost (creates mild peak at cutoff)\n                if (ks").concat(n,"_bodyResonance > 0.01f) {\n                    float resonanceFeedback = filtered * ks").concat(n,"_bodyResonance * 0.3f;\n                    filtered += resonanceFeedback;\n                }\n\n                ks").concat(n,"_bodyLpf = filtered;\n                bodySample = filtered;\n            }\n\n            // Apply pitch-dependent gain compensation for consistent amplitude across tuning range\n            bodySample *= ks").concat(n,"_pitchGainComp;\n\n            // === AMPLITUDE ENVELOPE (ADSR) ===\n            switch (ks").concat(n,"_ampStage) {\n                case 1: // Attack\n                    ks").concat(n,"_ampTime += dt;\n                    if (ks").concat(n,"_ampAttack > 0.0001f) {\n                        ks").concat(n,"_ampEnv = ks").concat(n,"_ampTime / ks").concat(n,"_ampAttack;\n                        if (ks").concat(n,"_ampEnv >= 1.0f) {\n                            ks").concat(n,"_ampEnv = 1.0f;\n                            ks").concat(n,"_ampStage = 2; // Move to decay\n                            ks").concat(n,"_ampTime = 0.0f;\n                        }\n                    } else {\n                        ks").concat(n,"_ampEnv = 1.0f;\n                        ks").concat(n,"_ampStage = 2;\n                        ks").concat(n,"_ampTime = 0.0f;\n                    }\n                    break;\n\n                case 2: // Decay\n                    ks").concat(n,"_ampTime += dt;\n                    if (ks").concat(n,"_ampDecay > 0.0001f) {\n                        float decayProgress = ks").concat(n,"_ampTime / ks").concat(n,"_ampDecay;\n                        ks").concat(n,"_ampEnv = 1.0f - (decayProgress * (1.0f - ks").concat(n,"_ampSustain));\n                        if (decayProgress >= 1.0f) {\n                            ks").concat(n,"_ampEnv = ks").concat(n,"_ampSustain;\n                            ks").concat(n,"_ampStage = 3; // Move to sustain\n                        }\n                    } else {\n                        ks").concat(n,"_ampEnv = ks").concat(n,"_ampSustain;\n                        ks").concat(n,"_ampStage = 3;\n                    }\n                    break;\n\n                case 3: // Sustain\n                    ks").concat(n,"_ampEnv = ks").concat(n,"_ampSustain;\n                    // Stay in sustain until gate released\n                    break;\n\n                case 4: // Release\n                    ks").concat(n,"_ampTime += dt;\n                    if (ks").concat(n,"_ampRelease > 0.0001f) {\n                        float releaseProgress = ks").concat(n,"_ampTime / ks").concat(n,"_ampRelease;\n                        ks").concat(n,"_ampEnv = ks").concat(n,"_ampSustain * (1.0f - releaseProgress);\n                        if (releaseProgress >= 1.0f) {\n                            ks").concat(n,"_ampEnv = 0.0f;\n                            ks").concat(n,"_ampStage = 0; // Idle\n                        }\n                    } else {\n                        ks").concat(n,"_ampEnv = 0.0f;\n                        ks").concat(n,"_ampStage = 0;\n                    }\n                    break;\n\n                default: // Idle\n                    ks").concat(n,"_ampEnv = 0.0f;\n                    break;\n            }\n\n            // === SINE OSCILLATOR FOR DEEP BASS ===\n            float sineOut = 0.0f;\n            if (ks").concat(n,"_sineEnabled) {\n                bool usePitchSweep = (strcmp(ks").concat(n,'_pitchSweepMode, "sine") == 0);\n\n                // Pitch envelope processing (only in "sine" mode)\n                if (usePitchSweep) {\n                    if (ks').concat(n,"_sinePitchStage == 1) { // Attack (instant)\n                        ks").concat(n,"_sinePitchStage = 2;\n                        ks").concat(n,"_sinePitchTime = 0.0f;\n                        ks").concat(n,"_sinePitchEnv = 1.0f;\n                    } else if (ks").concat(n,"_sinePitchStage == 2) { // Decay\n                        ks").concat(n,"_sinePitchTime += dt;\n                        if (ks").concat(n,"_sinePitchTime >= ks").concat(n,"_sinePitchDecay) {\n                            ks").concat(n,"_sinePitchStage = 0;\n                            ks").concat(n,"_sinePitchEnv = 0.0f;\n                        } else {\n                            float t = ks").concat(n,"_sinePitchTime / ks").concat(n,"_sinePitchDecay;\n                            // Exponential decay for smooth, musical pitch sweeps (classic 808 kick)\n                            ks").concat(n,"_sinePitchEnv = expf(-4.0f * t);\n                        }\n                    }\n                }\n\n                // Generate sine wave\n                if (ks").concat(n,"_ampStage > 0) {\n                    // Use pre-calculated base frequency from control rate (avoids expensive powf!)\n                    float sineFreq = ks").concat(n,"_baseSineFreq;\n                    if (usePitchSweep) {\n                        float pitchMod = powf(2.0f, ks").concat(n,"_sinePitchEnv * ks").concat(n,"_sinePitchAmount);\n                        sineFreq = ks").concat(n,"_baseSineFreq * pitchMod;\n                    }\n\n                    // Phase accumulation\n                    ks").concat(n,"_sinePhase += 2.0f * PI * sineFreq / 44100.0f;\n                    if (ks").concat(n,"_sinePhase >= 2.0f * PI) ks").concat(n,"_sinePhase -= 2.0f * PI;\n\n                    // Generate sine wave (no level scaling here - applied in output mixing)\n                    sineOut = fastSin(ks").concat(n,"_sinePhase);  // Fast approximation (5-10x faster than sinf)\n                } else {\n                    // Reset phase when envelope is idle to prevent artifacts\n                    ks").concat(n,"_sinePhase = 0.0f;\n                }\n            }\n\n            // === OUTPUT MIXING ===\n            // Apply envelope, velocity sensitivity, and output gain\n            float velocityAmount = 1.0f - ks").concat(n,"_velocitySensitivity + (ks").concat(n,"_velocitySensitivity * ks").concat(n,"_velocityInput);\n            float finalGain = ks").concat(n,"_ampEnv * velocityAmount * ks").concat(n,"_outputGain;\n\n            // Apply individual level controls and mix\n            float ksSampleScaled = bodySample * ks").concat(n,"_ksLevel;       // K-S harmonics level\n            float sineSampleScaled = sineOut * ks").concat(n,"_sineLevel;      // Sine fundamental level\n            float mixedSample = ksSampleScaled + sineSampleScaled;\n\n            ks").concat(n,"_outputL = mixedSample * finalGain;\n            ks").concat(n,"_outputR = mixedSample * finalGain; // Mono for now\n        }\n")}},{key:"generateDrumDesigner4Code",value:function(e,n,t){for(var a=this,o=e.params.bank||1,c="\n        // DrumDesigner4 ".concat(n," - 4-voice percussion synthesizer\n        {\n            // Banking controls (Bank ").concat(o,"): Pot=volume, Button=gate, Button hold + Pot=pitch\n            // Read button states from MCP23017 (rate-limited to avoid I2S interference)\n            {\n                static unsigned long lastBtnRead_dd4").concat(n," = 0;\n                if (millis() - lastBtnRead_dd4").concat(n," > 20) { // Read every 20ms\n                    lastBtnRead_dd4").concat(n," = millis();\n                    uint16_t mcpInputs = mcp.readGPIOAB();\n                    btn1_state = !(mcpInputs & (1 << 2)); // GPA2 - active low (v1.0 mapping)\n                    btn2_state = !(mcpInputs & (1 << 1)); // GPA1 - active low\n                    btn3_state = !(mcpInputs & (1 << 0)); // GPA0 - active low\n                    btn4_state = !(mcpInputs & (1 << 3)); // GPA3 - active low\n                }\n            }\n\n            // Mix buffer for all enabled voices\n            float dd4").concat(n,"_mixL = 0.0f;\n            float dd4").concat(n,"_mixR = 0.0f;\n\n            // Read pots and update NeoPixels for Bank ").concat(o," (once per buffer)\n            if (currentBank == ").concat(o,") {\n                static unsigned long dd4").concat(n,"_lastPotRead = 0;\n                static bool dd4").concat(n,"_firstBankEntry = true;\n\n                if (millis() - dd4").concat(n,"_lastPotRead > 10) { // Read every 10ms\n                    dd4").concat(n,"_lastPotRead = millis();\n\n                    // Read pots (GPIO4-7)\n                    float pot_raw[4];\n                    pot_raw[0] = analogRead(4) / 4095.0;\n                    pot_raw[1] = analogRead(5) / 4095.0;\n                    pot_raw[2] = analogRead(6) / 4095.0;\n                    pot_raw[3] = analogRead(7) / 4095.0;\n\n                    // First time entering this bank - initialize to physical position immediately\n                    if (dd4").concat(n,"_firstBankEntry) {\n                        pot1_value = pot_raw[0];\n                        pot2_value = pot_raw[1];\n                        pot3_value = pot_raw[2];\n                        pot4_value = pot_raw[3];\n                        pot1_physical = pot_raw[0];\n                        pot2_physical = pot_raw[1];\n                        pot3_physical = pot_raw[2];\n                        pot4_physical = pot_raw[3];\n                        pot1_taken_over = true;\n                        pot2_taken_over = true;\n                        pot3_taken_over = true;\n                        pot4_taken_over = true;\n                        dd4").concat(n,"_firstBankEntry = false;\n                    } else {\n                        // Smooth physical readings\n                        const float smooth_factor = 0.8; // Heavy smoothing to reduce ESP32 ADC noise\n                        pot1_physical = pot1_physical * smooth_factor + pot_raw[0] * (1.0 - smooth_factor);\n                        pot2_physical = pot2_physical * smooth_factor + pot_raw[1] * (1.0 - smooth_factor);\n                        pot3_physical = pot3_physical * smooth_factor + pot_raw[2] * (1.0 - smooth_factor);\n                        pot4_physical = pot4_physical * smooth_factor + pot_raw[3] * (1.0 - smooth_factor);\n\n                        // Soft takeover: update value when physical pot crosses within threshold\n                        const float takeover_threshold = 0.03;\n                        if (pot1_taken_over || fabs(pot1_physical - pot1_value) < takeover_threshold) {\n                            pot1_value = pot1_physical;\n                            pot1_taken_over = true;\n                        }\n                        if (pot2_taken_over || fabs(pot2_physical - pot2_value) < takeover_threshold) {\n                            pot2_value = pot2_physical;\n                            pot2_taken_over = true;\n                        }\n                        if (pot3_taken_over || fabs(pot3_physical - pot3_value) < takeover_threshold) {\n                            pot3_value = pot3_physical;\n                            pot3_taken_over = true;\n                        }\n                        if (pot4_taken_over || fabs(pot4_physical - pot4_value) < takeover_threshold) {\n                            pot4_value = pot4_physical;\n                            pot4_taken_over = true;\n                        }\n                    }\n                }\n\n                // Update NeoPixel LEDs for buttons and pots (Bank ").concat(o,")\n                static unsigned long dd4").concat(n,"_lastLedUpdate = 0;\n                static uint8_t dd4").concat(n,"_lastPotBrightness[4] = {0, 0, 0, 0}; // Track last brightness for hysteresis\n                static bool dd4").concat(n,"_lastBtnState[4] = {false, false, false, false};\n\n                if (millis() - dd4").concat(n,"_lastLedUpdate > 100) { // Update every 100ms\n                    dd4").concat(n,"_lastLedUpdate = millis();\n\n                    bool buttonsChanged = false;\n                    bool potsChanged = false;\n\n                    // Check if button states changed\n                    if (btn1_state != dd4").concat(n,"_lastBtnState[0] || btn2_state != dd4").concat(n,"_lastBtnState[1] ||\n                        btn3_state != dd4").concat(n,"_lastBtnState[2] || btn4_state != dd4").concat(n,"_lastBtnState[3]) {\n                        buttonsChanged = true;\n                        dd4").concat(n,"_lastBtnState[0] = btn1_state;\n                        dd4").concat(n,"_lastBtnState[1] = btn2_state;\n                        dd4").concat(n,"_lastBtnState[2] = btn3_state;\n                        dd4").concat(n,"_lastBtnState[3] = btn4_state;\n                    }\n\n                    // Calculate pot brightness values with hysteresis (only update if changed by >10)\n                    uint8_t pot_brightness[4];\n                    pot_brightness[0] = (uint8_t)(pot1_value * 255);\n                    pot_brightness[1] = (uint8_t)(pot2_value * 255);\n                    pot_brightness[2] = (uint8_t)(pot3_value * 255);\n                    pot_brightness[3] = (uint8_t)(pot4_value * 255);\n\n                    for (int i = 0; i < 4; i++) {\n                        if (abs((int)pot_brightness[i] - (int)dd4").concat(n,"_lastPotBrightness[i]) > 10) {\n                            potsChanged = true;\n                            dd4").concat(n,"_lastPotBrightness[i] = pot_brightness[i];\n                        }\n                    }\n\n                    // Update button LEDs if button states changed\n                    if (buttonsChanged) {\n                        // Button LEDs (3,2,1,0) - white when pressed, off when not\n                        neoPixels.setPixelColor(3, btn1_state ? 255 : 0, btn1_state ? 255 : 0, btn1_state ? 255 : 0);\n                        neoPixels.setPixelColor(2, btn2_state ? 255 : 0, btn2_state ? 255 : 0, btn2_state ? 255 : 0);\n                        neoPixels.setPixelColor(1, btn3_state ? 255 : 0, btn3_state ? 255 : 0, btn3_state ? 255 : 0);\n                        neoPixels.setPixelColor(0, btn4_state ? 255 : 0, btn4_state ? 255 : 0, btn4_state ? 255 : 0);\n                    }\n\n                    // Update pot LEDs if pot values changed OR button states changed (color mode switch)\n                    if (potsChanged || buttonsChanged) {\n                        // Pot LEDs (7,6,5,4) - Bank color (green for bank 1)\n                        // When button held: Yellow (pitch control mode)\n                        // When button not held: Green (volume control mode)\n\n                        // Pot 1 LED (LED 7)\n                        if (btn1_state) {\n                            // Yellow (pitch mode) - brightness based on pot value\n                            neoPixels.setPixelColor(7, dd4").concat(n,"_lastPotBrightness[0], dd4").concat(n,"_lastPotBrightness[0], 0);\n                        } else {\n                            // Green (volume mode) - brightness based on pot value\n                            neoPixels.setPixelColor(7, 0, dd4").concat(n,"_lastPotBrightness[0], 0);\n                        }\n\n                        // Pot 2 LED (LED 6)\n                        if (btn2_state) {\n                            neoPixels.setPixelColor(6, dd4").concat(n,"_lastPotBrightness[1], dd4").concat(n,"_lastPotBrightness[1], 0);\n                        } else {\n                            neoPixels.setPixelColor(6, 0, dd4").concat(n,"_lastPotBrightness[1], 0);\n                        }\n\n                        // Pot 3 LED (LED 5)\n                        if (btn3_state) {\n                            neoPixels.setPixelColor(5, dd4").concat(n,"_lastPotBrightness[2], dd4").concat(n,"_lastPotBrightness[2], 0);\n                        } else {\n                            neoPixels.setPixelColor(5, 0, dd4").concat(n,"_lastPotBrightness[2], 0);\n                        }\n\n                        // Pot 4 LED (LED 4)\n                        if (btn4_state) {\n                            neoPixels.setPixelColor(4, dd4").concat(n,"_lastPotBrightness[3], dd4").concat(n,"_lastPotBrightness[3], 0);\n                        } else {\n                            neoPixels.setPixelColor(4, 0, dd4").concat(n,"_lastPotBrightness[3], 0);\n                        }\n                    }\n\n                    // Only call show() if something actually changed\n                    if (buttonsChanged || potsChanged) {\n                        neoPixels.show();\n                    }\n                }\n            }\n"),r=function(r){if(!1===e.params["voice".concat(r,"_enabled")])return c+="\n            // Voice ".concat(r,": DISABLED (no processing)\n            dd4").concat(n,"_v").concat(r,"_outL = 0.0f;\n            dd4").concat(n,"_v").concat(r,"_outR = 0.0f;\n"),1;var i=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&n.to.port==="gate".concat(r)}),l=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&n.to.port==="pitch".concat(r)}),s="false",u=!i;if(i){var d=i.from.id.split(":")[0],p=a.connectionResolver.modules.find(function(e){return e.id===d}),f=i.from.port;if(p){var m,_=(null===(m=d.match(/\d+$/))||void 0===m?void 0:m[0])||"1";switch(p.type){case"Clock":var g=f.replace("out","");s="clock".concat(_,"_out").concat(g);break;case"LEDButton":var h=p.params.index||1;s="btn".concat(h,"_gate");break;case"MIDIIn":s="midiin".concat(_,"_gate");break;case"GateGen":s="gate".concat(_,"_output")}}}var v="dd4".concat(n,"_v").concat(r,"_pitch"),b=!l;if(l){var y=l.from.id.split(":")[0],k=a.connectionResolver.modules.find(function(e){return e.id===y});if(k){var x,S=(null===(x=y.match(/\d+$/))||void 0===x?void 0:x[0])||"1";switch(k.type){case"Pot":v="(pot".concat(S,"_value * 72.0 + 24.0)");break;case"MIDIIn":v="midiin".concat(S,"_note")}}}c+="\n            // Voice ".concat(r,": ENABLED\n            {\n                // Control input processing (only when button NOT held, so banking pitch can take over)\n                ").concat(b?"\n                if (!btn".concat(r,"_state) {\n                "):"","\n                    static unsigned long dd4").concat(n,"_v").concat(r,"_lastControlUpdate = 0;\n                    if (currentTime - dd4").concat(n,"_v").concat(r,"_lastControlUpdate >= 10) {\n                        dd4").concat(n,"_v").concat(r,"_lastControlUpdate = currentTime;\n\n                        float currentPitch = ").concat(v,";\n                        float noteOffset = (currentPitch - 69.0f) + (dd4").concat(n,"_v").concat(r,"_fineTune / 100.0f);\n                        dd4").concat(n,"_v").concat(r,"_currentFreq = 440.0f * powf(2.0f, noteOffset / 12.0f);\n                        dd4").concat(n,"_v").concat(r,"_baseSineFreq = dd4").concat(n,"_v").concat(r,"_currentFreq;\n                    }\n                ").concat(b?"\n                }\n                ":"","\n\n                // Banking controls (Bank ").concat(o,")\n                ").concat(u||b?"\n                if (currentBank == ".concat(o,") {\n                    // Pot ").concat(r," = volume control\n                    dd4").concat(n,"_v").concat(r,"_volume = pot").concat(r,"_value;\n\n                    ").concat(u?"\n                    // Button ".concat(r," alone = one-shot trigger (not gate)\n                    if (!encoderBtn) {\n                        // Edge detection for one-shot triggering\n                        static bool btn").concat(r,"_lastState_dd4").concat(n," = false;\n                        bool btn").concat(r,"_edge = (btn").concat(r,"_state && !btn").concat(r,"_lastState_dd4").concat(n,");\n                        btn").concat(r,"_lastState_dd4").concat(n," = btn").concat(r,"_state;\n\n                        if (btn").concat(r,"_edge) {\n                            // Trigger on button press\n                            dd4").concat(n,"_v").concat(r,"_gateInput = 1.0f;\n                        } else if (dd4").concat(n,"_v").concat(r,"_ampStage == 0) {\n                            // Reset gate when envelope completes (allows retriggering)\n                            dd4").concat(n,"_v").concat(r,"_gateInput = 0.0f;\n                        }\n                    }\n                    "):"","\n\n                    ").concat(b?"\n                    // Button ".concat(r," hold + Pot ").concat(r," rotate = pitch control\n                    if (btn").concat(r,"_state) {\n                        // Button held - pot controls pitch (MIDI 24-96 range)\n                        float bankPitch = pot").concat(r,"_value * 72.0f + 24.0f;\n                        float noteOffset = (bankPitch - 69.0f) + (dd4").concat(n,"_v").concat(r,"_fineTune / 100.0f);\n                        dd4").concat(n,"_v").concat(r,"_currentFreq = 440.0f * powf(2.0f, noteOffset / 12.0f);\n                        dd4").concat(n,"_v").concat(r,"_baseSineFreq = dd4").concat(n,"_v").concat(r,"_currentFreq;\n                    }\n                    "):"","\n                }\n                "):"","\n\n                // Gate input\n                ").concat(u?"\n                // Using banking gate (set above in bank check)\n                ":"\n                dd4".concat(n,"_v").concat(r,"_gateInput = ").concat(s,"; // Canvas-connected gate\n                "),"\n\n                // Trigger detection\n                bool trigger = (dd4").concat(n,"_v").concat(r,"_gateInput > 0.5f && !dd4").concat(n,"_v").concat(r,"_lastGate);\n                bool release = (dd4").concat(n,"_v").concat(r,"_gateInput < 0.5f && dd4").concat(n,"_v").concat(r,"_lastGate);\n\n                if (trigger) {\n                    dd4").concat(n,"_v").concat(r,"_delayLength = (int)(44100.0f / dd4").concat(n,"_v").concat(r,"_currentFreq);\n                    if (dd4").concat(n,"_v").concat(r,"_delayLength < 10) dd4").concat(n,"_v").concat(r,"_delayLength = 10;\n                    if (dd4").concat(n,"_v").concat(r,"_delayLength > KS_MAX_DELAY_DD4").concat(n,"_V").concat(r,") dd4").concat(n,"_v").concat(r,"_delayLength = KS_MAX_DELAY_DD4").concat(n,"_V").concat(r,";\n\n                    // Initialize delay line with noise\n                    memcpy(dd4").concat(n,"_v").concat(r,"_delayLine, dd4").concat(n,"_v").concat(r,"_noiseBuffer, dd4").concat(n,"_v").concat(r,"_delayLength * sizeof(float));\n\n                    dd4").concat(n,"_v").concat(r,"_writePos = dd4").concat(n,"_v").concat(r,"_delayLength;\n                    dd4").concat(n,"_v").concat(r,"_ampStage = 1;\n                    dd4").concat(n,"_v").concat(r,"_ampTime = 0.0f;\n                    dd4").concat(n,"_v").concat(r,"_sinePhase = 0.0f;\n                }\n\n                // One-shot behavior: Don't force release on button release\n                // Envelope completes naturally through ADSR stages\n                // (Original gate-based release logic removed for drum one-shots)\n\n                dd4").concat(n,"_v").concat(r,"_lastGate = (dd4").concat(n,"_v").concat(r,"_gateInput > 0.5f);\n\n                const float dt = 1.0f / 44100.0f;\n\n                // Karplus-Strong synthesis\n                float ksSample = 0.0f;\n                if (dd4").concat(n,"_v").concat(r,"_ampStage > 0) {\n                    int readPos = dd4").concat(n,"_v").concat(r,"_writePos - dd4").concat(n,"_v").concat(r,"_delayLength;\n                    if (readPos < 0) readPos += KS_MAX_DELAY_DD4").concat(n,"_V").concat(r,";\n                    float delaySample = dd4").concat(n,"_v").concat(r,"_delayLine[readPos];\n\n                    // Simple damping filter\n                    float dampingCoeff = 0.5f + (dd4").concat(n,"_v").concat(r,"_damping * 0.499f);\n                    float filteredSample = dampingCoeff * delaySample + (1.0f - dampingCoeff) * dd4").concat(n,"_v").concat(r,"_prevSample;\n                    dd4").concat(n,"_v").concat(r,"_prevSample = filteredSample;\n\n                    ksSample = filteredSample;\n                    dd4").concat(n,"_v").concat(r,"_delayLine[dd4").concat(n,"_v").concat(r,"_writePos] = filteredSample;\n                    dd4").concat(n,"_v").concat(r,"_writePos++;\n                    if (dd4").concat(n,"_v").concat(r,"_writePos >= KS_MAX_DELAY_DD4").concat(n,"_V").concat(r,") dd4").concat(n,"_v").concat(r,"_writePos = 0;\n                }\n\n                // Sine oscillator\n                float sineOut = 0.0f;\n                if (dd4").concat(n,"_v").concat(r,"_sineEnabled && dd4").concat(n,"_v").concat(r,"_ampStage > 0) {\n                    sineOut = sinf(dd4").concat(n,"_v").concat(r,"_sinePhase * 2.0f * M_PI);\n                    float phaseInc = dd4").concat(n,"_v").concat(r,"_baseSineFreq / 44100.0f;\n                    dd4").concat(n,"_v").concat(r,"_sinePhase += phaseInc;\n                    if (dd4").concat(n,"_v").concat(r,"_sinePhase >= 1.0f) dd4").concat(n,"_v").concat(r,"_sinePhase -= 1.0f;\n                }\n\n                // Amplitude envelope (simplified ADSR)\n                float envOut = 0.0f;\n                dd4").concat(n,"_v").concat(r,"_ampTime += dt;\n\n                switch(dd4").concat(n,"_v").concat(r,"_ampStage) {\n                    case 1: // Attack\n                        if (dd4").concat(n,"_v").concat(r,"_ampTime >= dd4").concat(n,"_v").concat(r,"_attack) {\n                            envOut = 1.0f;\n                            dd4").concat(n,"_v").concat(r,"_ampStage = 2;\n                            dd4").concat(n,"_v").concat(r,"_ampTime = 0.0f;\n                        } else {\n                            envOut = dd4").concat(n,"_v").concat(r,"_ampTime / dd4").concat(n,"_v").concat(r,"_attack;\n                        }\n                        break;\n                    case 2: // Decay\n                        if (dd4").concat(n,"_v").concat(r,"_ampTime >= dd4").concat(n,"_v").concat(r,"_decay) {\n                            envOut = dd4").concat(n,"_v").concat(r,"_sustain;\n                            dd4").concat(n,"_v").concat(r,"_ampStage = 3;\n                        } else {\n                            float t = dd4").concat(n,"_v").concat(r,"_ampTime / dd4").concat(n,"_v").concat(r,"_decay;\n                            envOut = 1.0f - t * (1.0f - dd4").concat(n,"_v").concat(r,"_sustain);\n                        }\n                        break;\n                    case 3: // Sustain\n                        envOut = dd4").concat(n,"_v").concat(r,"_sustain;\n                        break;\n                    case 4: // Release\n                        if (dd4").concat(n,"_v").concat(r,"_ampTime >= dd4").concat(n,"_v").concat(r,"_release) {\n                            envOut = 0.0f;\n                            dd4").concat(n,"_v").concat(r,"_ampStage = 0;\n                        } else {\n                            float t = dd4").concat(n,"_v").concat(r,"_ampTime / dd4").concat(n,"_v").concat(r,"_release;\n                            envOut = dd4").concat(n,"_v").concat(r,"_sustain * (1.0f - t);\n                        }\n                        break;\n                    default:\n                        envOut = 0.0f;\n                        dd4").concat(n,"_v").concat(r,"_ampStage = 0;\n                        break;\n                }\n\n                // Mix K-S and sine, apply envelope, output gain, and volume\n                float mixedSample = (ksSample * dd4").concat(n,"_v").concat(r,"_ksLevel) + (sineOut * dd4").concat(n,"_v").concat(r,"_sineLevel);\n                float finalSample = mixedSample * envOut * dd4").concat(n,"_v").concat(r,"_outputGain * dd4").concat(n,"_v").concat(r,"_volume;\n\n                dd4").concat(n,"_v").concat(r,"_outL = finalSample;\n                dd4").concat(n,"_v").concat(r,"_outR = finalSample;\n\n                // Add to mix\n                dd4").concat(n,"_mixL += finalSample;\n                dd4").concat(n,"_mixR += finalSample;\n            }\n")},i=1;i<=4;i++)r(i);return c+="\n            // Output assignments\n            dd4".concat(n,"_outputMixL = dd4").concat(n,"_mixL;\n            dd4").concat(n,"_outputMixR = dd4").concat(n,"_mixR;\n        }\n")}},{key:"generateNoiseCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gain"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"morph"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"type"===n.to.port}),i="noise".concat(n,"_gate"),l="noise".concat(n,"_gain"),s="noise".concat(n,"_morph"),u="noise".concat(n,"_type");if(a){var d=a.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"LEDButton":var _=p.params.index||1;i="btn".concat(_,"_gate");break;case"ADSR":i="(adsr".concat(m,"_output > 0.1)")}}}if(o){var g=o.from.id.split(":")[0],h=this.connectionResolver.modules.find(function(e){return e.id===g});if(h){var v,b=(null===(v=g.match(/\d+$/))||void 0===v?void 0:v[0])||"1";switch(h.type){case"Pot":l=this.getPotReference(h,b);break;case"ADSR":l="adsr".concat(b,"_output")}}}if(c){var y=c.from.id.split(":")[0],k=this.connectionResolver.modules.find(function(e){return e.id===y});if(k){var x,S=(null===(x=y.match(/\d+$/))||void 0===x?void 0:x[0])||"1";switch(k.type){case"Pot":var E=k.params.index||1;s="pot".concat(E,"_value");break;case"LFO":s="lfo".concat(S,"_output")}}}if(r){var P,w=r.from.id.split(":")[0],C=this.connectionResolver.modules.find(function(e){return e.id===w});if(C&&(null===(P=w.match(/\d+$/))||void 0===P||P[0],"Pot"===C.type)){var I=C.params.index||1;u="(int)(pot".concat(I,"_value * 2.99)")}}return"\n        // Noise Generator ".concat(n," processing\n        {\n            float gate = ").concat(i," ? 1.0 : 0.0;\n            float gain = ").concat(l,";\n            float morph = constrain(").concat(s,", 0.0, 1.0);\n            int noiseType = ").concat(u,';\n            noiseType = constrain(noiseType, 0, 2); // Ensure valid range\n\n            // DEBUG: Noise generator gate\n            static unsigned long lastNoiseDebug = 0;\n            if (millis() - lastNoiseDebug > 500) {\n                lastNoiseDebug = millis();\n                Serial.print("DEBUG: Noise generator gate=");\n                Serial.print(gate);\n                Serial.print(", gain=");\n                Serial.print(gain);\n                Serial.print(", currentBank=");\n                Serial.println(currentBank);\n            }\n\n            if (gate > 0.1) {\n                float white_noise = 0.0;\n                float pink_noise = 0.0;\n                float brown_noise = 0.0;\n\n                // Generate white noise using isolated deterministic LCG (avoids ESP32 FPU interference)\n                // Use completely isolated integer math to avoid affecting oscillator FPU state\n                uint32_t temp_seed = noise').concat(n,"_lcg_seed;\n                temp_seed = (temp_seed * 1103515245U + 12345U) & 0x7FFFFFFFU;\n                noise").concat(n,"_lcg_seed = temp_seed;\n                // Convert to float using safe integer division to avoid FPU precision issues\n                int32_t noise_int = (int32_t)(temp_seed & 0xFFFF) - 32768;\n                white_noise = (float)noise_int * (1.0f / 32768.0f);\n\n                // TEMPORARY: White noise only until FPU interference resolved\n                // Complex filtering causes oscillator frequency modulation on ESP32\n                pink_noise = white_noise * 0.5; // Scaled white noise approximation\n                brown_noise = white_noise * 0.3; // Scaled white noise approximation\n\n                // Mix noise types based on current type and morph\n                float output = 0.0;\n                if (noiseType == 0) {\n                    // White noise base - morph towards pink\n                    output = white_noise * (1.0 - morph) + pink_noise * morph * 0.11;\n                } else if (noiseType == 1) {\n                    // Pink noise base - morph towards brown\n                    output = pink_noise * 0.11 * (1.0 - morph) + brown_noise * morph;\n                } else if (noiseType == 2) {\n                    // Brown noise base - morph towards white\n                    output = brown_noise * (1.0 - morph) + white_noise * morph;\n                }\n\n                noise").concat(n,"_output = output * gain;\n\n                // DEBUG: Print noise output every 500ms\n                static unsigned long noiseDebugTime_").concat(n," = 0;\n                if (millis() - noiseDebugTime_").concat(n," > 500) {\n                    noiseDebugTime_").concat(n,' = millis();\n                    Serial.print("Noise').concat(n,' - gate=");\n                    Serial.print(gate);\n                    Serial.print(", gain=");\n                    Serial.print(gain);\n                    Serial.print(", out=");\n                    Serial.println(noise').concat(n,"_output);\n                }\n            } else {\n                noise").concat(n,"_output = 0.0;\n            }\n        }\n")}},{key:"generateReverbCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"mix"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"size"===n.to.port}),i=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"damp"===n.to.port}),l="0.0",s="0.0",u="reverb".concat(n,"_mix"),d="reverb".concat(n,"_size"),p="reverb".concat(n,"_damp");if(a){var f=a.from.id.split(":")[0],m=this.connectionResolver.modules.find(function(e){return e.id===f});if(m){var _,g=(null===(_=f.match(/\d+$/))||void 0===_?void 0:_[0])||"1";switch(m.type){case"VCA":l="vca".concat(g,"_outputL");break;case"Oscillator":l="osc".concat(g,"_outputL");break;case"Filter":l="filter".concat(g,"_outputL");break;case"Delay":l="delay".concat(g,"_outputL");break;case"LineIn":l="linein".concat(g,"_outputL");break;case"CleanReverb":l="cleanreverb".concat(g,"_outputL");break;case"Reverb":l="reverb".concat(g,"_outputL")}}}if(o){var h=o.from.id.split(":")[0],v=this.connectionResolver.modules.find(function(e){return e.id===h});if(v){var b,y=(null===(b=h.match(/\d+$/))||void 0===b?void 0:b[0])||"1";switch(v.type){case"VCA":s="vca".concat(y,"_outputR");break;case"Oscillator":s="osc".concat(y,"_outputR");break;case"Filter":s="filter".concat(y,"_outputR");break;case"Delay":s="delay".concat(y,"_outputR");break;case"LineIn":s="linein".concat(y,"_outputR");break;case"CleanReverb":s="cleanreverb".concat(y,"_outputR");break;case"Reverb":s="reverb".concat(y,"_outputR")}}}if(c){var k=c.from.id.split(":")[0],x=this.connectionResolver.modules.find(function(e){return e.id===k});if(x){var S,E=(null===(S=k.match(/\d+$/))||void 0===S?void 0:S[0])||"1";switch(x.type){case"Pot":u="pot".concat(E,"_value");break;case"LFO":u="lfo".concat(E,"_output")}}}if(r){var P=r.from.id.split(":")[0],w=this.connectionResolver.modules.find(function(e){return e.id===P});if(w){var C,I=(null===(C=P.match(/\d+$/))||void 0===C?void 0:C[0])||"1";switch(w.type){case"Pot":d="pot".concat(I,"_value");break;case"LFO":d="lfo".concat(I,"_output")}}}if(i){var R=i.from.id.split(":")[0],L=this.connectionResolver.modules.find(function(e){return e.id===R});if(L){var M,D=(null===(M=R.match(/\d+$/))||void 0===M?void 0:M[0])||"1";switch(L.type){case"Pot":p="pot".concat(D,"_value");break;case"LFO":p="lfo".concat(D,"_output")}}}return"\n        // Reverb ".concat(n," processing - Clouds Reverb (Dattorro Algorithm)\n        {\n            float inputL = ").concat(l,";\n            float inputR = ").concat(s,";\n            float mix = constrain(").concat(u,", 0.0, 1.0);\n            float size = constrain(").concat(d,", 0.0, 1.0);\n            float damp = constrain(").concat(p,", 0.0, 1.0);\n\n            reverb").concat(n,"_inputL = inputL;\n            reverb").concat(n,"_inputR = inputR;\n\n            // Mono input sum for reverb tank\n            float input_mono = (inputL + inputR) * 0.5;\n\n            // Pre-delay\n            float predelayed = reverb").concat(n,"_predelay[reverb").concat(n,"_predelay_pos];\n            reverb").concat(n,"_predelay[reverb").concat(n,"_predelay_pos] = input_mono;\n            reverb").concat(n,"_predelay_pos = (reverb").concat(n,"_predelay_pos + 1) % REVERB").concat(n,"_PREDELAY_SIZE;\n\n            // Diffusion stage (4 all-pass filters in series)\n            float diffused = predelayed;\n\n            // All-pass 1 (Left tank input)\n            float ap1_delay = reverb").concat(n,"_ap1L[reverb").concat(n,"_ap1L_pos];\n            float ap1_out = -0.75 * diffused + ap1_delay;\n            reverb").concat(n,"_ap1L[reverb").concat(n,"_ap1L_pos] = diffused + 0.75 * ap1_out;\n            reverb").concat(n,"_ap1L_pos = (reverb").concat(n,"_ap1L_pos + 1) % REVERB").concat(n,"_AP1_SIZE;\n\n            // All-pass 2 (Left tank continued)\n            float ap2_delay = reverb").concat(n,"_ap2L[reverb").concat(n,"_ap2L_pos];\n            float ap2_out = -0.75 * ap1_out + ap2_delay;\n            reverb").concat(n,"_ap2L[reverb").concat(n,"_ap2L_pos] = ap1_out + 0.75 * ap2_out;\n            reverb").concat(n,"_ap2L_pos = (reverb").concat(n,"_ap2L_pos + 1) % REVERB").concat(n,"_AP2_SIZE;\n\n            // Split into left and right tanks\n            float tankL_input = ap2_out;\n            float tankR_input = ap2_out;\n\n            // Left tank processing\n            // Delay 1\n            float delay1_out = reverb").concat(n,"_delay1L[reverb").concat(n,"_delay1L_pos];\n            reverb").concat(n,"_delay1L[reverb").concat(n,"_delay1L_pos] = tankL_input;\n            reverb").concat(n,"_delay1L_pos = (reverb").concat(n,"_delay1L_pos + 1) % REVERB").concat(n,"_DELAY1_SIZE;\n\n            // Low-pass damping filter\n            reverb").concat(n,"_lpf_L = reverb").concat(n,"_lpf_L + damp * (delay1_out - reverb").concat(n,"_lpf_L);\n            delay1_out = reverb").concat(n,"_lpf_L;\n\n            // All-pass 3\n            float ap3_delay = reverb").concat(n,"_ap3R[reverb").concat(n,"_ap3R_pos];\n            float ap3_out = -0.5 * delay1_out + ap3_delay;\n            reverb").concat(n,"_ap3R[reverb").concat(n,"_ap3R_pos] = delay1_out + 0.5 * ap3_out;\n            reverb").concat(n,"_ap3R_pos = (reverb").concat(n,"_ap3R_pos + 1) % REVERB").concat(n,"_AP3_SIZE;\n\n            // Delay 2 (main left delay)\n            float delay2_out = reverb").concat(n,"_delay2L[reverb").concat(n,"_delay2L_pos];\n            reverb").concat(n,"_delay2L[reverb").concat(n,"_delay2L_pos] = ap3_out + reverb").concat(n,"_feedback * size * delay2_out;\n            reverb").concat(n,"_delay2L_pos = (reverb").concat(n,"_delay2L_pos + 1) % REVERB").concat(n,"_DELAY2_SIZE;\n\n            // Right tank processing (simplified for brevity)\n            // All-pass 4\n            float ap4_delay = reverb").concat(n,"_ap4R[reverb").concat(n,"_ap4R_pos];\n            float ap4_out = -0.5 * tankR_input + ap4_delay;\n            reverb").concat(n,"_ap4R[reverb").concat(n,"_ap4R_pos] = tankR_input + 0.5 * ap4_out;\n            reverb").concat(n,"_ap4R_pos = (reverb").concat(n,"_ap4R_pos + 1) % REVERB").concat(n,"_AP4_SIZE;\n\n            // Low-pass damping filter (right)\n            reverb").concat(n,"_lpf_R = reverb").concat(n,"_lpf_R + damp * (ap4_out - reverb").concat(n,"_lpf_R);\n            ap4_out = reverb").concat(n,"_lpf_R;\n\n            // Delay 3 (main right delay)\n            float delay3_out = reverb").concat(n,"_delay3R[reverb").concat(n,"_delay3R_pos];\n            reverb").concat(n,"_delay3R[reverb").concat(n,"_delay3R_pos] = ap4_out + reverb").concat(n,"_feedback * size * delay3_out;\n            reverb").concat(n,"_delay3R_pos = (reverb").concat(n,"_delay3R_pos + 1) % REVERB").concat(n,"_DELAY3_SIZE;\n\n            // Output taps from delay lines (multiple taps for fuller sound)\n            float outL = delay2_out * 0.6 + delay3_out * 0.3;\n            float outR = delay3_out * 0.6 + delay2_out * 0.3;\n\n            // Final output mixing\n            reverb").concat(n,"_outputL = inputL * (1.0 - mix) + outL * mix;\n            reverb").concat(n,"_outputR = inputR * (1.0 - mix) + outR * mix;\n        }\n")}},{key:"generateCleanReverbCode",value:function(e,n,t){var a=this,o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"mix"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"size"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"damp"===n.to.port}),i="cleanreverb".concat(n,"_mix"),l="cleanreverb".concat(n,"_size"),s="cleanreverb".concat(n,"_damp"),u=null,d=null,p=null,f=function(e){if(!e)return null;var n=e.from.id.split(":")[0],t=a.connectionResolver.modules.find(function(e){return e.id===n});if(t&&"Pot"===t.type){var o,c,r=(null===(o=t.params)||void 0===o?void 0:o.index)||(null===(c=n.match(/\d+$/))||void 0===c?void 0:c[0])||"1",i=e.from.bank||1;return{potVar:"pot".concat(r,"_value"),bank:i}}return null};if(o){var m=f(o);if(m)u=m;else{var _=o.from.id.split(":")[0],g=this.connectionResolver.modules.find(function(e){return e.id===_});if(g){var h,v=(null===(h=_.match(/\d+$/))||void 0===h?void 0:h[0])||"1";i="LFO"===g.type?"lfo".concat(v,"_output"):"".concat(g.type.toLowerCase()).concat(v,"_output")}}}if(c){var b=f(c);if(b)d=b;else{var y=c.from.id.split(":")[0],k=this.connectionResolver.modules.find(function(e){return e.id===y});if(k){var x,S=(null===(x=y.match(/\d+$/))||void 0===x?void 0:x[0])||"1";l="LFO"===k.type?"lfo".concat(S,"_output"):"".concat(k.type.toLowerCase()).concat(S,"_output")}}}if(r){var E=f(r);if(E)p=E;else{var P=r.from.id.split(":")[0],w=this.connectionResolver.modules.find(function(e){return e.id===P});if(w){var C,I=(null===(C=P.match(/\d+$/))||void 0===C?void 0:C[0])||"1";s="LFO"===w.type?"lfo".concat(I,"_output"):"".concat(w.type.toLowerCase()).concat(I,"_output")}}}return"\n        // CleanReverb ".concat(e.id," processing (Freeverb-style diffuse reverb)\n        {\n            // Inputs & raw params (from standard connection system)\n            float inL  = cleanreverb").concat(n,"_inputL;\n            float inR  = cleanreverb").concat(n,"_inputR;\n\n            // Pot values with bank-aware persistence\n            // pot_value is shared across banks (pot1 controls ADSR in bank1, reverb in bank2)\n            // We need to remember the reverb's pot value when we're NOT in its bank\n            ").concat(u?"static float cleanreverb".concat(n,"_mix_saved = ").concat(i,";\n            if (currentBank == ").concat(u.bank,") cleanreverb").concat(n,"_mix_saved = ").concat(u.potVar,";"):"","\n            ").concat(d?"static float cleanreverb".concat(n,"_size_saved = ").concat(l,";\n            if (currentBank == ").concat(d.bank,") cleanreverb").concat(n,"_size_saved = ").concat(d.potVar,";"):"","\n            ").concat(p?"static float cleanreverb".concat(n,"_damp_saved = ").concat(s,";\n            if (currentBank == ").concat(p.bank,") cleanreverb").concat(n,"_damp_saved = ").concat(p.potVar,";"):"","\n\n            float mix  = ").concat(u?"cleanreverb".concat(n,"_mix_saved"):i,";\n            float size = ").concat(d?"cleanreverb".concat(n,"_size_saved"):l,";\n            float damp = ").concat(p?"cleanreverb".concat(n,"_damp_saved"):s,";\n\n            // Parameter smoothing (one-pole)\n            const float z = 0.0025f; // ~2.5 ms smoothing at 44.1kHz inside sample loop chunk\n            cleanreverb").concat(n,"_mix_z  += z * (mix  - cleanreverb").concat(n,"_mix_z);\n            cleanreverb").concat(n,"_size_z += z * (size - cleanreverb").concat(n,"_size_z);\n            cleanreverb").concat(n,"_damp_z += z * (damp - cleanreverb").concat(n,"_damp_z);\n            mix  = constrain(cleanreverb").concat(n,"_mix_z,  0.0f, 1.0f);\n            size = constrain(cleanreverb").concat(n,"_size_z, 0.0f, 1.0f);\n            damp = constrain(cleanreverb").concat(n,'_damp_z, 0.0f, 1.0f);\n\n            // Map "size" to feedback gain (higher = longer decay, smoother tail)\n            // Extended range: 0.7-0.88 gives classic reverb character with smooth decay\n            const float g = constrain(0.70f + 0.18f * size, 0.0f, 0.88f);\n\n            // Map "damp" to LPF coefficient (Freeverb-style damping)\n            // Higher damp => more filtering => darker tail\n            const float d = constrain(0.2f + 0.7f * (1.0f - damp), 0.05f, 0.95f);\n\n            // Gentle input limiter\n            inL = inL > 0.8f ? 0.8f : (inL < -0.8f ? -0.8f : inL);\n            inR = inR > 0.8f ? 0.8f : (inR < -0.8f ? -0.8f : inR);\n\n            // Mono feed to comb bank (classic Schroeder); stereo will be built later\n            float x = 0.5f * (inL + inR);\n\n            // Predelay (early reflections feel)\n            float pdTap = cleanreverb').concat(n,"_predelay[cleanreverb").concat(n,"_predelay_pos];\n            cleanreverb").concat(n,"_predelay[cleanreverb").concat(n,"_predelay_pos] = x;\n            if (++cleanreverb").concat(n,"_predelay_pos >= CLEANREVERB").concat(n,"_PREDELAY_SIZE) cleanreverb").concat(n,"_predelay_pos = 0;\n            x = pdTap;\n\n            // 4 parallel feedback combs with LPF *inside* the feedback loop (Freeverb style)\n            // comb1\n            float c1 = cleanreverb").concat(n,"_comb1[cleanreverb").concat(n,"_comb1_pos];\n            cleanreverb").concat(n,"_comb1_lpf = c1 * (1.0f - d) + cleanreverb").concat(n,"_comb1_lpf * d;\n            cleanreverb").concat(n,"_comb1[cleanreverb").concat(n,"_comb1_pos] = x + g * cleanreverb").concat(n,"_comb1_lpf;\n            if (++cleanreverb").concat(n,"_comb1_pos >= CLEANREVERB").concat(n,"_COMB1_SIZE) cleanreverb").concat(n,"_comb1_pos = 0;\n\n            // comb2\n            float c2 = cleanreverb").concat(n,"_comb2[cleanreverb").concat(n,"_comb2_pos];\n            cleanreverb").concat(n,"_comb2_lpf = c2 * (1.0f - d) + cleanreverb").concat(n,"_comb2_lpf * d;\n            cleanreverb").concat(n,"_comb2[cleanreverb").concat(n,"_comb2_pos] = x + g * cleanreverb").concat(n,"_comb2_lpf;\n            if (++cleanreverb").concat(n,"_comb2_pos >= CLEANREVERB").concat(n,"_COMB2_SIZE) cleanreverb").concat(n,"_comb2_pos = 0;\n\n            // comb3\n            float c3 = cleanreverb").concat(n,"_comb3[cleanreverb").concat(n,"_comb3_pos];\n            cleanreverb").concat(n,"_comb3_lpf = c3 * (1.0f - d) + cleanreverb").concat(n,"_comb3_lpf * d;\n            cleanreverb").concat(n,"_comb3[cleanreverb").concat(n,"_comb3_pos] = x + g * cleanreverb").concat(n,"_comb3_lpf;\n            if (++cleanreverb").concat(n,"_comb3_pos >= CLEANREVERB").concat(n,"_COMB3_SIZE) cleanreverb").concat(n,"_comb3_pos = 0;\n\n            // comb4\n            float c4 = cleanreverb").concat(n,"_comb4[cleanreverb").concat(n,"_comb4_pos];\n            cleanreverb").concat(n,"_comb4_lpf = c4 * (1.0f - d) + cleanreverb").concat(n,"_comb4_lpf * d;\n            cleanreverb").concat(n,"_comb4[cleanreverb").concat(n,"_comb4_pos] = x + g * cleanreverb").concat(n,"_comb4_lpf;\n            if (++cleanreverb").concat(n,"_comb4_pos >= CLEANREVERB").concat(n,"_COMB4_SIZE) cleanreverb").concat(n,"_comb4_pos = 0;\n\n            // Sum combs\n            float combSum = 0.25f * (c1 + c2 + c3 + c4);\n\n            // 2 serial allpasses for diffusion (critical for smooth reverb character)\n            // AP1\n            float ap1_delay = cleanreverb").concat(n,"_ap1[cleanreverb").concat(n,"_ap1_pos];\n            const float ap1_a = 0.5f;\n            float ap1_out = -ap1_a * combSum + ap1_delay;\n            cleanreverb").concat(n,"_ap1[cleanreverb").concat(n,"_ap1_pos] = combSum + ap1_a * ap1_out;\n            if (++cleanreverb").concat(n,"_ap1_pos >= CLEANREVERB").concat(n,"_AP1_SIZE) cleanreverb").concat(n,"_ap1_pos = 0;\n\n            // AP2\n            float ap2_delay = cleanreverb").concat(n,"_ap2[cleanreverb").concat(n,"_ap2_pos];\n            const float ap2_a = 0.5f;\n            float ap2_out = -ap2_a * ap1_out + ap2_delay;\n            cleanreverb").concat(n,"_ap2[cleanreverb").concat(n,"_ap2_pos] = ap1_out + ap2_a * ap2_out;\n            if (++cleanreverb").concat(n,"_ap2_pos >= CLEANREVERB").concat(n,"_AP2_SIZE) cleanreverb").concat(n,"_ap2_pos = 0;\n\n            // Stereo decorrelation: Use fully diffused allpass output for smooth character\n            // Mix different comb taps with the diffused signal for stereo width\n            float wetL = 0.6f * ap2_out + 0.2f * c1 + 0.2f * c3;\n            float wetR = 0.6f * ap2_out + 0.2f * c2 + 0.2f * c4;\n\n            // Scale down wet signal to prevent buildup (diffused signal is denser)\n            wetL *= 0.5f;\n            wetR *= 0.5f;\n\n            // Final mix (no additional clipping - rely on output limiter)\n            float outL = inL * (1.0f - mix) + wetL * mix;\n            float outR = inR * (1.0f - mix) + wetR * mix;\n\n            // Denormal guard\n            if (fabsf(outL) < 1e-12f) outL = 0.0f;\n            if (fabsf(outR) < 1e-12f) outR = 0.0f;\n\n            cleanreverb").concat(n,"_outputL = outL;\n            cleanreverb").concat(n,"_outputR = outR;\n        }\n")}},{key:"generateSnareDrumCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"trigger"===n.to.port}),o="false";if(a){var c=a.from.id.split(":")[0],r=this.connectionResolver.modules.find(function(e){return e.id===c});if(r){var i,l=(null===(i=c.match(/\d+$/))||void 0===i?void 0:i[0])||"1";switch(r.type){case"LEDButton":o="btn".concat(l,"_pressed");break;case"Clock":o="clock".concat(l,"_output");break;case"GateGen":o="gate".concat(l,"_output")}}}return"\n        // SnareDrum ".concat(n," processing - Layered Snare Drum Synthesizer\n        {\n            bool trigger = ").concat(o,";\n\n            // Trigger all envelopes on rising edge\n            static bool snare").concat(n,"_lastTrigger = false;\n            if (trigger && !snare").concat(n,"_lastTrigger) {\n                // Start all envelope stages\n                snare").concat(n,"_amp_stage = 1; // Attack\n                snare").concat(n,"_amp_time = 0.0;\n                snare").concat(n,"_pitch_stage = 1; // Attack\n                snare").concat(n,"_pitch_time = 0.0;\n                snare").concat(n,"_noise_stage = 1; // Attack\n                snare").concat(n,"_noise_time = 0.0;\n                snare").concat(n,"_triggered = true;\n            }\n            snare").concat(n,"_lastTrigger = trigger;\n\n            float sampleTime = 1.0 / 44100.0;\n\n            // Process amplitude envelope\n            if (snare").concat(n,"_amp_stage > 0) {\n                snare").concat(n,"_amp_time += sampleTime;\n\n                switch (snare").concat(n,"_amp_stage) {\n                    case 1: // Attack\n                        if (snare").concat(n,"_amp_time >= snare").concat(n,"_amp_attack) {\n                            snare").concat(n,"_amp_stage = 2;\n                            snare").concat(n,"_amp_time = 0.0;\n                            snare").concat(n,"_amp_env = 1.0;\n                        } else {\n                            snare").concat(n,"_amp_env = snare").concat(n,"_amp_time / snare").concat(n,"_amp_attack;\n                        }\n                        break;\n\n                    case 2: // Decay\n                        if (snare").concat(n,"_amp_time >= snare").concat(n,"_amp_decay) {\n                            snare").concat(n,"_amp_stage = 3;\n                            snare").concat(n,"_amp_time = 0.0;\n                        } else {\n                            float progress = snare").concat(n,"_amp_time / snare").concat(n,"_amp_decay;\n                            snare").concat(n,"_amp_env = 1.0 - progress * (1.0 - snare").concat(n,"_amp_sustain);\n                        }\n                        break;\n\n                    case 3: // Sustain\n                        snare").concat(n,"_amp_env = snare").concat(n,"_amp_sustain;\n                        if (!trigger) {\n                            snare").concat(n,"_amp_stage = 4; // Release\n                            snare").concat(n,"_amp_time = 0.0;\n                        }\n                        break;\n\n                    case 4: // Release\n                        if (snare").concat(n,"_amp_time >= snare").concat(n,"_amp_release) {\n                            snare").concat(n,"_amp_stage = 0; // Idle\n                            snare").concat(n,"_amp_env = 0.0;\n                        } else {\n                            float progress = snare").concat(n,"_amp_time / snare").concat(n,"_amp_release;\n                            snare").concat(n,"_amp_env = snare").concat(n,"_amp_sustain * (1.0 - progress);\n                        }\n                        break;\n                }\n            }\n\n            // Process pitch envelope\n            if (snare").concat(n,"_pitch_stage > 0) {\n                snare").concat(n,"_pitch_time += sampleTime;\n\n                switch (snare").concat(n,"_pitch_stage) {\n                    case 1: // Attack\n                        if (snare").concat(n,"_pitch_time >= snare").concat(n,"_pitch_attack) {\n                            snare").concat(n,"_pitch_stage = 2;\n                            snare").concat(n,"_pitch_time = 0.0;\n                            snare").concat(n,"_pitch_env = 1.0;\n                        } else {\n                            snare").concat(n,"_pitch_env = snare").concat(n,"_pitch_time / snare").concat(n,"_pitch_attack;\n                        }\n                        break;\n\n                    case 2: // Decay\n                        if (snare").concat(n,"_pitch_time >= snare").concat(n,"_pitch_decay) {\n                            snare").concat(n,"_pitch_stage = 0; // Skip sustain, go to idle\n                            snare").concat(n,"_pitch_env = 0.0;\n                        } else {\n                            float progress = snare").concat(n,"_pitch_time / snare").concat(n,"_pitch_decay;\n                            snare").concat(n,"_pitch_env = 1.0 - progress;\n                        }\n                        break;\n                }\n            }\n\n            // Process noise envelope\n            if (snare").concat(n,"_noise_stage > 0) {\n                snare").concat(n,"_noise_time += sampleTime;\n\n                switch (snare").concat(n,"_noise_stage) {\n                    case 1: // Attack\n                        if (snare").concat(n,"_noise_time >= snare").concat(n,"_noise_attack) {\n                            snare").concat(n,"_noise_stage = 2;\n                            snare").concat(n,"_noise_time = 0.0;\n                            snare").concat(n,"_noise_env = 1.0;\n                        } else {\n                            snare").concat(n,"_noise_env = snare").concat(n,"_noise_time / snare").concat(n,"_noise_attack;\n                        }\n                        break;\n\n                    case 2: // Decay\n                        if (snare").concat(n,"_noise_time >= snare").concat(n,"_noise_decay) {\n                            snare").concat(n,"_noise_stage = 3;\n                            snare").concat(n,"_noise_time = 0.0;\n                        } else {\n                            float progress = snare").concat(n,"_noise_time / snare").concat(n,"_noise_decay;\n                            snare").concat(n,"_noise_env = 1.0 - progress * (1.0 - snare").concat(n,"_noise_sustain);\n                        }\n                        break;\n\n                    case 3: // Sustain\n                        snare").concat(n,"_noise_env = snare").concat(n,"_noise_sustain;\n                        if (!trigger) {\n                            snare").concat(n,"_noise_stage = 4; // Release\n                            snare").concat(n,"_noise_time = 0.0;\n                        }\n                        break;\n\n                    case 4: // Release\n                        if (snare").concat(n,"_noise_time >= snare").concat(n,"_noise_release) {\n                            snare").concat(n,"_noise_stage = 0; // Idle\n                            snare").concat(n,"_noise_env = 0.0;\n                        } else {\n                            float progress = snare").concat(n,"_noise_time / snare").concat(n,"_noise_release;\n                            snare").concat(n,"_noise_env = snare").concat(n,"_noise_sustain * (1.0 - progress);\n                        }\n                        break;\n                }\n            }\n\n            // Generate sound sources\n            float osc_output = 0.0;\n            float noise_output = 0.0;\n\n            if (snare").concat(n,"_amp_env > 0.001) {\n                // Oscillator layer with pitch envelope\n                float pitch_mod = snare").concat(n,"_pitch_env * snare").concat(n,"_pitch_env_amount;\n                float effective_freq = snare").concat(n,"_osc_freq * pow(2.0, pitch_mod);\n\n                snare").concat(n,"_osc_phase += (2.0 * M_PI * effective_freq) / 44100.0;\n                if (snare").concat(n,"_osc_phase >= 2.0 * M_PI) {\n                    snare").concat(n,"_osc_phase -= 2.0 * M_PI;\n                }\n\n                osc_output = sin(snare").concat(n,"_osc_phase) * snare").concat(n,"_osc_level;\n\n                // Noise layer with separate envelope\n                if (snare").concat(n,"_noise_env > 0.001) {\n                    float white_noise = ((float)random(-32768, 32767)) / 32767.0;\n\n                    // Simple noise filtering based on type\n                    if (snare").concat(n,"_noise_type == 0) {\n                        // White noise (no filtering)\n                        noise_output = white_noise;\n                    } else {\n                        // Simple lowpass for pink/brown approximation\n                        snare").concat(n,"_noise_state = snare").concat(n,"_noise_state * 0.99 + white_noise * 0.01;\n                        noise_output = snare").concat(n,"_noise_state * 10.0; // Boost filtered noise\n                    }\n\n                    noise_output *= snare").concat(n,"_noise_level * snare").concat(n,"_noise_env;\n                }\n            }\n\n            // Mix all layers with amplitude envelope\n            float mixed_output = (osc_output + noise_output) * snare").concat(n,"_amp_env;\n\n            snare").concat(n,"_outputL = mixed_output;\n            snare").concat(n,"_outputR = mixed_output;\n        }\n")}},{key:"generateAudioMathCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inA"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inB"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"mod"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"amount"===n.to.port}),i="0.0",l="0.0",s="0.0",u="audioMath".concat(n,"_amount");if(a){var d=a.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"Oscillator":i="osc".concat(m,"_outputL");break;case"VCA":i="vca".concat(m,"_outputL");break;case"Filter":i="filter".concat(m,"_outputL");break;case"Noise":i="noise".concat(m,"_output")}}}if(o){var _=o.from.id.split(":")[0],g=this.connectionResolver.modules.find(function(e){return e.id===_});if(g){var h,v=(null===(h=_.match(/\d+$/))||void 0===h?void 0:h[0])||"1";switch(g.type){case"Oscillator":l="osc".concat(v,"_outputL");break;case"VCA":l="vca".concat(v,"_outputL");break;case"Filter":l="filter".concat(v,"_outputL");break;case"Noise":l="noise".concat(v,"_output")}}}if(c){var b=c.from.id.split(":")[0],y=this.connectionResolver.modules.find(function(e){return e.id===b});if(y){var k,x=(null===(k=b.match(/\d+$/))||void 0===k?void 0:k[0])||"1";switch(y.type){case"LFO":s="lfo".concat(x,"_output");break;case"ADSR":s="adsr".concat(x,"_output");break;case"Pot":s="pot".concat(x,"_value");break;case"Oscillator":s="osc".concat(x,"_outputL")}}}if(r){var S=r.from.id.split(":")[0],E=this.connectionResolver.modules.find(function(e){return e.id===S});if(E){var P,w=(null===(P=S.match(/\d+$/))||void 0===P?void 0:P[0])||"1";switch(E.type){case"Pot":u="pot".concat(w,"_value");break;case"LFO":u="lfo".concat(w,"_output");break;case"ADSR":u="adsr".concat(w,"_output")}}}return"\n        // AudioMath ".concat(n," processing\n        {\n            audioMath").concat(n,"_inputA = ").concat(i,";\n            audioMath").concat(n,"_inputB = ").concat(l,";\n            audioMath").concat(n,"_modInput = ").concat(s,";\n            float amount = ").concat(u,";\n            float offset = audioMath").concat(n,"_offset;\n\n            switch (audioMath").concat(n,"_mode) {\n                case 0: // Amplitude Modulation (AM)\n                    {\n                        float modulated_signal = audioMath").concat(n,"_modInput + offset;\n                        modulated_signal = constrain(modulated_signal, 0.0, 1.0);\n                        audioMath").concat(n,"_output = audioMath").concat(n,"_inputA * modulated_signal * amount +\n                                                   audioMath").concat(n,"_inputA * (1.0 - amount);\n                    }\n                    break;\n\n                case 1: // Crossfade\n                    {\n                        float mix = constrain(amount + audioMath").concat(n,"_modInput + offset, 0.0, 1.0);\n                        audioMath").concat(n,"_output = audioMath").concat(n,"_inputA * (1.0 - mix) +\n                                                   audioMath").concat(n,"_inputB * mix;\n                    }\n                    break;\n\n                case 2: // Ring Modulation\n                    {\n                        float modulated = audioMath").concat(n,"_inputA * (audioMath").concat(n,"_modInput + offset);\n                        audioMath").concat(n,"_output = modulated * amount +\n                                                   audioMath").concat(n,"_inputA * (1.0 - amount);\n                    }\n                    break;\n\n                case 3: // Vocoder (simplified envelope follower)\n                    {\n                        // Envelope follower on carrier signal (inputA)\n                        float carrier_env = fabs(audioMath").concat(n,"_inputA);\n                        if (carrier_env > audioMath").concat(n,"_vocoder_env) {\n                            audioMath").concat(n,"_vocoder_env += (carrier_env - audioMath").concat(n,"_vocoder_env) *\n                                                            audioMath").concat(n,"_vocoder_attack;\n                        } else {\n                            audioMath").concat(n,"_vocoder_env += (carrier_env - audioMath").concat(n,"_vocoder_env) *\n                                                            audioMath").concat(n,"_vocoder_release;\n                        }\n\n                        // Apply carrier envelope to modulator (inputB)\n                        audioMath").concat(n,"_output = audioMath").concat(n,"_inputB * audioMath").concat(n,"_vocoder_env * amount +\n                                                   audioMath").concat(n,"_inputB * (1.0 - amount);\n                    }\n                    break;\n\n                default:\n                    audioMath").concat(n,"_output = audioMath").concat(n,"_inputA; // Pass-through\n                    break;\n            }\n\n            // Apply final gain limiting\n            audioMath").concat(n,"_output = constrain(audioMath").concat(n,"_output, -1.0, 1.0);\n        }\n")}},{key:"generatePannerCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pan"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"width"===n.to.port}),i="0.0",l="0.0",s="panner".concat(n,"_pan"),u="panner".concat(n,"_width");if(a){var d=a.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"Oscillator":i="osc".concat(m,"_outputL");break;case"VCA":i="vca".concat(m,"_outputL");break;case"Filter":i="filter".concat(m,"_outputL");break;case"AudioMath":i="audioMath".concat(m,"_output");break;case"Noise":i="noise".concat(m,"_output")}}}if(o){var _=o.from.id.split(":")[0],g=this.connectionResolver.modules.find(function(e){return e.id===_});if(g){var h,v=(null===(h=_.match(/\d+$/))||void 0===h?void 0:h[0])||"1";switch(g.type){case"Oscillator":l="osc".concat(v,"_outputR");break;case"VCA":l="vca".concat(v,"_outputR");break;case"Filter":l="filter".concat(v,"_outputR");break;case"AudioMath":l="audioMath".concat(v,"_output");break;case"Noise":l="noise".concat(v,"_output")}}}if(c){var b=c.from.id.split(":")[0],y=this.connectionResolver.modules.find(function(e){return e.id===b});if(y){var k,x=(null===(k=b.match(/\d+$/))||void 0===k?void 0:k[0])||"1";switch(y.type){case"Pot":s="pot".concat(x,"_value");break;case"LFO":s="(lfo".concat(x,"_output * 0.5 + 0.5)");break;case"ADSR":s="adsr".concat(x,"_output")}}}if(r){var S=r.from.id.split(":")[0],E=this.connectionResolver.modules.find(function(e){return e.id===S});if(E){var P,w=(null===(P=S.match(/\d+$/))||void 0===P?void 0:P[0])||"1";switch(E.type){case"Pot":u="pot".concat(w,"_value");break;case"LFO":u="(lfo".concat(w,"_output * 0.5 + 0.5)");break;case"ADSR":u="adsr".concat(w,"_output")}}}return"\n        // Panner ".concat(n," processing\n        {\n            panner").concat(n,"_inputL = ").concat(i,";\n            panner").concat(n,"_inputR = ").concat(l,";\n            float pan = constrain(").concat(s,", 0.0, 1.0);\n            float width = constrain(").concat(u,", 0.0, 1.0);\n\n            // Convert stereo input to mid/side representation\n            float mid = (panner").concat(n,"_inputL + panner").concat(n,"_inputR) * 0.5;\n            float side = (panner").concat(n,"_inputL - panner").concat(n,"_inputR) * 0.5;\n\n            // Apply width control to side signal\n            side *= width;\n\n            // Convert back to left/right\n            float processedL = mid + side;\n            float processedR = mid - side;\n\n            // Apply constant-power panning\n            float pan_angle = pan * M_PI * 0.5; // 0 to PI/2\n            float left_gain = cos(pan_angle);   // 1.0 at left, 0.707 at center, 0.0 at right\n            float right_gain = sin(pan_angle);  // 0.0 at left, 0.707 at center, 1.0 at right\n\n            panner").concat(n,"_outputL = processedL * left_gain + processedR * left_gain;\n            panner").concat(n,"_outputR = processedL * right_gain + processedR * right_gain;\n\n            // Apply final output limiting\n            panner").concat(n,"_outputL = constrain(panner").concat(n,"_outputL, -1.0, 1.0);\n            panner").concat(n,"_outputR = constrain(panner").concat(n,"_outputR, -1.0, 1.0);\n        }\n")}},{key:"generateStereoMixer4Code",value:function(e,n,t){t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"1L"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"1R"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"2L"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"2R"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"3L"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"3R"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"4L"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"4R"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"g1"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"g2"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"g3"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"g4"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"master"===n.to.port});var a=e.params.start_bank||2;return"\n        // StereoMixer4 ".concat(n," processing (Banks ").concat(a," and ").concat(a+1,")\n        // Note: Inputs are assigned by CodeGenerator before this code runs\n        {\n            // Get gain controls (use hardware banking values set in updateControl)\n            float gain1 = stereoMixer4_").concat(n,"_gain1;\n            float gain2 = stereoMixer4_").concat(n,"_gain2;\n            float gain3 = stereoMixer4_").concat(n,"_gain3;\n            float gain4 = stereoMixer4_").concat(n,"_gain4;\n            float master = stereoMixer4_").concat(n,"_master;\n\n            // Apply mute/solo logic\n            // Solo mode: only when encoder held (detected by solo_channel != 0)\n            if (stereoMixer4_").concat(n,"_solo_channel != 0) {\n                // Solo mode: only play the solo channel\n                if (stereoMixer4_").concat(n,"_solo_channel != 1) gain1 = 0.0;\n                if (stereoMixer4_").concat(n,"_solo_channel != 2) gain2 = 0.0;\n                if (stereoMixer4_").concat(n,"_solo_channel != 3) gain3 = 0.0;\n                if (stereoMixer4_").concat(n,"_solo_channel != 4) gain4 = 0.0;\n            } else {\n                // Individual mute mode (Bank 1)\n                if (stereoMixer4_").concat(n,"_mute[0]) gain1 = 0.0;\n                if (stereoMixer4_").concat(n,"_mute[1]) gain2 = 0.0;\n                if (stereoMixer4_").concat(n,"_mute[2]) gain3 = 0.0;\n                if (stereoMixer4_").concat(n,"_mute[3]) gain4 = 0.0;\n            }\n\n            // Apply panning using pre-calculated coefficients (updated at control rate)\n            // Pan coefficients calculated in updateControl() to avoid expensive cos/sin in audio loop\n\n            // Mix all channels with panning\n            float mixedL = (stereoMixer4_").concat(n,"_input1L * stereoMixer4_").concat(n,"_panL[0] * gain1) +\n                           (stereoMixer4_").concat(n,"_input1R * stereoMixer4_").concat(n,"_panL[0] * gain1) +\n                           (stereoMixer4_").concat(n,"_input2L * stereoMixer4_").concat(n,"_panL[1] * gain2) +\n                           (stereoMixer4_").concat(n,"_input2R * stereoMixer4_").concat(n,"_panL[1] * gain2) +\n                           (stereoMixer4_").concat(n,"_input3L * stereoMixer4_").concat(n,"_panL[2] * gain3) +\n                           (stereoMixer4_").concat(n,"_input3R * stereoMixer4_").concat(n,"_panL[2] * gain3) +\n                           (stereoMixer4_").concat(n,"_input4L * stereoMixer4_").concat(n,"_panL[3] * gain4) +\n                           (stereoMixer4_").concat(n,"_input4R * stereoMixer4_").concat(n,"_panL[3] * gain4);\n\n            float mixedR = (stereoMixer4_").concat(n,"_input1L * stereoMixer4_").concat(n,"_panR[0] * gain1) +\n                           (stereoMixer4_").concat(n,"_input1R * stereoMixer4_").concat(n,"_panR[0] * gain1) +\n                           (stereoMixer4_").concat(n,"_input2L * stereoMixer4_").concat(n,"_panR[1] * gain2) +\n                           (stereoMixer4_").concat(n,"_input2R * stereoMixer4_").concat(n,"_panR[1] * gain2) +\n                           (stereoMixer4_").concat(n,"_input3L * stereoMixer4_").concat(n,"_panR[2] * gain3) +\n                           (stereoMixer4_").concat(n,"_input3R * stereoMixer4_").concat(n,"_panR[2] * gain3) +\n                           (stereoMixer4_").concat(n,"_input4L * stereoMixer4_").concat(n,"_panR[3] * gain4) +\n                           (stereoMixer4_").concat(n,"_input4R * stereoMixer4_").concat(n,"_panR[3] * gain4);\n\n            // Apply master gain and output limiting\n            stereoMixer4_").concat(n,"_outputL = constrain(mixedL * master, -1.0, 1.0);\n            stereoMixer4_").concat(n,"_outputR = constrain(mixedR * master, -1.0, 1.0);\n        }\n")}},{key:"generateMatrix2x2Code",value:function(e,n,t){var a=this,o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inAL"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inAR"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inBL"===n.to.port}),i=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inBR"===n.to.port}),l=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"aa"===n.to.port}),s=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"ab"===n.to.port}),u=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"ba"===n.to.port}),d=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"bb"===n.to.port}),p=function(e){var n;if(!e)return"0.0";var t=e.from.id.split(":")[0],o=a.connectionResolver.modules.find(function(e){return e.id===t});if(!o)return"0.0";var c=(null===(n=t.match(/\d+$/))||void 0===n?void 0:n[0])||"1",r=e.from.port;switch(o.type){case"Oscillator":return"osc".concat(c,"outR"===r?"_outputR":"_outputL");case"VCA":return"vca".concat(c,"outR"===r?"_outputR":"_outputL");case"Filter":return"filter".concat(c,"outR"===r?"_outputR":"_outputL");case"Panner":return"panner".concat(c,"outR"===r?"_outputR":"_outputL");case"StereoMixer4":return"stereoMixer4_".concat(c,"outR"===r?"_outputR":"_outputL");case"Matrix2x2":return"outAL"===r?"matrix".concat(c,"_outputAL"):"outAR"===r?"matrix".concat(c,"_outputAR"):"outBL"===r?"matrix".concat(c,"_outputBL"):"outBR"===r?"matrix".concat(c,"_outputBR"):"0.0";case"AudioMath":return"audioMath".concat(c,"_output");case"Noise":return"noise".concat(c,"_output");case"Delay":return"delay".concat(c,"outR"===r?"_outputR":"_outputL");default:return"0.0"}},f=function(e,n){var t;if(!e)return n;var o=e.from.id.split(":")[0],c=a.connectionResolver.modules.find(function(e){return e.id===o});if(!c)return n;var r=(null===(t=o.match(/\d+$/))||void 0===t?void 0:t[0])||"1";switch(c.type){case"Pot":return"(pot".concat(r,"_value * 2.0 - 1.0)");case"LFO":return"lfo".concat(r,"_output");case"ADSR":return"(adsr".concat(r,"_output * 2.0 - 1.0)");default:return n}};return"\n        // Matrix2x2 ".concat(n," processing - 2x2 Audio Router with Feedback\n        {\n            // Get input signals\n            matrix").concat(n,"_inputAL = ").concat(p(o),";\n            matrix").concat(n,"_inputAR = ").concat(p(c),";\n            matrix").concat(n,"_inputBL = ").concat(p(r),";\n            matrix").concat(n,"_inputBR = ").concat(p(i),";\n\n            // Get matrix coefficients (with external control)\n            float aa = ").concat(f(l,"matrix".concat(n,"_aa")),";\n            float ab = ").concat(f(s,"matrix".concat(n,"_ab")),";\n            float ba = ").concat(f(u,"matrix".concat(n,"_ba")),";\n            float bb = ").concat(f(d,"matrix".concat(n,"_bb")),";\n\n            // Constrain matrix gains to prevent runaway feedback\n            aa = constrain(aa, -2.0, 2.0);\n            ab = constrain(ab, -2.0, 2.0);\n            ba = constrain(ba, -2.0, 2.0);\n            bb = constrain(bb, -2.0, 2.0);\n\n            // Add tiny noise floor to seed feedback loops (analog mixer behavior)\n            // Uses fast LCG random number generator to avoid ESP32 random() overhead\n            static uint32_t matrix").concat(n,"_seed = ").concat(7919*n,"; // Unique seed per instance\n            matrix").concat(n,"_seed = (1103515245u * matrix").concat(n,"_seed + 12345u) & 0x7fffffffu;\n            float noise = ((float)matrix").concat(n,"_seed / 2147483648.0f) - 1.0f; // -1.0 to +1.0\n            float noise_floor = noise * 0.0001f; // -60dB noise floor\n\n            // Matrix multiplication with noise injection:\n            // [outA] = [aa ab] * [inA]\n            // [outB]   [ba bb]   [inB]\n\n            // Left channel\n            matrix").concat(n,"_outputAL = (matrix").concat(n,"_inputAL * aa) + (matrix").concat(n,"_inputBL * ab) + noise_floor;\n            matrix").concat(n,"_outputBL = (matrix").concat(n,"_inputAL * ba) + (matrix").concat(n,"_inputBL * bb) + noise_floor;\n\n            // Right channel (same matrix applied to right signals)\n            matrix").concat(n,"_outputAR = (matrix").concat(n,"_inputAR * aa) + (matrix").concat(n,"_inputBR * ab) + noise_floor;\n            matrix").concat(n,"_outputBR = (matrix").concat(n,"_inputAR * ba) + (matrix").concat(n,"_inputBR * bb) + noise_floor;\n\n            // Apply soft clipping to prevent runaway feedback (tanh gives smooth saturation)\n            matrix").concat(n,"_outputAL = tanh(matrix").concat(n,"_outputAL);\n            matrix").concat(n,"_outputAR = tanh(matrix").concat(n,"_outputAR);\n            matrix").concat(n,"_outputBL = tanh(matrix").concat(n,"_outputBL);\n            matrix").concat(n,"_outputBR = tanh(matrix").concat(n,"_outputBR);\n        }\n")}},{key:"generateChorusFlangeRingCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o="0.0";if(a){var c=a.from.id.split(":")[0];if(this.connectionResolver.modules.find(function(e){return e.id===c})){var r,i=(null===(r=c.match(/\d+$/))||void 0===r?void 0:r[0])||"1";o="osc".concat(i,"_outputL")}}return"\n        // ChorusFlangeRing ".concat(n," processing\n        {\n            float input = ").concat(o,";\n            cfr").concat(n,"_phase += cfr").concat(n,"_rate * 2.0 * M_PI / 44100.0;\n            if (cfr").concat(n,"_phase >= 2.0 * M_PI) cfr").concat(n,"_phase -= 2.0 * M_PI;\n\n            if (cfr").concat(n,"_mode == 2) { // Ring modulation\n                float modulated = input * sin(cfr").concat(n,"_phase) * cfr").concat(n,"_depth;\n                cfr").concat(n,"_outputL = input * (1.0 - cfr").concat(n,"_mix) + modulated * cfr").concat(n,"_mix;\n            } else { // Chorus/Flange (simplified)\n                cfr").concat(n,"_buffer[cfr").concat(n,"_writePos] = input;\n                cfr").concat(n,"_writePos = (cfr").concat(n,"_writePos + 1) % CFR").concat(n,"_BUFFER_SIZE;\n                int delayOffset = (int)(sin(cfr").concat(n,"_phase) * cfr").concat(n,"_depth * 100);\n                int readPos = (cfr").concat(n,"_writePos - 100 - delayOffset + CFR").concat(n,"_BUFFER_SIZE) % CFR").concat(n,"_BUFFER_SIZE;\n                float delayed = cfr").concat(n,"_buffer[readPos];\n                cfr").concat(n,"_outputL = input * (1.0 - cfr").concat(n,"_mix) + delayed * cfr").concat(n,"_mix;\n            }\n            cfr").concat(n,"_outputR = cfr").concat(n,"_outputL;\n        }\n")}},{key:"generateLimiterCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o="0.0";if(a){var c=a.from.id.split(":")[0];if(this.connectionResolver.modules.find(function(e){return e.id===c})){var r,i=(null===(r=c.match(/\d+$/))||void 0===r?void 0:r[0])||"1";o="osc".concat(i,"_outputL")}}return"\n        // Limiter ".concat(n," processing\n        {\n            float input = ").concat(o,";\n            float inputLevel = abs(input);\n            float targetGain = 1.0;\n\n            if (inputLevel > limiter").concat(n,"_threshold) {\n                targetGain = limiter").concat(n,"_threshold / inputLevel;\n            }\n\n            // Envelope following\n            float rate = (targetGain < limiter").concat(n,"_envelope) ? limiter").concat(n,"_attack : limiter").concat(n,"_release;\n            limiter").concat(n,"_envelope = limiter").concat(n,"_envelope * (1.0 - rate) + targetGain * rate;\n\n            float output = input * limiter").concat(n,"_envelope * limiter").concat(n,"_makeup;\n            limiter").concat(n,"_outputL = output;\n            limiter").concat(n,"_outputR = output;\n        }\n")}},{key:"generateEQ8Code",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o="0.0";if(a){var c=a.from.id.split(":")[0];if(this.connectionResolver.modules.find(function(e){return e.id===c})){var r,i=(null===(r=c.match(/\d+$/))||void 0===r?void 0:r[0])||"1";o="osc".concat(i,"_outputL")}}return"\n        // EQ8 ".concat(n," processing (simplified 8-band EQ)\n        {\n            float input = ").concat(o,";\n            float output = input; // Simplified - just pass through for now\n            // TODO: Implement proper 8-band EQ with biquad filters\n            eq").concat(n,"_outputL = output;\n            eq").concat(n,"_outputR = output;\n        }\n")}},{key:"generatePercussionCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"trig"===n.to.port}),o="false";if(a){var c=a.from.id.split(":")[0],r=this.connectionResolver.modules.find(function(e){return e.id===c});if(r){var i=r.params?r.params.index:0;"LEDButton"===r.type&&(o="btn".concat(i,"_pressed"))}}return"\n        // Percussion ".concat(n," processing\n        {\n            bool trigger = ").concat(o,";\n\n            if (trigger && !perc").concat(n,"_triggered) {\n                perc").concat(n,"_triggered = true;\n                // Reset all envelope stages\n                perc").concat(n,"_stage1 = 1; perc").concat(n,"_stage2 = 1; perc").concat(n,"_stage3 = 1;\n                perc").concat(n,"_time1 = 0.0; perc").concat(n,"_time2 = 0.0; perc").concat(n,"_time3 = 0.0;\n            } else if (!trigger) {\n                perc").concat(n,"_triggered = false;\n            }\n\n            // Simple percussion synthesis (metallic tone with decay)\n            float sampleTime = 1.0 / 44100.0;\n            float tone = sin(2.0 * M_PI * perc").concat(n,"_freq * perc").concat(n,"_time1) * perc").concat(n,"_env1;\n            tone += sin(2.0 * M_PI * perc").concat(n,"_freq * 2.1 * perc").concat(n,"_time2) * perc").concat(n,"_env2 * perc").concat(n,"_metallic;\n\n            // Update envelopes\n            if (perc").concat(n,"_stage1 == 1) {\n                perc").concat(n,"_time1 += sampleTime;\n                perc").concat(n,"_env1 = exp(-perc").concat(n,"_time1 / perc").concat(n,"_decay);\n                if (perc").concat(n,"_env1 < 0.001) perc").concat(n,"_stage1 = 0;\n            }\n\n            perc").concat(n,"_outputL = tone * perc").concat(n,"_gain;\n            perc").concat(n,"_outputR = perc").concat(n,"_outputL;\n        }\n")}},{key:"generateWavetableFMConnection",value:function(e,n){var t,a=e.from.id.split(":")[0],o=this.connectionResolver.modules.find(function(e){return e.id===a});if(!o)return"";var c=(null===(t=a.match(/\d+$/))||void 0===t?void 0:t[0])||"1";switch(o.type){case"Wavetable":return"wt".concat(n,"_fm_input = wt").concat(c,"_outputL; // FM from Wavetable ").concat(c);case"Oscillator":return"wt".concat(n,"_fm_input = osc").concat(c,"_outputL; // FM from Oscillator ").concat(c);case"VCA":return"wt".concat(n,"_fm_input = vca").concat(c,"_outputL; // FM from VCA ").concat(c);case"LFO":return"wt".concat(n,"_fm_input = lfo").concat(c,"_output; // FM from LFO ").concat(c);case"ADSR":return"wt".concat(n,"_fm_input = adsr").concat(c,"_output; // FM from ADSR ").concat(c);default:return""}}},{key:"generateWavetableControlProcessing",value:function(e,n,t){var a=this,o="\n            // Update control parameters\n            float wt".concat(n,"_currentFreq = wt").concat(n,"_freq;\n            float wt").concat(n,"_currentMorph = wt").concat(n,"_morph;\n            float wt").concat(n,"_currentGate = wt").concat(n,"_gate;\n            float wt").concat(n,"_currentPitchCv = 0.5; // Default = no modulation\n            float wt").concat(n,"_currentVelocity = wt").concat(n,"_velocity; // Velocity scaling\n");t.forEach(function(t){var c,r;if(t.to.id.includes("".concat(e.id,":"))){var i=t.from.id.split(":")[0],l=a.connectionResolver.modules.find(function(e){return e.id===i});if(l){var s=(null===(c=l.params)||void 0===c?void 0:c.index)||(null===(r=i.match(/\d+$/))||void 0===r?void 0:r[0])||"1";switch(t.to.port){case"freq":switch(l.type){case"Pot":o+="\n            wt".concat(n,"_currentFreq = (pot").concat(s,"_value * 19980.0 + 20.0); // 20Hz to 20000Hz\n");break;case"Scale":o+="\n            wt".concat(n,"_currentFreq = scale").concat(s,"_output;\n");break;case"MIDIIn":o+="\n            // Only recalculate frequency when MIDI note changes (avoids expensive pow() every sample)\n            if (midiin".concat(s,"_note != wt").concat(n,"_lastMidiNote) {\n                wt").concat(n,"_lastMidiNote = midiin").concat(s,"_note;\n                wt").concat(n,"_cachedFreq = 440.0 * pow(2.0, (midiin").concat(s,"_note * 48.0 + 48.0 - 69.0) / 12.0);\n            }\n            wt").concat(n,"_currentFreq = wt").concat(n,"_cachedFreq; // Use cached frequency\n            wt").concat(n,"_currentGate = midiin").concat(s,"_gate; // Auto-gate from MIDIIn\n");break;case"MIDILooper":o+="\n            // Only recalculate frequency when MIDILooper note changes (avoids expensive pow() every sample)\n            if (midiloop".concat(s,"_out_note != wt").concat(n,"_lastMidiNote) {\n                wt").concat(n,"_lastMidiNote = midiloop").concat(s,"_out_note;\n                wt").concat(n,"_cachedFreq = 440.0 * pow(2.0, (midiloop").concat(s,"_out_note * 48.0 + 48.0 - 69.0) / 12.0);\n            }\n            wt").concat(n,"_currentFreq = wt").concat(n,"_cachedFreq; // Use cached frequency\n            wt").concat(n,"_currentGate = midiloop").concat(s,"_out_gate; // Auto-gate from MIDILooper\n");break;case"HarmonicSequencer":case"BankSequencer":var u=t.from.port;u&&u.includes("pitch_step")&&u.includes("_hz")&&(o+="\n            wt".concat(n,"_currentFreq = seq").concat(s,"_").concat(u,"; // ").concat(l.type," step frequency\n"));break;case"LFO":o+="\n            wt".concat(n,"_currentFreq = wt").concat(n,"_freq + (lfo").concat(s,"_output * 100.0); // 100Hz modulation\n");break;case"Automation":var d=t.from.port,p=d.replace("out_","output_");o+="\n            wt".concat(n,"_currentFreq = (automation").concat(s,"_").concat(p," * 19980.0 + 20.0); // Automation ").concat(s," ").concat(d,": 20Hz to 20000Hz\n")}break;case"gate":if("LEDButton"===l.type){var f=l.params.bank||1,m=l.params.locked||!1;o+=m?"\n            wt".concat(n,"_currentGate = btn").concat(s,"_gate ? 1.0 : 0.0; // Button").concat(s," (LOCKED)\n"):"\n            if (currentBank == ".concat(f,") { wt").concat(n,"_currentGate = btn").concat(s,"_gate ? 1.0 : 0.0; } // Button").concat(s," Bank ").concat(f,"\n")}else"ADSR"===l.type?o+="\n            wt".concat(n,"_currentGate = adsr").concat(s,"_output;\n"):"MIDIIn"===l.type?o+="\n            wt".concat(n,"_currentGate = midiin").concat(s,"_gate; // MIDI gate\n"):"MIDILooper"===l.type?o+="\n            wt".concat(n,"_currentGate = midiloop").concat(s,"_out_gate; // MIDILooper gate\n"):"Arpeggiator"===l.type&&(o+="\n            wt".concat(n,"_currentGate = arp").concat(s,"_out_gate; // Arpeggiator gate\n"));break;case"note":"MIDIIn"===l.type?o+="\n            // Note input from MIDIIn - pitch, gate, AND velocity\n            if (midiin".concat(s,"_note != wt").concat(n,"_lastMidiNote) {\n                wt").concat(n,"_lastMidiNote = midiin").concat(s,"_note;\n                wt").concat(n,"_cachedFreq = 440.0 * pow(2.0, (midiin").concat(s,"_note * 48.0 + 48.0 - 69.0) / 12.0);\n            }\n            wt").concat(n,"_currentFreq = wt").concat(n,"_cachedFreq;\n            wt").concat(n,"_currentGate = midiin").concat(s,"_gate;\n            wt").concat(n,"_currentVelocity = midiin").concat(s,"_velocity; // Velocity scaling (0-1)\n"):"MIDILooper"===l.type?o+="\n            // Note input from MIDILooper - pitch, gate, AND velocity\n            if (midiloop".concat(s,"_out_note != wt").concat(n,"_lastMidiNote) {\n                wt").concat(n,"_lastMidiNote = midiloop").concat(s,"_out_note;\n                wt").concat(n,"_cachedFreq = 440.0 * pow(2.0, (midiloop").concat(s,"_out_note * 48.0 + 48.0 - 69.0) / 12.0);\n            }\n            wt").concat(n,"_currentFreq = wt").concat(n,"_cachedFreq;\n            wt").concat(n,"_currentGate = midiloop").concat(s,"_out_gate;\n            wt").concat(n,"_currentVelocity = midiloop").concat(s,"_out_velocity; // Velocity scaling (0-1)\n"):"Arpeggiator"===l.type&&(o+="\n            // Note input from Arpeggiator - pitch, gate, AND velocity\n            float arp".concat(s,"_midi_note = arp").concat(s,"_out_note * 48.0 + 48.0; // Convert 0-1 back to MIDI note\n            if (arp").concat(s,"_midi_note != wt").concat(n,"_lastMidiNote) {\n                wt").concat(n,"_lastMidiNote = arp").concat(s,"_midi_note;\n                wt").concat(n,"_cachedFreq = 440.0 * pow(2.0, (arp").concat(s,"_midi_note - 69.0) / 12.0);\n            }\n            wt").concat(n,"_currentFreq = wt").concat(n,"_cachedFreq;\n            wt").concat(n,"_currentGate = arp").concat(s,"_out_gate;\n            wt").concat(n,"_currentVelocity = arp").concat(s,"_out_velocity; // Velocity scaling (0-1)\n"));break;case"morph":switch(l.type){case"Pot":o+="\n            wt".concat(n,"_currentMorph = pot").concat(s,"_value * 3.0; // 0-3 range for 4 tables\n");break;case"LFO":o+="\n            wt".concat(n,"_currentMorph = (lfo").concat(s,"_output + 1.0) * 1.5; // 0-3 range\n");break;case"ADSR":o+="\n            wt".concat(n,"_currentMorph = adsr").concat(s,"_output * 3.0; // 0-3 range\n")}break;case"pitch_cv":switch(l.type){case"ADSR":o+="\n            wt".concat(n,"_currentPitchCv = adsr").concat(s,"_output;\n");break;case"LFO":o+="\n            wt".concat(n,"_currentPitchCv = lfo").concat(s,"_output;\n");break;case"Pot":o+="\n            wt".concat(n,"_currentPitchCv = pot").concat(s,"_value;\n")}break;case"fm_ratio_cv":if("Pot"===l.type)o+="\n            wt".concat(n,"_fm_ratio_cv = pot").concat(s,"_value; // FM ratio CV from pot (0-1)\n");else if("Automation"===l.type){var _=t.from.port.replace("out_","output_");o+="\n            wt".concat(n,"_fm_ratio_cv = automation").concat(s,"_").concat(_,"; // FM ratio CV from Automation (0-1)\n")}break;case"fm_amount":if("Pot"===l.type)o+="\n            wt".concat(n,"_fm_amount = pot").concat(s,"_value; // FM amount from pot (0-1)\n");else if("LFO"===l.type)o+="\n            wt".concat(n,"_fm_amount = (lfo").concat(s,"_output + 1.0) * 0.5; // FM amount from LFO (0-1)\n");else if("ADSR"===l.type)o+="\n            wt".concat(n,"_fm_amount = adsr").concat(s,"_output; // FM amount from ADSR (0-1)\n");else if("Automation"===l.type){var g=t.from.port.replace("out_","output_");o+="\n            wt".concat(n,"_fm_amount = automation").concat(s,"_").concat(g,"; // FM amount from Automation (0-1)\n")}}}}});var c=t.find(function(n){var t=n.from.id.split(":")[0],a=n.to.id?n.to.id.split(":")[1]:n.to.port;return t===e.id&&"fm"===a});if(c&&!1!==e.params.fm_tracking){var r=c.to.id?c.to.id.split(":")[0]:c.to,i=this.connectionResolver.modules.find(function(e){return e.id===r});if(i&&"Wavetable"===i.type){var l,s=(null===(l=r.match(/\d+$/))||void 0===l?void 0:l[0])||"1",u=e.params.fm_ratio_mode||"zones";o+="\n            // FM Tracking: This modulator tracks Wavetable".concat(s,' frequency\n            // FM Ratio Mapping Mode: "').concat(u,'"\n'),o+="zones"===u?"\n            float cv = wt".concat(n,"_fm_ratio_cv;\n            float computed_ratio;\n\n            // Zone mapping: pure ratios get wider zones for easy tuning\n            if (cv < 0.1) {\n                computed_ratio = 0.5; // 1:2 (octave below) - zone\n            } else if (cv < 0.15) {\n                computed_ratio = 0.5 + (cv - 0.1) / 0.05 * (0.667 - 0.5); // Smooth transition\n            } else if (cv < 0.25) {\n                computed_ratio = 0.667; // 2:3 (perfect fifth down) - zone\n            } else if (cv < 0.3) {\n                computed_ratio = 0.667 + (cv - 0.25) / 0.05 * (1.0 - 0.667); // Smooth transition\n            } else if (cv < 0.4) {\n                computed_ratio = 1.0; // 1:1 (unison) - zone\n            } else if (cv < 0.45) {\n                computed_ratio = 1.0 + (cv - 0.4) / 0.05 * (1.5 - 1.0); // Smooth transition\n            } else if (cv < 0.55) {\n                computed_ratio = 1.5; // 3:2 (perfect fifth) - zone\n            } else if (cv < 0.6) {\n                computed_ratio = 1.5 + (cv - 0.55) / 0.05 * (2.0 - 1.5); // Smooth transition\n            } else if (cv < 0.7) {\n                computed_ratio = 2.0; // 2:1 (octave) - zone\n            } else if (cv < 0.75) {\n                computed_ratio = 2.0 + (cv - 0.7) / 0.05 * (3.0 - 2.0); // Smooth transition\n            } else if (cv < 0.85) {\n                computed_ratio = 3.0; // 3:1 - zone\n            } else if (cv < 0.9) {\n                computed_ratio = 3.0 + (cv - 0.85) / 0.05 * (4.0 - 3.0); // Smooth transition\n            } else {\n                computed_ratio = 4.0; // 4:1 (two octaves) - zone\n            }\n\n            float final_ratio = computed_ratio;\n            wt").concat(n,"_currentFreq = wt").concat(s,"_freq * final_ratio;\n"):"quantized"===u?"\n            float cv = wt".concat(n,"_fm_ratio_cv;\n            float ratios[] = {0.5, 0.667, 1.0, 1.5, 2.0, 3.0, 4.0};\n            int numRatios = 7;\n            float scaledCV = cv * 6.0; // Map 0-1 to 0-6 (ratio indices)\n            int idx = constrain((int)scaledCV, 0, numRatios - 1);\n            float computed_ratio = ratios[idx];\n\n            wt").concat(n,"_currentFreq = wt").concat(s,"_freq * computed_ratio;\n"):"\n            float cv = wt".concat(n,"_fm_ratio_cv;\n            float computed_ratio = 0.1 + cv * 7.9; // 0-1 CV maps to 0.1-8.0 ratio range\n\n            wt").concat(n,"_currentFreq = wt").concat(s,"_freq * computed_ratio;\n")}}return o+="\n            // Apply exponential pitch CV modulation (semitones, like Oscillator)\n            // Optimized: Skip pow() when pitch CV is at center (0.5 = no modulation)\n            if (fabsf(wt".concat(n,"_currentPitchCv - 0.5f) > 0.001f) {\n                float pitch_offset_semitones = (wt").concat(n,"_currentPitchCv - 0.5f) * wt").concat(n,"_pitch_amount;\n                float pitch_multiplier = pow(2.0f, pitch_offset_semitones / 12.0f);\n                wt").concat(n,"_freq = wt").concat(n,"_currentFreq * pitch_multiplier;\n            } else {\n                wt").concat(n,"_freq = wt").concat(n,"_currentFreq; // No pitch modulation, skip pow()\n            }\n\n            // Apply other control values\n            wt").concat(n,"_morph = wt").concat(n,"_currentMorph;\n            wt").concat(n,"_gate = wt").concat(n,"_currentGate;\n            wt").concat(n,"_velocity = wt").concat(n,"_currentVelocity;\n")}},{key:"generateGranularDenseCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port});return"\n        // Granular Dense ".concat(n," - 20 concurrent 32ms grains for rich textural synthesis\n        {\n            // Control processing\n            ").concat(this.generateGranularDenseControlProcessing(e,n,t),"\n\n            // Audio input processing\n            granular").concat(n,"_inputL = 0.0;\n            granular").concat(n,"_inputR = 0.0;\n\n            ").concat(a?this.generateGranularDenseInputConnection(a,n,"L"):"","\n            ").concat(o?this.generateGranularDenseInputConnection(o,n,"R"):"","\n\n            // Record input to buffer (if not frozen)\n            if (!granular").concat(n,"_currentFreeze) {\n                granular").concat(n,"_buffer_L[granular").concat(n,"_write_pos] = granular").concat(n,"_inputL;\n                granular").concat(n,"_buffer_R[granular").concat(n,"_write_pos] = granular").concat(n,"_inputR;\n                granular").concat(n,"_write_pos++;\n                if (granular").concat(n,"_write_pos >= granular").concat(n,"_buffer_size) {\n                    granular").concat(n,"_write_pos = 0;\n                }\n            }\n\n            // Grain triggering - rate-limited dense processing\n            float grainTriggerRate = constrain(granular").concat(n,"_currentDensity, 1.0, 20.0); // Max 20 grains/sec\n            int samplesBetweenGrains = (int)(SAMPLE_RATE / grainTriggerRate);\n            granular").concat(n,"_samples_since_grain++;\n\n            if (granular").concat(n,"_samples_since_grain >= samplesBetweenGrains) {\n                // Find inactive grain slot (memory-efficient)\n                int activeGrains = 0;\n                int availableSlot = -1;\n\n                for (int g = 0; g < 20; g++) {\n                    if (granular").concat(n,"_grains[g].active) {\n                        activeGrains++;\n                    } else if (availableSlot == -1) {\n                        availableSlot = g;\n                    }\n                }\n\n                // Limit to 18/20 grains max for stability\n                if (availableSlot != -1 && activeGrains < 18) {\n                    // Trigger new grain with constrained parameters\n                    granular").concat(n,"_grains[availableSlot].active = true;\n\n                    // Grain position with spread\n                    float basePosition = constrain(granular").concat(n,"_currentPosition, 0.1, 0.9);\n                    float spread = constrain(granular").concat(n,"_position_spread, 0.0, 0.3);\n                    float positionJitter = (random(0, 1000) / 1000.0 - 0.5) * spread;\n                    granular").concat(n,"_grains[availableSlot].position = constrain(basePosition + positionJitter, 0.0, 1.0);\n\n                    // Grain pitch with controlled spread\n                    float basePitchRatio = pow(2.0, constrain(granular").concat(n,"_currentPitch, -2.0, 2.0)); // 2 octaves max\n                    float pitchSpread = constrain(granular").concat(n,"_pitch_spread, 0.0, 0.3);\n                    float pitchJitter = (random(0, 1000) / 1000.0 - 0.5) * pitchSpread;\n                    granular").concat(n,"_grains[availableSlot].pitch_ratio = constrain(basePitchRatio + pitchJitter, 0.25, 4.0);\n\n                    // Fixed 32ms grain duration for dense texture\n                    int grainSamples = (int)(0.032 * SAMPLE_RATE); // 32ms grains\n                    granular").concat(n,"_grains[availableSlot].samples_remaining = grainSamples;\n                    granular").concat(n,"_grains[availableSlot].envelope_pos = 0.0;\n                    granular").concat(n,"_grains[availableSlot].envelope_inc = 1.0 / grainSamples;\n                }\n\n                granular").concat(n,"_samples_since_grain = 0;\n            }\n\n            // Process all active grains with efficient envelope\n            float outL = 0.0;\n            float outR = 0.0;\n\n            for (int g = 0; g < 20; g++) {\n                if (granular").concat(n,"_grains[g].active) {\n                    // Calculate buffer read position\n                    float bufferPos = granular").concat(n,"_grains[g].position * granular").concat(n,"_buffer_size;\n                    int readPos = (int)bufferPos;\n                    float frac = bufferPos - readPos;\n\n                    // Bounds checking\n                    if (readPos >= 0 && readPos < (granular").concat(n,"_buffer_size - 1)) {\n                        // Linear interpolation for smooth pitch shifting\n                        float sampleL = granular").concat(n,"_buffer_L[readPos] * (1.0 - frac) +\n                                       granular").concat(n,"_buffer_L[readPos + 1] * frac;\n                        float sampleR = granular").concat(n,"_buffer_R[readPos] * (1.0 - frac) +\n                                       granular").concat(n,"_buffer_R[readPos + 1] * frac;\n\n                        // Cosine envelope for smooth grains\n                        float envelope = 0.5 * (1.0 + cos(PI * (2.0 * granular").concat(n,"_grains[g].envelope_pos - 1.0)));\n                        envelope = constrain(envelope, 0.0, 1.0);\n\n                        // Scale output to prevent clipping with 20 grains\n                        float grainScale = 0.15; // Reduced amplitude per grain\n                        outL += sampleL * envelope * grainScale;\n                        outR += sampleR * envelope * grainScale;\n                    }\n\n                    // Update grain state\n                    granular").concat(n,"_grains[g].envelope_pos += granular").concat(n,"_grains[g].envelope_inc;\n                    granular").concat(n,"_grains[g].position += granular").concat(n,"_grains[g].pitch_ratio / granular").concat(n,"_buffer_size;\n                    granular").concat(n,"_grains[g].samples_remaining--;\n\n                    // Wrap position\n                    if (granular").concat(n,"_grains[g].position >= 1.0) {\n                        granular").concat(n,"_grains[g].position -= 1.0;\n                    }\n\n                    // Deactivate finished grains\n                    if (granular").concat(n,"_grains[g].samples_remaining <= 0) {\n                        granular").concat(n,"_grains[g].active = false;\n                    }\n                }\n            }\n\n            // Dry/wet mix with input\n            float dryGain = 1.0 - constrain(granular").concat(n,"_currentDryWet, 0.0, 1.0);\n            float wetGain = constrain(granular").concat(n,"_currentDryWet, 0.0, 1.0);\n\n            granular").concat(n,"_outputL = granular").concat(n,"_inputL * dryGain + outL * wetGain;\n            granular").concat(n,"_outputR = granular").concat(n,"_inputR * dryGain + outR * wetGain;\n        }\n")}},{key:"generateGranularDenseControlProcessing",value:function(e,n,t){var a=this,o="\n            // Update granular parameters from connections\n            float granular".concat(n,"_currentDensity = granular").concat(n,"_grain_density;\n            float granular").concat(n,"_currentPosition = granular").concat(n,"_position;\n            float granular").concat(n,"_currentPitch = granular").concat(n,"_pitch;\n            float granular").concat(n,"_currentDryWet = granular").concat(n,"_dry_wet;\n            bool granular").concat(n,"_currentFreeze = granular").concat(n,"_freeze;\n");return t.forEach(function(t){var c,r;if(t.to.id.includes("".concat(e.id,":"))){var i=t.from.id.split(":")[0],l=a.connectionResolver.modules.find(function(e){return e.id===i});if(l){var s=(null===(c=l.params)||void 0===c?void 0:c.index)||(null===(r=i.match(/\d+$/))||void 0===r?void 0:r[0])||"1";switch(t.to.port){case"density":switch(l.type){case"Pot":o+="\n            granular".concat(n,"_currentDensity = pot").concat(s,"_value * 20.0; // 0-20 grains/sec\n");break;case"LFO":o+="\n            granular".concat(n,"_currentDensity = granular").concat(n,"_grain_density + (lfo").concat(s,"_output * 10.0);\n")}break;case"position":switch(l.type){case"Pot":o+="\n            granular".concat(n,"_currentPosition = pot").concat(s,"_value; // 0-1 buffer position\n");break;case"LFO":o+="\n            granular".concat(n,"_currentPosition = constrain(granular").concat(n,"_position + (lfo").concat(s,"_output * 0.3), 0.0, 1.0);\n")}break;case"pitch":switch(l.type){case"Pot":o+="\n            granular".concat(n,"_currentPitch = (pot").concat(s,"_value - 0.5) * 4.0; // 2 octaves\n");break;case"ADSR":o+="\n            granular".concat(n,"_currentPitch = granular").concat(n,"_pitch + (adsr").concat(s,"_output * 2.0);\n")}break;case"dry_wet":"Pot"===l.type&&(o+="\n            granular".concat(n,"_currentDryWet = pot").concat(s,"_value; // 0=dry, 1=wet\n"));break;case"freeze":"LEDButton"===l.type&&(o+="\n            granular".concat(n,"_currentFreeze = btn").concat(s,"_pressed; // Freeze buffer\n"))}}}}),o+="\n            // Apply parameter constraints for stability\n            granular".concat(n,"_grain_density = constrain(granular").concat(n,"_currentDensity, 1.0, 20.0);\n            granular").concat(n,"_position = constrain(granular").concat(n,"_currentPosition, 0.0, 1.0);\n            granular").concat(n,"_pitch = constrain(granular").concat(n,"_currentPitch, -2.0, 2.0);\n            granular").concat(n,"_dry_wet = constrain(granular").concat(n,"_currentDryWet, 0.0, 1.0);\n            granular").concat(n,"_freeze = granular").concat(n,"_currentFreeze;\n")}},{key:"generateGranularDenseInputConnection",value:function(e,n,t){var a,o=e.from.id.split(":")[0],c=this.connectionResolver.modules.find(function(e){return e.id===o});if(!c)return"";var r=(null===(a=o.match(/\d+$/))||void 0===a?void 0:a[0])||"1";switch(c.type){case"Oscillator":return"granular".concat(n,"_input").concat(t," = osc").concat(r,"_output;");case"Filter":return"granular".concat(n,"_input").concat(t," = filter").concat(r,"_output").concat(t,";");case"VCA":return"granular".concat(n,"_input").concat(t," = vca").concat(r,"_output").concat(t,";");case"SamplePlayer":return"granular".concat(n,"_input").concat(t," = sdPlayer").concat(r,"_output").concat(t,";");default:return"// Unknown input type: ".concat(c.type)}}},{key:"generateSamplePlayerCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"trig"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch"===n.to.port}),c=(t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"sample_select"===n.to.port}),"false"),r="sp".concat(n,"_pitch"),i="sp".concat(n,"_currentFile");if(a){var l=a.from.id.split(":")[0],s=this.connectionResolver.modules.find(function(e){return e.id===l});if(s){var u=s.params?s.params.index:0;"LEDButton"===s.type&&(c="btn".concat(u,"_pressed"))}}if(o){var d=o.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"Scale":r="(scale".concat(m,"_output / 440.0)");break;case"ADSR":r="(sp".concat(n,"_pitch + adsr").concat(m,"_output * 0.5)");break;case"Pot":r="(pot".concat(m,"_value * 2.0 + 0.5)")}}}return e.params.polyphonic?"\n        // SamplePlayer ".concat(n," processing - Polyphonic Mode (6 voices)\n        {\n            bool trigger = ").concat(c,";\n            float pitchRatio = ").concat(r,";\n\n            // Voice allocation and triggering (simplified)\n            if (trigger) {\n                // Find available voice or steal oldest\n                int voiceToUse = sp").concat(n,"_nextVoice;\n                sp").concat(n,"_nextVoice = (sp").concat(n,"_nextVoice + 1) % SP").concat(n,"_VOICES;\n\n                // Initialize voice\n                sp").concat(n,"_voices[voiceToUse].active = true;\n                sp").concat(n,"_voices[voiceToUse].playPosition = 0;\n                sp").concat(n,"_voices[voiceToUse].pitch = pitchRatio;\n                sp").concat(n,"_voices[voiceToUse].fractionalPos = 0.0;\n            }\n\n            // Mix all active voices\n            float mixL = 0.0, mixR = 0.0;\n            for (int v = 0; v < SP").concat(n,"_VOICES; v++) {\n                if (sp").concat(n,"_voices[v].active && sp").concat(n,"_voices[v].psramData) {\n                    // Simple sample playback with pitch control\n                    uint32_t pos = (uint32_t)sp").concat(n,"_voices[v].fractionalPos;\n                    if (pos < sp").concat(n,"_voices[v].sampleLength) {\n                        float sample = (float)sp").concat(n,"_voices[v].psramData[pos] / 32767.0f;\n                        mixL += sample * sp").concat(n,"_voices[v].gain;\n                        mixR += sample * sp").concat(n,"_voices[v].gain;\n\n                        // Advance position with pitch control\n                        sp").concat(n,"_voices[v].fractionalPos += sp").concat(n,"_voices[v].pitch;\n                    } else {\n                        // Sample finished\n                        sp").concat(n,"_voices[v].active = false;\n                    }\n                }\n            }\n\n            sp").concat(n,"_outputL = mixL * sp").concat(n,"_masterGain;\n            sp").concat(n,"_outputR = mixR * sp").concat(n,"_masterGain;\n        }\n"):"\n        // SamplePlayer ".concat(n," processing - Single Voice Mode\n        {\n            // Control signal processing (from existing SampleModules)\n            bool currentTrigger = ").concat(c,";\n            float currentPitch = ").concat(r,";\n            int targetFile = ").concat(i,";\n\n            // Edge detection for trigger\n            if (currentTrigger && !sp").concat(n,"_lastTrigger) {\n                // Trigger detected - start playback\n                if (sp").concat(n,"_lastLoadedFile != -1) {\n                    sp").concat(n,"_player.play();\n                    sp").concat(n,"_playing = true;\n                }\n            }\n            sp").concat(n,"_lastTrigger = currentTrigger;\n\n            // Audio generation\n            if (sp").concat(n,"_playing) {\n                float sampleL, sampleR;\n                sp").concat(n,"_player.getStereoSample(sampleL, sampleR);\n\n                sp").concat(n,"_outputL = sampleL * sp").concat(n,"_gain;\n                sp").concat(n,"_outputR = sampleR * sp").concat(n,"_gain;\n\n                sp").concat(n,"_playing = sp").concat(n,"_player.playing();\n            } else {\n                sp").concat(n,"_outputL = 0.0f;\n                sp").concat(n,"_outputR = 0.0f;\n            }\n\n            // Update pitch if changed\n            if (currentPitch != sp").concat(n,"_pitch) {\n                sp").concat(n,"_pitch = currentPitch;\n                sp").concat(n,"_player.setPlaybackSpeed(sp").concat(n,"_pitch);\n            }\n        }\n")}},{key:"generateProcessingCode",value:function(e,n,t){switch(e.type){case"Oscillator":return this.generateOscillatorProcessingCode(e,n,t);case"PolyOscillator":return this.generatePolyOscillatorProcessingCode(e,n,t);case"Wavetable":return this.generateWavetableCode(e,n,t);case"Noise":case"NoiseGenerator":return this.generateNoiseCode(e,n,t);case"VCA":return this.generateVCAProcessingCode(e,n,t);case"Filter":return this.generateFilterCode(e,n,t);case"Distortion":return this.generateDistortionCode(e,n,t);case"StereoMixer4":return this.generateStereoMixer4Code(e,n,t);case"Matrix2x2":return this.generateMatrix2x2Code(e,n,t);case"I2SOut":case"PCM5102A Out":return this.generateI2SOutProcessingCode(e,n,t);case"LineIn":return this.generateLineInProcessingCode(e,n,t);case"AudioRecorder":return this.generateAudioRecorderCode(e,n,t);case"SamplePlayer":return null;case"CleanReverb":return this.generateCleanReverbCode(e,n,t);case"Delay":return this.generateDelayCode(e,n,t);case"GranularDense":return this.generateGranularDenseProcessingCode(e,n,t);case"GranularSynth":return this.generateGranularSynthProcessingCode(e,n,t);case"Resonance":return this.generateResonanceProcessingCode(e,n,t);case"DrumDesigner":return this.generateDrumDesignerCode(e,n,t);case"DrumDesigner4":return this.generateDrumDesigner4Code(e,n,t);default:return console.warn("No audio processing code generator for: ".concat(e.type)),null}}},{key:"generateNoiseProcessingCode",value:function(e,n,t){return"\n        // Noise Generator ".concat(n," processing\n        if (noise").concat(n,'_debug_counter % 1000 == 0) { // Every ~23ms at 44.1kHz\n            Serial.print("DEBUG: Noise generator').concat(n,' gate=");\n            Serial.print(noise').concat(n,'_gate);\n            Serial.print(", gain=");\n            Serial.print(noise').concat(n,'_gain);\n            Serial.print(", output=");\n            Serial.println(noise').concat(n,"_output);\n        }\n        noise").concat(n,"_debug_counter++;\n\n        float noise").concat(n,"_gateVal = noise").concat(n,"_gate;\n        if (noise").concat(n,"_gateVal > 0.1) {\n            // Generate white noise\n            float sample = ((float)random(-32768, 32768)) / 32768.0;\n            noise").concat(n,"_output = sample * noise").concat(n,"_gain;\n        } else {\n            noise").concat(n,"_output = 0.0;\n        }\n")}},{key:"generateVCAProcessingCode",value:function(e,n,t){return this.generateVCACode(e,n,t)}},{key:"generateFilterProcessingCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&("inL"===n.to.port||"input_left"===n.to.port)}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&("inR"===n.to.port||"input_right"===n.to.port)}),c="0.0",r="0.0";if(a){var i=a.from.id.split(":")[0],l=this.connectionResolver.modules.find(function(e){return e.id===i});if(l){var s,u=(null===(s=i.match(/\d+$/))||void 0===s?void 0:s[0])||"1";switch(l.type){case"Oscillator":c="osc".concat(u,"_output");break;case"CleanReverb":c="cleanreverb".concat(u,"_outputL");break;case"VCA":c="vca".concat(u,"_outputL");break;case"Noise":c="noise".concat(u,"_output");break;default:c="0.0"}}}if(o){var d=o.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"Oscillator":r="osc".concat(m,"_output");break;case"CleanReverb":r="cleanreverb".concat(m,"_outputR");break;case"VCA":r="vca".concat(m,"_outputR");break;case"Noise":r="noise".concat(m,"_output");break;default:r="0.0"}}}return"\n        // Filter ".concat(n," processing\n        filter").concat(n,"_inputL = ").concat(c,";\n        filter").concat(n,"_inputR = ").concat(r,";\n\n        // Simple low-pass filter implementation\n        float cutoffNorm = constrain(filter").concat(n,"_cutoff / 22050.0, 0.001, 0.99);\n        float alpha = sin(PI * cutoffNorm) / (1.0 + cos(PI * cutoffNorm));\n\n        // Apply filter to left channel\n        filter").concat(n,"_outputL = filter").concat(n,"_y1 + alpha * (filter").concat(n,"_inputL - filter").concat(n,"_y1);\n        filter").concat(n,"_y1 = filter").concat(n,"_outputL;\n\n        // Apply filter to right channel\n        filter").concat(n,"_outputR = filter").concat(n,"_y2 + alpha * (filter").concat(n,"_inputR - filter").concat(n,"_y2);\n        filter").concat(n,"_y2 = filter").concat(n,"_outputR;\n")}},{key:"generateStereoMixer4ProcessingCode",value:function(e,n,t){return"\n        // Stereo Mixer ".concat(n," processing\n        stereoMixer4_").concat(n,"_outputL = (stereoMixer4_").concat(n,"_input1L * stereoMixer4_").concat(n,"_gain1) +\n                                       (stereoMixer4_").concat(n,"_input2L * stereoMixer4_").concat(n,"_gain2) +\n                                       (stereoMixer4_").concat(n,"_input3L * stereoMixer4_").concat(n,"_gain3) +\n                                       (stereoMixer4_").concat(n,"_input4L * stereoMixer4_").concat(n,"_gain4);\n\n        stereoMixer4_").concat(n,"_outputR = (stereoMixer4_").concat(n,"_input1R * stereoMixer4_").concat(n,"_gain1) +\n                                       (stereoMixer4_").concat(n,"_input2R * stereoMixer4_").concat(n,"_gain2) +\n                                       (stereoMixer4_").concat(n,"_input3R * stereoMixer4_").concat(n,"_gain3) +\n                                       (stereoMixer4_").concat(n,"_input4R * stereoMixer4_").concat(n,"_gain4);\n")}},{key:"generateI2SOutProcessingCode",value:function(e,n,t){console.log("DEBUG I2S Processing - Module:",e.id,"Index:",n),console.log("DEBUG I2S Processing - Connections:",t.length);var a=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&("L"===a||"inL"===a)}),o=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&("R"===a||"inR"===a)});console.log("DEBUG I2S Processing - InputL Connection:",a),console.log("DEBUG I2S Processing - InputR Connection:",o);var c="0.0",r="0.0";if(a){for(var i,l,s=(null===(i=(l=a.from&&"string"==typeof a.from?a.from:a.from&&a.from.id?a.from.id.split(":")[0]:"unknown").match(/\d+$/))||void 0===i?void 0:i[0])||"1",u="Unknown",d=0,p=Object.entries({vca:"VCA",oscillator:"Wavetable",wavetable:"Wavetable",osc:"Oscillator",filter:"Filter",noise:"Noise",cleanreverb:"CleanReverb",reverb:"CleanReverb",delay:"Delay",stereomix:"StereoMixer4",panner:"Panner",matrix2x2:"Matrix2x2",granular:"GranularDense",linein:"LineIn",stereoin:"LineIn",audiorecorder:"AudioRecorder",rec:"AudioRecorder",drumdesigner:"DrumDesigner",polyoscillator:"PolyOscillator"});d<p.length;d++){var f=ke(p[d],2),m=f[0],_=f[1];if(l.toLowerCase().startsWith(m)){u=_;break}}switch(console.log("DEBUG I2S Processing - FromModuleId:",l,"Type:",u,"Index:",s),u){case"StereoMixer4":c="stereoMixer4_".concat(s,"_outputL");break;case"Wavetable":c="wt".concat(s,"_outputL");break;case"Oscillator":c="osc".concat(s,"_outputL");break;case"VCA":c="vca".concat(s,"_outputL");break;case"Filter":c="filter".concat(s,"_outputL");break;case"Noise":c="noise".concat(s,"_output");break;case"CleanReverb":c="cleanreverb".concat(s,"_outputL");break;case"Delay":c="delay".concat(s,"_outputL");break;case"GranularDense":c="granular".concat(s,"_outputL");break;case"LineIn":c="linein".concat(s,"_outputL");break;case"AudioRecorder":c="rec".concat(s,"_outputL");break;case"DrumDesigner":c="dd4".concat(s,"_outputMixL");break;case"PolyOscillator":c="polyosc".concat(s,"_outputL");break;default:c="0.0"}}if(o){for(var g,h,v=(null===(g=(h=o.from&&"string"==typeof o.from?o.from:o.from&&o.from.id?o.from.id.split(":")[0]:"unknown").match(/\d+$/))||void 0===g?void 0:g[0])||"1",b="Unknown",y=0,k=Object.entries({vca:"VCA",oscillator:"Wavetable",wavetable:"Wavetable",osc:"Oscillator",filter:"Filter",noise:"Noise",cleanreverb:"CleanReverb",reverb:"CleanReverb",delay:"Delay",stereomix:"StereoMixer4",panner:"Panner",matrix2x2:"Matrix2x2",granular:"GranularDense",linein:"LineIn",stereoin:"LineIn",audiorecorder:"AudioRecorder",rec:"AudioRecorder",drumdesigner:"DrumDesigner",polyoscillator:"PolyOscillator"});y<k.length;y++){var x=ke(k[y],2),S=x[0],E=x[1];if(h.toLowerCase().startsWith(S)){b=E;break}}switch(console.log("DEBUG I2S Processing - FromModuleId R:",h,"Type:",b,"Index:",v),b){case"StereoMixer4":r="stereoMixer4_".concat(v,"_outputR");break;case"Wavetable":r="wt".concat(v,"_outputR");break;case"Oscillator":r="osc".concat(v,"_outputR");break;case"VCA":r="vca".concat(v,"_outputR");break;case"Filter":r="filter".concat(v,"_outputR");break;case"Noise":r="noise".concat(v,"_output");break;case"CleanReverb":r="cleanreverb".concat(v,"_outputR");break;case"Delay":r="delay".concat(v,"_outputR");break;case"GranularDense":r="granular".concat(v,"_outputR");break;case"LineIn":r="linein".concat(v,"_outputR");break;case"AudioRecorder":r="rec".concat(v,"_outputR");break;case"DrumDesigner":r="dd4".concat(v,"_outputMixR");break;case"PolyOscillator":r="polyosc".concat(v,"_outputR");break;default:r="0.0"}}return console.log("DEBUG I2S Processing - Final Sources: L="+c+", R="+r),"\n        // I2S Output ".concat(n," processing - assign inputs then process (per sample)\n        i2sout").concat(n,"_inputL = ").concat(c,";\n        i2sout").concat(n,"_inputR = ").concat(r,";\n\n        // Debug output disabled for cleaner serial output\n\n        // Add connected signals to buffers (like working 1709Code)\n        leftBuffer[i] += i2sout").concat(n,"_inputL * i2sout").concat(n,"_volume;\n        rightBuffer[i] += i2sout").concat(n,"_inputR * i2sout").concat(n,"_volume;\n")}},{key:"generateLineInProcessingCode",value:function(e,n,t){var a=e.params.dc_block?"\n        // Apply DC blocking filter (HPF ~3.5Hz at 44.1kHz)\n        float linein".concat(n,"_dc_out_L = linein").concat(n,"_rawL - linein").concat(n,"_dc_x_prev_L + linein").concat(n,"_dc_coeff * linein").concat(n,"_dc_y_prev_L;\n        float linein").concat(n,"_dc_out_R = linein").concat(n,"_rawR - linein").concat(n,"_dc_x_prev_R + linein").concat(n,"_dc_coeff * linein").concat(n,"_dc_y_prev_R;\n        linein").concat(n,"_dc_x_prev_L = linein").concat(n,"_rawL;\n        linein").concat(n,"_dc_x_prev_R = linein").concat(n,"_rawR;\n        linein").concat(n,"_dc_y_prev_L = linein").concat(n,"_dc_out_L;\n        linein").concat(n,"_dc_y_prev_R = linein").concat(n,"_dc_out_R;\n        linein").concat(n,"_outputL = linein").concat(n,"_dc_out_L;\n        linein").concat(n,"_outputR = linein").concat(n,"_dc_out_R;"):"\n        linein".concat(n,"_outputL = linein").concat(n,"_rawL;\n        linein").concat(n,"_outputR = linein").concat(n,"_rawR;");return"\n        // Line In ".concat(n," processing\n        // Read from I2S input buffer (i2sInputBuffer) and apply gain\n        // Note: i2sInputBuffer is populated by i2s_read in the main audio processing function\n        int32_t linein").concat(n,"_sample_L = i2sInputBuffer[i * 2];\n        int32_t linein").concat(n,"_sample_R = i2sInputBuffer[i * 2 + 1];\n\n        // Convert 24-bit in 32-bit slot to float and apply gain\n        int32_t linein").concat(n,"_val24_L = (linein").concat(n,"_sample_L >> 8);  // 24-bit domain\n        int32_t linein").concat(n,"_val24_R = (linein").concat(n,"_sample_R >> 8);\n        float linein").concat(n,"_rawL = ((float)linein").concat(n,"_val24_L / 8388608.0f) * linein").concat(n,"_gain;\n        float linein").concat(n,"_rawR = ((float)linein").concat(n,"_val24_R / 8388608.0f) * linein").concat(n,"_gain;\n\n        // Clamp to valid range\n        if (linein").concat(n,"_rawL >  1.0f) linein").concat(n,"_rawL =  1.0f;\n        if (linein").concat(n,"_rawL < -1.0f) linein").concat(n,"_rawL = -1.0f;\n        if (linein").concat(n,"_rawR >  1.0f) linein").concat(n,"_rawR =  1.0f;\n        if (linein").concat(n,"_rawR < -1.0f) linein").concat(n,"_rawR = -1.0f;\n").concat(a,"\n")}},{key:"generateAudioRecorderCode",value:function(e,n,t){var a=e.params,o=(a.bank,a.max_duration_sec||60),c=Math.floor(44100*o),r=a.bit_depth||24,i=24===r?3:2,l=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),s=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port}),u="0.0f",d="0.0f";if(l){var p,f=(null===(p=l.from.id.split(":")[0].match(/\d+$/))||void 0===p?void 0:p[0])||"1";u="linein".concat(f,"_outputL")}if(s){var m,_=(null===(m=s.from.id.split(":")[0].match(/\d+$/))||void 0===m?void 0:m[0])||"1";d="linein".concat(_,"_outputR")}return"\n        // AudioRecorder ".concat(n," - With throttled hardware reads to prevent I2C audio dropouts\n        {\n            // THROTTLED HARDWARE READING - Only every 1024 samples (~23ms @ 44.1kHz)\n            // This prevents MCP23017 I2C reads from blocking audio processing\n            // Track total samples to increment counter once per buffer (always incrementing, not just when recording)\n            static uint32_t rec").concat(n,"_totalSampleCounter = 0;\n            rec").concat(n,"_totalSampleCounter++;\n\n            // Increment hardware read counter every 256 samples (once per buffer)\n            if (rec").concat(n,"_totalSampleCounter % 256 == 0) {\n                rec").concat(n,"_hwReadCounter++;\n            }\n\n            if (rec").concat(n,"_hwReadCounter >= rec").concat(n,"_hwReadInterval) {\n                rec").concat(n,'_hwReadCounter = 0;\n\n                // Debug: Print recording state at hardware read\n                static unsigned long lastStateDebug = 0;\n                if (millis() - lastStateDebug > 2000) {\n                    lastStateDebug = millis();\n                    Serial.printf("[REC%d] State: recording=%d, samples=%lu, armed=%d\\n",\n                                 ').concat(n,", rec").concat(n,"_recording, rec").concat(n,"_samplesRecorded, rec").concat(n,"_armedForEdge);\n                }\n\n                // Check if we need to finalize a recording (SD writer finished draining)\n                if (rec").concat(n,"_finalizePending && rec").concat(n,'_buffered == 0) {\n                    Serial.printf("[REC%d] SD writer finished, finalizing file...\\n", ').concat(n,");\n                    // Update WAV header with final size\n                    if (rec").concat(n,"_recFile) {\n                        uint32_t dataSize = rec").concat(n,"_samplesRecorded * 2 * ").concat(i,";\n                        uint32_t fileSize = dataSize + 36;\n                        rec").concat(n,"_recFile.seek(4);\n                        rec").concat(n,"_recFile.write((uint8_t*)&fileSize, 4);\n                        rec").concat(n,"_recFile.seek(40);\n                        rec").concat(n,"_recFile.write((uint8_t*)&dataSize, 4);\n                        rec").concat(n,'_recFile.close();\n                        Serial.printf("[REC%d] WAV header updated, file closed\\n", ').concat(n,");\n                        rec").concat(n,"_fileAvailable = true;  // File ready for playback\n\n                        // Increment file index for next recording (persistent auto-increment)\n                        rec").concat(n,'_currentFileIndex++;\n                        Serial.printf("[REC%d] Next recording will use: rec%03d.wav\\n", ').concat(n,", rec").concat(n,"_currentFileIndex);\n                    }\n                    rec").concat(n,"_finalizePending = false;\n                }\n\n                // Read buttons and pots only when in correct bank\n                if (currentBank == rec").concat(n,"_bank) {\n                    // Use global 'inputs' variable (batch read by updateHardware on Core 0)\n                    // Button mapping: Btn1=GPA2, Btn2=GPA1, Btn3=GPA0, Btn4=GPA3 - active low\n                    rec").concat(n,"_btn1_state = !(inputs & (1 << 2));  // Button 1 (GPA2) - Record\n                    rec").concat(n,"_btn2_state = !(inputs & (1 << 1));  // Button 2 (GPA1) - Play/Pause\n                    rec").concat(n,"_btn3_state = !(inputs & (1 << 0));  // Button 3 (GPA0) - Prev/Rewind\n                    rec").concat(n,"_btn4_state = !(inputs & (1 << 3));  // Button 4 (GPA3) - Next/FFwd\n\n                    float pot1_raw = analogRead(4) / 4095.0f;  // Pot 1 - Input Gain\n                    float pot2_raw = analogRead(5) / 4095.0f;  // Pot 2 - Playback Volume\n                    float pot3_raw = analogRead(6) / 4095.0f;  // Pot 3 - Play Mode (0-3)\n                    float pot4_raw = analogRead(7) / 4095.0f;  // Pot 4 - Play Speed (0.25x-2.0x)\n\n                    rec").concat(n,"_inputGain = pot1_raw * 4.0f;         // 0.0x-4.0x (attenuator: 0 = silent input)\n                    rec").concat(n,"_playbackVol = pot2_raw * 2.0f;       // 0.0x-2.0x\n                    rec").concat(n,"_playMode = (int)(pot3_raw * 3.999f); // 0-3 (normal, loop, reverse, ping-pong)\n\n                    // Speed control with octave detents (0.25x-2.0x)\n                    float rawSpeed = pot4_raw * 1.75f + 0.25f;\n                    // Octave detent zones (+/- 3% around each octave):\n                    // 0.25x (2 oct down) at pot=0%, 0.5x (1 oct down) at pot=14.3%, 1.0x (original) at pot=42.9%, 2.0x (1 oct up) at pot=100%\n                    const float detentWidth = 0.03f;  // 3% deadzone around each octave\n                    if (pot4_raw < 0.0f + detentWidth) {\n                        rec").concat(n,"_playSpeed = 0.25f;  // 2 octaves down detent\n                    } else if (fabs(pot4_raw - 0.143f) < detentWidth) {\n                        rec").concat(n,"_playSpeed = 0.5f;   // 1 octave down detent\n                    } else if (fabs(pot4_raw - 0.429f) < detentWidth) {\n                        rec").concat(n,"_playSpeed = 1.0f;   // Original pitch detent (center)\n                    } else if (pot4_raw > 1.0f - detentWidth) {\n                        rec").concat(n,"_playSpeed = 2.0f;   // 1 octave up detent\n                    } else {\n                        rec").concat(n,"_playSpeed = rawSpeed;  // Smooth interpolation between detents\n                    }\n                }\n\n                // BUTTON 1: Record Toggle with debounce (prevents double-trigger from bounce/timing races)\n                unsigned long nowMs = millis();\n                bool rising = rec").concat(n,"_btn1_state && !rec").concat(n,"_btn1_last;\n\n                if (rising && rec").concat(n,"_armedForEdge && (nowMs - rec").concat(n,"_lastToggleMs > rec").concat(n,"_toggleDebounceMs)) {\n                    rec").concat(n,"_lastToggleMs = nowMs;\n                    rec").concat(n,'_armedForEdge = false;  // Disarm until button released\n\n                    Serial.printf("[REC%d] TOGGLE at %lums (armed=%d, lastToggle=%lums ago, recording=%d)\\n",\n                                 ').concat(n,", nowMs, rec").concat(n,"_armedForEdge, nowMs - rec").concat(n,"_lastToggleMs, rec").concat(n,"_recording);\n\n                    if (!rec").concat(n,"_recording) {\n                        // START RECORDING (block if currently playing)\n                        if (rec").concat(n,'_playing) {\n                            Serial.printf("[REC%d] Cannot record while playing - stop playback first\\n", ').concat(n,');\n                        } else {\n                            Serial.printf("[REC%d] START recording\\n", ').concat(n,");\n\n                        // Remember which file we're recording to (for playback later)\n                        rec").concat(n,"_lastRecordedFileIndex = rec").concat(n,"_currentFileIndex;\n\n                        // Reset counters FIRST (before any file operations)\n                        rec").concat(n,"_samplesRecorded = 0;\n                        rec").concat(n,'_currentBlockPos = 0;\n                        Serial.printf("[REC%d] Counters reset: samples=%lu, blockPos=%d\\n", ').concat(n,", rec").concat(n,"_samplesRecorded, rec").concat(n,'_currentBlockPos);\n\n                        char filename[32];\n                        snprintf(filename, sizeof(filename), "/rec%03d.wav", rec').concat(n,"_currentFileIndex);\n                        // Delete existing file (FILE_WRITE appends, which corrupts WAV files)\n                        if (SD.exists(filename)) {\n                            SD.remove(filename);\n                        }\n                        rec").concat(n,"_recFile = SD.open(filename, FILE_WRITE);\n                        if (rec").concat(n,'_recFile) {\n                            Serial.printf("[REC%d] File opened: %s\\n", ').concat(n,", filename);\n                            // Write WAV header\n                            rec").concat(n,'_recFile.write((const uint8_t*)"RIFF", 4);\n                            uint32_t tempSize = 0;\n                            rec').concat(n,"_recFile.write((uint8_t*)&tempSize, 4);\n                            rec").concat(n,'_recFile.write((const uint8_t*)"WAVE", 4);\n                            rec').concat(n,'_recFile.write((const uint8_t*)"fmt ", 4);\n                            uint32_t fmtSize = 16;\n                            rec').concat(n,"_recFile.write((uint8_t*)&fmtSize, 4);\n                            uint16_t audioFormat = 1;\n                            rec").concat(n,"_recFile.write((uint8_t*)&audioFormat, 2);\n                            uint16_t numChannels = 2;\n                            rec").concat(n,"_recFile.write((uint8_t*)&numChannels, 2);\n                            uint32_t sampleRate = 44100;\n                            rec").concat(n,"_recFile.write((uint8_t*)&sampleRate, 4);\n                            uint32_t byteRate = 44100 * 2 * ").concat(i,";\n                            rec").concat(n,"_recFile.write((uint8_t*)&byteRate, 4);\n                            uint16_t blockAlign = 2 * ").concat(i,";\n                            rec").concat(n,"_recFile.write((uint8_t*)&blockAlign, 2);\n                            uint16_t bitsPerSample = ").concat(r,";\n                            rec").concat(n,"_recFile.write((uint8_t*)&bitsPerSample, 2);\n                            rec").concat(n,'_recFile.write((const uint8_t*)"data", 4);\n                            rec').concat(n,"_recFile.write((uint8_t*)&tempSize, 4);\n                            rec").concat(n,'_recording = true;\n                            Serial.printf("[REC%d] Recording flag set to TRUE\\n", ').concat(n,');\n                        } else {\n                            Serial.printf("[REC%d] ERROR: Failed to open file %s\\n", ').concat(n,', filename);\n                        }\n                        }  // Close "if (!playing)" block\n                    } else {\n                        // STOP RECORDING - Flush final partial block and wait for SD writer\n                        Serial.printf("[REC%d] STOP recording (%lu samples = %.2f seconds)\\n",\n                                     ').concat(n,", rec").concat(n,"_samplesRecorded, rec").concat(n,"_samplesRecorded / 44100.0f);\n\n                        rec").concat(n,"_recording = false;  // Stop accepting new samples\n\n                        // If we have a partial block, push it to ring buffer\n                        if (rec").concat(n,'_currentBlockPos > 0) {\n                            Serial.printf("[REC%d] Flushing partial block: %d bytes\\n", ').concat(n,", rec").concat(n,"_currentBlockPos);\n\n                            // Pad remainder with zeros\n                            memset(&rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos], 0,\n                                   REC").concat(n,"_BLOCK_SIZE - rec").concat(n,"_currentBlockPos);\n\n                            // Check if ring buffer has space (should always have space since we stopped recording)\n                            if (rec").concat(n,"_buffered < REC").concat(n,"_BLOCK_COUNT) {\n                                // Copy block to ring buffer\n                                memcpy(&rec").concat(n,"_ringBuffer[rec").concat(n,"_writeIdx * REC").concat(n,"_BLOCK_SIZE],\n                                       rec").concat(n,"_currentBlock, REC").concat(n,"_BLOCK_SIZE);\n\n                                // Update ring buffer pointers (blocking lock is OK here - we're not in audio loop)\n                                if (xSemaphoreTake(rec").concat(n,"_bufferMutex, portMAX_DELAY)) {\n                                    rec").concat(n,"_writeIdx = (rec").concat(n,"_writeIdx + 1) % REC").concat(n,"_BLOCK_COUNT;\n                                    rec").concat(n,"_buffered++;\n                                    xSemaphoreGive(rec").concat(n,'_bufferMutex);\n                                }\n                            } else {\n                                Serial.printf("[REC%d] ERROR: Ring buffer full during stop! Data loss!\\n", ').concat(n,");\n                            }\n                            rec").concat(n,"_currentBlockPos = 0;\n                        }\n\n                        // Mark for finalization (don't block audio thread!)\n                        rec").concat(n,'_finalizePending = true;\n                        Serial.printf("[REC%d] Recording stopped, waiting for SD writer to finish (%d blocks buffered)\\n",\n                                     ').concat(n,", rec").concat(n,'_buffered);\n                        Serial.printf("[REC%d] Recording flag cleared (manual stop)\\n", ').concat(n,");\n                    }\n                }\n\n                // Re-arm only after clean button release AND debounce period elapsed\n                if (!rec").concat(n,"_btn1_state && rec").concat(n,"_btn1_last && (nowMs - rec").concat(n,"_lastToggleMs > rec").concat(n,"_toggleDebounceMs)) {\n                    rec").concat(n,'_armedForEdge = true;\n                    Serial.printf("[REC%d] RE-ARMED (button released, %lums after last toggle)\\n", ').concat(n,", nowMs - rec").concat(n,"_lastToggleMs);\n                }\n\n                rec").concat(n,"_btn1_last = rec").concat(n,"_btn1_state;\n\n                // BUTTON 2: Play/Pause Toggle\n                if (rec").concat(n,"_btn2_state && !rec").concat(n,'_btn2_last) {\n                    Serial.printf("[REC%d] BUTTON 2 pressed (playing=%d)\\n", ').concat(n,", rec").concat(n,"_playing);\n                    if (!rec").concat(n,"_playing) {\n                        // START STREAMING PLAYBACK - Only if a file has been recorded\n                        if (rec").concat(n,'_lastRecordedFileIndex == 0) {\n                            Serial.printf("[PLAY%d] No file recorded yet\\n", ').concat(n,');\n                        } else {\n                            char filename[32];\n                            snprintf(filename, sizeof(filename), "/rec%03d.wav", rec').concat(n,'_lastRecordedFileIndex);\n                            Serial.printf("[PLAY%d] Starting streaming playback: %s\\n", ').concat(n,", filename);\n\n                        rec").concat(n,"_playFile = SD.open(filename, FILE_READ);\n                        if (rec").concat(n,'_playFile) {\n                            Serial.printf("[PLAY%d] File opened for streaming\\n", ').concat(n,");\n\n                            // Read WAV header\n                            rec").concat(n,"_playFile.seek(22);\n                            uint16_t channels;\n                            rec").concat(n,"_playFile.read((uint8_t*)&channels, 2);\n                            rec").concat(n,"_channels = channels;\n\n                            rec").concat(n,"_playFile.seek(40);\n                            uint32_t dataSize;\n                            rec").concat(n,"_playFile.read((uint8_t*)&dataSize, 4);\n                            rec").concat(n,"_totalSamples = dataSize / (").concat(i," * rec").concat(n,'_channels);\n\n                            Serial.printf("[PLAY%d] Channels: %d, Total samples: %lu (%.2f seconds)\\n",\n                                         ').concat(n,", rec").concat(n,"_channels, rec").concat(n,"_totalSamples,\n                                         rec").concat(n,"_totalSamples / 44100.0f);\n\n                            // Seek to audio data start (byte 44)\n                            rec").concat(n,"_playFile.seek(44);\n\n                            // Reset ring buffer indices and counters\n                            if (xSemaphoreTake(play").concat(n,"_bufferMutex, portMAX_DELAY)) {\n                                play").concat(n,"_writeIdx = 0;\n                                play").concat(n,"_readIdx = 0;\n                                play").concat(n,"_buffered = 0;\n                                play").concat(n,"_eofReached = false;\n                                xSemaphoreGive(play").concat(n,"_bufferMutex);\n                            }\n\n                            play").concat(n,"_currentBlockPos = 0;\n                            play").concat(n,"_currentBlockSize = 0;\n                            rec").concat(n,"_sampleAccumulator = 0.0f;  // Reset speed accumulator\n\n                            // Initialize playback position and direction based on mode\n                            if (rec").concat(n,"_playMode == 2) {\n                                // Reverse mode - start at end, play backwards\n                                rec").concat(n,"_samplesPlayed = rec").concat(n,"_totalSamples - 1;\n                                rec").concat(n,'_playReverse = true;\n                                Serial.printf("[PLAY%d] Starting in REVERSE mode from end\\n", ').concat(n,");\n                            } else {\n                                // Normal/Loop/Ping-pong - start at beginning, play forwards\n                                rec").concat(n,"_samplesPlayed = 0;\n                                rec").concat(n,"_playReverse = false;\n                            }\n\n                            // Initialize output to silence\n                            rec").concat(n,"_outputL = 0.0f;\n                            rec").concat(n,"_outputR = 0.0f;\n\n                            // Start playback (SD reader task will automatically fill ring buffer)\n                            rec").concat(n,"_playing = true;\n                            rec").concat(n,'_paused = false;\n                            Serial.printf("[PLAY%d] Streaming playback started! SD reader task will fill ring buffer.\\n", ').concat(n,');\n                        } else {\n                            Serial.printf("[PLAY%d] ERROR: Failed to open file for playback\\n", ').concat(n,');\n                        }\n                        }  // Close "if (fileAvailable)" block\n                    } else {\n                        // TOGGLE PAUSE\n                        rec').concat(n,"_paused = !rec").concat(n,"_paused;\n                    }\n                }\n                rec").concat(n,"_btn2_last = rec").concat(n,"_btn2_state;\n\n                // BUTTON 3: Previous Track (short press) / Rewind (long press)\n                if (rec").concat(n,"_btn3_state && !rec").concat(n,"_btn3_last) {\n                    // Button just pressed - start timer\n                    rec").concat(n,"_btn3_pressStart = nowMs;\n                    rec").concat(n,"_btn3_longHandled = false;\n                } else if (rec").concat(n,"_btn3_state && (nowMs - rec").concat(n,"_btn3_pressStart > rec").concat(n,"_longPressThreshold) && !rec").concat(n,"_btn3_longHandled) {\n                    // Long press - REWIND (seek backward during playback)\n                    if (rec").concat(n,"_playing && rec").concat(n,"_samplesPlayed > 44100) {  // Skip back 1 second\n                        rec").concat(n,'_samplesPlayed -= 44100;\n                        Serial.printf("[PLAY%d] REWIND: Seek to %.2f seconds\\n", ').concat(n,", rec").concat(n,"_samplesPlayed / 44100.0f);\n                        // Mark as handled to prevent repeat until button released\n                        rec").concat(n,"_btn3_longHandled = true;\n                    }\n                } else if (!rec").concat(n,"_btn3_state && rec").concat(n,"_btn3_last) {\n                    // Button released\n                    if (!rec").concat(n,"_btn3_longHandled && (nowMs - rec").concat(n,"_btn3_pressStart < rec").concat(n,"_longPressThreshold)) {\n                        // Short press - PREVIOUS TRACK\n                        if (rec").concat(n,"_lastRecordedFileIndex > 1) {\n                            rec").concat(n,'_lastRecordedFileIndex--;\n                            Serial.printf("[PLAY%d] Previous track: rec%03d.wav\\n", ').concat(n,", rec").concat(n,"_lastRecordedFileIndex);\n                            // If currently playing, restart with new file\n                            if (rec").concat(n,"_playing) {\n                                rec").concat(n,"_playing = false;\n                                rec").concat(n,"_playFile.close();\n                                // Trigger playback restart (simulate button 2 press)\n                                rec").concat(n,"_btn2_state = true;\n                                rec").concat(n,"_btn2_last = false;\n                            }\n                        }\n                    }\n                }\n                rec").concat(n,"_btn3_last = rec").concat(n,"_btn3_state;\n\n                // BUTTON 4: Next Track (short press) / Fast Forward (long press)\n                if (rec").concat(n,"_btn4_state && !rec").concat(n,"_btn4_last) {\n                    // Button just pressed - start timer\n                    rec").concat(n,"_btn4_pressStart = nowMs;\n                    rec").concat(n,"_btn4_longHandled = false;\n                } else if (rec").concat(n,"_btn4_state && (nowMs - rec").concat(n,"_btn4_pressStart > rec").concat(n,"_longPressThreshold) && !rec").concat(n,"_btn4_longHandled) {\n                    // Long press - FAST FORWARD (seek forward during playback)\n                    if (rec").concat(n,"_playing && rec").concat(n,"_samplesPlayed < rec").concat(n,"_totalSamples - 44100) {  // Skip forward 1 second\n                        rec").concat(n,'_samplesPlayed += 44100;\n                        Serial.printf("[PLAY%d] FAST FORWARD: Seek to %.2f seconds\\n", ').concat(n,", rec").concat(n,"_samplesPlayed / 44100.0f);\n                        // Mark as handled to prevent repeat until button released\n                        rec").concat(n,"_btn4_longHandled = true;\n                    }\n                } else if (!rec").concat(n,"_btn4_state && rec").concat(n,"_btn4_last) {\n                    // Button released\n                    if (!rec").concat(n,"_btn4_longHandled && (nowMs - rec").concat(n,"_btn4_pressStart < rec").concat(n,"_longPressThreshold)) {\n                        // Short press - NEXT TRACK\n                        if (rec").concat(n,"_lastRecordedFileIndex < rec").concat(n,"_currentFileIndex - 1) {\n                            rec").concat(n,'_lastRecordedFileIndex++;\n                            Serial.printf("[PLAY%d] Next track: rec%03d.wav\\n", ').concat(n,", rec").concat(n,"_lastRecordedFileIndex);\n                            // If currently playing, restart with new file\n                            if (rec").concat(n,"_playing) {\n                                rec").concat(n,"_playing = false;\n                                rec").concat(n,"_playFile.close();\n                                // Trigger playback restart (simulate button 2 press)\n                                rec").concat(n,"_btn2_state = true;\n                                rec").concat(n,"_btn2_last = false;\n                            }\n                        }\n                    }\n                }\n                rec").concat(n,"_btn4_last = rec").concat(n,"_btn4_state;\n\n                // LED FEEDBACK (updated every hardware read ~23ms, NOT per-sample for performance)\n                // LED1 (Record): Solid red when recording, OFF otherwise\n                // LED2 (Play): Solid green when playing, pulsing green when file ready, OFF otherwise\n                if (rec").concat(n,"_recording || rec").concat(n,"_finalizePending) {\n                    rec").concat(n,"_led1 = 1.0f;  // Solid red while recording or finalizing\n                    rec").concat(n,"_led2 = 0.0f;  // Play LED off while recording\n                } else if (rec").concat(n,"_playing) {\n                    rec").concat(n,"_led1 = 0.0f;  // Record LED off while playing\n                    if (rec").concat(n,"_paused) {\n                        rec").concat(n,"_led2 = (sin(millis() / 300.0f) + 1.0f) * 0.5f;  // Pulsing green while paused\n                    } else {\n                        rec").concat(n,"_led2 = 1.0f;  // Solid green while playing\n                    }\n                } else {\n                    // Idle state - pulsing red when armed for recording, pulsing green if file ready for playback\n                    rec").concat(n,"_led1 = (millis() % 1000 < 500) ? 1.0f : 0.0f;  // Pulsing red (armed for recording)\n                    if (rec").concat(n,"_lastRecordedFileIndex > 0) {\n                        rec").concat(n,"_led2 = (sin(millis() / 500.0f) + 1.0f) * 0.5f;  // Pulsing green (file ready)\n                    } else {\n                        rec").concat(n,"_led2 = 0.0f;  // Off if no file\n                    }\n                }\n            }\n\n            // GET INPUT AUDIO (every sample)\n            float inL = ").concat(u,";\n            float inR = ").concat(d,";\n            inL *= rec").concat(n,"_inputGain;\n            inR *= rec").concat(n,"_inputGain;\n\n            // RECORDING PROCESS - Write to ring buffer (async SD writes, glitch-free!)\n            if (rec").concat(n,"_recording) {\n                // Write sample to current block (audio thread local, no locks needed)\n                int32_t sampleL = (int32_t)(constrain(inL, -1.0f, 1.0f) * 8388607.0f);\n                int32_t sampleR = (int32_t)(constrain(inR, -1.0f, 1.0f) * 8388607.0f);\n                rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos++] = sampleL & 0xFF;\n                rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos++] = (sampleL >> 8) & 0xFF;\n                rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos++] = (sampleL >> 16) & 0xFF;\n                rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos++] = sampleR & 0xFF;\n                rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos++] = (sampleR >> 8) & 0xFF;\n                rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos++] = (sampleR >> 16) & 0xFF;\n                rec").concat(n,"_samplesRecorded++;\n\n                // When current block is full, push to ring buffer for SD writer task\n                if (rec").concat(n,"_currentBlockPos >= REC").concat(n,"_BLOCK_SIZE) {\n                    // Check if ring buffer has space\n                    if (rec").concat(n,"_buffered < REC").concat(n,"_BLOCK_COUNT) {\n                        // Copy block to ring buffer\n                        memcpy(&rec").concat(n,"_ringBuffer[rec").concat(n,"_writeIdx * REC").concat(n,"_BLOCK_SIZE],\n                               rec").concat(n,"_currentBlock,\n                               REC").concat(n,"_BLOCK_SIZE);\n\n                        // Update ring buffer pointers (thread-safe)\n                        if (xSemaphoreTake(rec").concat(n,"_bufferMutex, 0)) {  // Try-lock (don't block audio!)\n                            rec").concat(n,"_writeIdx = (rec").concat(n,"_writeIdx + 1) % REC").concat(n,"_BLOCK_COUNT;\n                            rec").concat(n,"_buffered++;\n                            xSemaphoreGive(rec").concat(n,'_bufferMutex);\n                        } else {\n                            // Couldn\'t get mutex - skip this block (rare, but prevents audio glitches)\n                            Serial.printf("[REC%d] Mutex busy, skipping block\\n", ').concat(n,');\n                        }\n                    } else {\n                        // Ring buffer full! SD writer task can\'t keep up\n                        Serial.printf("[REC%d] Ring buffer full! Dropping block (SD too slow)\\n", ').concat(n,");\n                    }\n\n                    // Reset current block\n                    rec").concat(n,"_currentBlockPos = 0;\n                }\n\n                // Auto-stop at max duration (").concat(c," samples = ").concat(o," seconds)\n                if (rec").concat(n,"_samplesRecorded >= ").concat(c,') {\n                    Serial.printf("[REC%d] Auto-stop at %lu samples (%.2f seconds)\\n",\n                                 ').concat(n,", rec").concat(n,"_samplesRecorded, rec").concat(n,"_samplesRecorded / 44100.0f);\n\n                    rec").concat(n,"_recording = false;  // Stop accepting new samples\n\n                    // Flush partial block to ring buffer (same as manual stop)\n                    if (rec").concat(n,"_currentBlockPos > 0) {\n                        memset(&rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos], 0,\n                               REC").concat(n,"_BLOCK_SIZE - rec").concat(n,"_currentBlockPos);\n\n                        if (rec").concat(n,"_buffered < REC").concat(n,"_BLOCK_COUNT) {\n                            memcpy(&rec").concat(n,"_ringBuffer[rec").concat(n,"_writeIdx * REC").concat(n,"_BLOCK_SIZE],\n                                   rec").concat(n,"_currentBlock, REC").concat(n,"_BLOCK_SIZE);\n\n                            if (xSemaphoreTake(rec").concat(n,"_bufferMutex, portMAX_DELAY)) {\n                                rec").concat(n,"_writeIdx = (rec").concat(n,"_writeIdx + 1) % REC").concat(n,"_BLOCK_COUNT;\n                                rec").concat(n,"_buffered++;\n                                xSemaphoreGive(rec").concat(n,"_bufferMutex);\n                            }\n                        }\n                        rec").concat(n,"_currentBlockPos = 0;\n                    }\n\n                    // Wait for SD writer to finish (with timeout)\n                    uint32_t waitStart = millis();\n                    while (rec").concat(n,"_buffered > 0 && (millis() - waitStart < 5000)) {\n                        delay(10);\n                    }\n\n                    // Update WAV header and close file\n                    if (rec").concat(n,"_recFile) {\n                        uint32_t dataSize = rec").concat(n,"_samplesRecorded * 2 * ").concat(i,";\n                        uint32_t fileSize = dataSize + 36;\n                        rec").concat(n,"_recFile.seek(4);\n                        rec").concat(n,"_recFile.write((uint8_t*)&fileSize, 4);\n                        rec").concat(n,"_recFile.seek(40);\n                        rec").concat(n,"_recFile.write((uint8_t*)&dataSize, 4);\n                        rec").concat(n,'_recFile.close();\n                    }\n\n                    Serial.printf("[REC%d] Recording flag cleared (auto-stop)\\n", ').concat(n,");\n                }\n            }\n\n            // PLAYBACK PROCESS - Read from ring buffer (streaming playback, glitch-free!)\n            if (rec").concat(n,"_playing && !rec").concat(n,"_paused) {\n                // Check if current block needs refill\n                if (play").concat(n,"_currentBlockPos >= play").concat(n,"_currentBlockSize) {\n                    // Try to get next block from ring buffer\n                    if (play").concat(n,"_buffered > 0) {\n                        // Get next block from ring\n                        if (xSemaphoreTake(play").concat(n,"_bufferMutex, 0)) {  // Try-lock (don't block audio!)\n                            size_t idx = play").concat(n,"_readIdx;\n\n                            // Calculate how many bytes we actually need (handle last partial block)\n                            uint32_t samplesRemaining = rec").concat(n,"_totalSamples - rec").concat(n,"_samplesPlayed;\n                            uint32_t bytesRemaining = samplesRemaining * 6;  // 6 bytes per stereo sample\n                            size_t blockSize = (bytesRemaining >= PLAY").concat(n,"_BLOCK_SIZE) ? PLAY").concat(n,"_BLOCK_SIZE : bytesRemaining;\n\n                            // Copy block from ring buffer (only copy what we need)\n                            memcpy(play").concat(n,"_currentBlock,\n                                   &play").concat(n,"_ringBuffer[idx * PLAY").concat(n,"_BLOCK_SIZE],\n                                   blockSize);\n                            play").concat(n,"_readIdx = (play").concat(n,"_readIdx + 1) % PLAY").concat(n,"_BLOCK_COUNT;\n                            play").concat(n,"_buffered--;\n                            xSemaphoreGive(play").concat(n,"_bufferMutex);\n\n                            play").concat(n,"_currentBlockPos = 0;\n                            play").concat(n,"_currentBlockSize = blockSize;  // Use calculated size (handles last partial block)\n                        } else {\n                            // Couldn't get mutex - keep previous output (sample-and-hold, prevents clicks)\n                        }\n                    } else if (play").concat(n,"_eofReached) {\n                        // Ring buffer empty and EOF reached - playback finished\n                        rec").concat(n,"_playing = false;\n                        rec").concat(n,"_playFile.close();\n                        rec").concat(n,'_samplesPlayed = 0;\n                        Serial.printf("[PLAY%d] Playback finished\\n", ').concat(n,");\n                        rec").concat(n,"_outputL = inL;\n                        rec").concat(n,"_outputR = inR;\n                    } else {\n                        // Ring buffer temporarily empty (SD reader still filling) - keep previous output\n                        // (No serial output here - Serial.print is SLOW and causes glitches!)\n                    }\n                }\n\n                // Variable speed playback using fractional sample accumulator\n                rec").concat(n,"_sampleAccumulator += rec").concat(n,"_playSpeed;\n\n                // Read sample from current block when accumulator >= 1.0\n                bool canReadSample = play").concat(n,"_currentBlockPos < play").concat(n,"_currentBlockSize &&\n                                     ((!rec").concat(n,"_playReverse && rec").concat(n,"_samplesPlayed < rec").concat(n,"_totalSamples) ||\n                                      (rec").concat(n,"_playReverse && rec").concat(n,"_samplesPlayed > 0));\n\n                while (rec").concat(n,"_sampleAccumulator >= 1.0f && canReadSample) {\n                    // Read 24-bit stereo sample (6 bytes total)\n                    uint8_t* pos = &play").concat(n,"_currentBlock[play").concat(n,"_currentBlockPos];\n                    int32_t sampleL = (int32_t)(pos[0] | (pos[1] << 8) | (pos[2] << 16));\n                    int32_t sampleR = (int32_t)(pos[3] | (pos[4] << 8) | (pos[5] << 16));\n\n                    // Sign extend 24-bit to 32-bit\n                    if (sampleL & 0x800000) sampleL |= 0xFF000000;\n                    if (sampleR & 0x800000) sampleR |= 0xFF000000;\n\n                    // Convert to float (-1.0 to 1.0), apply playback volume, and mix with live input (scaled by inputGain)\n                    rec").concat(n,"_outputL = (sampleL / 8388607.0f) * rec").concat(n,"_playbackVol + inL * rec").concat(n,"_inputGain;\n                    rec").concat(n,"_outputR = (sampleR / 8388607.0f) * rec").concat(n,"_playbackVol + inR * rec").concat(n,"_inputGain;\n\n                    play").concat(n,"_currentBlockPos += 6;  // Advance by 6 bytes (24-bit stereo)\n\n                    // Increment or decrement sample position based on direction\n                    if (rec").concat(n,"_playReverse) {\n                        rec").concat(n,"_samplesPlayed--;\n                    } else {\n                        rec").concat(n,"_samplesPlayed++;\n                    }\n                    rec").concat(n,"_sampleAccumulator -= 1.0f;  // Consume one sample from accumulator\n\n                    // Update canReadSample for next iteration\n                    canReadSample = play").concat(n,"_currentBlockPos < play").concat(n,"_currentBlockSize &&\n                                    ((!rec").concat(n,"_playReverse && rec").concat(n,"_samplesPlayed < rec").concat(n,"_totalSamples) ||\n                                     (rec").concat(n,"_playReverse && rec").concat(n,"_samplesPlayed > 0));\n                }\n\n                // Check for end of file (or start if playing reverse)\n                bool hitEnd = (!rec").concat(n,"_playReverse && rec").concat(n,"_samplesPlayed >= rec").concat(n,"_totalSamples) ||\n                              (rec").concat(n,"_playReverse && rec").concat(n,"_samplesPlayed == 0);\n\n                if (hitEnd) {\n                    // Play mode handling\n                    if (rec").concat(n,"_playMode == 1) {\n                        // LOOP MODE - Restart from beginning\n                        rec").concat(n,"_samplesPlayed = 0;\n                        rec").concat(n,"_sampleAccumulator = 0.0f;\n                        rec").concat(n,"_playReverse = false;  // Always loop forward\n                        play").concat(n,"_currentBlockPos = 0;\n                        play").concat(n,"_currentBlockSize = 0;\n                        // Reset ring buffer and SD reader (restart streaming from beginning)\n                        if (xSemaphoreTake(play").concat(n,"_bufferMutex, 0)) {\n                            play").concat(n,"_writeIdx = 0;\n                            play").concat(n,"_readIdx = 0;\n                            play").concat(n,"_buffered = 0;\n                            play").concat(n,"_eofReached = false;\n                            xSemaphoreGive(play").concat(n,"_bufferMutex);\n                        }\n                        rec").concat(n,'_playFile.seek(44);  // Seek back to audio data start\n                        Serial.printf("[PLAY%d] Loop mode: Restarting from beginning\\n", ').concat(n,");\n                    } else if (rec").concat(n,"_playMode == 2) {\n                        // REVERSE MODE - Loop backwards\n                        rec").concat(n,"_samplesPlayed = rec").concat(n,"_totalSamples - 1;\n                        rec").concat(n,"_sampleAccumulator = 0.0f;\n                        rec").concat(n,"_playReverse = true;  // Keep playing reverse\n                        play").concat(n,"_currentBlockPos = 0;\n                        play").concat(n,'_currentBlockSize = 0;\n                        Serial.printf("[PLAY%d] Reverse mode: Looping to end\\n", ').concat(n,");\n                    } else if (rec").concat(n,"_playMode == 3) {\n                        // PING-PONG MODE - Reverse direction\n                        rec").concat(n,"_playReverse = !rec").concat(n,"_playReverse;\n                        rec").concat(n,"_sampleAccumulator = 0.0f;\n                        if (rec").concat(n,"_playReverse) {\n                            rec").concat(n,"_samplesPlayed = rec").concat(n,'_totalSamples - 1;\n                            Serial.printf("[PLAY%d] Ping-pong mode: Now playing backwards\\n", ').concat(n,");\n                        } else {\n                            rec").concat(n,'_samplesPlayed = 0;\n                            Serial.printf("[PLAY%d] Ping-pong mode: Now playing forwards\\n", ').concat(n,");\n                        }\n                        play").concat(n,"_currentBlockPos = 0;\n                        play").concat(n,"_currentBlockSize = 0;\n                        // Reset ring buffer\n                        if (xSemaphoreTake(play").concat(n,"_bufferMutex, 0)) {\n                            play").concat(n,"_writeIdx = 0;\n                            play").concat(n,"_readIdx = 0;\n                            play").concat(n,"_buffered = 0;\n                            play").concat(n,"_eofReached = false;\n                            xSemaphoreGive(play").concat(n,"_bufferMutex);\n                        }\n                        rec").concat(n,"_playFile.seek(44 + (rec").concat(n,"_samplesPlayed * 6));\n                    } else {\n                        // NORMAL MODE - Stop playback\n                        rec").concat(n,"_playing = false;\n                        rec").concat(n,"_playFile.close();\n                        rec").concat(n,"_samplesPlayed = 0;\n                        rec").concat(n,"_sampleAccumulator = 0.0f;\n                        rec").concat(n,'_playReverse = false;\n                        Serial.printf("[PLAY%d] Playback finished\\n", ').concat(n,");\n                        rec").concat(n,"_outputL = inL;\n                        rec").concat(n,"_outputR = inR;\n                    }\n                }\n                // Note: If no new sample read, output keeps previous value (sample-and-hold for slow speeds)\n            } else {\n                // PASS-THROUGH MODE (not playing or paused)\n                rec").concat(n,"_outputL = inL;\n                rec").concat(n,"_outputR = inR;\n            }\n        }\n")}},{key:"generateDelayCode",value:function(e,n,t){var a=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&("inL"===a||"in"===a)}),o=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"inR"===a}),c=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"time"===a}),r=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"feedback"===a}),i=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"mix"===a}),l=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"tempo_hz"===a}),s=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"freeze"===a}),u=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"pingpong"===a}),d=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"pitch_shift"===a}),p="delay".concat(n,"_time_ms"),f="delay".concat(n,"_feedback"),m="delay".concat(n,"_mix"),_="delay".concat(n,"_pingpong"),g="delay".concat(n,"_freeze"),h="delay".concat(n,"_pitch_shift"),v="delay".concat(n,"_division"),b="delay".concat(n,"_tempo_hz");if(a){var y;a.from&&"string"==typeof a.from?y=a.from:a.from&&a.from.id&&(y=a.from.id.split(":")[0]);var k=this.connectionResolver.modules.find(function(e){return e.id===y});if(k){var x,S=(null===(x=y.match(/\d+$/))||void 0===x?void 0:x[0])||"1";switch(k.type){case"VCA":"vca".concat(S,"_outputL");break;case"Oscillator":"osc".concat(S,"_outputL");break;case"Filter":"filter".concat(S,"_outputL");break;case"Noise":case"NoiseGenerator":"noise".concat(S,"_output");break;case"CleanReverb":"cleanreverb".concat(S,"_outputL");break;case"StereoMixer4":"stereoMixer4_".concat(S,"_outputL")}}}if(o){var E;o.from&&"string"==typeof o.from?E=o.from:o.from&&o.from.id&&(E=o.from.id.split(":")[0]);var P=this.connectionResolver.modules.find(function(e){return e.id===E});if(P){var w,C=(null===(w=E.match(/\d+$/))||void 0===w?void 0:w[0])||"1";switch(P.type){case"VCA":"vca".concat(C,"_outputR");break;case"Oscillator":"osc".concat(C,"_outputR");break;case"Filter":"filter".concat(C,"_outputR");break;case"Noise":case"NoiseGenerator":"noise".concat(C,"_output");break;case"CleanReverb":"cleanreverb".concat(C,"_outputR");break;case"StereoMixer4":"stereoMixer4_".concat(C,"_outputR")}}}if(c){var I;c.from&&"string"==typeof c.from?I=c.from:c.from&&c.from.id&&(I=c.from.id.split(":")[0]);var R=this.connectionResolver.modules.find(function(e){return e.id===I});if(R){var L,M=(null===(L=I.match(/\d+$/))||void 0===L?void 0:L[0])||"1";if("Pot"===R.type){var D=R.params.index||M;p="(pot".concat(D,"_value * 1000.0)")}}}if(r){var A;r.from&&"string"==typeof r.from?A=r.from:r.from&&r.from.id&&(A=r.from.id.split(":")[0]);var O=this.connectionResolver.modules.find(function(e){return e.id===A});if(O){var B,T=(null===(B=A.match(/\d+$/))||void 0===B?void 0:B[0])||"1";if("Pot"===O.type){var F=O.params.index||T;f="pot".concat(F,"_value")}}}if(i){var N;i.from&&"string"==typeof i.from?N=i.from:i.from&&i.from.id&&(N=i.from.id.split(":")[0]);var z=this.connectionResolver.modules.find(function(e){return e.id===N});if(z){var G,q=(null===(G=N.match(/\d+$/))||void 0===G?void 0:G[0])||"1";if("Pot"===z.type){var U=z.params.index||q;m="pot".concat(U,"_value")}}}if(l){var W;l.from&&"string"==typeof l.from?W=l.from:l.from&&l.from.id&&(W=l.from.id.split(":")[0]);var V=this.connectionResolver.modules.find(function(e){return e.id===W});if(V){var H,j=(null===(H=W.match(/\d+$/))||void 0===H?void 0:H[0])||"1";switch(V.type){case"GateGen":case"Gate Generator":b="gate".concat(j,"_rate");break;case"Clock":b="clock".concat(j,"_tempo_hz")}}}if(s){var K;s.from&&"string"==typeof s.from?K=s.from:s.from&&s.from.id&&(K=s.from.id.split(":")[0]);var Y=this.connectionResolver.modules.find(function(e){return e.id===K});if(Y){var $,X,Z=(null===($=K.match(/\d+$/))||void 0===$?void 0:$[0])||"1",Q=(null===(X=Y.params)||void 0===X?void 0:X.index)||Z;switch(Y.type){case"LEDButton":g="btn".concat(Q,"_pressed ? 1.0 : 0.0");break;case"Pot":g="pot".concat(Q,"_value");break;case"ADSR":g="adsr".concat(Z,"_output");break;case"LFO":g="lfo".concat(Z,"_output")}}}if(u){var J;u.from&&"string"==typeof u.from?J=u.from:u.from&&u.from.id&&(J=u.from.id.split(":")[0]);var ee=this.connectionResolver.modules.find(function(e){return e.id===J});if(ee){var ne,te,ae=(null===(ne=J.match(/\d+$/))||void 0===ne?void 0:ne[0])||"1",oe=(null===(te=ee.params)||void 0===te?void 0:te.index)||ae;switch(ee.type){case"Pot":_="pot".concat(oe,"_value");break;case"LFO":_="lfo".concat(ae,"_output")}}}if(d){var ce;d.from&&"string"==typeof d.from?ce=d.from:d.from&&d.from.id&&(ce=d.from.id.split(":")[0]);var re=this.connectionResolver.modules.find(function(e){return e.id===ce});if(re){var ie,le,se=(null===(ie=ce.match(/\d+$/))||void 0===ie?void 0:ie[0])||"1",ue=(null===(le=re.params)||void 0===le?void 0:le.index)||se;switch(re.type){case"Pot":h="(0.25 + pot".concat(ue,"_value * 3.75)");break;case"LFO":h="(0.25 + lfo".concat(se,"_output * 3.75)")}}}return"\n        // Delay ".concat(n," processing - Professional Feedback Delay with Ping-Pong, Freeze & Pitch Shift\n        {\n            float time_ms = ").concat(p,";\n            float tempo_hz = ").concat(b,";\n            float division = ").concat(v,";\n            float feedback = ").concat(f,";\n            float mix = ").concat(m,";\n            float pingpong = constrain(").concat(_,", 0.0, 1.0);\n            float freeze = ").concat(g,";\n            float pitch_shift = constrain(").concat(h,", 0.25, 4.0);\n            float inputL = delay").concat(n,"_inputL;\n            float inputR = delay").concat(n,"_inputR;\n\n            // Tempo sync: if tempo_hz is connected, calculate time from tempo and division\n            if (tempo_hz > 0.01) {\n                time_ms = (1000.0 / tempo_hz) * division;\n            }\n\n            float delayTime = constrain(time_ms, 1.0, 2000.0); // 1ms to 2000ms\n            mix = constrain(mix, 0.0, 1.0);\n\n            // Freeze mode: mute input and set infinite feedback\n            if (freeze > 0.5) {\n                inputL = 0.0; // Mute input\n                inputR = 0.0;\n                feedback = 0.99; // Infinite feedback (freeze buffer)\n            } else {\n                feedback = constrain(feedback, 0.0, 0.95); // Prevent runaway feedback (normal mode)\n            }\n\n            // Calculate delay samples from time in milliseconds\n            float delaySamplesFloat = delayTime * 44.1; // Samples at 44.1kHz\n            int delaySamplesInt = (int)delaySamplesFloat;\n            delaySamplesInt = constrain(delaySamplesInt, 1, DELAY").concat(n,"_BUFFER_SIZE - 1);\n\n            // Pitch shift: variable read speed (only when pitch_shift != 1.0)\n            float readPosFloatL, readPosFloatR;\n            if (pitch_shift != 1.0) {\n                // Update read position with pitch ratio\n                delay").concat(n,"_readPosFloat += pitch_shift;\n                if (delay").concat(n,"_readPosFloat >= DELAY").concat(n,"_BUFFER_SIZE) {\n                    delay").concat(n,"_readPosFloat -= DELAY").concat(n,"_BUFFER_SIZE;\n                }\n                readPosFloatL = delay").concat(n,"_readPosFloat;\n                readPosFloatR = delay").concat(n,"_readPosFloat;\n            } else {\n                // Normal mode: read from delay time\n                readPosFloatL = (float)((delay").concat(n,"_writePos - delaySamplesInt + DELAY").concat(n,"_BUFFER_SIZE) % DELAY").concat(n,"_BUFFER_SIZE);\n                readPosFloatR = readPosFloatL;\n            }\n\n            // Linear interpolation for smooth pitch shifting\n            int readPosL_int = (int)readPosFloatL;\n            int readPosL_next = (readPosL_int + 1) % DELAY").concat(n,"_BUFFER_SIZE;\n            float fracL = readPosFloatL - (float)readPosL_int;\n            float delayedL = delay").concat(n,"_bufferL[readPosL_int] * (1.0 - fracL) + delay").concat(n,"_bufferL[readPosL_next] * fracL;\n\n            int readPosR_int = (int)readPosFloatR;\n            int readPosR_next = (readPosR_int + 1) % DELAY").concat(n,"_BUFFER_SIZE;\n            float fracR = readPosFloatR - (float)readPosR_int;\n            float delayedR = delay").concat(n,"_bufferR[readPosR_int] * (1.0 - fracR) + delay").concat(n,"_bufferR[readPosR_next] * fracR;\n\n            // Apply feedback damping filter to prevent harsh feedback\n            delay").concat(n,"_feedback_lpf_L = delay").concat(n,"_feedback_lpf_L * 0.7 + delayedL * 0.3;\n            delay").concat(n,"_feedback_lpf_R = delay").concat(n,"_feedback_lpf_R * 0.7 + delayedR * 0.3;\n\n            // Ping-pong mode: swap L/R feedback\n            float feedbackL_source = delay").concat(n,"_feedback_lpf_L * (1.0 - pingpong) + delay").concat(n,"_feedback_lpf_R * pingpong;\n            float feedbackR_source = delay").concat(n,"_feedback_lpf_R * (1.0 - pingpong) + delay").concat(n,"_feedback_lpf_L * pingpong;\n\n            // Write new samples with feedback\n            delay").concat(n,"_bufferL[delay").concat(n,"_writePos] = inputL + feedbackL_source * feedback;\n            delay").concat(n,"_bufferR[delay").concat(n,"_writePos] = inputR + feedbackR_source * feedback;\n\n            // Advance write position\n            delay").concat(n,"_writePos = (delay").concat(n,"_writePos + 1) % DELAY").concat(n,"_BUFFER_SIZE;\n\n            // Output with dry/wet mix\n            delay").concat(n,"_outputL = inputL * (1.0 - mix) + delayedL * mix;\n            delay").concat(n,"_outputR = inputR * (1.0 - mix) + delayedR * mix;\n\n            // Denormal protection (prevent CPU performance issues and artifacts)\n            if (fabsf(delay").concat(n,"_outputL) < 1e-12f) delay").concat(n,"_outputL = 0.0f;\n            if (fabsf(delay").concat(n,"_outputR) < 1e-12f) delay").concat(n,"_outputR = 0.0f;\n        }\n")}},{key:"generateWavetableVariables",value:function(e,n,t){for(var a=e.params.wavetables||[],o=512,c="",r=0;r<4;r++){var i=a[r];if(i&&i.length>0)c+="\n// Wavetable ".concat(r," data (").concat(i.length," samples)\nfloat wt").concat(n,"_table").concat(r,"[").concat(o,"] = {\n    ").concat(Array.from(i).map(function(e,n){var t=e.toFixed(6)+"f";return n%8==0&&n>0?"\n    "+t:t}).join(", "),"\n};");else{var l=void 0,s=void 0;switch(r){case 0:l=Array.from({length:o},function(e,n){return Math.sin(n/o*2*Math.PI)}),s="sine wave - default";break;case 1:l=Array.from({length:o},function(e,n){return n/o*2-1}),s="sawtooth wave - default";break;case 2:l=Array.from({length:o},function(e,n){return n<256?1:-1}),s="square wave - default";break;case 3:l=Array.from({length:o},function(e,n){var t=n/o;return t<.5?4*t-1:3-4*t}),s="triangle wave - default"}c+="\n// Wavetable ".concat(r," data (").concat(s,")\nfloat wt").concat(n,"_table").concat(r,"[").concat(o,"] = {\n    ").concat(l.map(function(e,n){var t=e.toFixed(6)+"f";return n%8==0&&n>0?"\n    "+t:t}).join(", "),"\n};")}}return"\n// ".concat(t.label," ").concat(n,"\n").concat(c,"\n\n// Wavetable oscillator variables\n#define WT").concat(n,"_TABLE_SIZE ").concat(o,"\nfloat wt").concat(n,"_phase = 0.0;\nfloat wt").concat(n,"_freq = ").concat(e.params.freq||440,";\nfloat wt").concat(n,"_gain = ").concat(e.params.gain||.25,";\nfloat wt").concat(n,"_gate = 0.0; // Default gate OFF (controlled by MIDI/Arpeggiator/button connections)\nfloat wt").concat(n,"_morph = ").concat(e.params.morph||0,";\nint wt").concat(n,"_current_table = ").concat(e.params.current_table||0,";\nfloat wt").concat(n,"_pitch_amount = ").concat(e.params.pitch_range||24,";\nfloat wt").concat(n,"_fm_amount = ").concat(e.params.fm_amount||0,";\nfloat wt").concat(n,"_fm_ratio = ").concat(e.params.fm_ratio||1,";\nfloat wt").concat(n,"_fm_ratio_cv = 0.0; // CV control for FM ratio (0-1)\nfloat wt").concat(n,"_pitch_smooth = 0.5;\nfloat wt").concat(n,"_outputL = 0.0;\nfloat wt").concat(n,"_outputR = 0.0;\nfloat wt").concat(n,"_lastMidiNote = -1.0; // Track last MIDI note for CPU optimization\nfloat wt").concat(n,"_cachedFreq = 440.0;  // Cached frequency to avoid pow() every sample\nfloat wt").concat(n,"_velocity = 1.0;      // Velocity scaling (0-1) from note input\n")}},{key:"generateSamplePlayerProcessingCode",value:function(e,n,t){return this.generateSamplePlayerCode(e,n,t)}},{key:"generateGranularDenseProcessingCode",value:function(e,n,t){var a=this,o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port}),r="0.0",i="0.0";if(o){var l=o.from.id.split(":")[0],s=this.connectionResolver.modules.find(function(e){return e.id===l});if(s){var u,d=(null===(u=l.match(/\d+$/))||void 0===u?void 0:u[0])||"1";r="".concat(s.type.toLowerCase()).concat(d,"_outputL"),"Oscillator"===s.type&&(r="osc".concat(d,"_outputL"))}}if(c){var p=c.from.id.split(":")[0],f=this.connectionResolver.modules.find(function(e){return e.id===p});if(f){var m,_=(null===(m=p.match(/\d+$/))||void 0===m?void 0:m[0])||"1";i="".concat(f.type.toLowerCase()).concat(_,"_outputR"),"Oscillator"===f.type&&(i="osc".concat(_,"_outputR"))}}var g=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"grain_density"===n.to.port}),h=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"position"===n.to.port}),v=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch"===n.to.port}),b=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"dry_wet"===n.to.port}),y=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"freeze"===n.to.port}),k=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"stereo_width"===n.to.port}),x=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"cloud_pan"===n.to.port}),S=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch_cv_1"===n.to.port}),E=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch_cv_2"===n.to.port}),P=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch_cv_3"===n.to.port}),w=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch_cv_4"===n.to.port}),C="\n        // GranularDense ".concat(n," - Dense granular synthesis with 20 grains (round-robin: 10 grains/sample, ~76% CPU at max density)\n        granular").concat(n,"_inputL = ").concat(r,";\n        granular").concat(n,"_inputR = ").concat(i,";");if(g||(C+="\n        granular".concat(n,"_currentDensity = granular").concat(n,"_grain_density;")),h||(C+="\n        granular".concat(n,"_currentPosition = granular").concat(n,"_position;")),v||(C+="\n        granular".concat(n,"_currentPitch = granular").concat(n,"_pitch;")),b||(C+="\n        granular".concat(n,"_currentDryWet = granular").concat(n,"_dry_wet;")),y||(C+="\n        granular".concat(n,"_currentFreeze = granular").concat(n,"_freeze;")),C+="\n",g){var I=g.from.id.split(":")[0],R=this.connectionResolver.modules.find(function(e){return e.id===I});if("Pot"===(null==R?void 0:R.type)){var L=R.params.index||1;C+=this.generateBankAwareAssignment(R,"granular".concat(n,"_currentDensity = pot").concat(L,"_value * 20.0; // 0-20 grains/sec (round-robin processing)"))}}if(h){var M=h.from.id.split(":")[0],D=this.connectionResolver.modules.find(function(e){return e.id===M});if("Pot"===(null==D?void 0:D.type)){var A=D.params.index||1;C+=this.generateBankAwareAssignment(D,"granular".concat(n,"_currentPosition = pot").concat(A,"_value; // 0-1 position"))}}if(v){var O=v.from.id.split(":")[0],B=this.connectionResolver.modules.find(function(e){return e.id===O});if("Pot"===(null==B?void 0:B.type)){var T=B.params.index||1;C+=this.generateBankAwareAssignment(B,"granular".concat(n,"_currentPitch = (pot").concat(T,"_value - 0.5) * 24.0; // -12 to +12 semitones (1 octave)"))}}if(b){var F=b.from.id.split(":")[0],N=this.connectionResolver.modules.find(function(e){return e.id===F});if("Pot"===(null==N?void 0:N.type)){var z=N.params.index||1;C+=this.generateBankAwareAssignment(N,"granular".concat(n,"_currentDryWet = pot").concat(z,"_value; // 0-1 dry/wet"))}}if(y){var G=y.from.id.split(":")[0],q=this.connectionResolver.modules.find(function(e){return e.id===G});if("LEDButton"===(null==q?void 0:q.type)){var U,W=(null===(U=G.match(/\d+$/))||void 0===U?void 0:U[0])||"1";C+="        granular".concat(n,"_currentFreeze = btn").concat(W,"_output; // Button freeze control\n")}}if(k){var V=k.from.id.split(":")[0],H=this.connectionResolver.modules.find(function(e){return e.id===V});if("Pot"===(null==H?void 0:H.type)){var j=H.params.index||1;C+=this.generateBankAwareAssignment(H,"granular".concat(n,"_currentStereoWidth = pot").concat(j,"_value; // 0-1 stereo width"))}}if(x){var K=x.from.id.split(":")[0],Y=this.connectionResolver.modules.find(function(e){return e.id===K});if("Pot"===(null==Y?void 0:Y.type)){var $=Y.params.index||1;C+=this.generateBankAwareAssignment(Y,"granular".concat(n,"_currentCloudPan = 0.1 + (pot").concat($,"_value * 0.8); // 0.1-0.9 cloud pan (10% margin)"))}}var X=function(e,t){if(!e)return"";var o="",c=e.from.id.split(":")[0],r=a.connectionResolver.modules.find(function(e){return e.id===c});if("Pot"===(null==r?void 0:r.type)){var i=r.params.index||1;o+=a.generateBankAwareAssignment(r,"granular".concat(n,"_currentPitchCV").concat(t," = (pot").concat(i,"_value - 0.5) * 24.0; // -12 to +12 semitones CV").concat(t))}else if("ADSR"===(null==r?void 0:r.type)){var l,s=(null===(l=c.match(/\d+$/))||void 0===l?void 0:l[0])||"1";o+="        granular".concat(n,"_currentPitchCV").concat(t," = (adsr").concat(s,"_output - 0.5) * 24.0; // CV").concat(t," from ADSR\n")}else if("LFO"===(null==r?void 0:r.type)){var u,d=(null===(u=c.match(/\d+$/))||void 0===u?void 0:u[0])||"1";o+="        granular".concat(n,"_currentPitchCV").concat(t," = lfo").concat(d,"_output * 12.0; // CV").concat(t," from LFO\n")}else if("HarmonicSequencer"===(null==r?void 0:r.type)){var p,f,m=(null===(p=c.match(/\d+$/))||void 0===p?void 0:p[0])||"1",_=(null===(f=e.from.port.match(/v(\d+)_pitch/))||void 0===f?void 0:f[1])||"1";o+="        granular".concat(n,"_currentPitchCV").concat(t," = harmseq").concat(m,"_v").concat(_,"_pitch; // CV").concat(t," from HarmonicSequencer voice ").concat(_,"\n")}return o};C+=X(S,1),C+=X(E,2),C+=X(P,3),C+=X(w,4),C+="\n        // Dense granular processing with freeze capability - 32ms grains, 20 concurrent\n        // Only fill buffer if not frozen\n        if (granular".concat(n,"_currentFreeze < 0.9) {\n            granular").concat(n,"_buffer_L[granular").concat(n,"_write_pos] = granular").concat(n,"_inputL;\n            granular").concat(n,"_buffer_R[granular").concat(n,"_write_pos] = granular").concat(n,"_inputR;\n            granular").concat(n,"_write_pos = (granular").concat(n,"_write_pos + 1) % granular").concat(n,"_buffer_size;\n        }\n\n        // Dense grain triggering with memory-efficient rate limiting\n        granular").concat(n,"_samples_since_grain++;\n        float grainInterval = 44100.0 / constrain(granular").concat(n,"_currentDensity, 0.1f, 20.0f);\n\n        // Only trigger if we have a reasonable interval and available grain slots\n        static int granular").concat(n,"_activeGrainCount = 0;\n        if (granular").concat(n,"_samples_since_grain >= (int)grainInterval && granular").concat(n,"_activeGrainCount < 16) {\n            // Find an inactive grain slot (limit to 16 concurrent for stability at max density)\n            for (int i = 0; i < 20; i++) {\n                if (!granular").concat(n,"_grains[i].active) {\n                    granular").concat(n,"_grains[i].active = true;\n\n                    // Position in buffer with spread - read from BEHIND write position for delay effect\n                    // currentPosition: 0=max delay (oldest audio), 1=min delay (recent audio)\n                    float delayAmount = (1.0f - granular").concat(n,"_currentPosition) * granular").concat(n,"_buffer_size * 0.9f; // Up to 90% of buffer\n                    float basePos = (float)granular").concat(n,"_write_pos - delayAmount;\n                    if (basePos < 0) basePos += granular").concat(n,"_buffer_size;\n\n                    float spreadRange = granular").concat(n,"_position_spread * granular").concat(n,"_buffer_size * 0.5;\n                    float spread = ((float)random(-1000, 1000) / 1000.0) * spreadRange;\n                    granular").concat(n,"_grains[i].position = basePos + spread;\n\n                    // Ensure position is within buffer bounds\n                    if (granular").concat(n,"_grains[i].position < 0)\n                        granular").concat(n,"_grains[i].position += granular").concat(n,"_buffer_size;\n                    if (granular").concat(n,"_grains[i].position >= granular").concat(n,"_buffer_size)\n                        granular").concat(n,"_grains[i].position -= granular").concat(n,"_buffer_size;\n\n                    // Pitch ratio with spread and grouped CV modulation\n                    float pitchSpread = ((float)random(-1000, 1000) / 1000.0) * granular").concat(n,"_pitch_spread;\n\n                    // Select pitch CV based on grain group (dynamic grouping)\n                    float cvPitch = 0.0;\n");var Z=[S,E,P,w].filter(function(e){return void 0!==e}).length;if(0===Z)C+="                    // No pitch CV connections\n";else if(1===Z){var Q=S?1:E?2:P?3:4;C+="                    // Single pitch CV - all grains use CV".concat(Q,"\n"),C+="                    cvPitch = granular".concat(n,"_currentPitchCV").concat(Q,";\n")}else if(2===Z){var J=S?1:E?2:3,ee=w?4:P?3:2;C+="                    // 2 pitch CVs - 10 grains per group\n",C+="                    if (i < 10) {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV").concat(J,";\n"),C+="                    } else {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV").concat(ee,";\n"),C+="                    }\n"}else if(3===Z){var ne=[S?1:0,E?2:0,P?3:0,w?4:0].filter(function(e){return e>0});C+="                    // 3 pitch CVs - groups of 7, 7, 6 grains\n",C+="                    if (i < 7) {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV").concat(ne[0],";\n"),C+="                    } else if (i < 14) {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV").concat(ne[1],";\n"),C+="                    } else {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV").concat(ne[2],";\n"),C+="                    }\n"}else C+="                    // 4 pitch CVs - 5 grains per group\n",C+="                    if (i < 5) {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV1;\n"),C+="                    } else if (i < 10) {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV2;\n"),C+="                    } else if (i < 15) {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV3;\n"),C+="                    } else {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV4;\n"),C+="                    }\n";return C+="\n                    float totalPitch = granular".concat(n,"_currentPitch + cvPitch + pitchSpread;\n                    granular").concat(n,"_grains[i].pitch_ratio = pow(2.0, totalPitch / 12.0);\n\n                    // Reverse every second grain (odd indices)\n                    if (i % 2 == 1) {\n                        granular").concat(n,"_grains[i].pitch_ratio = -granular").concat(n,"_grains[i].pitch_ratio;\n                    }\n"),C+="\n                    // Stereo panning calculation\n",Z>1?(C+="                    if (granular".concat(n,"_grouped_panning > 0.5) {\n"),C+="                        // GROUPED PANNING MODE: Each pitch group has its own pan anchor\n",2===Z?(C+="                        float groupAnchor;\n",C+="                        int groupIndex;\n",C+="                        bool isGroupLeader;\n",C+="                        if (i < 10) {\n",C+="                            groupIndex = 0;\n",C+="                            isGroupLeader = (i == 0);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan - granular").concat(n,"_currentStereoWidth * 0.25; // Group 1 left\n"),C+="                        } else {\n",C+="                            groupIndex = 1;\n",C+="                            isGroupLeader = (i == 10);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan + granular").concat(n,"_currentStereoWidth * 0.25; // Group 2 right\n"),C+="                        }\n"):3===Z?(C+="                        float groupAnchor;\n",C+="                        int groupIndex;\n",C+="                        bool isGroupLeader;\n",C+="                        if (i < 7) {\n",C+="                            groupIndex = 0;\n",C+="                            isGroupLeader = (i == 0);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan - granular").concat(n,"_currentStereoWidth * 0.333; // Group 1 left\n"),C+="                        } else if (i < 14) {\n",C+="                            groupIndex = 1;\n",C+="                            isGroupLeader = (i == 7);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan; // Group 2 center\n"),C+="                        } else {\n",C+="                            groupIndex = 2;\n",C+="                            isGroupLeader = (i == 14);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan + granular").concat(n,"_currentStereoWidth * 0.333; // Group 3 right\n"),C+="                        }\n"):4===Z&&(C+="                        float groupAnchor;\n",C+="                        int groupIndex;\n",C+="                        bool isGroupLeader;\n",C+="                        if (i < 5) {\n",C+="                            groupIndex = 0;\n",C+="                            isGroupLeader = (i == 0);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan - granular").concat(n,"_currentStereoWidth * 0.375; // Group 1 far left\n"),C+="                        } else if (i < 10) {\n",C+="                            groupIndex = 1;\n",C+="                            isGroupLeader = (i == 5);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan - granular").concat(n,"_currentStereoWidth * 0.125; // Group 2 center-left\n"),C+="                        } else if (i < 15) {\n",C+="                            groupIndex = 2;\n",C+="                            isGroupLeader = (i == 10);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan + granular").concat(n,"_currentStereoWidth * 0.125; // Group 3 center-right\n"),C+="                        } else {\n",C+="                            groupIndex = 3;\n",C+="                            isGroupLeader = (i == 15);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan + granular").concat(n,"_currentStereoWidth * 0.375; // Group 4 far right\n"),C+="                        }\n"),C+="                        // First grain of each group uses exact anchor, others spread relative to it\n",C+="                        if (isGroupLeader) {\n",C+="                            granular".concat(n,"_grains[i].pan = constrain(groupAnchor, 0.0f, 1.0f);\n"),C+="                        } else {\n",C+="                            // Spread within group (1/".concat(Z," of total stereo_width per group)\n"),C+="                            float groupSpread = ((float)random(-1000, 1000) / 1000.0) * granular".concat(n,"_currentStereoWidth * 0.5 / ").concat(Z,".0;\n"),C+="                            granular".concat(n,"_grains[i].pan = constrain(groupAnchor + groupSpread, 0.0f, 1.0f);\n"),C+="                        }\n",C+="                    } else {\n",C+="                        // NORMAL MODE: All grains spread from single cloud_pan anchor\n",C+="                        if (i == 0) {\n",C+="                            granular".concat(n,"_grains[i].pan = granular").concat(n,"_currentCloudPan;\n"),C+="                        } else {\n",C+="                            float panSpread = ((float)random(-1000, 1000) / 1000.0) * granular".concat(n,"_currentStereoWidth;\n"),C+="                            granular".concat(n,"_grains[i].pan = constrain(granular").concat(n,"_currentCloudPan + panSpread, 0.05f, 0.95f);\n"),C+="                        }\n",C+="                    }\n"):(C+="                    // Normal panning - first grain anchored, others spread relative\n",C+="                    if (i == 0) {\n",C+="                        granular".concat(n,"_grains[i].pan = granular").concat(n,"_currentCloudPan;\n"),C+="                    } else {\n",C+="                        float panSpread = ((float)random(-1000, 1000) / 1000.0) * granular".concat(n,"_currentStereoWidth;\n"),C+="                        granular".concat(n,"_grains[i].pan = constrain(granular").concat(n,"_currentCloudPan + panSpread, 0.05f, 0.95f);\n"),C+="                    }\n"),C+"\n\n                    // Short 32ms grains for dense texture - fixed size for consistent texture\n                    const int grainSamples = (int)(0.032 * 44100.0); // 32ms\n                    granular".concat(n,"_grains[i].samples_remaining = grainSamples;\n\n                    // Envelope setup for short grains\n                    granular").concat(n,"_grains[i].envelope_pos = 0.0;\n                    granular").concat(n,"_grains[i].envelope_inc = 1.0 / grainSamples;\n\n                    granular").concat(n,"_samples_since_grain = 0;\n                    granular").concat(n,"_activeGrainCount++;\n                    break;\n                }\n            }\n        }\n\n        // Process grains (round-robin: 10 grains per sample for 50% CPU reduction)\n        float grainSumL = 0.0;\n        float grainSumR = 0.0;\n        int activeGrains = 0;\n\n        // Alternate between even-indexed (0,2,4...) and odd-indexed (1,3,5...) grains\n        int startGrain = granular").concat(n,"_process_even ? 0 : 1;\n        for (int i = startGrain; i < 20; i += 2) {\n            if (granular").concat(n,"_grains[i].active) {\n                activeGrains++;\n\n                // Read from buffer with pitch shifting\n                int readPos = (int)granular").concat(n,"_grains[i].position;\n                float sampleL = granular").concat(n,"_buffer_L[readPos];\n                float sampleR = granular").concat(n,"_buffer_R[readPos];\n\n                // Apply envelope (Hann window from pre-calculated table - fast lookup)\n                // Clamp envelope_pos to [0.0, 1.0] to prevent clicks from out-of-range lookups\n                float envPos = constrain(granular").concat(n,"_grains[i].envelope_pos, 0.0f, 1.0f);\n                int tableIdx = (int)(envPos * 255.0f);\n                float envelope = granular").concat(n,"_envelopeTable[tableIdx];\n\n                // Additional fade-in/fade-out for click-free grain edges (first/last 5% of grain)\n                float fadeFactor = 1.0f;\n                if (envPos < 0.05f) {\n                    fadeFactor = envPos / 0.05f; // Fade in over first 5%\n                } else if (envPos > 0.95f) {\n                    fadeFactor = (1.0f - envPos) / 0.05f; // Fade out over last 5%\n                }\n                envelope *= fadeFactor;\n\n                // Apply stereo panning (equal power pan law)\n                float panL = sqrt(1.0 - granular").concat(n,"_grains[i].pan);  // Left channel gain\n                float panR = sqrt(granular").concat(n,"_grains[i].pan);        // Right channel gain\n\n                grainSumL += sampleL * envelope * panL;\n                grainSumR += sampleR * envelope * panR;\n\n                // Advance grain\n                granular").concat(n,"_grains[i].position += granular").concat(n,"_grains[i].pitch_ratio;\n\n                // Wrap position\n                if (granular").concat(n,"_grains[i].position >= granular").concat(n,"_buffer_size) {\n                    granular").concat(n,"_grains[i].position -= granular").concat(n,"_buffer_size;\n                }\n\n                // Advance envelope\n                granular").concat(n,"_grains[i].envelope_pos += granular").concat(n,"_grains[i].envelope_inc;\n                granular").concat(n,"_grains[i].samples_remaining--;\n\n                // Deactivate when finished\n                if (granular").concat(n,"_grains[i].samples_remaining <= 0) {\n                    granular").concat(n,"_grains[i].active = false;\n                    granular").concat(n,"_activeGrainCount--;\n                }\n            }\n        }\n\n        // Toggle round-robin flag for next sample (alternate even/odd grains)\n        granular").concat(n,"_process_even = !granular").concat(n,"_process_even;\n\n        // Scale output by active grains to prevent excessive volume with many concurrent grains\n        if (activeGrains > 0) {\n            float grainScale = 2.0 / sqrt((float)activeGrains); // Boosted grain amplitude for better presence\n            grainSumL *= grainScale;\n            grainSumR *= grainScale;\n        }\n\n        // Apply dry/wet mix\n        float dryGain = 1.0 - granular").concat(n,"_currentDryWet;\n        float wetGain = granular").concat(n,"_currentDryWet;\n\n        granular").concat(n,"_outputL = granular").concat(n,"_inputL * dryGain + grainSumL * wetGain;\n        granular").concat(n,"_outputR = granular").concat(n,"_inputR * dryGain + grainSumR * wetGain;\n")}},{key:"generateGranularSynthProcessingCode",value:function(e,n,t){return"\n        // TODO: Implement GranularSynth processing (4 grains, variable size 10-200ms)\n        granular".concat(n,"_outputL = 0.0;\n        granular").concat(n,"_outputR = 0.0;\n")}},{key:"generateResonanceProcessingCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"trigger"===n.to.port}),o="0.0";if(a){var c,r=a.from.id.split(":")[0],i=(a.from.port,this.connectionResolver.modules.find(function(e){return e.id===r})),l=(null===(c=r.match(/\d+$/))||void 0===c?void 0:c[0])||"1";if(i)switch(i.type){case"LEDButton":o="btn".concat(l,"_gate");break;case"GateGen":o="gategen".concat(l,"_gate");break;default:o="resonance".concat(n,"_trigger")}}return"\n        // Resonance ".concat(n," - Resonant Object Exploration System\n        {\n            // Read control inputs\n            bool trigger = ").concat(o," > 0.5;\n\n            // Mode handling: 0=discovery, 1=performance, 2=exploration\n            int currentMode = resonance").concat(n,"_mode;\n\n            // Update mode from control input if connected\n            if (resonance").concat(n,"_mode_select > 0.0) {\n                currentMode = (int)(resonance").concat(n,"_mode_select * 2.0); // 0.0-0.5=discovery, 0.5-1.0=performance\n                resonance").concat(n,"_mode = currentMode;\n            }\n\n            // Update sensitivity and intensity from control inputs\n            if (resonance").concat(n,"_sensitivity > 0.0) {\n                resonance").concat(n,"_gyroSensitivity = resonance").concat(n,"_sensitivity;\n            }\n            if (resonance").concat(n,"_intensity > 0.0) {\n                resonance").concat(n,"_hapticIntensity = resonance").concat(n,"_intensity;\n            }\n\n            switch (currentMode) {\n                case 0: // DISCOVERY MODE: Frequency sweep analysis\n                {\n                    if (trigger && !resonance").concat(n,"_analyzing) {\n                        // Start frequency sweep analysis\n                        resonance").concat(n,"_analyzing = true;\n                        resonance").concat(n,"_sweepStartTime = millis();\n                        resonance").concat(n,"_currentSweepFreq = resonance").concat(n,"_sweepStart;\n                        resonance").concat(n,"_sweepPhase = 0.0;\n                        resonance").concat(n,"_analysis_complete = 0.0;\n\n                        // Allocate FFT buffers in PSRAM if not already allocated\n                        if (resonance").concat(n,"_fft_input == nullptr) {\n                            resonance").concat(n,"_fft_input = (float*)ps_malloc(resonance").concat(n,"_fftSize * sizeof(float));\n                            resonance").concat(n,"_fft_output = (float*)ps_malloc(resonance").concat(n,"_fftSize * sizeof(float));\n                            resonance").concat(n,"_window = (float*)ps_malloc(resonance").concat(n,"_fftSize * sizeof(float));\n\n                            // Initialize Hann window\n                            for (int i = 0; i < resonance").concat(n,"_fftSize; i++) {\n                                resonance").concat(n,"_window[i] = 0.5 * (1.0 - cos(2.0 * PI * i / (resonance").concat(n,"_fftSize - 1)));\n                            }\n                        }\n                    }\n\n                    if (resonance").concat(n,"_analyzing) {\n                        unsigned long elapsed = millis() - resonance").concat(n,"_sweepStartTime;\n                        float sweepProgress = (float)elapsed / resonance").concat(n,"_sweepDuration;\n\n                        if (sweepProgress < 1.0) {\n                            // Generate logarithmic frequency sweep\n                            float logStart = log(resonance").concat(n,"_sweepStart);\n                            float logEnd = log(resonance").concat(n,"_sweepEnd);\n                            resonance").concat(n,"_currentSweepFreq = exp(logStart + sweepProgress * (logEnd - logStart));\n\n                            // Generate sweep tone through exciter\n                            resonance").concat(n,"_sweepPhase += 2.0 * PI * resonance").concat(n,"_currentSweepFreq / SAMPLE_RATE;\n                            if (resonance").concat(n,"_sweepPhase >= 2.0 * PI) resonance").concat(n,"_sweepPhase -= 2.0 * PI;\n\n                            resonance").concat(n,"_exciterOutput = sin(resonance").concat(n,"_sweepPhase) * 0.3; // 30% amplitude\n\n                            // Collect contact mic input for FFT analysis\n                            // NOTE: Actual FFT runs on Core 0 task to avoid blocking audio\n                            // This is a placeholder - full implementation requires FreeRTOS task\n\n                        } else {\n                            // Sweep complete - trigger FFT analysis\n                            resonance").concat(n,"_analyzing = false;\n                            resonance").concat(n,"_analysis_complete = 1.0;\n                            resonance").concat(n,"_exciterOutput = 0.0;\n\n                            // TODO: Launch Core 0 FFT task here\n                            // For now, output placeholder frequencies\n                            resonance").concat(n,"_freq1 = 100.0;\n                            resonance").concat(n,"_freq2 = 200.0;\n                            resonance").concat(n,"_freq3 = 400.0;\n                            resonance").concat(n,"_freq4 = 800.0;\n                            resonance").concat(n,"_freq5 = 1600.0;\n                            resonance").concat(n,"_freq6 = 3200.0;\n                            resonance").concat(n,"_freq7 = 6400.0;\n                            resonance").concat(n,"_freq8 = 12800.0;\n                            resonance").concat(n,"_resonance_strength = 0.8;\n                        }\n                    } else {\n                        resonance").concat(n,"_exciterOutput = 0.0;\n                    }\n                    break;\n                }\n\n                case 1: // PERFORMANCE MODE: Output stored resonant frequencies\n                {\n                    // Read from object library slot\n                    int objectSlot = (int)(resonance").concat(n,"_object_select * 39.0); // 0-1 maps to 0-39\n                    if (objectSlot != resonance").concat(n,"_objectSlot) {\n                        resonance").concat(n,"_objectSlot = objectSlot;\n                        // TODO: Load resonant frequencies from SPIFFS/SD\n                        // String path = resonance").concat(n,'_objectLibraryPath + String(objectSlot) + ".json";\n                    }\n\n                    // Output resonant frequencies as CV (already set during discovery)\n                    // Frequencies remain stable for performance use\n\n                    // Optionally play through exciter when triggered\n                    if (trigger) {\n                        // Simple resonant tone using detected fundamental\n                        static float perfPhase = 0.0;\n                        perfPhase += 2.0 * PI * resonance').concat(n,"_freq1 / SAMPLE_RATE;\n                        if (perfPhase >= 2.0 * PI) perfPhase -= 2.0 * PI;\n                        resonance").concat(n,"_exciterOutput = sin(perfPhase) * 0.2;\n                    } else {\n                        resonance").concat(n,"_exciterOutput = 0.0;\n                    }\n                    break;\n                }\n\n                case 2: // EXPLORATION MODE: Impulse response with gyroscope sensing\n                {\n                    if (trigger && !resonance").concat(n,"_analyzing) {\n                        // Send impulse through exciter\n                        resonance").concat(n,"_analyzing = true;\n                        resonance").concat(n,"_sweepStartTime = millis();\n                        resonance").concat(n,"_analysis_complete = 0.0;\n                    }\n\n                    if (resonance").concat(n,"_analyzing) {\n                        unsigned long elapsed = millis() - resonance").concat(n,"_sweepStartTime;\n\n                        if (elapsed < resonance").concat(n,"_impulseLength) {\n                            // Generate brief impulse (first 10% is the actual impulse)\n                            if (elapsed < resonance").concat(n,"_impulseLength * 0.1) {\n                                resonance").concat(n,"_exciterOutput = 1.0; // Full amplitude impulse\n                            } else {\n                                resonance").concat(n,"_exciterOutput = 0.0; // Listen to decay\n                            }\n\n                            // Record contact mic response (decay analysis)\n                            // TODO: Measure decay time for Q factor calculation\n\n                        } else {\n                            // Impulse analysis complete\n                            resonance").concat(n,"_analyzing = false;\n                            resonance").concat(n,"_analysis_complete = 1.0;\n                            resonance").concat(n,"_exciterOutput = 0.0;\n\n                            // TODO: Analyze decay for resonance strength\n                            resonance").concat(n,"_resonance_strength = 0.6; // Placeholder\n                        }\n                    } else {\n                        resonance").concat(n,"_exciterOutput = 0.0;\n                    }\n\n                    // TODO: Read gyroscope for vibration sensing\n                    // Wire.requestFrom(GYRO_I2C_ADDR, 6); // Read 6 bytes (XYZ accelerometer)\n\n                    // TODO: Control haptic motors if enabled\n                    if (resonance").concat(n,"_hapticEnable && trigger) {\n                        // Wire.beginTransmission(HAPTIC_I2C_ADDR);\n                        // Wire.write((uint8_t)(resonance").concat(n,"_hapticIntensity * 255));\n                        // Wire.endTransmission();\n                    }\n                    break;\n                }\n            }\n\n            // Read contact mic input (placeholder - actual ADC read goes here)\n            // resonance").concat(n,"_contactMicInput = analogRead(CONTACT_MIC_PIN) / 4095.0;\n        }\n")}}])&&Se(e.prototype,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function we(e){return we="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},we(e)}function Ce(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,Ie(a.key),a)}}function Ie(e){var n=function(e){if("object"!=we(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=we(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==we(n)?n:n+""}var Re=function(){return e=function e(n){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.connectionResolver=n},(n=[{key:"generateIncludes",value:function(e){var n=[];return"Sample Player"===e&&(n.push("#include <SD.h>"),n.push("#include <FS.h>"),n.push("#include <freertos/FreeRTOS.h>"),n.push("#include <freertos/task.h>"),n.push("#include <freertos/semphr.h>")),n}},{key:"generateModuleClasses",value:function(){return'\n// WAV File Header Structure\nstruct WAVHeader {\n    char riff[4];           // "RIFF"\n    uint32_t fileSize;      // File size minus 8 bytes\n    char wave[4];           // "WAVE"\n    char fmt[4];            // "fmt "\n    uint32_t fmtSize;       // Format chunk size\n    uint16_t audioFormat;   // Audio format (1 = PCM)\n    uint16_t numChannels;   // Number of channels\n    uint32_t sampleRate;    // Sample rate\n    uint32_t byteRate;      // Byte rate\n    uint16_t blockAlign;    // Block alignment\n    uint16_t bitsPerSample; // Bits per sample\n    char data[4];           // "data"\n    uint32_t dataSize;      // Data size\n};\n\n#define CHUNK_SIZE 4096  // Buffer size in bytes (1024 samples * 2 channels * 2 bytes)\n#define CHUNK_SAMPLES (CHUNK_SIZE / 4) // 1024 samples for stereo 16-bit\n\nclass MinimalWAVPlayer {\nprivate:\n    File wavFile;\n    WAVHeader header;\n    \n    // Double buffering for seamless playback\n    int16_t* bufferA;\n    int16_t* bufferB;\n    int16_t* playingBuffer;       // Currently being played\n    int16_t* loadingBuffer;       // Being loaded in background\n    \n    uint32_t totalDataBytes;      // Total bytes in WAV data section\n    uint32_t filePosition;        // Current position in file (bytes from start of data)\n    uint32_t playingSamples;      // Samples in currently playing buffer\n    uint32_t playPosition;        // Current play position within playing buffer (legacy)\n    float fractionalPosition;     // Fractional position for pitch control\n    \n    bool isPlaying;\n    bool fileEnded;\n    uint16_t channels;\n    \n    // Control variables for new functionality\n    float playbackSpeed;          // Playback speed multiplier (0.1 to 4.0)\n    float startPosition;          // Start position (0.0 to 1.0)  \n    float endPosition;            // End position (0.0 to 1.0)\n    \n    // Background loading task\n    TaskHandle_t loaderTaskHandle;\n    SemaphoreHandle_t bufferMutex;\n    volatile bool loadingBufferReady;\n    volatile uint32_t loadingBufferSamples;\n    \npublic:\n    MinimalWAVPlayer() : bufferA(nullptr), bufferB(nullptr), totalDataBytes(0), filePosition(0),\n                         playingSamples(0), playPosition(0), fractionalPosition(0.0f), isPlaying(false),\n                         fileEnded(false), channels(2), playbackSpeed(1.0f), startPosition(0.0f), \n                         endPosition(1.0f), loaderTaskHandle(NULL), loadingBufferReady(false), \n                         loadingBufferSamples(0) {\n        \n        // Allocate double buffers\n        bufferA = (int16_t*)heap_caps_malloc(CHUNK_SIZE, MALLOC_CAP_SPIRAM);\n        bufferB = (int16_t*)heap_caps_malloc(CHUNK_SIZE, MALLOC_CAP_SPIRAM);\n        \n        if (!bufferA || !bufferB) {\n            if (bufferA) free(bufferA);\n            if (bufferB) free(bufferB);\n            bufferA = (int16_t*)malloc(CHUNK_SIZE);\n            bufferB = (int16_t*)malloc(CHUNK_SIZE);\n        }\n        \n        if (bufferA && bufferB) {\n            playingBuffer = bufferA;\n            loadingBuffer = bufferB;\n            bufferMutex = xSemaphoreCreateMutex();\n        }\n    }\n    \n    // Core player methods would be defined here\n    bool loadFile(const String& filename);\n    void play();\n    void stop();\n    bool playing();\n    void setPlaybackSpeed(float speed);\n    void setStartPosition(float pos);\n    void setEndPosition(float pos);\n    int16_t getNextSample();\n    \n    ~MinimalWAVPlayer() {\n        stop();\n        if (bufferA) free(bufferA);\n        if (bufferB) free(bufferB);\n        if (bufferMutex) vSemaphoreDelete(bufferMutex);\n    }\n};\n'}},{key:"generateGlobalVariables",value:function(e,n,t){return console.log('SampleModules.generateGlobalVariables called: module.type="'.concat(e.type,'", index="').concat(n,'", module.id="').concat(e.id,'"')),["SamplePlayer","SDPlayer"].includes(e.type)?(console.log("  -> Generating variables for ".concat(e.type," ").concat(n)),"\n// ".concat(t.label," ").concat(n," - Minimal WAV Player (legacy single-voice)\nMinimalWAVPlayer sdPlayer").concat(n,"_player;\nfloat sdPlayer").concat(n,"_gain = ").concat(e.params.gain||3,";\nfloat sdPlayer").concat(n,"_pitch = ").concat(e.params.pitch||1,";\nbool sdPlayer").concat(n,"_loop = ").concat(e.params.loop||!0,";\nbool sdPlayer").concat(n,"_playing = false;\nint sdPlayer").concat(n,"_currentFile = 1;\nint sdPlayer").concat(n,"_sampleCount = 0;  // Dynamic count of available samples\nString sdPlayer").concat(n,'_currentFileName = "";\nfloat sdPlayer').concat(n,"_triggerThreshold = 0.5;\nbool sdPlayer").concat(n,"_lastTrigger = false;\nfloat sdPlayer").concat(n,"_outputL = 0.0;\nfloat sdPlayer").concat(n,"_outputR = 0.0;\nint sdPlayer").concat(n,"_lastLoadedFile = -1;  // Track loaded sample to avoid unnecessary reloads\n\n// File transfer variables (inline implementation - no external library needed)\nbool fileTransferActive").concat(n," = false;\nString transferFilename").concat(n,' = "";\nFile transferFile').concat(n,";\nuint32_t expectedFileSize").concat(n," = 0;\nuint32_t receivedBytes").concat(n," = 0;\n\n// Ring buffer variables for credit-based file transfer\nuint8_t* ringBuffer").concat(n," = NULL;\nvolatile int ringWritePos").concat(n," = 0;\nvolatile int ringReadPos").concat(n," = 0;\nvolatile int ringBufferCount").concat(n," = 0;\nconst int ringBufferSize").concat(n," = 65536; // 64KB ring buffer\nportMUX_TYPE ringBufferMux").concat(n," = portMUX_INITIALIZER_UNLOCKED;\nTaskHandle_t sdWriterTaskHandle").concat(n," = NULL;\n")):(console.log("  -> Skipping (not SamplePlayer/SDPlayer)"),null)}},{key:"generateSetupCode",value:function(e,n,t){return"\n    // Sample Player ".concat(n," setup\n    sdPlayer").concat(n,'_sampleCount = 10; // Default sample count\n    \n    // Count actual samples available on SD card\n    File root = SD.open("/");\n    int count = 0;\n    while (true) {\n        File entry = root.openNextFile();\n        if (!entry) break;\n        if (entry.name()[0] != \'.\' && !entry.isDirectory()) {\n            String name = String(entry.name()).toLowerCase();\n            if (name.endsWith(".wav")) {\n                count++;\n            }\n        }\n        entry.close();\n    }\n    root.close();\n    \n    if (count > 0) {\n        sdPlayer').concat(n,"_sampleCount = count;\n    }\n    \n    // Preload default sample to avoid SD I/O during audio processing\n    String preloadFile").concat(n,' = "/sample0" + String(sdPlayer').concat(n,'_currentFile) + ".wav";\n    if (SD.exists(preloadFile').concat(n,") && sdPlayer").concat(n,"_player.loadFile(preloadFile").concat(n,".c_str())) {\n        sdPlayer").concat(n,"_lastLoadedFile = 1;\n    }\n    \n    // Initialize ring buffer for file transfers\n    ringBuffer").concat(n," = (uint8_t*)heap_caps_malloc(ringBufferSize").concat(n,", MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);\n    if (!ringBuffer").concat(n,") {\n        ringBuffer").concat(n," = (uint8_t*)malloc(ringBufferSize").concat(n,");\n    }\n")}},{key:"generateProcessingCode",value:function(e,n,t){return["SamplePlayer","SDPlayer"].includes(e.type)?"\n        // Sample Player ".concat(n," processing\n        {\n            // Process control inputs\n            ").concat(this.generateControlProcessing(e,n,t),"\n\n            // Audio generation\n            if (sdPlayer").concat(n,"_playing) {\n                float sampleL, sampleR;\n                sdPlayer").concat(n,"_player.getStereoSample(sampleL, sampleR);\n\n                sdPlayer").concat(n,"_outputL = sampleL * sdPlayer").concat(n,"_gain;\n                sdPlayer").concat(n,"_outputR = sampleR * sdPlayer").concat(n,"_gain;\n\n                sdPlayer").concat(n,"_playing = sdPlayer").concat(n,"_player.playing();\n            } else {\n                sdPlayer").concat(n,"_outputL = 0.0f;\n                sdPlayer").concat(n,"_outputR = 0.0f;\n            }\n        }\n"):null}},{key:"generateControlProcessing",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch"===n.to.port}),c=(t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"sample_select"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"start_pos"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"end_pos"===n.to.port}),"\n            // Control signal processing\n            float sdPlayer".concat(n,"_currentPitch = sdPlayer").concat(n,"_pitch;\n            int sdPlayer").concat(n,"_targetFile = sdPlayer").concat(n,"_currentFile;\n            float sdPlayer").concat(n,"_startPos = ").concat(e.params.start_pos||0,";\n            float sdPlayer").concat(n,"_endPos = ").concat(e.params.end_pos||1,";\n            \n            // Track loaded sample to avoid unnecessary reloads (declared globally)\n"));if(a){var r=a.from.id.split(":")[0],i=this.connectionResolver.modules.find(function(e){return e.id===r});if(i){var l,s=(null===(l=r.match(/\d+$/))||void 0===l?void 0:l[0])||"1";c+="\n                // Trigger from ".concat(i.type," ").concat(s,"\n                bool currentTrigger = false;\n                switch (").concat("LEDButton"===i.type?"true":"false",") {\n                    case true: // LEDButton\n                        currentTrigger = btn").concat(s,"_pressed;\n                        break;\n                    default:\n                        currentTrigger = false;\n                        break;\n                }\n                \n                // Edge detection for trigger\n                if (currentTrigger && !sdPlayer").concat(n,"_lastTrigger) {\n                    // Trigger detected - start playback\n                    if (sdPlayer").concat(n,"_lastLoadedFile != -1) {\n                        sdPlayer").concat(n,"_player.play();\n                        sdPlayer").concat(n,"_playing = true;\n                    }\n                }\n                sdPlayer").concat(n,"_lastTrigger = currentTrigger;\n")}}if(o){var u=o.from.id.split(":")[0],d=this.connectionResolver.modules.find(function(e){return e.id===u});if(d){var p,f=(null===(p=u.match(/\d+$/))||void 0===p?void 0:p[0])||"1";c+="\n                // Pitch control from ".concat(d.type," ").concat(f,"\n                float scaleFreq = scale").concat(f,"_output;\n                float scalePitchRatio = scaleFreq / 440.0; // Convert frequency to pitch ratio (440Hz = 1.0x)\n                scalePitchRatio = constrain(scalePitchRatio, 0.25, 4.0); // Limit to reasonable range\n                sdPlayer").concat(n,"_currentPitch = scalePitchRatio;\n                \n                // Final safety constraint\n                sdPlayer").concat(n,"_currentPitch = constrain(sdPlayer").concat(n,"_currentPitch, 0.1, 8.0);\n                \n                sdPlayer").concat(n,"_player.setPlaybackSpeed(sdPlayer").concat(n,"_currentPitch);\n")}}return c}}])&&Ce(e.prototype,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function Le(e){return Le="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Le(e)}function Me(e,n){var t="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=function(e,n){if(e){if("string"==typeof e)return De(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?De(e,n):void 0}}(e))||n&&e&&"number"==typeof e.length){t&&(e=t);var a=0,o=function(){};return{s:o,n:function(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function(e){throw e},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var c,r=!0,i=!1;return{s:function(){t=t.call(e)},n:function(){var e=t.next();return r=e.done,e},e:function(e){i=!0,c=e},f:function(){try{r||null==t.return||t.return()}finally{if(i)throw c}}}}function De(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}function Ae(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,Oe(a.key),a)}}function Oe(e){var n=function(e){if("object"!=Le(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=Le(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==Le(n)?n:n+""}var Be=function(){return e=function e(n){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.connectionResolver=n},(n=[{key:"getWaveTypeIndex",value:function(e){if("number"==typeof e)return e;if("string"!=typeof e)return 0;switch(e.toLowerCase()){case"sine":default:return 0;case"sawtooth":case"saw":return 1;case"square":return 2;case"triangle":case"tri":return 3}}},{key:"generateIncludes",value:function(e){var n=[];switch(e){case"ADSR":case"Scale":case"LFO":case"HarmonicSequencer":case"Arpeggiator":case"MIDILooper":n.push("#include <math.h>"),n.push("#include <string.h>")}return n}},{key:"generateGlobalVariables",value:function(e,n,t){switch(e.type){case"ADSR":var a=e.params.loop_mode||"oneshot";return"\n// ".concat(t.label," ").concat(n,"\nfloat adsr").concat(n,"_attack = ").concat((e.params.attack_ms||10)/1e3,"; // Convert ms to seconds\nfloat adsr").concat(n,"_decay = ").concat((e.params.decay_ms||120)/1e3,"; // Convert ms to seconds\nfloat adsr").concat(n,"_sustain = ").concat(e.params.sustain||.6,"; // Already 0-1 range\nfloat adsr").concat(n,"_release = ").concat((e.params.release_ms||200)/1e3,"; // Convert ms to seconds\nfloat adsr").concat(n,"_timescale = ").concat(e.params.timescale||1,"; // Timing scale multiplier\nconst char* adsr").concat(n,'_loop_mode = "').concat(a,'"; // "oneshot", "loop", "pingpong"\nfloat adsr').concat(n,"_level = 0.0;\nint adsr").concat(n,"_stage = 0; // 0=idle, 1=attack, 2=decay, 3=sustain, 4=release\nbool adsr").concat(n,"_gate = false;\nbool adsr").concat(n,"_lastGate = false;\nvolatile float adsr").concat(n,"_output = 0.0;\nvolatile float adsr").concat(n,"_prevOutput = 0.0; // Previous buffer's output for interpolation\nvolatile float adsr").concat(n,"_targetOutput = 0.0; // Target output from envelope processing\nfloat adsr").concat(n,"_stageTime = 0.0; // Time within current stage\nfloat adsr").concat(n,"_releaseStartLevel = 0.0; // Level when release stage started\nfloat adsr").concat(n,"_attackStartLevel = 0.0; // Level when attack stage started\n// Curve types: ").concat(e.params.attack_curve||"linear",", ").concat(e.params.decay_curve||"exp",", ").concat(e.params.release_curve||"exp","\n");case"Scale":return"\n// ".concat(t.label," ").concat(n,"\nfloat scale").concat(n,"_input = 0.0;\nvolatile float scale").concat(n,"_output = ").concat(12*e.params.base_octave+60||60,"; // Middle C as default\n");case"LFO":return"\n// ".concat(t.label," ").concat(n,"\nfloat lfo").concat(n,"_freq = ").concat(e.params.freq||1,";\nfloat lfo").concat(n,"_phase = 0.0;\nvolatile float lfo").concat(n,"_output = 0.0;\nint lfo").concat(n,"_waveform = ").concat(this.getWaveTypeIndex(e.params.waveform),"; // 0=sine, 1=triangle, 2=saw, 3=square\nfloat lfo").concat(n,"_amplitude = ").concat(e.params.amplitude||1,";\nfloat lfo").concat(n,"_offset = ").concat(e.params.offset||0,";\n\n// Additional variables for legacy compatibility\nbool lfo").concat(n,"_sync_to_clock = ").concat(e.params.sync_to_clock||!1,";\nunsigned long lfo").concat(n,"_last_update = 0;\nfloat lfo").concat(n,"_rate_hz = ").concat(e.params.rate_hz||e.params.freq||1,";\nint lfo").concat(n,"_wave = ").concat(this.getWaveTypeIndex(e.params.wave||e.params.waveform),";\nfloat lfo").concat(n,"_depth = ").concat(e.params.depth||e.params.amplitude||1,";\n");case"Automation":for(var o=e.params.buffer_size||1e3,c=e.params.num_inputs||1,r="",i="",l="",s="",u="",d=1;d<=c;d++)r+="float automation".concat(n,"_input_").concat(d," = 0.0;\n"),i+="volatile float automation".concat(n,"_output_").concat(d," = 0.0;\n"),l+="float* automation".concat(n,"_buffer_").concat(d," = nullptr; // PSRAM buffer for channel ").concat(d,"\n"),s+="float automation".concat(n,"_last_input_").concat(d," = 0.0; // For touch detection\n"),u+="int automation".concat(n,"_channel_").concat(d,"_length = 0; // Channel ").concat(d," loop length\n"),u+="int automation".concat(n,"_channel_").concat(d,"_position = 0; // Channel ").concat(d," playback position\n"),u+="bool automation".concat(n,"_channel_").concat(d,"_recording = false; // Channel ").concat(d," recording\n"),u+="bool automation".concat(n,"_channel_").concat(d,"_playing = false; // Channel ").concat(d," playing\n"),u+="unsigned long automation".concat(n,"_channel_").concat(d,"_start_time = 0; // Channel ").concat(d," playback start\n");return"\n// ".concat(t.label," ").concat(n," - Independent Per-Channel Automation (").concat(c," channels)\nconst int automation").concat(n,"_buffer_size = ").concat(o,";\nconst int automation").concat(n,"_num_inputs = ").concat(c,";\nconst float automation").concat(n,"_movement_threshold = 0.005; // 0.5% movement = channel is being moved\nconst float automation").concat(n,"_touch_threshold = 0.01; // 1% change triggers touch override (smooth takeover)\nconst unsigned long automation").concat(n,"_touch_grace_ms = 50; // 50ms grace period (minimal for responsiveness)\n").concat(l).concat(u,"\n// Global recording trigger (button)\nbool automation").concat(n,"_record_trigger = false;\nbool automation").concat(n,"_last_record_trigger = false;\nbool automation").concat(n,"_loop = ").concat(e.params.loop||!0,";\n\n// Clock sync and playback modes\nbool automation").concat(n,"_clock_sync = ").concat(e.params.clock_sync||!1,"; // Sync to Clock module\nint automation").concat(n,"_clock_quantize = ").concat(e.params.clock_quantize||4,"; // Quantize to N beats (1, 2, 4, 8, 16)\nfloat automation").concat(n,"_clock_input = 0.0; // Clock signal input\nbool automation").concat(n,"_last_clock = false;\nint automation").concat(n,"_playback_mode = 0; // 0=normal, 1=reverse, 2=double, 3=half, 4=pingpong\nbool automation").concat(n,"_mode_select = false; // Encoder button held for mode selection\nint automation").concat(n,"_selected_mode = 0; // Mode being previewed during selection\n\n").concat(r).concat(i).concat(s,"\n");case"GateGen":return"\n// ".concat(t.label," ").concat(n," - Gate Generator with S&H and gate input control\nfloat gate").concat(n,"_length = ").concat(e.params.gate_length||.8,"; // Gate length as fraction of clock period\nbool gate").concat(n,"_use_self_clock = ").concat(e.params.use_self_clock||!0,";\nfloat gate").concat(n,"_self_clock_bpm = ").concat(e.params.self_clock_bpm||120,";\nfloat gate").concat(n,"_probability = ").concat(e.params.probability||1,"; // Probability 0-1\nbool gate").concat(n,"_retrigger = ").concat(e.params.retrigger||!0,";\nbool gate").concat(n,"_sh_enabled = ").concat(e.params.sh_enabled||!0,"; // Sample & Hold enabled\nbool gate").concat(n,"_state = false;\nbool gate").concat(n,"_last_clock = false;\nunsigned long gate").concat(n,"_start_time = 0;\nunsigned long gate").concat(n,"_last_self_clock = 0;\nfloat gate").concat(n,"_output = 0.0;\nfloat gate").concat(n,"_led_output = 0.0; // Separate LED output for metronome flash\nunsigned long gate").concat(n,"_led_start_time = 0;\nint gate").concat(n,"_led_flash_ms = ").concat(e.params.led_flash_ms||0,"; // LED flash duration (0 = follow gate)\nfloat gate").concat(n,"_sh_input = 0.0; // Sample & Hold input\nfloat gate").concat(n,"_sh_output = 0.0; // Sample & Hold output (held value)\nfloat gate").concat(n,"_gate_input = 0.0; // Gate input control\nbool gate").concat(n,"_gate_enabled = true; // Gate control state\nfloat gate").concat(n,"_rate = 0.0; // Rate output in Hz for tempo sync\nbool gate").concat(n,"_running = false; // Start/stop control (encoder button)\n");case"Clock":return"\n// ".concat(t.label," ").concat(n," - 8-output clock divider/multiplier\nfloat clock").concat(n,"_bpm = ").concat(e.params.bpm||120,";\nbool clock").concat(n,"_running = true;\nfloat clock").concat(n,"_period_ms = 0.0;\nunsigned long clock").concat(n,"_last_tick = 0;\nbool clock").concat(n,"_master_pulse = false;\nfloat clock").concat(n,"_master_phase = 0.0;\n\n// MIDI Clock outputs (24 PPQ and 96 PPQ)\nfloat clock").concat(n,"_tick24 = 0.0;        // 24 PPQ tick (standard MIDI clock)\nfloat clock").concat(n,"_tick96 = 0.0;        // 96 PPQ tick (high resolution)\nuint32_t clock").concat(n,"_tick24_counter = 0; // 24 PPQ counter\nuint32_t clock").concat(n,"_tick96_counter = 0; // 96 PPQ counter\nfloat clock").concat(n,"_start = 0.0;         // Start pulse output\nfloat clock").concat(n,"_stop = 0.0;          // Stop pulse output\n\n// 8 output counters and rate multipliers (0.0625 = /16, 1.0 = clock rate, 16.0 = x16)\nfloat clock").concat(n,"_counter1 = 0.0, clock").concat(n,"_rate1 = ").concat(e.params.rate1||1,";\nfloat clock").concat(n,"_counter2 = 0.0, clock").concat(n,"_rate2 = ").concat(e.params.rate2||.5,";\nfloat clock").concat(n,"_counter3 = 0.0, clock").concat(n,"_rate3 = ").concat(e.params.rate3||.25,";\nfloat clock").concat(n,"_counter4 = 0.0, clock").concat(n,"_rate4 = ").concat(e.params.rate4||.125,";\nfloat clock").concat(n,"_counter5 = 0.0, clock").concat(n,"_rate5 = ").concat(e.params.rate5||2,";\nfloat clock").concat(n,"_counter6 = 0.0, clock").concat(n,"_rate6 = ").concat(e.params.rate6||4,";\nfloat clock").concat(n,"_counter7 = 0.0, clock").concat(n,"_rate7 = ").concat(e.params.rate7||8,";\nfloat clock").concat(n,"_counter8 = 0.0, clock").concat(n,"_rate8 = ").concat(e.params.rate8||16,";\n\n// Gate mode for each output (false = clock/toggle, true = gate/pulse)\nbool clock").concat(n,"_gate_mode1 = ").concat(e.params.gate_mode1?"true":"false",";\nbool clock").concat(n,"_gate_mode2 = ").concat(e.params.gate_mode2?"true":"false",";\nbool clock").concat(n,"_gate_mode3 = ").concat(e.params.gate_mode3?"true":"false",";\nbool clock").concat(n,"_gate_mode4 = ").concat(e.params.gate_mode4?"true":"false",";\nbool clock").concat(n,"_gate_mode5 = ").concat(e.params.gate_mode5?"true":"false",";\nbool clock").concat(n,"_gate_mode6 = ").concat(e.params.gate_mode6?"true":"false",";\nbool clock").concat(n,"_gate_mode7 = ").concat(e.params.gate_mode7?"true":"false",";\nbool clock").concat(n,"_gate_mode8 = ").concat(e.params.gate_mode8?"true":"false",";\n\n// Probability for each output (0.0 = never, 1.0 = always)\nfloat clock").concat(n,"_prob1 = ").concat(e.params.prob1||1,";\nfloat clock").concat(n,"_prob2 = ").concat(e.params.prob2||1,";\nfloat clock").concat(n,"_prob3 = ").concat(e.params.prob3||1,";\nfloat clock").concat(n,"_prob4 = ").concat(e.params.prob4||1,";\nfloat clock").concat(n,"_prob5 = ").concat(e.params.prob5||1,";\nfloat clock").concat(n,"_prob6 = ").concat(e.params.prob6||1,";\nfloat clock").concat(n,"_prob7 = ").concat(e.params.prob7||1,";\nfloat clock").concat(n,"_prob8 = ").concat(e.params.prob8||1,";\n\n// Euclidean subdivisions (1-8: 1=no subdivision, 8=8 rate subdivision for fills)\nint clock").concat(n,"_euclid1 = ").concat(e.params.euclid1||1,";\nint clock").concat(n,"_euclid2 = ").concat(e.params.euclid2||1,";\nint clock").concat(n,"_euclid3 = ").concat(e.params.euclid3||1,";\nint clock").concat(n,"_euclid4 = ").concat(e.params.euclid4||1,";\nint clock").concat(n,"_euclid5 = ").concat(e.params.euclid5||1,";\nint clock").concat(n,"_euclid6 = ").concat(e.params.euclid6||1,";\nint clock").concat(n,"_euclid7 = ").concat(e.params.euclid7||1,";\nint clock").concat(n,"_euclid8 = ").concat(e.params.euclid8||1,";\n\n// Fill button states (momentary - multiply rate by euclid while held)\nbool clock").concat(n,"_fill1 = false, clock").concat(n,"_fill2 = false;\nbool clock").concat(n,"_fill3 = false, clock").concat(n,"_fill4 = false;\nbool clock").concat(n,"_fill5 = false, clock").concat(n,"_fill6 = false;\nbool clock").concat(n,"_fill7 = false, clock").concat(n,"_fill8 = false;\n\n// Pot values for probability attenuation during fill (0.0-1.0)\nfloat clock").concat(n,"_pot_value1 = ").concat(e.params.rate1||1,";\nfloat clock").concat(n,"_pot_value2 = ").concat(e.params.rate2||.5,";\nfloat clock").concat(n,"_pot_value3 = ").concat(e.params.rate3||.25,";\nfloat clock").concat(n,"_pot_value4 = ").concat(e.params.rate4||.125,";\nfloat clock").concat(n,"_pot_value5 = ").concat(e.params.rate5||2,";\nfloat clock").concat(n,"_pot_value6 = ").concat(e.params.rate6||4,";\nfloat clock").concat(n,"_pot_value7 = ").concat(e.params.rate7||8,";\nfloat clock").concat(n,"_pot_value8 = ").concat(e.params.rate8||16,";\n\n// Soft takeover for banking (outputs 1-4 only)\nfloat clock").concat(n,"_rate_physical[4] = {").concat(e.params.rate1||1,", ").concat(e.params.rate2||.5,", ").concat(e.params.rate3||.25,", ").concat(e.params.rate4||.125,"};\nfloat clock").concat(n,"_rate_target[4] = {").concat(e.params.rate1||1,", ").concat(e.params.rate2||.5,", ").concat(e.params.rate3||.25,", ").concat(e.params.rate4||.125,"};\nfloat clock").concat(n,"_rate_saved[4] = {").concat(e.params.rate1||1,", ").concat(e.params.rate2||.5,", ").concat(e.params.rate3||.25,", ").concat(e.params.rate4||.125,"};\nbool clock").concat(n,"_rate_taken_over[4] = {false, false, false, false}; // Start as NOT taken over\nint clock").concat(n,"_last_bank = -1; // Track bank entry (-1 = first time)\n\n// 8 output states\nbool clock").concat(n,"_out1 = false;\nbool clock").concat(n,"_out2 = false;\nbool clock").concat(n,"_out3 = false;\nbool clock").concat(n,"_out4 = false;\nbool clock").concat(n,"_out5 = false;\nbool clock").concat(n,"_out6 = false;\nbool clock").concat(n,"_out7 = false;\nbool clock").concat(n,"_out8 = false;\n\n// Gate pulse timing (for gate mode outputs)\nunsigned long clock").concat(n,"_gate_start1 = 0, clock").concat(n,"_gate_start2 = 0;\nunsigned long clock").concat(n,"_gate_start3 = 0, clock").concat(n,"_gate_start4 = 0;\nunsigned long clock").concat(n,"_gate_start5 = 0, clock").concat(n,"_gate_start6 = 0;\nunsigned long clock").concat(n,"_gate_start7 = 0, clock").concat(n,"_gate_start8 = 0;\nint clock").concat(n,"_gate_length_ms = ").concat(e.params.gate_length_ms||20,"; // Gate pulse duration\n\n// LED flash output for pot NeoPixel (metronome flash)\nfloat clock").concat(n,"_led_output = 0.0;\nunsigned long clock").concat(n,"_led_start_time = 0;\nint clock").concat(n,"_led_flash_ms = ").concat(e.params.led_flash_ms||50,"; // LED flash duration (50ms default)\n");case"Modulation":return"\n// ".concat(t.label," ").concat(n," - 4LFO Modulation Matrix\nfloat mod").concat(n,"_lfo1_rate = ").concat(e.params.lfo1_rate||1,";\nfloat mod").concat(n,"_lfo2_rate = ").concat(e.params.lfo2_rate||2,";\nfloat mod").concat(n,"_lfo3_rate = ").concat(e.params.lfo3_rate||.5,";\nfloat mod").concat(n,"_lfo4_rate = ").concat(e.params.lfo4_rate||4,";\nfloat mod").concat(n,"_phase1 = 0.0, mod").concat(n,"_phase2 = 0.0;\nfloat mod").concat(n,"_phase3 = 0.0, mod").concat(n,"_phase4 = 0.0;\nfloat mod").concat(n,"_output1 = 0.0, mod").concat(n,"_output2 = 0.0;\nfloat mod").concat(n,"_output3 = 0.0, mod").concat(n,"_output4 = 0.0;\nint mod").concat(n,"_wave1 = ").concat(e.params.wave1||0,"; // 0=sine, 1=tri, 2=saw, 3=square\nint mod").concat(n,"_wave2 = ").concat(e.params.wave2||1,";\nint mod").concat(n,"_wave3 = ").concat(e.params.wave3||2,";\nint mod").concat(n,"_wave4 = ").concat(e.params.wave4||3,";\n");case"Invert":return"\n// ".concat(t.label," ").concat(n," - Control Signal Inverter\nfloat invert").concat(n,"_input = 0.0;\nfloat invert").concat(n,"_output = 0.0;\nfloat invert").concat(n,"_gain = ").concat(e.params.gain||1,";\nfloat invert").concat(n,"_offset = ").concat(e.params.offset||0,";\n");case"HarmonicSequencer":var p=this.generateStepArray(e,4,1,"pitch",function(e){return(.1*e).toFixed(2)}),f=this.generateStepArray(e,4,1,"duration",function(){return"1.0"}),m=this.generateStepArray(e,4,1,"muted",function(){return"false"}),_=this.generateStepArray(e,4,1,"active",function(e){return"true"}),g=this.generateStepArray(e,4,1,"pitchRandomness",function(){return"0.0"}),h=this.generateStepArray(e,4,1,"probability",function(){return"1.0"}),v=this.generateStepArray(e,4,1,"glissando_time",function(){return"0.0"}),b=this.generateStepArray(e,4,1,"glissando_probability",function(){return"0.0"}),y=this.generateStepArray(e,4,1,"glissando_curve",function(){return"0"},function(e){return"exponential"===e?"1":"logarithmic"===e?"2":"0"}),k=this.generateStepArray(e,4,1,"velocity",function(){return"0.8"}),x=this.generateStepArray(e,4,1,"pattern",function(){return"0"},function(e){return"up_down"===e?"1":"chord"===e?"2":"random"===e?"3":"octave"===e?"4":"fifth"===e?"5":"0"}),S=this.generateStepArray(e,4,1,"interval",function(){return"2"}),E=this.generateStepArray(e,4,1,"patternProbability",function(){return"1.0"});return"\n// ".concat(t.label," ").concat(n," - Single-Bank Navigation Sequencer\n// Sequencer state\nbool seq").concat(n,"_running = ").concat(e.params.running||!1,";\nint seq").concat(n,"_current_step = ").concat(e.params.current_step||0,"; // 0-3 (fixed 4 steps)\nint seq").concat(n,"_sequence_length = ").concat(e.params.sequence_length||4,";\nint seq").concat(n,"_loop_start = ").concat(e.params.loop_start||0,";\nint seq").concat(n,"_loop_end = ").concat(e.params.loop_end||3,";\nbool seq").concat(n,"_loop_active = ").concat(e.params.loop_active||!1,";\n\n// Timing\nfloat seq").concat(n,"_bpm = ").concat(e.params.bpm||120,";\nint seq").concat(n,"_clock_div = ").concat(e.params.clock_div||4,";\nfloat seq").concat(n,"_swing = ").concat(e.params.swing||0,";\nfloat seq").concat(n,"_gate_length = ").concat(e.params.gate_length||.7,";\nunsigned long seq").concat(n,"_last_clock = 0;\nunsigned long seq").concat(n,"_step_start_time = 0;\nbool seq").concat(n,"_last_clock_state = false;\nbool seq").concat(n,"_gate_active = false;\n\n// Step data arrays (").concat(1," banks  4 steps each = ").concat(4," total steps)\nfloat seq").concat(n,"_pitch[").concat(4,"] = {").concat(p,"};\nfloat seq").concat(n,"_duration[").concat(4,"] = {").concat(f,"};\nbool seq").concat(n,"_muted[").concat(4,"] = {").concat(m,"};\nbool seq").concat(n,"_active[").concat(4,"] = {").concat(_,"};\nfloat seq").concat(n,"_pitch_randomness[").concat(4,"] = {").concat(g,"};\nfloat seq").concat(n,"_probability[").concat(4,"] = {").concat(h,"};\nfloat seq").concat(n,"_glissando_time[").concat(4,"] = {").concat(v,"};\nfloat seq").concat(n,"_glissando_probability[").concat(4,"] = {").concat(b,"};\nint seq").concat(n,"_glissando_curve[").concat(4,"] = {").concat(y,"}; // 0=linear, 1=exponential, 2=logarithmic\nint seq").concat(n,"_pattern[").concat(4,"] = {").concat(x,"}; // 0=static, 1=up_down, 2=chord, 3=random, 4=octave, 5=fifth\nint seq").concat(n,"_interval[").concat(4,"] = {").concat(S,"}; // Semitone interval amount (1-12)\nfloat seq").concat(n,"_pattern_probability[").concat(4,"] = {").concat(E,"}; // Pattern trigger probability (0.0-1.0)\nint seq").concat(n,"_pattern_counter[").concat(4,"] = {0, 0, 0, 0}; // Pattern alternation counter per step\nfloat seq").concat(n,"_velocity[").concat(4,"] = {").concat(k,"}; // Per-step velocity (0-1, maps to MIDI 0-127)\n\n// Hardware button states\nbool seq").concat(n,"_btn_pressed[4] = {false, false, false, false};\nbool seq").concat(n,"_btn_last[4] = {false, false, false, false};\nunsigned long seq").concat(n,"_btn_press_time[4] = {0, 0, 0, 0}; // Track button press duration\nbool seq").concat(n,"_btn_long_hold_handled[4] = {false, false, false, false}; // Prevent multiple long hold actions\nbool seq").concat(n,"_btn_used_for_shift[4] = {false, false, false, false}; // Track if button was used for shift mode\n\n// Encoder button states for sequence clear\nbool seq").concat(n,"_enc_btn_last = false;\nunsigned long seq").concat(n,"_enc_btn_press_time = 0;\nbool seq").concat(n,"_enc_long_hold_handled = false;\n\n// Playback behavior control\nint seq").concat(n,"_playback_mode = 0; // 0=iteration, 1=rest, 2=reverse\nbool seq").concat(n,"_reverse_direction = false; // For reverse mode\n\n// Soft takeover system for duration control (when in shift mode)\nfloat seq").concat(n,"_last_pot_values[4] = {0.0, 0.0, 0.0, 0.0}; // Last pot positions\nbool seq").concat(n,"_pot_taken_over[4] = {true, true, true, true}; // Has pot taken over pitch control\n\n// Pot smoothing to reduce noise-induced pitch wavering\nfloat seq").concat(n,"_smoothed_pot[4] = {0.0, 0.0, 0.0, 0.0}; // Smoothed pot values\n\n// Cascading harmonic linking system\nbool seq").concat(n,"_harmonic_linking = ").concat(e.params.harmonic_linking?"true":"false",";\nint seq").concat(n,"_harmonic_follow_steps[").concat(4,"] = {").concat(e.params.harmonic_follow_steps?e.params.harmonic_follow_steps.join(", "):"-1, -1, -1, -1","}; // Which step each step follows (-1 = none)\nfloat seq").concat(n,"_harmonic_intervals[").concat(4,"] = {").concat(e.params.harmonic_intervals?e.params.harmonic_intervals.map(function(e){return e/12}).join(", "):"0.583, 0.583, 0.583, 0.583","}; // Convert semitones to CV (7/12 = perfect fifth)\nfloat seq").concat(n,"_base_pitch[").concat(4,"] = {").concat(f.split(", ").map(function(e,n){return"0.0"}).join(", "),"}; // Base pitch before harmonic adjustments\nfloat seq").concat(n,"_last_base_pitch[").concat(4,"] = {").concat(f.split(", ").map(function(e,n){return"0.0"}).join(", "),"}; // Track base pitch changes for cascading updates\nconst float seq").concat(n,"_pot_smooth_factor = 0.8; // Smoothing factor (0.0=no smooth, 1.0=max smooth)\n\n// Musical Scale System (always active)\nconst char* seq").concat(n,'_quantization_scale = "').concat(e.params.quantization_scale||"major",'";\nconst char* seq').concat(n,'_quantization_root = "').concat(e.params.quantization_root||"C",'";\nconst char* seq').concat(n,'_quantization_tuning = "').concat(e.params.quantization_tuning||"12tet",'";\n\n// Outputs (MIDI-compatible: pitch, gate, velocity)\nvolatile float seq').concat(n,"_pitch_sum = 0.0;\nvolatile float seq").concat(n,"_gate_sum = 0.0;\nvolatile float seq").concat(n,"_velocity_sum = 0.8;  // Velocity output (0-1, maps to MIDI 0-127)\nvolatile float seq").concat(n,"_pitch_hz = 440.0;  // Direct frequency output in Hz\nvolatile float seq").concat(n,"_current_step_cv = 0.0;\nvolatile float seq").concat(n,"_current_bank_cv = 0.0;\nvolatile float seq").concat(n,"_sampled_pitch = 0.0; // Sample-and-hold for pitch randomness\n\n// Random pitch offsets - calculated once per sequence pass, not per step\nfloat seq").concat(n,"_pitch_random_offset[").concat(4,"] = {").concat(f.split(", ").map(function(e,n){return"0.0"}).join(", "),"}; // Random offset per step\nint seq").concat(n,"_last_step = -1; // Track last step to detect sequence loop\n\n// Chord/arpeggio intervals (semitone offsets from root)\n").concat(e.params.steps.map(function(e,t){var a=e.chordIntervals||[0];return"const float seq".concat(n,"_chord_intervals_step").concat(t+1,"[] = {").concat(a.map(function(e){return"".concat(e,".0")}).join(", "),"}; // Step ").concat(t+1," chord intervals\nconst int seq").concat(n,"_chord_intervals_step").concat(t+1,"_count = ").concat(a.length,";")}).join("\n"),"\n// Diatonic mode flags (true = scale-aware transposition)\n").concat(e.params.steps.map(function(e,t){return"const bool seq".concat(n,"_chord_diatonic_step").concat(t+1," = ").concat(!1!==e.chordDiatonic?"true":"false",";")}).join("\n"),"\n// Chord position counters (which interval in the chord is currently playing)\nint seq").concat(n,"_chord_position[").concat(4,"] = {").concat(e.params.steps.map(function(){return"0"}).join(", "),"}; // Current chord tone index per step\n\n// Individual step outputs (4 steps) - MIDI-compatible\nvolatile float seq").concat(n,"_pitch_step1 = 0.0, seq").concat(n,"_pitch_step2 = 0.0, seq").concat(n,"_pitch_step3 = 0.0, seq").concat(n,"_pitch_step4 = 0.0;\nvolatile float seq").concat(n,"_gate_step1 = 0.0, seq").concat(n,"_gate_step2 = 0.0, seq").concat(n,"_gate_step3 = 0.0, seq").concat(n,"_gate_step4 = 0.0;\nvolatile float seq").concat(n,"_velocity_step1 = 0.8, seq").concat(n,"_velocity_step2 = 0.8, seq").concat(n,"_velocity_step3 = 0.8, seq").concat(n,"_velocity_step4 = 0.8;\nvolatile float seq").concat(n,"_pitch_step1_hz = 440.0, seq").concat(n,"_pitch_step2_hz = 440.0, seq").concat(n,"_pitch_step3_hz = 440.0, seq").concat(n,"_pitch_step4_hz = 440.0;\n\n// Glissando state variables\nfloat seq").concat(n,"_glissando_start_pitch = 0.0; // Starting pitch for glissando\nfloat seq").concat(n,"_glissando_target_pitch = 0.0; // Target pitch for glissando\nunsigned long seq").concat(n,"_glissando_start_time = 0; // When glissando started\nbool seq").concat(n,"_glissando_active = false; // Whether glissando is currently active\nvolatile float seq").concat(n,"_glissando_current_hz = 440.0; // Current interpolated frequency\n\n// Pattern variables (melodic patterns)\nbool seq").concat(n,"_pattern_enabled = ").concat(e.params.pattern_enabled?"true":"false",";\nunsigned long seq").concat(n,"_pattern_start_time = 0; // When current step pattern started\nfloat seq").concat(n,"_pattern_phase = 0.0; // Pattern phase (0.0-1.0)\n\n// Pattern calculation function - works around pot position with intervals and probability\nfloat calculatePatternModulation").concat(n,"(int stepIndex, unsigned long currentTime, unsigned long stepStartTime, float stepDuration, float potPosition) {\n    if (!seq").concat(n,"_pattern_enabled) return 0.0;\n\n    int patternType = seq").concat(n,"_pattern[stepIndex];\n    if (patternType == 0) return 0.0; // Static pattern\n\n    // Check probability - use deterministic check based on pattern counter to avoid tremolo\n    float probability = seq").concat(n,"_pattern_probability[stepIndex];\n    // Use pattern counter to create deterministic but varied probability\n    float deterministicCheck = (float)(seq").concat(n,"_pattern_counter[stepIndex] % 100) / 100.0;\n    if (deterministicCheck > probability) return 0.0;\n\n    // Get interval amount in semitones\n    int intervalSemitones = seq").concat(n,"_interval[stepIndex];\n    float intervalCV = (float)intervalSemitones / 12.0; // Convert semitones to CV (1V/oct)\n\n    // Calculate pattern phase (0.0-1.0) based on time within step\n    float stepTimeMs = stepDuration * 1000.0;\n    float elapsedTime = (float)(currentTime - stepStartTime);\n    float phase = elapsedTime / stepTimeMs;\n    phase = constrain(phase, 0.0, 1.0);\n\n    float modulation = 0.0;\n    switch (patternType) {\n        case 1: // Up/Down Alternating - alternate between +interval and -interval\n            modulation = (seq").concat(n,"_pattern_counter[stepIndex] % 2 == 0) ? intervalCV : -intervalCV;\n            break;\n\n        case 2: // Chord/Arpeggio - cycle through custom chord intervals per pass\n            {\n                // Get the correct chord interval array and count for this step\n                const float* chordIntervals;\n                int chordCount;\n                switch (stepIndex) {\n                    case 0: chordIntervals = seq").concat(n,"_chord_intervals_step1; chordCount = seq").concat(n,"_chord_intervals_step1_count; break;\n                    case 1: chordIntervals = seq").concat(n,"_chord_intervals_step2; chordCount = seq").concat(n,"_chord_intervals_step2_count; break;\n                    case 2: chordIntervals = seq").concat(n,"_chord_intervals_step3; chordCount = seq").concat(n,"_chord_intervals_step3_count; break;\n                    case 3: chordIntervals = seq").concat(n,"_chord_intervals_step4; chordCount = seq").concat(n,"_chord_intervals_step4_count; break;\n                    default: chordIntervals = seq").concat(n,"_chord_intervals_step1; chordCount = 1; break;\n                }\n\n                // Cycle through chord tones - one different tone per pass through step\n                int chordTone = seq").concat(n,"_pattern_counter[stepIndex] % chordCount;\n                float intervalSemitones = chordIntervals[chordTone];\n                modulation = intervalSemitones / 12.0; // Convert semitones to CV (1V/oct)\n            }\n            break;\n\n        case 3: // Random Jump - random interval amount\n            modulation = (((float)random(0, 1000) / 1000.0) - 0.5) * 2.0 * intervalCV;\n            break;\n\n        case 4: // Octave Jump - alternate between pot position and +octave\n            modulation = (seq").concat(n,"_pattern_counter[stepIndex] % 2 == 0) ? 0.0 : (12.0 / 12.0); // +1 octave\n            break;\n\n        case 5: // Fifth Jump - alternate between pot position and +perfect fifth\n            modulation = (seq").concat(n,"_pattern_counter[stepIndex] % 2 == 0) ? 0.0 : (7.0 / 12.0); // +perfect fifth\n            break;\n    }\n\n    return modulation;\n}\n\n// Cascading harmonic relationship system - allows chained dependencies\nvoid updateHarmonicRelationships").concat(n,"() {\n    if (!seq").concat(n,"_harmonic_linking) return;\n\n    // Check each step to see if its followed step has changed\n    bool needsAnotherPass = true;\n    int passCount = 0;\n    const int maxPasses = 4; // Prevent infinite loops\n\n    while (needsAnotherPass && passCount < maxPasses) {\n        needsAnotherPass = false;\n        passCount++;\n\n        for (int step = 0; step < ").concat(4,"; step++) {\n            int followsStep = seq").concat(n,"_harmonic_follow_steps[step];\n            if (followsStep == -1) continue; // This step doesn't follow anyone\n\n            // Check if the step we're following has changed its base pitch\n            float followedBasePitch = seq").concat(n,"_base_pitch[followsStep];\n            if (abs(followedBasePitch - seq").concat(n,"_last_base_pitch[followsStep]) > 0.001) {\n                // The followed step's base pitch changed, update this step\n                float pitchChange = followedBasePitch - seq").concat(n,"_last_base_pitch[followsStep];\n\n                // Apply additive harmonic interval + cascading change\n                float harmonicInterval = seq").concat(n,"_harmonic_intervals[step];\n                float newPitch = seq").concat(n,"_base_pitch[step] + pitchChange + harmonicInterval;\n\n                // Extended range: allow harmonic relationships to exceed 0-1 pot range\n                // Clamp to reasonable musical range: -2 to +3 (5 octave span)\n                newPitch = constrain(newPitch, -2.0, 3.0);\n\n                // Update this step's pitch if it changed significantly\n                if (abs(newPitch - seq").concat(n,"_pitch[step]) > 0.001) {\n                    seq").concat(n,"_pitch[step] = newPitch;\n                    // Mark that we need another pass to handle cascading\n                    needsAnotherPass = true;\n                }\n            }\n        }\n\n        // Update last base pitch tracking after each pass\n        for (int step = 0; step < ").concat(4,"; step++) {\n            seq").concat(n,"_last_base_pitch[step] = seq").concat(n,"_base_pitch[step];\n        }\n    }\n}\n");case"Arpeggiator":var P=e.params.pattern||"up",w=e.params.octaves||1,C=e.params.gate_length||.5,I=e.params.rate_mode||"sync",R=e.params.clock_div||4,L=e.params.rate_hz||4,M=e.params.swing||0,D=e.params.hold||!1,A=e.params.velocity_mode||"original",O=e.params.fixed_velocity||100,B=e.params.accent_amount||1.3;return"\n// ".concat(t.label," ").concat(n," - MIDI Arpeggiator\n#define ARP").concat(n,"_MAX_NOTES 16\n\n// Pattern: 0=up, 1=down, 2=updown, 3=downup, 4=random, 5=asplayed\nint arp").concat(n,"_pattern = ").concat(["up","down","updown","downup","random","asplayed"].indexOf(P),";\nint arp").concat(n,"_octaves = ").concat(w,";\nfloat arp").concat(n,"_gate_length = ").concat(C,";\n\n// Timing\nbool arp").concat(n,"_sync_mode = ").concat("sync"===I?"true":"false",";\nint arp").concat(n,"_clock_div = ").concat(R,";\nfloat arp").concat(n,"_rate_hz = ").concat(L,";\nfloat arp").concat(n,"_swing = ").concat(M,";\n\n// Hold mode (latch) - note-offs ignored, new chords replace current\nbool arp").concat(n,"_hold = ").concat(D?"true":"false",";\nbool arp").concat(n,"_hold_input = false; // External hold control from button (toggle on short press)\n\n// Velocity\nint arp").concat(n,"_velocity_mode = ").concat(["original","fixed","accent"].indexOf(A),";\nint arp").concat(n,"_fixed_velocity = ").concat(O,";\nfloat arp").concat(n,"_accent_amount = ").concat(B,";\n\n// Note storage (sorted by pitch for up/down patterns)\nuint8_t arp").concat(n,"_notes[ARP").concat(n,"_MAX_NOTES];\nuint8_t arp").concat(n,"_velocities[ARP").concat(n,"_MAX_NOTES];\nint arp").concat(n,"_note_count = 0;\n\n// Play order storage (for as-played pattern)\nuint8_t arp").concat(n,"_play_order[ARP").concat(n,"_MAX_NOTES];\nint arp").concat(n,"_play_order_count = 0;\n\n// Sequencer state\nint arp").concat(n,"_current_step = 0;\nint arp").concat(n,"_current_octave = 0;\nint arp").concat(n,"_direction = 1; // 1=up, -1=down (for updown/downup patterns)\nbool arp").concat(n,"_playing = false;\n\n// Timing state\nunsigned long arp").concat(n,"_last_step_time = 0;\nfloat arp").concat(n,"_step_interval_ms = 250.0; // Updated from clock or rate_hz\nint arp").concat(n,"_clock_counter = 0;\nbool arp").concat(n,"_clock_pulse = false;\nbool arp").concat(n,"_last_clock = false;\n\n// Gate timing\nunsigned long arp").concat(n,"_gate_start = 0;\nbool arp").concat(n,"_gate_active = false;\nfloat arp").concat(n,"_gate_duration_ms = 0.0; // Calculated at note start, not dynamically\n\n// Output values\nfloat arp").concat(n,"_out_note = 0.0;\nfloat arp").concat(n,"_out_gate = 0.0;\nfloat arp").concat(n,"_out_velocity = 0.0;\n\n// Input tracking for note on/off detection\nfloat arp").concat(n,"_last_note_input = 0.0;\nfloat arp").concat(n,"_last_gate_input = 0.0;\n");case"MIDILooper":var T=e.params.loop_bars||4,F=e.params.count_in_bars||1,N=e.params.quantize||"off",z=e.params.max_voices||8,G=!1!==e.params.pass_through,q=e.params.bank||1,U={off:0,"1/4":96,"1/8":48,"1/16":24,"1/32":12}[N]||0;return"\n// ".concat(t.label," ").concat(n," - MIDI Looper with Key Detection & Auto-Banking\n// Bank ").concat(q,": Btn1=state/clear, Btn2=scale-lock | Pot1=velocity, Pot2=transpose, Pot3=timing rand, Pot4=pitch rand\n#define MIDILOOP").concat(n,"_MAX_EVENTS 2000\n#define MIDILOOP").concat(n,"_PPQ 96\n#define MIDILOOP").concat(n,"_MAX_VOICES ").concat(z,"\n#define MIDILOOP").concat(n,"_BANK ").concat(q,"\n\n// Loop settings\nint midiloop").concat(n,"_loop_bars = ").concat(T,";\nint midiloop").concat(n,"_count_in_bars = ").concat(F,";\nint midiloop").concat(n,"_quantize_ticks = ").concat(U,";\nint midiloop").concat(n,"_loop_ticks = ").concat(T," * 4 * MIDILOOP").concat(n,"_PPQ; // bars * beats * PPQ\n\n// State: 0=armed, 1=count_in, 2=recording, 3=playing, 4=overdub, 5=stopped\nint midiloop").concat(n,"_state = 0;\nint midiloop").concat(n,"_playhead = 0; // Current tick position\nint midiloop").concat(n,"_count_in_tick = 0; // Count-in progress\n\n// Event storage\nstruct MIDILoopEvent").concat(n," {\n    int tick;\n    uint8_t type; // 0=note_off, 1=note_on\n    uint8_t note;\n    uint8_t velocity;\n};\nMIDILoopEvent").concat(n," midiloop").concat(n,"_events[MIDILOOP").concat(n,"_MAX_EVENTS];\nint midiloop").concat(n,"_event_count = 0;\n\n// Voice management for playback\nstruct MIDILoopVoice").concat(n," {\n    uint8_t note;\n    uint8_t velocity;\n    bool active;\n    unsigned long start_time;\n};\nMIDILoopVoice").concat(n," midiloop").concat(n,"_voices[MIDILOOP").concat(n,"_MAX_VOICES];\nint midiloop").concat(n,"_active_voices = 0;\n\n// Key detection (Krumhansl-Schmuckler)\nint midiloop").concat(n,"_pitch_histogram[12] = {0}; // Count of each pitch class\nint midiloop").concat(n,"_detected_key = 0; // 0=C, 1=C#, ... 11=B\nbool midiloop").concat(n,"_detected_minor = false;\nfloat midiloop").concat(n,"_key_confidence = 0.0;\n\n// Transpose\nint midiloop").concat(n,"_transpose = 0;           // Current transpose in semitones\nbool midiloop").concat(n,"_scale_lock = false;     // Btn3 held = scale-step mode\nint midiloop").concat(n,"_last_transpose_pot = -1; // For detecting pot movement\n\n// Velocity control (Pot1)\nfloat midiloop").concat(n,"_velocity_scale = 1.0;  // Global velocity multiplier\n\n// Randomization (Pot3=timing, Pot4=pitch)\nfloat midiloop").concat(n,"_pitch_random = 0.0;\nfloat midiloop").concat(n,"_timing_random = 0.0;\n\n// Pass-through\nbool midiloop").concat(n,"_pass_through = ").concat(G?"true":"false",";\n\n// Clock input with multiplier for MIDI clock (24PPQ -> 96PPQ)\nfloat midiloop").concat(n,"_clock_input = 0.0;\nbool midiloop").concat(n,"_last_clock = false;\nint midiloop").concat(n,"_clock_multiplier = 1;  // 1 for 96PPQ internal, 4 for 24PPQ MIDI clock\nunsigned long midiloop").concat(n,"_last_ext_clock_time = 0;  // Last time external clock was received\nbool midiloop").concat(n,"_using_internal_clock = true;       // Start with internal clock (switch to external when received)\n\n// Internal clock fallback (100 BPM = 600ms per beat = 6.25ms per tick at 96PPQ)\nconst float MIDILOOP").concat(n,"_FALLBACK_BPM = 100.0;\nconst unsigned long MIDILOOP").concat(n,"_TICK_INTERVAL_US = (unsigned long)(60000000.0 / (MIDILOOP").concat(n,"_FALLBACK_BPM * 96.0));  // ~6250us\nunsigned long midiloop").concat(n,"_last_internal_tick_us = 0;\nconst unsigned long MIDILOOP").concat(n,"_EXT_CLOCK_TIMEOUT = 500;  // 500ms without clock = switch to internal\n\n// Button control (auto-mapped from bank)\nbool midiloop").concat(n,"_btn1_state = false;     // Current Btn1 state\nbool midiloop").concat(n,"_btn1_last = false;      // Previous Btn1 state\nunsigned long midiloop").concat(n,"_btn1_press_time = 0; // For long-hold detection\nbool midiloop").concat(n,"_btn2_state = false;     // Scale-lock modifier (Btn2 held)\n\n// Output values\nfloat midiloop").concat(n,"_out_note = 0.0;\nfloat midiloop").concat(n,"_out_gate = 0.0;\nfloat midiloop").concat(n,"_out_velocity = 1.0;  // Default to full velocity until first note\nfloat midiloop").concat(n,"_out_playing = 0.0;\nfloat midiloop").concat(n,"_out_recording = 0.0;\nfloat midiloop").concat(n,"_out_beat = 0.0;\n\n// Input tracking (from connected note/gate/velocity)\nfloat midiloop").concat(n,"_note_input = 0.0;\nfloat midiloop").concat(n,"_gate_input = 0.0;\nfloat midiloop").concat(n,"_velocity_input = 1.0;\nbool midiloop").concat(n,"_last_gate = false;  // For edge detection\n");default:return""}}},{key:"generateGlissandoFunction",value:function(e,n){return"\n// Glissando interpolation function for Sequencer ".concat(n,"\nfloat glissandoInterpolate").concat(n,'(float startPitch, float targetPitch, float progress, const char* curve) {\n    // Clamp progress to 0-1 range\n    progress = constrain(progress, 0.0, 1.0);\n\n    if (strcmp(curve, "linear") == 0) {\n        // Linear interpolation\n        return startPitch + (targetPitch - startPitch) * progress;\n    } else if (strcmp(curve, "exponential") == 0) {\n        // Exponential curve (fast start, slow end)\n        float expProgress = 1.0 - exp(-3.0 * progress);\n        return startPitch + (targetPitch - startPitch) * expProgress;\n    } else if (strcmp(curve, "logarithmic") == 0) {\n        // Logarithmic curve (slow start, fast end)\n        float logProgress = log(1.0 + progress * (exp(1.0) - 1.0));\n        return startPitch + (targetPitch - startPitch) * logProgress;\n    } else {\n        // Default to linear\n        return startPitch + (targetPitch - startPitch) * progress;\n    }\n}\n')}},{key:"generateQuantizationFunction",value:function(e,n){return"\n// Musical Scale Quantization Function for Sequencer ".concat(n,"\nfloat quantizePitch").concat(n,"(float inputPitch) {\n\n    // Convert 0-1 pitch to MIDI note number (C3=48 to C7=84, 3 octaves)\n    float midiNote = 48.0 + (inputPitch * 36.0);\n\n    // Get root note offset (C=0, C#=1, D=2, etc.)\n    int rootOffset = 0;\n    if (strcmp(seq").concat(n,'_quantization_root, "C#") == 0 || strcmp(seq').concat(n,'_quantization_root, "Db") == 0) rootOffset = 1;\n    else if (strcmp(seq').concat(n,'_quantization_root, "D") == 0) rootOffset = 2;\n    else if (strcmp(seq').concat(n,'_quantization_root, "D#") == 0 || strcmp(seq').concat(n,'_quantization_root, "Eb") == 0) rootOffset = 3;\n    else if (strcmp(seq').concat(n,'_quantization_root, "E") == 0) rootOffset = 4;\n    else if (strcmp(seq').concat(n,'_quantization_root, "F") == 0) rootOffset = 5;\n    else if (strcmp(seq').concat(n,'_quantization_root, "F#") == 0 || strcmp(seq').concat(n,'_quantization_root, "Gb") == 0) rootOffset = 6;\n    else if (strcmp(seq').concat(n,'_quantization_root, "G") == 0) rootOffset = 7;\n    else if (strcmp(seq').concat(n,'_quantization_root, "G#") == 0 || strcmp(seq').concat(n,'_quantization_root, "Ab") == 0) rootOffset = 8;\n    else if (strcmp(seq').concat(n,'_quantization_root, "A") == 0) rootOffset = 9;\n    else if (strcmp(seq').concat(n,'_quantization_root, "A#") == 0 || strcmp(seq').concat(n,'_quantization_root, "Bb") == 0) rootOffset = 10;\n    else if (strcmp(seq').concat(n,'_quantization_root, "B") == 0) rootOffset = 11;\n\n    // Define scale intervals\n    int scaleIntervals[12];\n    int scaleLength = 12;\n\n    if (strcmp(seq').concat(n,'_quantization_scale, "major") == 0) {\n        int intervals[] = {0, 2, 4, 5, 7, 9, 11};\n        scaleLength = 7;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else if (strcmp(seq').concat(n,'_quantization_scale, "minor") == 0) {\n        int intervals[] = {0, 2, 3, 5, 7, 8, 10};\n        scaleLength = 7;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else if (strcmp(seq').concat(n,'_quantization_scale, "pentatonic_major") == 0) {\n        int intervals[] = {0, 2, 4, 7, 9};\n        scaleLength = 5;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else if (strcmp(seq').concat(n,'_quantization_scale, "pentatonic_minor") == 0) {\n        int intervals[] = {0, 3, 5, 7, 10};\n        scaleLength = 5;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else if (strcmp(seq').concat(n,'_quantization_scale, "blues") == 0) {\n        int intervals[] = {0, 3, 5, 6, 7, 10};\n        scaleLength = 6;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else if (strcmp(seq').concat(n,'_quantization_scale, "dorian") == 0) {\n        int intervals[] = {0, 2, 3, 5, 7, 9, 10};\n        scaleLength = 7;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else if (strcmp(seq').concat(n,'_quantization_scale, "wholetone") == 0) {\n        int intervals[] = {0, 2, 4, 6, 8, 10};\n        scaleLength = 6;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else {\n        // Chromatic or unknown scale - all 12 semitones\n        for (int i = 0; i < 12; i++) scaleIntervals[i] = i;\n        scaleLength = 12;\n    }\n\n    // Get the note within the octave (0-11)\n    int noteInOctave = ((int)midiNote + rootOffset) % 12;\n    int octave = ((int)midiNote + rootOffset) / 12;\n\n    // Find closest scale note\n    int closestInterval = scaleIntervals[0];\n    int minDistance = abs(noteInOctave - closestInterval);\n\n    for (int i = 1; i < scaleLength; i++) {\n        int distance = abs(noteInOctave - scaleIntervals[i]);\n        if (distance < minDistance) {\n            minDistance = distance;\n            closestInterval = scaleIntervals[i];\n        }\n    }\n\n    // Handle wrapping at octave boundaries\n    if (minDistance > 6) {\n        // Check if wrapping to next/previous octave is closer\n        int wrapUpDistance = abs(noteInOctave - (closestInterval + 12));\n        int wrapDownDistance = abs(noteInOctave - (closestInterval - 12));\n\n        if (wrapUpDistance < minDistance) {\n            closestInterval += 12;\n            octave -= 1;\n        } else if (wrapDownDistance < minDistance) {\n            closestInterval -= 12;\n            octave += 1;\n        }\n    }\n\n    // Reconstruct quantized MIDI note\n    float quantizedMidi = (octave * 12) + closestInterval - rootOffset;\n\n    // Convert back to 0-1 range\n    float quantizedPitch = (quantizedMidi - 48.0) / 36.0;\n\n    // Clamp to valid range\n    if (quantizedPitch < 0.0) quantizedPitch = 0.0;\n    if (quantizedPitch > 1.0) quantizedPitch = 1.0;\n\n    return quantizedPitch;\n}\n')}},{key:"generateProcessingCode",value:function(e,n,t){switch(e.type){case"ADSR":return this.generateADSRCode(e,n,t);case"Scale":return this.generateScaleCode(e,n,t);case"LFO":return this.generateLFOCode(e,n,t);case"GateGen":return this.generateGateGenCode(e,n,t);case"Clock":return this.generateClockCode(e,n,t);case"Modulation":return this.generateModulationCode(e,n,t);case"Invert":return this.generateInvertCode(e,n,t);case"HarmonicSequencer":return this.generateHarmonicSequencerCode(e,n,t);case"Automation":return this.generateAutomationCode(e,n,t);case"Arpeggiator":return this.generateArpeggiatorCode(e,n,t);case"MIDILooper":return this.generateMIDILooperCode(e,n,t);default:return""}}},{key:"generateADSRCode",value:function(e,n,t){return"\n        // ADSR ".concat(n," processing\n        {\n            bool currentGate = (adsr").concat(n,"_gate > 0.5);\n            \n            // Gate edge detection\n            if (currentGate && !adsr").concat(n,"_lastGate) {\n                // Gate on - start attack\n                // Capture current level to avoid click (smooth retriggering)\n                adsr").concat(n,"_attackStartLevel = adsr").concat(n,"_level;\n                adsr").concat(n,"_stage = 1;\n                adsr").concat(n,"_stageTime = 0.0;\n            } else if (!currentGate && adsr").concat(n,"_lastGate) {\n                // Gate off - start release\n                if (adsr").concat(n,"_stage != 0) {\n                    adsr").concat(n,"_releaseStartLevel = adsr").concat(n,"_level; // Capture current level for release\n                    adsr").concat(n,"_stage = 4;\n                    adsr").concat(n,"_stageTime = 0.0;\n                }\n            }\n            \n            adsr").concat(n,"_lastGate = currentGate;\n\n            // Process envelope stages\n            // CRITICAL: This runs once per buffer, so advance time by buffer duration\n            // timescale > 1 = slower (more time per buffer), timescale < 1 = faster (less time per buffer)\n            float bufferTime = (BUFFER_SIZE / 44100.0) / adsr").concat(n,"_timescale; // Buffer duration in seconds (DIVIDE for correct behavior)\n            adsr").concat(n,"_stageTime += bufferTime;\n            \n            switch (adsr").concat(n,"_stage) {\n                case 0: // Idle\n                    adsr").concat(n,"_level = 0.0;\n                    break;\n                    \n                case 1: // Attack\n                    if (adsr").concat(n,"_attack > 0.0) {\n                        float progress = adsr").concat(n,"_stageTime / adsr").concat(n,"_attack;\n                        if (progress >= 1.0) {\n                            adsr").concat(n,"_level = 1.0;\n                            adsr").concat(n,"_stage = 2;\n                            adsr").concat(n,"_stageTime = 0.0;\n                        } else {\n                            // Smooth attack: interpolate from captured start level to 1.0\n                            // This prevents clicks when retriggering during decay/release\n                            adsr").concat(n,"_level = adsr").concat(n,"_attackStartLevel + (1.0 - adsr").concat(n,"_attackStartLevel) * progress;\n                        }\n                    } else {\n                        adsr").concat(n,"_level = 1.0;\n                        adsr").concat(n,"_stage = 2;\n                        adsr").concat(n,"_stageTime = 0.0;\n                    }\n                    break;\n                    \n                case 2: // Decay\n                    if (adsr").concat(n,"_decay > 0.0) {\n                        float progress = adsr").concat(n,"_stageTime / adsr").concat(n,"_decay;\n                        if (progress >= 1.0) {\n                            adsr").concat(n,"_level = adsr").concat(n,"_sustain;\n                            adsr").concat(n,"_stage = 3;\n                        } else {\n                            adsr").concat(n,"_level = 1.0 - progress * (1.0 - adsr").concat(n,"_sustain);\n                        }\n                    } else {\n                        adsr").concat(n,"_level = adsr").concat(n,"_sustain;\n                        adsr").concat(n,"_stage = 3;\n                    }\n                    break;\n                    \n                case 3: // Sustain\n                    adsr").concat(n,"_level = adsr").concat(n,"_sustain;\n                    break;\n                    \n                case 4: // Release\n                    if (adsr").concat(n,"_release > 0.0) {\n                        float progress = adsr").concat(n,"_stageTime / adsr").concat(n,"_release;\n                        if (progress >= 1.0) {\n                            adsr").concat(n,"_level = 0.0;\n\n                            // Looping logic\n                            if (strcmp(adsr").concat(n,'_loop_mode, "loop") == 0) {\n                                // Loop mode: restart attack from 0\n                                adsr').concat(n,"_attackStartLevel = 0.0;\n                                adsr").concat(n,"_stage = 1; // Go to attack\n                                adsr").concat(n,"_stageTime = 0.0;\n                            } else if (strcmp(adsr").concat(n,'_loop_mode, "pingpong") == 0) {\n                                // Pingpong mode: reverse direction (future implementation)\n                                adsr').concat(n,"_attackStartLevel = 0.0;\n                                adsr").concat(n,"_stage = 1; // For now, same as loop\n                                adsr").concat(n,"_stageTime = 0.0;\n                            } else {\n                                // Oneshot mode: go to idle\n                                adsr").concat(n,"_stage = 0;\n                            }\n                        } else {\n                            // Exponential release curve: faster at start, slower toward zero\n                            float releaseAmount = progress * progress; // Quadratic curve for smooth release\n                            adsr").concat(n,"_level = adsr").concat(n,"_releaseStartLevel * (1.0 - releaseAmount);\n\n                            // Ensure envelope reaches exactly zero when very close\n                            if (adsr").concat(n,"_level < 0.001) {\n                                adsr").concat(n,"_level = 0.0;\n\n                                // Looping logic for early termination\n                                if (strcmp(adsr").concat(n,'_loop_mode, "loop") == 0) {\n                                    adsr').concat(n,"_attackStartLevel = 0.0;\n                                    adsr").concat(n,"_stage = 1;\n                                    adsr").concat(n,"_stageTime = 0.0;\n                                } else if (strcmp(adsr").concat(n,'_loop_mode, "pingpong") == 0) {\n                                    adsr').concat(n,"_attackStartLevel = 0.0;\n                                    adsr").concat(n,"_stage = 1;\n                                    adsr").concat(n,"_stageTime = 0.0;\n                                } else {\n                                    adsr").concat(n,"_stage = 0;\n                                }\n                            }\n                        }\n                    } else {\n                        adsr").concat(n,"_level = 0.0;\n\n                        // Looping logic for instant release\n                        if (strcmp(adsr").concat(n,'_loop_mode, "loop") == 0) {\n                            adsr').concat(n,"_attackStartLevel = 0.0;\n                            adsr").concat(n,"_stage = 1;\n                            adsr").concat(n,"_stageTime = 0.0;\n                        } else if (strcmp(adsr").concat(n,'_loop_mode, "pingpong") == 0) {\n                            adsr').concat(n,"_attackStartLevel = 0.0;\n                            adsr").concat(n,"_stage = 1;\n                            adsr").concat(n,"_stageTime = 0.0;\n                        } else {\n                            adsr").concat(n,"_stage = 0;\n                        }\n                    }\n                    break;\n            }\n\n            // Store previous output and set new target for interpolation\n            adsr").concat(n,"_prevOutput = adsr").concat(n,"_output;\n            adsr").concat(n,"_targetOutput = adsr").concat(n,"_level;\n        }\n")}},{key:"generateScaleCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&("in"===n.to.port||void 0===n.to.port)}),o="0.0",c="",r=this.connectionResolver.modules.find(function(e){return"HarmonicSequencer"===e.type});if(r){var i,l=(null===(i=r.id.match(/\d+$/))||void 0===i?void 0:i[0])||"1";o="seq".concat(l,"_pitch_sum"),c="seq".concat(l,"_running && seq").concat(l,"_gate_active")}else c="false";if(a){var s=a.from.id.split(":")[0],u=this.connectionResolver.modules.find(function(e){return e.id===s});if(u){var d,p=(null===(d=s.match(/\d+$/))||void 0===d?void 0:d[0])||"1";switch(u.type){case"GateGen":o="gate".concat(p,"_sh_output");break;case"LFO":o="lfo".concat(p,"_output");break;case"Pot":o="pot".concat(p,"_value")}}}return"\n        // Scale ".concat(n," processing\n        {\n            float input = ").concat(o,";\n            scale").concat(n,"_input = input;\n\n            // Only output frequency when HarmonicSequencer is running and has a gate\n            bool hasActiveGate = ").concat(c,";\n\n            static float lastInput = -1.0;\n            static float lastOutput = 0.0;\n            static bool lastGateState = false;\n            static unsigned long lastDebugTime = 0;\n\n            // Debug output every 100ms or when values change significantly\n            unsigned long currentTime = millis();\n            bool shouldDebug = (currentTime - lastDebugTime > 100) ||\n                              (abs(input - lastInput) > 0.01) ||\n                              (hasActiveGate != lastGateState);\n\n            if (hasActiveGate && input > 0.0) {\n                // Convert 0-1 input to MIDI note number using module parameters\n                int baseOctave = ").concat(e.params.base_octave||4,"; // Base octave (C4 = octave 4)\n                int octaveRange = ").concat(e.params.octave_range||2,'; // Octaves to span\n                int baseNote = (baseOctave * 12) + 12; // Convert octave to MIDI note (C0=12, C4=60)\n                int rangeSemitones = octaveRange * 12; // Convert octaves to semitones\n                int midiNote = baseNote + (int)(input * rangeSemitones);\n                float newOutput = 440.0 * pow(2.0, (midiNote - 69) / 12.0); // Convert to frequency\n\n                // Debug output changes\n                if (shouldDebug && (abs(newOutput - lastOutput) > 1.0)) {\n                    Serial.print("Scale').concat(n,': IN=");\n                    Serial.print(input, 3);\n                    Serial.print(" MIDI=");\n                    Serial.print(midiNote);\n                    Serial.print(" FREQ=");\n                    Serial.print(newOutput, 1);\n                    Serial.print(" GATE=");\n                    Serial.println(hasActiveGate ? "ON" : "OFF");\n                    lastDebugTime = currentTime;\n                }\n\n                scale').concat(n,'_output = newOutput;\n                lastOutput = newOutput;\n            } else {\n                // No active gate or zero input - maintain last frequency to avoid clicks\n                if (shouldDebug && hasActiveGate != lastGateState) {\n                    Serial.print("Scale').concat(n,': GATE=");\n                    Serial.print(hasActiveGate ? "ON" : "OFF");\n                    Serial.print(" (holding freq=");\n                    Serial.print(scale').concat(n,'_output, 1);\n                    Serial.println(")");\n                    lastDebugTime = currentTime;\n                }\n                // scale').concat(n,"_output remains at last value\n            }\n\n            lastInput = input;\n            lastGateState = hasActiveGate;\n        }\n")}},{key:"generateLFOCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"rate_hz"===n.to.port}),o="lfo".concat(n,"_rate_hz"),c=null;if(a){var r=a.from.id.split(":")[0],i=this.connectionResolver.modules.find(function(e){return e.id===r});if(i){var l,s=(null===(l=r.match(/\d+$/))||void 0===l?void 0:l[0])||"1",u=e.params.rate_min_hz||.01,d=(e.params.rate_max_hz||40)-u;switch(i.type){case"Pot":var p=a.from.bank||1;c={potVar:"pot".concat(s,"_value"),bank:p,min:u,range:d},o="lfo".concat(n,"_rate_saved");break;case"ADSR":o="(".concat(u," + adsr").concat(s,"_output * ").concat(d,")")}}}var f=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"depth"===n.to.port}),m="lfo".concat(n,"_depth");if(f){var _=f.from.id.split(":")[0],g=f.from.port,h=this.connectionResolver.modules.find(function(e){return e.id===_});if(h){var v,b=(null===(v=_.match(/\d+$/))||void 0===v?void 0:v[0])||"1";switch(h.type){case"Pot":m="pot".concat(b,"_value");break;case"ADSR":m="adsr".concat(b,"_output");break;case"LFO":m="((lfo".concat(b,"_output + 1.0) * 0.5)");break;case"MIDIIn":"velocity"===g?m="midiin".concat(b,"_velocity"):"mod"===g?m="midiin".concat(b,"_modWheel"):"aftertouch"===g&&(m="midiin".concat(b,"_aftertouch"))}}}var y=c?"\n            // Bank-aware rate persistence - only update rate when in correct bank\n            static float lfo".concat(n,"_rate_saved = ").concat(c.min," + 0.5f * ").concat(c.range,";\n            if (currentBank == ").concat(c.bank,") {\n                lfo").concat(n,"_rate_saved = ").concat(c.min,"f + ").concat(c.potVar," * ").concat(c.range,"f;\n            }"):"";return"\n        // LFO ".concat(n," - Low Frequency Oscillator (RESTORED ORIGINAL IMPLEMENTATION)\n        {\n            unsigned long currentTime = millis();\n").concat(y,"\n\n            // Update LFO phase based on rate\n            if (!lfo").concat(n,"_sync_to_clock) {\n                // Free-running mode\n                float deltaTime = (currentTime - lfo").concat(n,"_last_update) / 1000.0; // Convert to seconds\n                lfo").concat(n,"_phase += ").concat(o," * deltaTime * 2.0 * M_PI;\n\n                // Wrap phase to 0-2\n                while (lfo").concat(n,"_phase >= 2.0 * M_PI) {\n                    lfo").concat(n,"_phase -= 2.0 * M_PI;\n                }\n            } else {\n                // Clock-sync mode - would need clock input connection\n                // For now, just use free-running mode\n            }\n            lfo").concat(n,"_last_update = currentTime;\n\n            // Generate LFO waveform\n            float waveValue = 0.0;\n            switch (lfo").concat(n,"_wave) {\n                case 0: // Sine\n                    waveValue = sin(lfo").concat(n,"_phase);\n                    break;\n                case 1: // Sawtooth\n                    waveValue = 2.0 * (lfo").concat(n,"_phase / (2.0 * M_PI)) - 1.0;\n                    break;\n                case 2: // Square\n                    waveValue = (lfo").concat(n,"_phase < M_PI) ? 1.0 : -1.0;\n                    break;\n                case 3: // Triangle\n                    if (lfo").concat(n,"_phase < M_PI) {\n                        waveValue = -1.0 + 2.0 * (lfo").concat(n,"_phase / M_PI);\n                    } else {\n                        waveValue = 1.0 - 2.0 * ((lfo").concat(n,"_phase - M_PI) / M_PI);\n                    }\n                    break;\n            }\n\n            // Apply depth and offset\n            // With offset=0.5, depth=0.5: waveValue (-1 to +1) maps to output (0 to 1)\n            // With offset=0.0, depth=1.0: waveValue (-1 to +1) maps to output (-1 to +1)\n            lfo").concat(n,"_output = lfo").concat(n,"_offset + (waveValue * ").concat(m,");\n\n            // Note: No clamping - allow bipolar output for modulation sources\n            // Control connections will handle range conversion as needed\n        }\n")}},{key:"generateClockCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"bpm_input"===n.to.port}),o="clock".concat(n,"_bpm");if(a){var c=a.from.id.split(":")[0],r=this.connectionResolver.modules.find(function(e){return e.id===c});if(r){var i,l=(null===(i=c.match(/\d+$/))||void 0===i?void 0:i[0])||"1";switch(r.type){case"Pot":o="(40.0 + pot".concat(l,"_value * 200.0)");break;case"LFO":o="(40.0 + (lfo".concat(l,"_output * 0.5 + 0.5) * 200.0)")}}}return"\n        // Clock ".concat(n," - 8-output divider processing\n        {\n            unsigned long currentTime = millis();\n            static unsigned long clock").concat(n,"_last_tick24 = 0;\n            static unsigned long clock").concat(n,"_last_tick96 = 0;\n            static bool clock").concat(n,"_was_running = false;\n\n            // Update BPM from connection\n            clock").concat(n,"_bpm = ").concat(o,";\n\n            // Clear pulse outputs (they pulse for one control cycle)\n            clock").concat(n,"_tick24 = 0.0;\n            clock").concat(n,"_tick96 = 0.0;\n            clock").concat(n,"_start = 0.0;\n            clock").concat(n,"_stop = 0.0;\n\n            // Detect start/stop transitions\n            if (clock").concat(n,"_running && !clock").concat(n,"_was_running) {\n                clock").concat(n,"_start = 1.0;  // Start pulse\n                clock").concat(n,"_tick24_counter = 0;\n                clock").concat(n,"_tick96_counter = 0;\n            }\n            if (!clock").concat(n,"_running && clock").concat(n,"_was_running) {\n                clock").concat(n,"_stop = 1.0;   // Stop pulse\n            }\n            clock").concat(n,"_was_running = clock").concat(n,"_running;\n\n            // MIDI Clock outputs (24 PPQ and 96 PPQ)\n            if (clock").concat(n,"_running) {\n                // 24 PPQ: period = 60000 / (BPM * 24) = 2500 / BPM\n                float period24_ms = 2500.0 / clock").concat(n,"_bpm;\n                if (currentTime - clock").concat(n,"_last_tick24 >= (unsigned long)period24_ms) {\n                    clock").concat(n,"_tick24 = 1.0;\n                    clock").concat(n,"_tick24_counter++;\n                    clock").concat(n,"_last_tick24 = currentTime;\n                }\n\n                // 96 PPQ: period = 60000 / (BPM * 96) = 625 / BPM\n                float period96_ms = 625.0 / clock").concat(n,"_bpm;\n                if (currentTime - clock").concat(n,"_last_tick96 >= (unsigned long)period96_ms) {\n                    clock").concat(n,"_tick96 = 1.0;\n                    clock").concat(n,"_tick96_counter++;\n                    clock").concat(n,"_last_tick96 = currentTime;\n                }\n            }\n\n            // Master clock tick (quarter note)\n            if (clock").concat(n,"_running) {\n                clock").concat(n,"_period_ms = 60000.0 / clock").concat(n,"_bpm; // Period in ms\n\n                if (currentTime - clock").concat(n,"_last_tick >= clock").concat(n,"_period_ms) {\n                    // Master tick occurred\n                    clock").concat(n,"_master_pulse = true;\n                    clock").concat(n,"_last_tick = currentTime;\n\n                    // Increment master phase\n                    clock").concat(n,"_master_phase += 1.0;\n\n                    // Process all 8 outputs with rate multipliers, gate modes, and probability\n                    // Output 1\n                    float effective_rate1 = clock").concat(n,"_fill1 ? (clock").concat(n,"_rate1 * clock").concat(n,"_euclid1) : clock").concat(n,"_rate1;\n                    clock").concat(n,"_counter1 += effective_rate1;\n                    if (clock").concat(n,"_counter1 >= 1.0) {\n                        clock").concat(n,"_counter1 -= 1.0;  // Preserve fractional remainder\n                        // Probability check: base probability  pot attenuation (when fill active)\n                        float effective_prob1 = clock").concat(n,"_fill1 ? (clock").concat(n,"_prob1 * clock").concat(n,"_pot_value1) : clock").concat(n,"_prob1;\n                        if ((float)random(10000) / 10000.0 <= effective_prob1) {\n                            if (clock").concat(n,"_gate_mode1) {\n                                // Gate mode: pulse HIGH then LOW\n                                clock").concat(n,"_out1 = true;\n                                clock").concat(n,"_gate_start1 = currentTime;\n                            } else {\n                                // Toggle mode: alternate HIGH/LOW\n                                clock").concat(n,"_out1 = !clock").concat(n,"_out1;\n                            }\n                        }\n                    }\n\n                    // Output 2\n                    float effective_rate2 = clock").concat(n,"_fill2 ? (clock").concat(n,"_rate2 * clock").concat(n,"_euclid2) : clock").concat(n,"_rate2;\n                    clock").concat(n,"_counter2 += effective_rate2;\n                    if (clock").concat(n,"_counter2 >= 1.0) {\n                        clock").concat(n,"_counter2 -= 1.0;\n                        float effective_prob2 = clock").concat(n,"_fill2 ? (clock").concat(n,"_prob2 * clock").concat(n,"_pot_value2) : clock").concat(n,"_prob2;\n                        if ((float)random(10000) / 10000.0 <= effective_prob2) {\n                            if (clock").concat(n,"_gate_mode2) {\n                                clock").concat(n,"_out2 = true;\n                                clock").concat(n,"_gate_start2 = currentTime;\n                            } else {\n                                clock").concat(n,"_out2 = !clock").concat(n,"_out2;\n                            }\n                        }\n                    }\n\n                    // Output 3\n                    float effective_rate3 = clock").concat(n,"_fill3 ? (clock").concat(n,"_rate3 * clock").concat(n,"_euclid3) : clock").concat(n,"_rate3;\n                    clock").concat(n,"_counter3 += effective_rate3;\n                    if (clock").concat(n,"_counter3 >= 1.0) {\n                        clock").concat(n,"_counter3 -= 1.0;\n                        float effective_prob3 = clock").concat(n,"_fill3 ? (clock").concat(n,"_prob3 * clock").concat(n,"_pot_value3) : clock").concat(n,"_prob3;\n                        if ((float)random(10000) / 10000.0 <= effective_prob3) {\n                            if (clock").concat(n,"_gate_mode3) {\n                                clock").concat(n,"_out3 = true;\n                                clock").concat(n,"_gate_start3 = currentTime;\n                            } else {\n                                clock").concat(n,"_out3 = !clock").concat(n,"_out3;\n                            }\n                        }\n                    }\n\n                    // Output 4\n                    float effective_rate4 = clock").concat(n,"_fill4 ? (clock").concat(n,"_rate4 * clock").concat(n,"_euclid4) : clock").concat(n,"_rate4;\n                    clock").concat(n,"_counter4 += effective_rate4;\n                    if (clock").concat(n,"_counter4 >= 1.0) {\n                        clock").concat(n,"_counter4 -= 1.0;\n                        float effective_prob4 = clock").concat(n,"_fill4 ? (clock").concat(n,"_prob4 * clock").concat(n,"_pot_value4) : clock").concat(n,"_prob4;\n                        if ((float)random(10000) / 10000.0 <= effective_prob4) {\n                            if (clock").concat(n,"_gate_mode4) {\n                                clock").concat(n,"_out4 = true;\n                                clock").concat(n,"_gate_start4 = currentTime;\n                            } else {\n                                clock").concat(n,"_out4 = !clock").concat(n,"_out4;\n                            }\n                        }\n                    }\n\n                    // Output 5\n                    float effective_rate5 = clock").concat(n,"_fill5 ? (clock").concat(n,"_rate5 * clock").concat(n,"_euclid5) : clock").concat(n,"_rate5;\n                    clock").concat(n,"_counter5 += effective_rate5;\n                    if (clock").concat(n,"_counter5 >= 1.0) {\n                        clock").concat(n,"_counter5 -= 1.0;\n                        float effective_prob5 = clock").concat(n,"_fill5 ? (clock").concat(n,"_prob5 * clock").concat(n,"_pot_value5) : clock").concat(n,"_prob5;\n                        if ((float)random(10000) / 10000.0 <= effective_prob5) {\n                            if (clock").concat(n,"_gate_mode5) {\n                                clock").concat(n,"_out5 = true;\n                                clock").concat(n,"_gate_start5 = currentTime;\n                            } else {\n                                clock").concat(n,"_out5 = !clock").concat(n,"_out5;\n                            }\n                        }\n                    }\n\n                    // Output 6\n                    float effective_rate6 = clock").concat(n,"_fill6 ? (clock").concat(n,"_rate6 * clock").concat(n,"_euclid6) : clock").concat(n,"_rate6;\n                    clock").concat(n,"_counter6 += effective_rate6;\n                    if (clock").concat(n,"_counter6 >= 1.0) {\n                        clock").concat(n,"_counter6 -= 1.0;\n                        float effective_prob6 = clock").concat(n,"_fill6 ? (clock").concat(n,"_prob6 * clock").concat(n,"_pot_value6) : clock").concat(n,"_prob6;\n                        if ((float)random(10000) / 10000.0 <= effective_prob6) {\n                            if (clock").concat(n,"_gate_mode6) {\n                                clock").concat(n,"_out6 = true;\n                                clock").concat(n,"_gate_start6 = currentTime;\n                            } else {\n                                clock").concat(n,"_out6 = !clock").concat(n,"_out6;\n                            }\n                        }\n                    }\n\n                    // Output 7\n                    float effective_rate7 = clock").concat(n,"_fill7 ? (clock").concat(n,"_rate7 * clock").concat(n,"_euclid7) : clock").concat(n,"_rate7;\n                    clock").concat(n,"_counter7 += effective_rate7;\n                    if (clock").concat(n,"_counter7 >= 1.0) {\n                        clock").concat(n,"_counter7 -= 1.0;\n                        float effective_prob7 = clock").concat(n,"_fill7 ? (clock").concat(n,"_prob7 * clock").concat(n,"_pot_value7) : clock").concat(n,"_prob7;\n                        if ((float)random(10000) / 10000.0 <= effective_prob7) {\n                            if (clock").concat(n,"_gate_mode7) {\n                                clock").concat(n,"_out7 = true;\n                                clock").concat(n,"_gate_start7 = currentTime;\n                            } else {\n                                clock").concat(n,"_out7 = !clock").concat(n,"_out7;\n                            }\n                        }\n                    }\n\n                    // Output 8\n                    float effective_rate8 = clock").concat(n,"_fill8 ? (clock").concat(n,"_rate8 * clock").concat(n,"_euclid8) : clock").concat(n,"_rate8;\n                    clock").concat(n,"_counter8 += effective_rate8;\n                    if (clock").concat(n,"_counter8 >= 1.0) {\n                        clock").concat(n,"_counter8 -= 1.0;\n                        float effective_prob8 = clock").concat(n,"_fill8 ? (clock").concat(n,"_prob8 * clock").concat(n,"_pot_value8) : clock").concat(n,"_prob8;\n                        if ((float)random(10000) / 10000.0 <= effective_prob8) {\n                            if (clock").concat(n,"_gate_mode8) {\n                                clock").concat(n,"_out8 = true;\n                                clock").concat(n,"_gate_start8 = currentTime;\n                            } else {\n                                clock").concat(n,"_out8 = !clock").concat(n,"_out8;\n                            }\n                        }\n                    }\n\n                    clock").concat(n,"_master_pulse = false;\n                }\n\n                // Gate pulse end detection (turn off gates after gate_length_ms)\n                if (clock").concat(n,"_gate_mode1 && clock").concat(n,"_out1 && (currentTime - clock").concat(n,"_gate_start1 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out1 = false;\n                }\n                if (clock").concat(n,"_gate_mode2 && clock").concat(n,"_out2 && (currentTime - clock").concat(n,"_gate_start2 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out2 = false;\n                }\n                if (clock").concat(n,"_gate_mode3 && clock").concat(n,"_out3 && (currentTime - clock").concat(n,"_gate_start3 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out3 = false;\n                }\n                if (clock").concat(n,"_gate_mode4 && clock").concat(n,"_out4 && (currentTime - clock").concat(n,"_gate_start4 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out4 = false;\n                }\n                if (clock").concat(n,"_gate_mode5 && clock").concat(n,"_out5 && (currentTime - clock").concat(n,"_gate_start5 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out5 = false;\n                }\n                if (clock").concat(n,"_gate_mode6 && clock").concat(n,"_out6 && (currentTime - clock").concat(n,"_gate_start6 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out6 = false;\n                }\n                if (clock").concat(n,"_gate_mode7 && clock").concat(n,"_out7 && (currentTime - clock").concat(n,"_gate_start7 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out7 = false;\n                }\n                if (clock").concat(n,"_gate_mode8 && clock").concat(n,"_out8 && (currentTime - clock").concat(n,"_gate_start8 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out8 = false;\n                }\n            } else {\n                // Clock stopped - reset all gate outputs to LOW for proper note release\n                clock").concat(n,"_out1 = false;\n                clock").concat(n,"_out2 = false;\n                clock").concat(n,"_out3 = false;\n                clock").concat(n,"_out4 = false;\n                clock").concat(n,"_out5 = false;\n                clock").concat(n,"_out6 = false;\n                clock").concat(n,"_out7 = false;\n                clock").concat(n,"_out8 = false;\n                clock").concat(n,"_master_pulse = false;\n            }\n        }\n")}},{key:"generateGateGenCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"self_clock_bpm"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"probability"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate_input"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"sh_input"===n.to.port}),i="gate".concat(n,"_self_clock_bpm"),l="gate".concat(n,"_probability"),s="true",u="0.5",d=e.params.bpm_min||40,p=(e.params.bpm_max||180)-d;if(a){var f=a.from.id.split(":")[0],m=this.connectionResolver.modules.find(function(e){return e.id===f});if(m){var _,g=(null===(_=f.match(/\d+$/))||void 0===_?void 0:_[0])||"1";"Pot"===m.type&&(i="(".concat(d,".0 + pot").concat(g,"_value * ").concat(p,".0)"))}}if(o){var h=o.from.id.split(":")[0],v=this.connectionResolver.modules.find(function(e){return e.id===h});if(v){var b,y=(null===(b=h.match(/\d+$/))||void 0===b?void 0:b[0])||"1";"Pot"===v.type&&(l="pot".concat(y,"_value"))}}if(c){var k=c.from.id.split(":")[0],x=this.connectionResolver.modules.find(function(e){return e.id===k});if(x){var S=x.params.index;switch(x.type){case"LEDButton":s="btn".concat(S,"_pressed");break;case"ADSR":s="(adsr".concat(S,"_output > 0.5)");break;case"LFO":s="(lfo".concat(S,"_output > 0.5)");break;case"Clock":s="clock".concat(S,"_output")}}}if(r){var E=r.from.id.split(":")[0],P=this.connectionResolver.modules.find(function(e){return e.id===E});if(P){var w,C=(null===(w=E.match(/\d+$/))||void 0===w?void 0:w[0])||"1";switch(P.type){case"LFO":u="lfo".concat(C,"_output");break;case"Pot":u="pot".concat(C,"_value");break;case"ADSR":u="adsr".concat(C,"_output")}}}return"\n        // GateGen ".concat(n," processing\n        {\n            float currentBPM = ").concat(i,";\n            float currentProbability = ").concat(l,";\n            bool gateInputState = ").concat(s,";\n            float shInput = ").concat(u,";\n\n            // Output rate in Hz for tempo sync\n            gate").concat(n,"_rate = currentBPM / 60.0;\n\n            // Update gate enable state\n            gate").concat(n,"_gate_enabled = gateInputState;\n\n            // Self-clock generation (only when running)\n            if (gate").concat(n,"_use_self_clock && gate").concat(n,"_gate_enabled && gate").concat(n,"_running) {\n                unsigned long currentTime = millis();\n                unsigned long clockInterval = (unsigned long)(60000.0 / currentBPM);\n\n                if (currentTime - gate").concat(n,"_last_self_clock >= clockInterval) {\n                    // Clock trigger - test probability\n                    float randVal = (float)random(0, 1000) / 1000.0;\n                    if (randVal < currentProbability) {\n                        // Trigger gate\n                        gate").concat(n,"_state = true;\n                        gate").concat(n,"_start_time = currentTime;\n\n                        // Sample & Hold on trigger\n                        if (gate").concat(n,"_sh_enabled) {\n                            gate").concat(n,"_sh_output = shInput;\n                        }\n                    }\n                    gate").concat(n,"_last_self_clock = currentTime;\n                }\n\n                // Check gate length\n                if (gate").concat(n,"_state) {\n                    unsigned long gateLength = (unsigned long)(clockInterval * gate").concat(n,"_length);\n                    if (currentTime - gate").concat(n,"_start_time >= gateLength) {\n                        gate").concat(n,"_state = false;\n                    }\n                }\n            }\n\n            // Update gate output\n            gate").concat(n,"_output = gate").concat(n,"_state ? 1.0 : 0.0;\n\n            // Update LED output (metronome flash mode if led_flash_ms > 0)\n            if (gate").concat(n,"_led_flash_ms > 0) {\n                // Metronome mode: Fixed-duration flash on gate trigger\n                if (gate").concat(n,"_state && gate").concat(n,"_led_output == 0.0f) {\n                    // Gate just went high - start LED flash\n                    gate").concat(n,"_led_output = 1.0f;\n                    gate").concat(n,"_led_start_time = currentTime;\n                } else if (gate").concat(n,"_led_output > 0.0f) {\n                    // LED is on - check if flash duration expired\n                    if (currentTime - gate").concat(n,"_led_start_time >= gate").concat(n,"_led_flash_ms) {\n                        gate").concat(n,"_led_output = 0.0f; // Turn off LED after flash\n                    }\n                }\n            } else {\n                // Normal mode: LED follows gate state\n                gate").concat(n,"_led_output = gate").concat(n,"_output;\n            }\n\n            gate").concat(n,"_sh_input = shInput;\n        }\n")}},{key:"generateModulationCode",value:function(e,n,t){return"\n        // Modulation ".concat(n," - 4LFO Matrix processing\n        {\n            unsigned long currentTime = millis();\n            float deltaTime = (currentTime - lfo").concat(n,"_last_update) / 1000.0;\n\n            // Update all 4 LFO phases\n            mod").concat(n,"_phase1 += mod").concat(n,"_lfo1_rate * deltaTime * 2.0 * M_PI;\n            mod").concat(n,"_phase2 += mod").concat(n,"_lfo2_rate * deltaTime * 2.0 * M_PI;\n            mod").concat(n,"_phase3 += mod").concat(n,"_lfo3_rate * deltaTime * 2.0 * M_PI;\n            mod").concat(n,"_phase4 += mod").concat(n,"_lfo4_rate * deltaTime * 2.0 * M_PI;\n\n            // Wrap phases\n            if (mod").concat(n,"_phase1 >= 2.0 * M_PI) mod").concat(n,"_phase1 -= 2.0 * M_PI;\n            if (mod").concat(n,"_phase2 >= 2.0 * M_PI) mod").concat(n,"_phase2 -= 2.0 * M_PI;\n            if (mod").concat(n,"_phase3 >= 2.0 * M_PI) mod").concat(n,"_phase3 -= 2.0 * M_PI;\n            if (mod").concat(n,"_phase4 >= 2.0 * M_PI) mod").concat(n,"_phase4 -= 2.0 * M_PI;\n\n            // Generate LFO outputs (simplified - just sine waves for now)\n            mod").concat(n,"_output1 = (sin(mod").concat(n,"_phase1) + 1.0) * 0.5; // 0-1 range\n            mod").concat(n,"_output2 = (sin(mod").concat(n,"_phase2) + 1.0) * 0.5;\n            mod").concat(n,"_output3 = (sin(mod").concat(n,"_phase3) + 1.0) * 0.5;\n            mod").concat(n,"_output4 = (sin(mod").concat(n,"_phase4) + 1.0) * 0.5;\n        }\n")}},{key:"generateInvertCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&("in"===n.to.port||void 0===n.to.port)}),o="0.5";if(a){var c=a.from.id.split(":")[0],r=this.connectionResolver.modules.find(function(e){return e.id===c});if(r){var i,l=(null===(i=c.match(/\d+$/))||void 0===i?void 0:i[0])||"1";switch(r.type){case"ADSR":o="adsr".concat(l,"_output");break;case"LFO":o="lfo".concat(l,"_output");break;case"Pot":o="pot".concat(l,"_value")}}}return"\n        // Invert ".concat(n," processing\n        {\n            invert").concat(n,"_input = ").concat(o,";\n            // Invert: 1.0 - input, with gain and offset\n            invert").concat(n,"_output = (1.0 - invert").concat(n,"_input) * invert").concat(n,"_gain + invert").concat(n,"_offset;\n            // Clamp to 0-1 range for control signals\n            invert").concat(n,"_output = constrain(invert").concat(n,"_output, 0.0, 1.0);\n        }\n")}},{key:"generateStepArray",value:function(e,n,t,a,o,c){for(var r=[],i=0;i<t;i++)for(var l=e.params["bank".concat(i,"_steps")]||[],s=0;s<4;s++){var u=4*i+s;if(u<n){var d=null;if(l[s]&&void 0!==l[s][a]?d=l[s]:e.params.steps&&e.params.steps[u]&&void 0!==e.params.steps[u][a]&&(d=e.params.steps[u]),d)if("muted"===a||"active"===a)r.push(d[a]?"true":"false");else{var p=d[a].toString();c&&(p=c(d[a])),r.push(p)}else r.push(o(u))}}return r.join(", ")}},{key:"generateHarmonicSequencerCode",value:function(e,n,t){var a=e.params.step_count||4,o=e.params.start_bank||1,c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"clock"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"start_stop"===n.to.port}),i=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"behavior"===n.to.port}),l=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"bpm"===n.to.port}),s=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"clock_div"===n.to.port}),u="false",d="false",p="0.0";"rest"===e.params.playback_mode?p="0.5":"reverse"===e.params.playback_mode&&(p="0.8");var f="seq".concat(n,"_bpm"),m="seq".concat(n,"_clock_div");if(c){var _=c.from.id.split(":")[0],g=this.connectionResolver.modules.find(function(e){return e.id===_});if(g){var h,v=(null===(h=_.match(/\d+$/))||void 0===h?void 0:h[0])||"1";switch(g.type){case"Clock":u="clock".concat(v,"_output");break;case"LFO":u="(lfo".concat(v,"_output > 0.5)");break;case"LEDButton":u="btn".concat(g.params.index,"_pressed")}}}if(r){var b=r.from.id.split(":")[0],y=this.connectionResolver.modules.find(function(e){return e.id===b});if(y){var k=y.params.index;switch(y.type){case"LEDButton":d="btn".concat(k,"_pressed");break;case"Encoder":d="enc".concat(k,"_button_pressed")}}}var x=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate"===n.to.port}),S=null;if(x){var E=x.from.id.split(":")[0],P=this.connectionResolver.modules.find(function(e){return e.id===E});if(P){var w,C=(null===(w=E.match(/\d+$/))||void 0===w?void 0:w[0])||"1";switch(P.type){case"ADSR":S="adsr".concat(C,"_output");break;case"LFO":S="lfo".concat(C,"_output");break;case"LEDButton":S="btn".concat(P.params.index,"_gate");break;case"Clock":S="clock".concat(C,"_output");break;case"GateGen":S="gategen".concat(C,"_gate");break;case"HarmonicSequencer":S="seq".concat(C,"_gate_sum")}}}if(i){var I=i.from.id.split(":")[0],R=this.connectionResolver.modules.find(function(e){return e.id===I});if(R){var L,M=(null===(L=I.match(/\d+$/))||void 0===L?void 0:L[0])||"1";switch(R.type){case"Pot":p="pot".concat(R.params.index,"_value");break;case"ADSR":p="adsr".concat(M,"_output");break;case"LFO":p="lfo".concat(M,"_output")}}}if(l){var D=l.from.id.split(":")[0],A=this.connectionResolver.modules.find(function(e){return e.id===D});if(A){var O,B=(null===(O=D.match(/\d+$/))||void 0===O?void 0:O[0])||"1";switch(A.type){case"Pot":f="(60.0 + pot".concat(A.params.index,"_value * 200.0)");break;case"ADSR":f="(60.0 + adsr".concat(B,"_output * 200.0)");break;case"LFO":f="(60.0 + lfo".concat(B,"_output * 200.0)")}}}if(s){var T=s.from.id.split(":")[0],F=this.connectionResolver.modules.find(function(e){return e.id===T});if(F){var N,z=(null===(N=T.match(/\d+$/))||void 0===N?void 0:N[0])||"1";switch(F.type){case"Pot":m="(int)(1.0 + pot".concat(F.params.index,"_value * 15.0)");break;case"ADSR":m="(int)(1.0 + adsr".concat(z,"_output * 15.0)");break;case"LFO":m="(int)(1.0 + lfo".concat(z,"_output * 15.0)")}}}return"\n        // HarmonicSequencer ".concat(n," processing\n        {\n            // Banking: Only process pots when in correct bank (").concat(o,")\n            if (currentBank == ").concat(o,") {\n                // Read and smooth hardware pots to reduce noise-induced pitch wavering\n                float pot1_raw = analogRead(4) / 4095.0; // GPIO4 - POT1\n                float pot2_raw = analogRead(5) / 4095.0; // GPIO5 - POT2\n                float pot3_raw = analogRead(6) / 4095.0; // GPIO6 - POT3\n                float pot4_raw = analogRead(7) / 4095.0; // GPIO7 - POT4\n\n                // Apply exponential smoothing to reduce pot noise\n                seq").concat(n,"_smoothed_pot[0] = seq").concat(n,"_smoothed_pot[0] * seq").concat(n,"_pot_smooth_factor + pot1_raw * (1.0 - seq").concat(n,"_pot_smooth_factor);\n                seq").concat(n,"_smoothed_pot[1] = seq").concat(n,"_smoothed_pot[1] * seq").concat(n,"_pot_smooth_factor + pot2_raw * (1.0 - seq").concat(n,"_pot_smooth_factor);\n                seq").concat(n,"_smoothed_pot[2] = seq").concat(n,"_smoothed_pot[2] * seq").concat(n,"_pot_smooth_factor + pot3_raw * (1.0 - seq").concat(n,"_pot_smooth_factor);\n                seq").concat(n,"_smoothed_pot[3] = seq").concat(n,"_smoothed_pot[3] * seq").concat(n,"_pot_smooth_factor + pot4_raw * (1.0 - seq").concat(n,"_pot_smooth_factor);\n            } // End banking check for pot reading\n\n            float pot1_val = seq").concat(n,"_smoothed_pot[0];\n            float pot2_val = seq").concat(n,"_smoothed_pot[1];\n            float pot3_val = seq").concat(n,"_smoothed_pot[2];\n            float pot4_val = seq").concat(n,"_smoothed_pot[3];\n\n            // Rate-limited MCP23017 I2C read to prevent audio interference\n            static unsigned long lastMcpRead = 0;\n            static bool btn_current[4] = {false, false, false, false};\n            if (currentTime - lastMcpRead > 20) { // Read every 20ms to avoid I2S interference\n                lastMcpRead = currentTime;\n                uint16_t mcpInputs = mcp.readGPIOAB();\n                btn_current[0] = !(mcpInputs & (1 << 0)); // GPA0 - active low\n                btn_current[1] = !(mcpInputs & (1 << 1)); // GPA1 - active low\n                btn_current[2] = !(mcpInputs & (1 << 2)); // GPA2 - active low\n                btn_current[3] = !(mcpInputs & (1 << 3)); // GPA3 - active low\n            }\n\n            // Banking: Only process pot manipulation when in correct bank (").concat(o,")\n            if (currentBank == ").concat(o,") {\n                // Direct mapping: Button 1-4 controls steps 0-3\n                {\n                    // Check if any buttons are currently held (shift mode)\n                    bool shiftMode = btn_current[0] || btn_current[1] || btn_current[2] || btn_current[3];\n\n                if (shiftMode) {\n                    // SHIFT MODE: Held buttons enable duration control\n                    // Only update duration for pots whose buttons are held\n                    if (btn_current[0]) {\n                        // Check soft takeover for duration\n                        float targetDuration = 0.25 + (pot1_val * 3.75); // Map to 0.25x-4.0x\n                        float currentDuration = seq").concat(n,"_duration[0];\n                        if (seq").concat(n,"_pot_taken_over[0] || abs(targetDuration - currentDuration) < 0.1) {\n                            seq").concat(n,"_duration[0] = targetDuration;\n                            seq").concat(n,"_pot_taken_over[0] = true;\n                            // Mark as shift mode only when pot is actually being used\n                            if (currentTime - seq").concat(n,"_btn_press_time[0] > 500) {\n                                seq").concat(n,"_btn_used_for_shift[0] = true;\n                            }\n                        }\n                    }\n                    if (btn_current[1]) {\n                        float targetDuration = 0.25 + (pot2_val * 3.75);\n                        float currentDuration = seq").concat(n,"_duration[1];\n                        if (seq").concat(n,"_pot_taken_over[1] || abs(targetDuration - currentDuration) < 0.1) {\n                            seq").concat(n,"_duration[1] = targetDuration;\n                            seq").concat(n,"_pot_taken_over[1] = true;\n                            // Mark as shift mode only when pot is actually being used\n                            if (currentTime - seq").concat(n,"_btn_press_time[1] > 500) {\n                                seq").concat(n,"_btn_used_for_shift[1] = true;\n                            }\n                        }\n                    }\n                    if (btn_current[2]) {\n                        float targetDuration = 0.25 + (pot3_val * 3.75);\n                        float currentDuration = seq").concat(n,"_duration[2];\n                        if (seq").concat(n,"_pot_taken_over[2] || abs(targetDuration - currentDuration) < 0.1) {\n                            seq").concat(n,"_duration[2] = targetDuration;\n                            seq").concat(n,"_pot_taken_over[2] = true;\n                            // Mark as shift mode only when pot is actually being used\n                            if (currentTime - seq").concat(n,"_btn_press_time[2] > 500) {\n                                seq").concat(n,"_btn_used_for_shift[2] = true;\n                            }\n                        }\n                    }\n                    if (btn_current[3]) {\n                        float targetDuration = 0.25 + (pot4_val * 3.75);\n                        float currentDuration = seq").concat(n,"_duration[3];\n                        if (seq").concat(n,"_pot_taken_over[3] || abs(targetDuration - currentDuration) < 0.1) {\n                            seq").concat(n,"_duration[3] = targetDuration;\n                            seq").concat(n,"_pot_taken_over[3] = true;\n                            // Mark as shift mode only when pot is actually being used\n                            if (currentTime - seq").concat(n,"_btn_press_time[3] > 500) {\n                                seq").concat(n,"_btn_used_for_shift[3] = true;\n                            }\n                        }\n                    }\n                } else {\n                    // NORMAL MODE: Pots control pitch with soft takeover after duration editing\n                    // Pot 1 pitch control with soft takeover\n                    float targetPitch1 = pot1_val;\n                    float currentPitch1 = seq").concat(n,"_pitch[0];\n                    if (seq").concat(n,"_pot_taken_over[0] || abs(targetPitch1 - currentPitch1) < 0.05) {\n                        seq").concat(n,"_pitch[0] = targetPitch1;\n                        seq").concat(n,"_base_pitch[0] = targetPitch1; // Track base pitch for harmonic linking\n                        seq").concat(n,"_pot_taken_over[0] = true;\n                    }\n\n                    // Pot 2 pitch control with soft takeover\n                    float targetPitch2 = pot2_val;\n                    float currentPitch2 = seq").concat(n,"_pitch[1];\n                    if (seq").concat(n,"_pot_taken_over[1] || abs(targetPitch2 - currentPitch2) < 0.05) {\n                        seq").concat(n,"_pitch[1] = targetPitch2;\n                        seq").concat(n,"_base_pitch[1] = targetPitch2; // Track base pitch for harmonic linking\n                        seq").concat(n,"_pot_taken_over[1] = true;\n                    }\n\n                    // Pot 3 pitch control with soft takeover\n                    float targetPitch3 = pot3_val;\n                    float currentPitch3 = seq").concat(n,"_pitch[2];\n                    if (seq").concat(n,"_pot_taken_over[2] || abs(targetPitch3 - currentPitch3) < 0.05) {\n                        seq").concat(n,"_pitch[2] = targetPitch3;\n                        seq").concat(n,"_base_pitch[2] = targetPitch3; // Track base pitch for harmonic linking\n                        seq").concat(n,"_pot_taken_over[2] = true;\n                    }\n\n                    // Pot 4 pitch control with soft takeover\n                    float targetPitch4 = pot4_val;\n                    float currentPitch4 = seq").concat(n,"_pitch[3];\n                    if (seq").concat(n,"_pot_taken_over[3] || abs(targetPitch4 - currentPitch4) < 0.05) {\n                        seq").concat(n,"_pitch[3] = targetPitch4;\n                        seq").concat(n,"_base_pitch[3] = targetPitch4; // Track base pitch for harmonic linking\n                        seq").concat(n,"_pot_taken_over[3] = true;\n                    }\n                }\n\n                // Update harmonic relationships after pot changes\n                updateHarmonicRelationships").concat(n,"();\n\n                // Reset takeover flags when buttons are released\n                if (!btn_current[0]) seq").concat(n,"_pot_taken_over[0] = false;\n                if (!btn_current[1]) seq").concat(n,"_pot_taken_over[1] = false;\n                if (!btn_current[2]) seq").concat(n,"_pot_taken_over[2] = false;\n                if (!btn_current[3]) seq").concat(n,"_pot_taken_over[3] = false;\n            }\n            } // End banking check for pot manipulation\n\n            // Behavior control - determine playback mode\n            float behaviorInput = ").concat(p,";\n            if (behaviorInput < 0.33) {\n                seq").concat(n,"_playback_mode = 0; // Iteration mode (default)\n            } else if (behaviorInput < 0.66) {\n                seq").concat(n,"_playback_mode = 1; // Rest mode (linear ").concat(a," steps)\n            } else {\n                seq").concat(n,"_playback_mode = 2; // Reverse mode\n            }\n\n            // Handle button press detection and timing\n            for (int btn = 0; btn < 4; btn++) {\n                if (btn_current[btn] && !seq").concat(n,"_btn_last[btn]) {\n                    // Button just pressed - start timing\n                    seq").concat(n,"_btn_press_time[btn] = currentTime;\n                    seq").concat(n,"_btn_long_hold_handled[btn] = false;\n                } else if (btn_current[btn] && seq").concat(n,"_btn_last[btn]) {\n                    // Button held - used for shift mode (duration control) - no additional action needed\n                    // The shift mode logic is handled in the pot control section above\n                } else if (!btn_current[btn] && seq").concat(n,"_btn_last[btn]) {\n                    // Button just released - only toggle step if button wasn't used for shift mode\n                    if (!seq").concat(n,"_btn_used_for_shift[btn]) {\n                        int stepIndex = btn; // Button 0-3 = Step 0-3\n                        if (stepIndex >= 0 && stepIndex < ").concat(a,") {\n                            seq").concat(n,"_active[stepIndex] = !seq").concat(n,'_active[stepIndex];\n                            Serial.print("Step ");\n                            Serial.print(stepIndex + 1);\n                            Serial.println(seq').concat(n,'_active[stepIndex] ? " ACTIVATED" : " DEACTIVATED");\n\n                            // Update step count for iteration mode\n                            int activeCount = 0;\n                            for (int i = 0; i < ').concat(a,"; i++) {\n                                if (seq").concat(n,'_active[i]) activeCount++;\n                            }\n                            Serial.print("Active steps: ");\n                            Serial.println(activeCount);\n                        }\n                    } else {\n                        Serial.print("Button ");\n                        Serial.print(btn + 1);\n                        Serial.println(" was used for duration control - no step toggle");\n                    }\n                }\n                seq').concat(n,"_btn_last[btn] = btn_current[btn];\n\n                // Reset shift mode flag after button state is updated\n                if (!btn_current[btn]) {\n                    seq").concat(n,"_btn_used_for_shift[btn] = false;\n                }\n            }\n\n            // Encoder button handling - long hold clears sequence, short press starts/stops\n            bool encBtnCurrent = !digitalRead(48); // Encoder button GPIO48 - active low\n            bool startStopTrigger = ").concat(d,";\n\n            // TEMPORARY: Use encoder button for start/stop if no connection\n            if (").concat(d," == false) {\n                // Encoder button press detection with long hold for sequence clear\n                if (encBtnCurrent && !seq").concat(n,"_enc_btn_last) {\n                    // Button just pressed - start timing\n                    seq").concat(n,"_enc_btn_press_time = currentTime;\n                    seq").concat(n,"_enc_long_hold_handled = false;\n\n                    // IMMEDIATE START/STOP TRIGGER: Trigger immediately on press for responsiveness\n                    // (Long hold will override if held for 2+ seconds)\n                    startStopTrigger = true;\n                } else if (encBtnCurrent && seq").concat(n,"_enc_btn_last) {\n                    // Button held - check for long hold (2 seconds for sequence clear)\n                    unsigned long holdDuration = currentTime - seq").concat(n,"_enc_btn_press_time;\n                    if (holdDuration > 2000 && !seq").concat(n,"_enc_long_hold_handled) {\n                        // Long hold detected - clear sequence and reset all parameters\n                        for (int i = 0; i < ").concat(a,"; i++) {\n                            seq").concat(n,"_active[i] = false;          // Clear active states\n                            seq").concat(n,"_pitch[i] = (i % 4) * 0.25;  // Reset to default pitch pattern (0, 0.25, 0.5, 0.75)\n                            seq").concat(n,"_duration[i] = 1.0;         // Reset to default duration (1.0x)\n                            seq").concat(n,"_muted[i] = false;          // Unmute all steps\n                            seq").concat(n,"_pitch_randomness[i] = 0.0; // Clear pitch randomness\n                            seq").concat(n,"_probability[i] = 1.0;      // Reset probability to 100%\n                            seq").concat(n,"_glissando_time[i] = 0.0;   // Clear glissando time\n                            seq").concat(n,"_glissando_probability[i] = 0.0; // Clear glissando probability\n                        }\n                        seq").concat(n,'_enc_long_hold_handled = true;\n                        Serial.println("HarmonicSequencer: SEQUENCE CLEARED & RESET TO DEFAULTS (long encoder hold)");\n                    }\n                } else if (!encBtnCurrent && seq').concat(n,"_enc_btn_last) {\n                    // Button just released - nothing to do here\n                }\n                seq").concat(n,"_enc_btn_last = encBtnCurrent;\n            } else {\n                // External start/stop connection exists\n                startStopTrigger = ").concat(d,";\n            }\n\n            // Start/Stop processing\n            static bool lastStartStopTrigger = false;\n            if (startStopTrigger && !lastStartStopTrigger) {\n                seq").concat(n,"_running = !seq").concat(n,"_running;\n                if (seq").concat(n,"_running) {\n                    seq").concat(n,"_current_step = 0; // Reset to beginning when starting\n                    seq").concat(n,"_last_step = -1; // Reset last step tracker\n\n                    // Generate initial random offsets for first sequence pass\n                    for (int i = 0; i < ").concat(a,"; i++) {\n                        float basePitch = seq").concat(n,"_pitch[i];\n                        float randomness = seq").concat(n,"_pitch_randomness[i];\n                        float randomRange = basePitch * randomness;\n                        seq").concat(n,'_pitch_random_offset[i] = (((float)random(0, 1000) / 1000.0) - 0.5) * 2.0 * randomRange;\n                    }\n\n                    Serial.println("HarmonicSequencer STARTED");\n                } else {\n                    Serial.println("HarmonicSequencer STOPPED");\n                }\n            }\n            lastStartStopTrigger = startStopTrigger;\n\n            // Clock processing\n            bool clockTrigger = ').concat(u,";\n\n            // AUTO CLOCK: Use internal clock when no external clock connected\n            if (").concat(u," == false) {\n                static unsigned long lastInternalClock = 0;\n                // Calculate step duration based on BPM and clock division (supports CV control)\n                float currentBpm = ").concat(f,";\n                int currentClockDiv = ").concat(m,";\n                unsigned long baseDuration = (60000 / currentBpm) / currentClockDiv; // Convert BPM to milliseconds per step\n                unsigned long currentStepDuration = (unsigned long)(baseDuration * seq").concat(n,"_duration[seq").concat(n,"_current_step]);\n\n                if (currentTime - lastInternalClock > currentStepDuration) {\n                    lastInternalClock = currentTime;\n                    clockTrigger = true;\n                }\n            }\n\n            if (seq").concat(n,"_running) {\n                // Advance step on clock trigger\n                if (clockTrigger && !seq").concat(n,"_last_clock_state) {\n                    // Find next step based on playback mode\n                    int nextStep = seq").concat(n,"_current_step;\n                    int attempts = 0;\n\n                    if (seq").concat(n,"_playback_mode == 1) {\n                        // Rest mode: Linear progression through all ").concat(a," steps (includes rests)\n                        if (seq").concat(n,"_reverse_direction) {\n                            nextStep = (seq").concat(n,"_current_step - 1 + ").concat(a,") % ").concat(a,";\n                        } else {\n                            nextStep = (seq").concat(n,"_current_step + 1) % ").concat(a,";\n                        }\n                    } else if (seq").concat(n,"_playback_mode == 2) {\n                        // Reverse mode: Only active steps, but in reverse order\n                        do {\n                            nextStep = (nextStep - 1 + ").concat(a,") % ").concat(a,";\n                            attempts++;\n                            if (attempts > ").concat(a,") break; // Prevent infinite loop\n                        } while (!seq").concat(n,"_active[nextStep] && attempts <= ").concat(a,");\n                    } else {\n                        // Iteration mode (default): Only active steps, forward\n                        do {\n                            nextStep = (nextStep + 1) % ").concat(a,";\n                            attempts++;\n                            if (attempts > ").concat(a,") break; // Prevent infinite loop\n                        } while (!seq").concat(n,"_active[nextStep] && attempts <= ").concat(a,");\n                    }\n\n                    // Detect sequence loop (when going to step 0 from a higher step)\n                    // Regenerate random pitch offsets once per sequence pass\n                    if (nextStep == 0 && seq").concat(n,"_last_step > 0) {\n                        // Sequence looped - regenerate all random offsets for this pass\n                        for (int i = 0; i < ").concat(a,"; i++) {\n                            float basePitch = seq").concat(n,"_pitch[i];\n                            float patternMod = 0.0; // Simplified - pattern affects playback, not random generation\n                            float modifiedPitch = basePitch + patternMod;\n\n                            float randomness = seq").concat(n,"_pitch_randomness[i];\n                            float randomRange = modifiedPitch * randomness;\n                            seq").concat(n,'_pitch_random_offset[i] = (((float)random(0, 1000) / 1000.0) - 0.5) * 2.0 * randomRange;\n                        }\n                        Serial.println("Seq').concat(n,': New random pass generated");\n                    }\n\n                    seq').concat(n,"_last_step = seq").concat(n,"_current_step; // Store current before updating\n                    seq").concat(n,"_current_step = nextStep;\n                    seq").concat(n,"_step_start_time = currentTime;\n\n                    // Increment pattern counter for this step (for pattern alternation)\n                    seq").concat(n,"_pattern_counter[seq").concat(n,"_current_step]++;\n\n                    // Use pre-calculated random offset from current sequence pass\n                    float basePitch = seq").concat(n,"_pitch[seq").concat(n,"_current_step];\n\n                    // Apply melodic pattern modulation around pot position\n                    // If this step is harmonically linked, use the pattern counter from the followed step\n                    int followedStep = seq").concat(n,"_harmonic_follow_steps[seq").concat(n,"_current_step];\n                    int effectiveStepForPattern = (followedStep != -1) ? followedStep : seq").concat(n,"_current_step;\n                    float patternModulation = calculatePatternModulation").concat(n,"(effectiveStepForPattern, currentTime, seq").concat(n,"_step_start_time, seq").concat(n,"_duration[seq").concat(n,"_current_step], basePitch);\n\n                    // Diatonic mode: double quantization to keep intervals in scale\n                    // Chromatic mode: single quantization at the end\n                    bool isDiatonic = false;\n                    switch (seq").concat(n,"_current_step) {\n                        case 0: isDiatonic = seq").concat(n,"_chord_diatonic_step1; break;\n                        case 1: isDiatonic = seq").concat(n,"_chord_diatonic_step2; break;\n                        case 2: isDiatonic = seq").concat(n,"_chord_diatonic_step3; break;\n                        case 3: isDiatonic = seq").concat(n,"_chord_diatonic_step4; break;\n                    }\n\n                    float modifiedPitch;\n                    if (isDiatonic) {\n                        // Diatonic mode: quantize base, add pattern, quantize again\n                        float quantizedBase = quantizePitch").concat(n,"(basePitch);\n                        modifiedPitch = quantizePitch").concat(n,"(quantizedBase + patternModulation);\n                    } else {\n                        // Chromatic mode: add pattern, quantize once at end\n                        modifiedPitch = basePitch + patternModulation;\n                    }\n\n                    // Use stored random offset instead of calculating new one each step\n                    float randomOffset = seq").concat(n,"_pitch_random_offset[seq").concat(n,"_current_step];\n                    float rawPitch = modifiedPitch + randomOffset;\n\n                    // Apply musical scale quantization (always active)\n                    seq").concat(n,"_sampled_pitch = quantizePitch").concat(n,"(rawPitch);\n\n                    // Gate activation depends on mode and step state\n                    if (seq").concat(n,"_playback_mode == 1) {\n                        // Rest mode: Gate active for all steps, but inactive steps produce silence\n                        seq").concat(n,"_gate_active = !seq").concat(n,"_muted[seq").concat(n,"_current_step];\n                    } else {\n                        // Iteration/Reverse modes: Gate only active for non-muted steps\n                        seq").concat(n,"_gate_active = seq").concat(n,"_active[seq").concat(n,"_current_step] && !seq").concat(n,"_muted[seq").concat(n,'_current_step];\n                    }\n\n                    // Debug output\n                    Serial.print("Step: ");\n                    Serial.print(seq').concat(n,'_current_step + 1);\n                    Serial.print(", Duration: ");\n                    Serial.print(seq').concat(n,"_duration[seq").concat(n,'_current_step]);\n                    Serial.print("x, Gate: ");\n                    Serial.println(seq').concat(n,'_gate_active ? "ON" : "OFF");\n                }\n                seq').concat(n,"_last_clock_state = clockTrigger;\n\n                // Gate length control with individual step durations\n                if (seq").concat(n,"_gate_active) {\n                    unsigned long baseDuration = 500; // Base step duration (120 BPM)\n                    // Apply individual step duration multiplier\n                    unsigned long stepDuration = (unsigned long)(baseDuration * seq").concat(n,"_duration[seq").concat(n,"_current_step]);\n                    unsigned long gateLength = (unsigned long)(stepDuration * seq").concat(n,"_gate_length);\n                    if (currentTime - seq").concat(n,"_step_start_time > gateLength) {\n                        seq").concat(n,"_gate_active = false;\n                    }\n                }\n            }\n\n            // LED Chase - show currently playing step (only if step is active)\n            // LED display (only update when state changes to prevent flickering)\n            static int lastDisplayedStep = -1;\n            static bool lastDisplayedActive[4];\n            static bool lastWasRunning = false;\n            static bool firstRun = true;\n\n            // Initialize array on first run\n            if (firstRun) {\n                for (int i = 0; i < 4; i++) {\n                    lastDisplayedActive[i] = false;\n                }\n                firstRun = false;\n            }\n\n            bool ledsNeedUpdate = false;\n\n            if (seq").concat(n,"_running) {\n                // Check if we need to update LEDs (step changed or just started)\n                int currentStepInBank = seq").concat(n,"_current_step % 4; // 0-3\n                if (currentStepInBank != lastDisplayedStep || !lastWasRunning) {\n                    ledsNeedUpdate = true;\n                    lastDisplayedStep = currentStepInBank;\n                }\n\n                if (ledsNeedUpdate && !showingBankIndicator) {\n                    // Clear all button LEDs\n                    neoPixels.setPixelColor(0, neoPixels.Color(0, 0, 0));\n                    neoPixels.setPixelColor(1, neoPixels.Color(0, 0, 0));\n                    neoPixels.setPixelColor(2, neoPixels.Color(0, 0, 0));\n                    neoPixels.setPixelColor(3, neoPixels.Color(0, 0, 0));\n\n                    // Light current step LED (white) - reversed mapping\n                    if (currentStepInBank == 0) neoPixels.setPixelColor(3, neoPixels.Color(255, 255, 255));      // Step 1  LED3\n                    else if (currentStepInBank == 1) neoPixels.setPixelColor(2, neoPixels.Color(255, 255, 255)); // Step 2  LED2\n                    else if (currentStepInBank == 2) neoPixels.setPixelColor(1, neoPixels.Color(255, 255, 255)); // Step 3  LED1\n                    else if (currentStepInBank == 3) neoPixels.setPixelColor(0, neoPixels.Color(255, 255, 255)); // Step 4  LED0\n\n                    neoPixels.show();\n                }\n            } else {\n                // Check if active states changed or just stopped\n                bool activeChanged = false;\n                for (int i = 0; i < 4; i++) {\n                    if (seq").concat(n,"_active[i] != lastDisplayedActive[i]) {\n                        activeChanged = true;\n                        lastDisplayedActive[i] = seq").concat(n,"_active[i];\n                    }\n                }\n\n                if ((activeChanged || lastWasRunning) && !showingBankIndicator) {\n                    // Show active steps (white) vs inactive steps (off)\n                    // Reversed mapping: Step 1LED3, Step 2LED2, Step 3LED1, Step 4LED0\n                    neoPixels.setPixelColor(3, seq").concat(n,"_active[0] ? neoPixels.Color(255, 255, 255) : neoPixels.Color(0, 0, 0)); // Step 1  LED3\n                    neoPixels.setPixelColor(2, seq").concat(n,"_active[1] ? neoPixels.Color(255, 255, 255) : neoPixels.Color(0, 0, 0)); // Step 2  LED2\n                    neoPixels.setPixelColor(1, seq").concat(n,"_active[2] ? neoPixels.Color(255, 255, 255) : neoPixels.Color(0, 0, 0)); // Step 3  LED1\n                    neoPixels.setPixelColor(0, seq").concat(n,"_active[3] ? neoPixels.Color(255, 255, 255) : neoPixels.Color(0, 0, 0)); // Step 4  LED0\n\n                    neoPixels.show();\n                }\n            }\n\n            lastWasRunning = seq").concat(n,"_running;\n\n            // Generate outputs based on mode and step state\n            static float lastPitchOutput = -1.0;\n            static int lastStepOutput = -1;\n            static unsigned long lastSeqDebugTime = 0;\n            static bool lastRunningState = false;\n\n            if (seq").concat(n,"_running && seq").concat(n,"_gate_active) {\n                // Apply probability check for this step\n                float stepProbability = seq").concat(n,"_probability[seq").concat(n,"_current_step];\n                bool stepFires = ((float)random(0, 1000) / 1000.0) < stepProbability;\n\n                if (seq").concat(n,"_playback_mode == 1) {\n                    // Rest mode: Output pitch only for active steps, gate always on when not muted\n                    if (seq").concat(n,"_active[seq").concat(n,"_current_step] && stepFires) {\n                        // Use sample-and-hold pitch (calculated once when step started)\n                        seq").concat(n,"_pitch_sum = seq").concat(n,"_sampled_pitch;\n                        seq").concat(n,"_velocity_sum = seq").concat(n,"_velocity[seq").concat(n,"_current_step];\n                    } else {\n                        seq").concat(n,"_pitch_sum = 0.0; // Rest - no pitch output\n                        seq").concat(n,"_velocity_sum = 0.0;\n                    }\n                    seq").concat(n,"_gate_sum = stepFires ? 1.0 : 0.0; // Gate depends on probability\n                } else {\n                    // Iteration/Reverse modes: Normal operation (only active steps play)\n                    if (stepFires) {\n                        // Use sample-and-hold pitch (calculated once when step started)\n                        seq").concat(n,"_pitch_sum = seq").concat(n,"_sampled_pitch;\n                        seq").concat(n,"_gate_sum = 1.0;\n                        seq").concat(n,"_velocity_sum = seq").concat(n,"_velocity[seq").concat(n,"_current_step];\n                    } else {\n                        seq").concat(n,"_pitch_sum = 0.0;\n                        seq").concat(n,"_gate_sum = 0.0;\n                        seq").concat(n,"_velocity_sum = 0.0;\n                    }\n                }\n\n                // Convert quantized pitch to Hz frequency using octave_center (octave+1 range)\n                if (seq").concat(n,"_gate_sum > 0.0) {\n                    // Use octave_center parameter (default 4 = C4)\n                    int octave_center = ").concat(e.params.octave_center||4,";\n                    // Convert 0-1 pitch to MIDI note within octave+1 range (13 semitones, C4 to C5)\n                    // Note: pitch_sum = 0.0 is valid (root note), only silence when gate is off\n                    float baseMidi = (octave_center * 12.0); // C of the center octave\n                    float midiNote = baseMidi + (seq").concat(n,"_pitch_sum * 13.0); // octave+1 range (13 semitones)\n                    // Convert MIDI to frequency: f = 440 * 2^((midi-69)/12)\n                    float targetHz = 440.0 * pow(2.0, (midiNote - 69.0) / 12.0);\n\n                    // GLISSANDO PROCESSING\n                    // Check if we should start a new glissando on step change\n                    static int lastProcessedStep = -1;\n                    if (seq").concat(n,"_current_step != lastProcessedStep) {\n                        // Step just changed - check if glissando should trigger\n                        float glissProb = seq").concat(n,"_glissando_probability[seq").concat(n,"_current_step];\n                        float glissTime = seq").concat(n,"_glissando_time[seq").concat(n,"_current_step];\n\n                        // Roll probability dice (simple deterministic approach using step number as seed)\n                        float randomValue = (float)((seq").concat(n,"_current_step * 7 + 13) % 100) / 100.0; // 0-1 pseudo-random\n\n                        if (glissProb > 0.0 && glissTime > 0.0 && randomValue < glissProb) {\n                            // Glissando triggered! Start sliding from current Hz to target Hz\n                            seq").concat(n,"_glissando_start_pitch = seq").concat(n,"_pitch_hz; // Start from current frequency\n                            seq").concat(n,"_glissando_target_pitch = targetHz; // Slide to target frequency\n                            seq").concat(n,"_glissando_start_time = seq").concat(n,"_step_start_time;\n                            seq").concat(n,'_glissando_active = true;\n                            Serial.print("GLISS: Step ");\n                            Serial.print(seq').concat(n,'_current_step + 1);\n                            Serial.print(" triggered (prob=");\n                            Serial.print(glissProb * 100);\n                            Serial.print("%, time=");\n                            Serial.print(glissTime * 100);\n                            Serial.println("%)");\n                        } else {\n                            // No glissando - use target frequency directly\n                            seq').concat(n,"_glissando_active = false;\n                        }\n                        lastProcessedStep = seq").concat(n,"_current_step;\n                    }\n\n                    // Apply glissando interpolation if active\n                    if (seq").concat(n,"_glissando_active) {\n                        float glissTime = seq").concat(n,"_glissando_time[seq").concat(n,"_current_step];\n                        unsigned long stepDuration = (unsigned long)(60000.0 / seq").concat(n,"_bpm * 4.0 / seq").concat(n,"_clock_div * seq").concat(n,"_duration[seq").concat(n,"_current_step]);\n                        unsigned long glissDuration = (unsigned long)(stepDuration * glissTime);\n                        unsigned long elapsed = currentTime - seq").concat(n,"_glissando_start_time;\n\n                        if (elapsed < glissDuration) {\n                            // Still within glissando time - interpolate\n                            float rawProgress = (float)elapsed / (float)glissDuration;\n                            rawProgress = constrain(rawProgress, 0.0, 1.0);\n\n                            // Apply curve shaping based on curve type\n                            int curveType = seq").concat(n,"_glissando_curve[seq").concat(n,"_current_step];\n                            float progress = rawProgress;\n\n                            if (curveType == 1) {\n                                // Exponential curve (slow start, fast end)\n                                progress = pow(rawProgress, 2.0);\n                            } else if (curveType == 2) {\n                                // Logarithmic curve (fast start, slow end)\n                                progress = sqrt(rawProgress);\n                            }\n                            // curveType == 0 is linear (no change needed)\n\n                            // Linear interpolation with curve-shaped progress\n                            float interpolatedPitch = seq").concat(n,"_glissando_start_pitch +\n                                (seq").concat(n,"_glissando_target_pitch - seq").concat(n,"_glissando_start_pitch) * progress;\n\n                            seq").concat(n,"_pitch_hz = interpolatedPitch;\n                            seq").concat(n,"_glissando_current_hz = interpolatedPitch;\n                        } else {\n                            // Glissando finished - use target frequency\n                            seq").concat(n,"_pitch_hz = seq").concat(n,"_glissando_target_pitch;\n                            seq").concat(n,"_glissando_active = false;\n                        }\n                    } else {\n                        // No glissando active - use target frequency directly\n                        seq").concat(n,"_pitch_hz = targetHz;\n                    }\n                } else {\n                    seq").concat(n,"_pitch_hz = 0.0; // Silent when gate is off\n                    seq").concat(n,"_glissando_active = false; // Stop glissando when gate is off\n                }\n\n                // Apply external gate muting (if gate input is connected)\n                // Sequencer continues running, but outputs are muted when gate is low\n                ").concat(S?"\n                float gateInput = ".concat(S,";\n                bool gateEnabled = (gateInput > 0.5);\n                if (!gateEnabled) {\n                    // Mute outputs while sequencer continues running internally\n                    seq").concat(n,"_pitch_sum = 0.0;\n                    seq").concat(n,"_gate_sum = 0.0;\n                    seq").concat(n,"_pitch_hz = 0.0;\n                }\n                "):"// No gate input connected - outputs always enabled","\n\n                // Debug output when step or pitch changes\n                bool shouldSeqDebug = (seq").concat(n,"_current_step != lastStepOutput) ||\n                                     (abs(seq").concat(n,"_pitch_sum - lastPitchOutput) > 0.01) ||\n                                     (currentTime - lastSeqDebugTime > 200) ||\n                                     (seq").concat(n,'_running != lastRunningState);\n\n                if (shouldSeqDebug) {\n                    Serial.print("Seq').concat(n,': Step=");\n                    Serial.print(seq').concat(n,'_current_step + 1);\n                    Serial.print("/");\n                    Serial.print(seq').concat(n,"_active[seq").concat(n,'_current_step] ? "ACT" : "rest");\n                    Serial.print(" Bank=");\n                    Serial.print((seq').concat(n,'_current_step / 4) + 1);\n                    Serial.print(" Pitch=");\n                    Serial.print(seq').concat(n,'_pitch_sum, 3);\n                    Serial.print(" Gate=");\n                    Serial.print(seq').concat(n,'_gate_sum, 1);\n                    Serial.print(" Mode=");\n                    Serial.println(seq').concat(n,'_playback_mode == 0 ? "iter" : (seq').concat(n,'_playback_mode == 1 ? "rest" : "rev"));\n                    lastSeqDebugTime = currentTime;\n                }\n\n                lastPitchOutput = seq').concat(n,"_pitch_sum;\n                lastStepOutput = seq").concat(n,"_current_step;\n            } else {\n                seq").concat(n,"_pitch_sum = 0.0;\n                seq").concat(n,"_pitch_hz = 0.0;\n                seq").concat(n,"_gate_sum = 0.0;\n\n                // Debug when sequencer stops\n                if (seq").concat(n,'_running != lastRunningState) {\n                    Serial.println("Seq').concat(n,': STOPPED");\n                    lastSeqDebugTime = currentTime;\n                }\n            }\n\n            lastRunningState = seq').concat(n,"_running;\n\n            // Individual step outputs - each step gets its own pitch and gate\n            // Clear gate outputs only (pitch values persist from when step was last active)\n            seq").concat(n,"_gate_step1 = 0.0;\n            seq").concat(n,"_gate_step2 = 0.0;\n            seq").concat(n,"_gate_step3 = 0.0;\n            seq").concat(n,"_gate_step4 = 0.0;\n\n            // Update the output for the currently active step only\n            if (seq").concat(n,"_running && seq").concat(n,"_gate_active) {\n                float stepProbability = seq").concat(n,"_probability[seq").concat(n,"_current_step];\n                bool stepFires = ((float)random(0, 1000) / 1000.0) < stepProbability;\n\n                if (seq").concat(n,"_active[seq").concat(n,"_current_step] && stepFires) {\n                    // Calculate pitch and Hz for the current step\n                    float stepPitch = seq").concat(n,"_sampled_pitch;\n\n                    // Convert pitch to Hz using same logic as main output\n                    int octave_center = ").concat(e.params.octave_center||4,";\n                    float baseMidi = (octave_center * 12.0);\n                    float midiNote = baseMidi + (stepPitch * 13.0);\n                    float stepHz = 440.0 * pow(2.0, (midiNote - 69.0) / 12.0);\n\n                    // Get velocity for current step\n                    float stepVelocity = seq").concat(n,"_velocity[seq").concat(n,"_current_step];\n\n                    // Set outputs for the current step (1-indexed for outputs)\n                    switch (seq").concat(n,"_current_step) {\n                        case 0: // Step 1\n                            seq").concat(n,"_pitch_step1 = stepPitch;\n                            seq").concat(n,"_gate_step1 = 1.0;\n                            seq").concat(n,"_velocity_step1 = stepVelocity;\n                            seq").concat(n,"_pitch_step1_hz = stepHz;\n                            break;\n                        case 1: // Step 2\n                            seq").concat(n,"_pitch_step2 = stepPitch;\n                            seq").concat(n,"_gate_step2 = 1.0;\n                            seq").concat(n,"_velocity_step2 = stepVelocity;\n                            seq").concat(n,"_pitch_step2_hz = stepHz;\n                            break;\n                        case 2: // Step 3\n                            seq").concat(n,"_pitch_step3 = stepPitch;\n                            seq").concat(n,"_gate_step3 = 1.0;\n                            seq").concat(n,"_velocity_step3 = stepVelocity;\n                            seq").concat(n,"_pitch_step3_hz = stepHz;\n                            break;\n                        case 3: // Step 4\n                            seq").concat(n,"_pitch_step4 = stepPitch;\n                            seq").concat(n,"_gate_step4 = 1.0;\n                            seq").concat(n,"_velocity_step4 = stepVelocity;\n                            seq").concat(n,"_pitch_step4_hz = stepHz;\n                            break;\n                    }\n                }\n            }\n\n            // Status outputs\n            seq").concat(n,"_current_step_cv = seq").concat(n,"_current_step / 3.0; // 0-1 range (4 steps: 0/3, 1/3, 2/3, 3/3)\n            seq").concat(n,"_current_bank_cv = 0.0; // Fixed single bank - always 0\n        }\n")}},{key:"generateAutomationCode",value:function(e,n,t){for(var a=this,o=e.params.num_inputs||1,c="",r=function(o){var r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&n.to.port==="in_".concat(o)});if(r){var i=r.from.id.split(":")[0],l=a.connectionResolver.modules.find(function(e){return e.id===i});if(l){var s,u=(null===(s=i.match(/\d+$/))||void 0===s?void 0:s[0])||"1",d="0.0";switch(l.type){case"Pot":d="pot".concat(u,"_value");break;case"ADSR":d="adsr".concat(u,"_output");break;case"LFO":d="lfo".concat(u,"_output");break;case"LEDButton":var p=r.from.port||"value",f=l.params.index;d="btn".concat(f,"sampleOut"===p?"_sampleOut":"gate"===p?"_gate":"_output");break;case"Scale":d="scale".concat(u,"_output");break;case"HarmonicSequencer":var m=r.from.port||"cv1";d="pitch_norm"===m?"seq".concat(u,"_pitch_norm"):"pitch_sum"===m?"seq".concat(u,"_pitch_sum"):m.startsWith("cv")||m.startsWith("pitch_step")?"seq".concat(u,"_").concat(m):"seq".concat(u,"_cv1");break;case"Modulation":var _=r.from.port||"lfo1";d="mod".concat(u,"_").concat(_,"_output");break;case"VCA":d="vca".concat(u,"_outputL");break;case"Automation":var g=(r.from.port||"out_1").replace("out_","output_");d="automation".concat(u,"_").concat(g)}c+="            automation".concat(n,"_input_").concat(o," = ").concat(d,";\n")}}},i=1;i<=o;i++)r(i);for(var l="",s=1;s<=o;s++)l+="\n            // Channel ".concat(s," - Independent recording/playback\n            {\n                // Detect if channel is being moved during recording\n                if (recordTrigger && !automation").concat(n,"_last_record_trigger) {\n                    // Button just pressed - start monitoring for movement\n                    automation").concat(n,"_last_input_").concat(s," = automation").concat(n,"_input_").concat(s,";\n                }\n\n                // Recording mode for this channel\n                if (automation").concat(n,"_channel_").concat(s,"_recording) {\n                    // Check if channel is actually being moved\n                    float movement = abs(automation").concat(n,"_input_").concat(s," - automation").concat(n,"_last_input_").concat(s,");\n\n                    if (movement > automation").concat(n,"_movement_threshold || automation").concat(n,"_channel_").concat(s,"_length > 0) {\n                        // Channel is moving or already started - record it\n                        if (automation").concat(n,"_channel_").concat(s,"_position < automation").concat(n,"_buffer_size) {\n                            automation").concat(n,"_buffer_").concat(s,"[automation").concat(n,"_channel_").concat(s,"_position] = automation").concat(n,"_input_").concat(s,";\n                            automation").concat(n,"_channel_").concat(s,"_position++;\n                            automation").concat(n,"_channel_").concat(s,"_length = automation").concat(n,"_channel_").concat(s,"_position;\n                            // Debug: show recording progress every 50 samples\n                            if (automation").concat(n,"_channel_").concat(s,'_position % 50 == 1) {\n                                Serial.printf("DEBUG: Ch').concat(s,' recording... %d samples (movement=%.4f)\\n",\n                                    automation').concat(n,"_channel_").concat(s,"_position, movement);\n                            }\n                        }\n                    }\n\n                    automation").concat(n,"_last_input_").concat(s," = automation").concat(n,"_input_").concat(s,";\n\n                    // Pass through during recording\n                    automation").concat(n,"_output_").concat(s," = automation").concat(n,"_input_").concat(s,";\n                }\n                // Playback mode for this channel\n                else if (automation").concat(n,"_channel_").concat(s,"_playing && automation").concat(n,"_channel_").concat(s,"_length > 0) {\n                    // Touch detection - check if user moved this channel's control\n                    // BUT: Skip touch detection if encoder button is held (mode selection active)\n                    bool channelTouched = false;\n                    if (!automation").concat(n,"_mode_select && millis() - automation").concat(n,"_channel_").concat(s,"_start_time > automation").concat(n,"_touch_grace_ms) {\n                        float diff = abs(automation").concat(n,"_input_").concat(s," - automation").concat(n,"_last_input_").concat(s,");\n                        if (diff > automation").concat(n,'_touch_threshold) {\n                            Serial.printf("DEBUG: Channel ').concat(s,' TOUCHED - diff=%.3f\\n", diff);\n                            channelTouched = true;\n                        }\n                    }\n\n                    if (channelTouched) {\n                        // Stop playback for this channel, clear data, switch to pass-through\n                        automation').concat(n,"_channel_").concat(s,"_playing = false;\n                        automation").concat(n,"_channel_").concat(s,'_length = 0; // Clear so channel can be re-recorded\n                        Serial.printf("Automation ').concat(n," Channel ").concat(s,': Touch detected, cleared loop\\n");\n                    }\n\n\n                    if (automation').concat(n,"_channel_").concat(s,"_playing) {\n                        // Calculate playback position with mode transformation\n                        int readPosition = automation").concat(n,"_channel_").concat(s,"_position;\n\n                        switch (automation").concat(n,"_playback_mode) {\n                            case 0: // Normal\n                                readPosition = automation").concat(n,"_channel_").concat(s,"_position;\n                                break;\n                            case 1: // Reverse\n                                readPosition = automation").concat(n,"_channel_").concat(s,"_length - 1 - automation").concat(n,"_channel_").concat(s,"_position;\n                                break;\n                            case 2: // 2x speed\n                                readPosition = automation").concat(n,"_channel_").concat(s,"_position * 2;\n                                if (readPosition >= automation").concat(n,"_channel_").concat(s,"_length)\n                                    readPosition = automation").concat(n,"_channel_").concat(s,"_length - 1;\n                                break;\n                            case 3: // 0.5x speed\n                                readPosition = automation").concat(n,"_channel_").concat(s,"_position / 2;\n                                break;\n                            case 4: // Pingpong\n                                static bool automation").concat(n,"_channel_").concat(s,"_pingpong_forward = true;\n                                if (automation").concat(n,"_channel_").concat(s,"_pingpong_forward) {\n                                    readPosition = automation").concat(n,"_channel_").concat(s,"_position;\n                                } else {\n                                    readPosition = automation").concat(n,"_channel_").concat(s,"_length - 1 - automation").concat(n,"_channel_").concat(s,"_position;\n                                }\n                                break;\n                        }\n\n                        // Clamp position\n                        if (readPosition < 0) readPosition = 0;\n                        if (readPosition >= automation").concat(n,"_channel_").concat(s,"_length)\n                            readPosition = automation").concat(n,"_channel_").concat(s,"_length - 1;\n\n                        // Output from buffer\n                        automation").concat(n,"_output_").concat(s," = automation").concat(n,"_buffer_").concat(s,"[readPosition];\n\n                        // Advance position\n                        automation").concat(n,"_channel_").concat(s,"_position++;\n\n                        // Handle loop/stop\n                        int effectiveLength = automation").concat(n,"_channel_").concat(s,"_length;\n                        if (automation").concat(n,"_playback_mode == 2) effectiveLength /= 2;\n                        if (automation").concat(n,"_playback_mode == 3) effectiveLength *= 2;\n\n                        if (automation").concat(n,"_channel_").concat(s,"_position >= effectiveLength) {\n                            if (automation").concat(n,"_loop) {\n                                automation").concat(n,"_channel_").concat(s,"_position = 0;\n                            } else {\n                                automation").concat(n,"_channel_").concat(s,"_playing = false;\n                                automation").concat(n,"_channel_").concat(s,"_position = effectiveLength - 1;\n                            }\n                        }\n                    } else {\n                        // Touched - pass through\n                        automation").concat(n,"_output_").concat(s," = automation").concat(n,"_input_").concat(s,";\n                    }\n\n                    automation").concat(n,"_last_input_").concat(s," = automation").concat(n,"_input_").concat(s,";\n                }\n                // Idle mode - pass through\n                else {\n                    automation").concat(n,"_output_").concat(s," = automation").concat(n,"_input_").concat(s,";\n                }\n            }\n");return"\n        // Automation ".concat(n," - Independent Per-Channel Automation (").concat(o," channels)\n        {\n            // Read input values for all channels\n").concat(c,"\n            // Global recording trigger (button)\n            bool recordTrigger = automation").concat(n,"_record_trigger > 0.5;\n\n            // Rising edge: Start recording for moved channels (preserve playing channels)\n            if (recordTrigger && !automation").concat(n,'_last_record_trigger) {\n                Serial.println("Automation ').concat(n,': Button pressed - starting recording mode");\n                // Start recording mode for all channels (will filter by movement)\n                // Channels already playing are preserved\n').concat(this.generateChannelRecordingStart(n,o),"\n            }\n\n            // Falling edge: Stop recording, start playback for recorded channels\n            else if (!recordTrigger && automation").concat(n,"_last_record_trigger) {\n").concat(this.generateChannelRecordingStop(n,o),"\n            }\n\n            automation").concat(n,'_last_record_trigger = recordTrigger;\n\n            // MODE SELECTION: Encoder button + pot movement selects playback mode\n            // Works regardless of which channels are playing (global mode for all channels)\n            Serial.printf("DEBUG: mode_select=%d, input_1=%.3f\\n", automation').concat(n,"_mode_select, automation").concat(n,"_input_1);\n            if (automation").concat(n,"_mode_select) {\n                // Encoder button is held - use first input to select mode\n                // Map input 0.0-1.0 to modes: 0=normal, 1=reverse, 2=2x, 3=0.5x, 4=pingpong\n                automation").concat(n,"_selected_mode = (int)(automation").concat(n,"_input_1 * 4.99);\n                if (automation").concat(n,"_selected_mode != automation").concat(n,'_playback_mode) {\n                    const char* modeNames[] = {"Normal", "Reverse", "2x Speed", "0.5x Speed", "Pingpong"};\n                    Serial.printf("Automation ').concat(n,': Mode = %s\\n", modeNames[automation').concat(n,"_selected_mode]);\n                    automation").concat(n,"_playback_mode = automation").concat(n,"_selected_mode;\n                }\n            }\n\n").concat(l,"\n        }\n")}},{key:"generateStopAllChannels",value:function(e,n){for(var t="",a=1;a<=n;a++)t+="                automation".concat(e,"_channel_").concat(a,"_playing = false;\n");return t}},{key:"generateChannelRecordingStart",value:function(e,n){for(var t="",a=1;a<=n;a++)t+="                // Only reset channel ".concat(a," if it has no existing recording\n                if (automation").concat(e,"_channel_").concat(a,"_length == 0) {\n                    automation").concat(e,"_channel_").concat(a,"_recording = true;\n                    automation").concat(e,"_channel_").concat(a,"_playing = false;\n                    automation").concat(e,"_channel_").concat(a,"_position = 0;\n                } else {\n                    // Channel ").concat(a,' has existing data - keep it playing\n                    Serial.printf("Automation ').concat(e," Channel ").concat(a,': Preserving existing %d samples\\n", automation').concat(e,"_channel_").concat(a,"_length);\n                }\n");return t}},{key:"generateChannelRecordingStop",value:function(e,n){for(var t="",a=1;a<=n;a++)t+="                if (automation".concat(e,"_channel_").concat(a,"_recording) {\n                    automation").concat(e,"_channel_").concat(a,"_recording = false;\n                    if (automation").concat(e,"_channel_").concat(a,'_length > 0) {\n                        Serial.printf("Automation ').concat(e," Channel ").concat(a,': Recorded %d samples, starting playback\\n",\n                            automation').concat(e,"_channel_").concat(a,"_length);\n                        automation").concat(e,"_channel_").concat(a,"_playing = true;\n                        automation").concat(e,"_channel_").concat(a,"_position = 0;\n                        automation").concat(e,"_channel_").concat(a,"_start_time = millis();\n                        // Initialize last_input for touch detection\n                        automation").concat(e,"_last_input_").concat(a," = automation").concat(e,"_input_").concat(a,';\n                    } else {\n                        Serial.printf("Automation ').concat(e," Channel ").concat(a,': No movement detected\\n");\n                    }\n                }\n');return t}},{key:"generateArpeggiatorCode",value:function(e,n,t){var a,o,c=this,r="arp"+n+"_last_note_input",i="arp"+n+"_last_gate_input",l="0.8",s=null,u=null,d=null,p=null,f=null,m=null,_=null,g=null,h=null,v=null,b=Me(t);try{var y=function(){var n=a.value;if(n.to.id==="".concat(e.id,":note")){var t=n.from.id.split(":")[0],o=c.connectionResolver.modules.find(function(e){return e.id===t});if(o){var b,y=(null===(b=t.match(/\d+$/))||void 0===b?void 0:b[0])||"1";"MIDIIn"===o.type?(v=y,r="midiin".concat(y,"_note"),i="midiin".concat(y,"_gate ? 1.0f : 0.0f"),l="midiin".concat(y,"_velocity")):"USBMIDIIn"===o.type?(r="usbmidiin".concat(y,"_note"),i="usbmidiin".concat(y,"_gate ? 1.0f : 0.0f"),l="usbmidiin".concat(y,"_velocity")):"HarmonicSequencer"===o.type&&(r="seq".concat(y,"_pitch_sum"))}}if(n.to.id==="".concat(e.id,":gate")){var k=n.from.id.split(":")[0],x=c.connectionResolver.modules.find(function(e){return e.id===k});if(x){var S,E=(null===(S=k.match(/\d+$/))||void 0===S?void 0:S[0])||"1";"MIDIIn"===x.type?i="midiin".concat(E,"_gate ? 1.0f : 0.0f"):"USBMIDIIn"===x.type?i="usbmidiin".concat(E,"_gate ? 1.0f : 0.0f"):"Clock"===x.type?i="clock".concat(E,"_out1"):"LEDButton"===x.type&&(i="btn".concat(x.params.index,"_gate"))}}if(n.to.id==="".concat(e.id,":velocity")){var P=n.from.id.split(":")[0],w=c.connectionResolver.modules.find(function(e){return e.id===P});if(w){var C,I=(null===(C=P.match(/\d+$/))||void 0===C?void 0:C[0])||"1";"MIDIIn"===w.type?l="midiin".concat(I,"_velocity"):"USBMIDIIn"===w.type&&(l="usbmidiin".concat(I,"_velocity"))}}if(n.to.id==="".concat(e.id,":clock")){var R=n.from.id.split(":")[0],L=c.connectionResolver.modules.find(function(e){return e.id===R});if(L){var M,D=(null===(M=R.match(/\d+$/))||void 0===M?void 0:M[0])||"1";"Clock"===L.type?s="clock".concat(D,"_out1"):"MIDIIn"===L.type&&(s="midiin".concat(D,"_clock_tick"))}}if(n.to.id==="".concat(e.id,":rate")){var A=n.from.id.split(":")[0],O=c.connectionResolver.modules.find(function(e){return e.id===A});if(O){var B,T,F,N=(null===(B=A.match(/\d+$/))||void 0===B?void 0:B[0])||"1";if("Pot"===O.type)u="pot".concat((null===(T=O.params)||void 0===T?void 0:T.index)||N,"_value"),d=(null===(F=O.params)||void 0===F?void 0:F.bank)||1;else if("Modulation"===O.type){var z=n.from.id.split(":")[1]||"lfo1";u="mod".concat(N,"_").concat(z)}}}if(n.to.id==="".concat(e.id,":pattern")){var G=n.from.id.split(":")[0],q=c.connectionResolver.modules.find(function(e){return e.id===G});if(q){var U,W,V,H=(null===(U=G.match(/\d+$/))||void 0===U?void 0:U[0])||"1";if("Pot"===q.type)p="pot".concat((null===(W=q.params)||void 0===W?void 0:W.index)||H,"_value"),f=(null===(V=q.params)||void 0===V?void 0:V.bank)||1;else if("Modulation"===q.type){var j=n.from.id.split(":")[1]||"lfo1";p="mod".concat(H,"_").concat(j)}}}if(n.to.id==="".concat(e.id,":length")){var K=n.from.id.split(":")[0],Y=c.connectionResolver.modules.find(function(e){return e.id===K});if(Y){var $,X,Z,Q=(null===($=K.match(/\d+$/))||void 0===$?void 0:$[0])||"1";if("Pot"===Y.type)m="pot".concat((null===(X=Y.params)||void 0===X?void 0:X.index)||Q,"_value"),_=(null===(Z=Y.params)||void 0===Z?void 0:Z.bank)||1;else if("Modulation"===Y.type){var J=n.from.id.split(":")[1]||"lfo1";m="mod".concat(Q,"_").concat(J)}}}if(n.to.id==="".concat(e.id,":hold")){var ee=n.from.id.split(":")[0],ne=c.connectionResolver.modules.find(function(e){return e.id===ee});if(ne){var te,ae=(null===(te=ee.match(/\d+$/))||void 0===te?void 0:te[0])||"1";if("LEDButton"===ne.type){var oe,ce=(null===(oe=ne.params)||void 0===oe?void 0:oe.index)||ae;g="btn".concat(ce,"_state"),h=ce}else"Clock"===ne.type&&(g="clock".concat(ae,"_out1 > 0.5"))}}};for(b.s();!(a=b.n()).done;)y()}catch(e){b.e(e)}finally{b.f()}return s&&e.params.rate_mode,o=v?"\n            // Process all pending MIDI events from MIDIIn".concat(v," event queue (polyphonic)\n            // Hold mode: note-offs ignored, new chords replace current chord\n            // Track currently held keys to detect new chord vs adding to existing\n            static uint8_t arp").concat(n,"_held_keys[ARP").concat(n,"_MAX_NOTES]; // Keys physically held\n            static int arp").concat(n,"_held_count = 0;\n\n            while (midiin").concat(v,"_eventTail != midiin").concat(v,"_eventHead) {\n                MidiEvent1& event = midiin").concat(v,"_eventQueue[midiin").concat(v,"_eventTail];\n                midiin").concat(v,"_eventTail = (midiin").concat(v,"_eventTail + 1) % MIDIIN").concat(v,"_EVENT_QUEUE_SIZE;\n\n                uint8_t midiNote = event.note;\n                uint8_t velocity = event.velocity;\n\n                if (event.isNoteOn) {\n                    // Track held keys\n                    bool alreadyHeld = false;\n                    for (int i = 0; i < arp").concat(n,"_held_count; i++) {\n                        if (arp").concat(n,"_held_keys[i] == midiNote) { alreadyHeld = true; break; }\n                    }\n                    if (!alreadyHeld && arp").concat(n,"_held_count < ARP").concat(n,"_MAX_NOTES) {\n                        arp").concat(n,"_held_keys[arp").concat(n,"_held_count++] = midiNote;\n                    }\n\n                    // In hold mode: if this is first key after all released, clear arpeggio first\n                    bool holdActive = arp").concat(n,"_hold || arp").concat(n,"_hold_input;\n                    if (holdActive && arp").concat(n,"_held_count == 1) {\n                        // New chord starting - clear old notes\n                        arp").concat(n,"_note_count = 0;\n                        arp").concat(n,"_play_order_count = 0;\n                        arp").concat(n,"_current_step = 0;\n                    }\n\n                    // Add note to arpeggio\n                    if (arp").concat(n,"_note_count < ARP").concat(n,"_MAX_NOTES) {\n                        // Check if note already exists\n                        bool exists = false;\n                        for (int i = 0; i < arp").concat(n,"_note_count; i++) {\n                            if (arp").concat(n,"_notes[i] == midiNote) {\n                                exists = true;\n                                arp").concat(n,"_velocities[i] = velocity;\n                                break;\n                            }\n                        }\n                        if (!exists) {\n                            // Add note in sorted position (for up/down patterns)\n                            int insertPos = arp").concat(n,"_note_count;\n                            for (int i = 0; i < arp").concat(n,"_note_count; i++) {\n                                if (midiNote < arp").concat(n,"_notes[i]) {\n                                    insertPos = i;\n                                    break;\n                                }\n                            }\n                            // Shift notes up\n                            for (int i = arp").concat(n,"_note_count; i > insertPos; i--) {\n                                arp").concat(n,"_notes[i] = arp").concat(n,"_notes[i-1];\n                                arp").concat(n,"_velocities[i] = arp").concat(n,"_velocities[i-1];\n                            }\n                            arp").concat(n,"_notes[insertPos] = midiNote;\n                            arp").concat(n,"_velocities[insertPos] = velocity;\n                            arp").concat(n,"_note_count++;\n\n                            // Also add to play order (for as-played pattern)\n                            if (arp").concat(n,"_play_order_count < ARP").concat(n,"_MAX_NOTES) {\n                                arp").concat(n,"_play_order[arp").concat(n,"_play_order_count++] = midiNote;\n                            }\n\n                            // Start playing if we have notes\n                            if (!arp").concat(n,"_playing && arp").concat(n,"_note_count > 0) {\n                                arp").concat(n,"_playing = true;\n                                arp").concat(n,"_current_step = 0;\n                                arp").concat(n,"_current_octave = 0;\n                                arp").concat(n,"_direction = 1;\n                            }\n                        }\n                    }\n                } else {\n                    // Handle note off\n                    // Always update held keys tracking\n                    for (int i = 0; i < arp").concat(n,"_held_count; i++) {\n                        if (arp").concat(n,"_held_keys[i] == midiNote) {\n                            for (int j = i; j < arp").concat(n,"_held_count - 1; j++) {\n                                arp").concat(n,"_held_keys[j] = arp").concat(n,"_held_keys[j+1];\n                            }\n                            arp").concat(n,"_held_count--;\n                            break;\n                        }\n                    }\n\n                    // In hold mode: ignore note-offs for arpeggio\n                    // Notes stay until replaced by new chord or hold is disengaged\n                    bool holdActive = arp").concat(n,"_hold || arp").concat(n,"_hold_input;\n                    if (holdActive) continue;\n\n                    // Normal mode: remove note from arpeggio\n                    for (int i = 0; i < arp").concat(n,"_note_count; i++) {\n                        if (arp").concat(n,"_notes[i] == midiNote) {\n                            for (int j = i; j < arp").concat(n,"_note_count - 1; j++) {\n                                arp").concat(n,"_notes[j] = arp").concat(n,"_notes[j+1];\n                                arp").concat(n,"_velocities[j] = arp").concat(n,"_velocities[j+1];\n                            }\n                            arp").concat(n,"_note_count--;\n                            break;\n                        }\n                    }\n                    // Also remove from play order\n                    for (int i = 0; i < arp").concat(n,"_play_order_count; i++) {\n                        if (arp").concat(n,"_play_order[i] == midiNote) {\n                            for (int j = i; j < arp").concat(n,"_play_order_count - 1; j++) {\n                                arp").concat(n,"_play_order[j] = arp").concat(n,"_play_order[j+1];\n                            }\n                            arp").concat(n,"_play_order_count--;\n                            break;\n                        }\n                    }\n                    // Stop if no notes left\n                    if (arp").concat(n,"_note_count == 0) {\n                        arp").concat(n,"_playing = false;\n                        arp").concat(n,"_out_gate = 0.0;\n                    }\n                }\n            }"):"\n            // Mono mode note detection (for non-MIDIIn sources)\n            bool noteOn = (gateInput > 0.5) && (arp".concat(n,"_last_gate_input <= 0.5);\n            bool noteOff = (gateInput <= 0.5) && (arp").concat(n,"_last_gate_input > 0.5);\n            uint8_t midiNote = (uint8_t)(48.0 + noteInput * 48.0); // Convert 0-1 to MIDI note 48-96\n            uint8_t velocity = (uint8_t)(velocityInput * 127.0);\n\n            // Handle note on - add to arpeggio\n            if (noteOn && arp").concat(n,"_note_count < ARP").concat(n,"_MAX_NOTES) {\n                // Check if note already exists\n                bool exists = false;\n                for (int i = 0; i < arp").concat(n,"_note_count; i++) {\n                    if (arp").concat(n,"_notes[i] == midiNote) {\n                        exists = true;\n                        arp").concat(n,"_velocities[i] = velocity;\n                        break;\n                    }\n                }\n                if (!exists) {\n                    // Add note in sorted position (for up/down patterns)\n                    int insertPos = arp").concat(n,"_note_count;\n                    for (int i = 0; i < arp").concat(n,"_note_count; i++) {\n                        if (midiNote < arp").concat(n,"_notes[i]) {\n                            insertPos = i;\n                            break;\n                        }\n                    }\n                    // Shift notes up\n                    for (int i = arp").concat(n,"_note_count; i > insertPos; i--) {\n                        arp").concat(n,"_notes[i] = arp").concat(n,"_notes[i-1];\n                        arp").concat(n,"_velocities[i] = arp").concat(n,"_velocities[i-1];\n                    }\n                    arp").concat(n,"_notes[insertPos] = midiNote;\n                    arp").concat(n,"_velocities[insertPos] = velocity;\n                    arp").concat(n,"_note_count++;\n\n                    // Also add to play order (for as-played pattern)\n                    if (arp").concat(n,"_play_order_count < ARP").concat(n,"_MAX_NOTES) {\n                        arp").concat(n,"_play_order[arp").concat(n,"_play_order_count++] = midiNote;\n                    }\n\n                    // Start playing if we have notes\n                    if (!arp").concat(n,"_playing && arp").concat(n,"_note_count > 0) {\n                        arp").concat(n,"_playing = true;\n                        arp").concat(n,"_current_step = 0;\n                        arp").concat(n,"_current_octave = 0;\n                        arp").concat(n,"_direction = 1;\n                    }\n                }\n            }\n\n            // Handle note off - remove from arpeggio (unless hold mode)\n            if (noteOff && !holdActive) {\n                for (int i = 0; i < arp").concat(n,"_note_count; i++) {\n                    if (arp").concat(n,"_notes[i] == midiNote) {\n                        for (int j = i; j < arp").concat(n,"_note_count - 1; j++) {\n                            arp").concat(n,"_notes[j] = arp").concat(n,"_notes[j+1];\n                            arp").concat(n,"_velocities[j] = arp").concat(n,"_velocities[j+1];\n                        }\n                        arp").concat(n,"_note_count--;\n                        break;\n                    }\n                }\n                // Also remove from play order\n                for (int i = 0; i < arp").concat(n,"_play_order_count; i++) {\n                    if (arp").concat(n,"_play_order[i] == midiNote) {\n                        for (int j = i; j < arp").concat(n,"_play_order_count - 1; j++) {\n                            arp").concat(n,"_play_order[j] = arp").concat(n,"_play_order[j+1];\n                        }\n                        arp").concat(n,"_play_order_count--;\n                        break;\n                    }\n                }\n                // Stop if no notes left\n                if (arp").concat(n,"_note_count == 0) {\n                    arp").concat(n,"_playing = false;\n                    arp").concat(n,"_out_gate = 0.0;\n                }\n            }\n\n            // Update input tracking\n            arp").concat(n,"_last_note_input = noteInput;\n            arp").concat(n,"_last_gate_input = gateInput;"),"\n        // Arpeggiator ".concat(n," processing\n        {\n            // Read inputs from connections\n            float noteInput = ").concat(r,";\n            float gateInput = ").concat(i,";\n            float velocityInput = ").concat(l,";\n").concat(s?"            arp".concat(n,"_clock_pulse = ").concat(s,";"):"","\n").concat(s||"sync"!==e.params.rate_mode?"":"            arp".concat(n,"_sync_mode = false; // No clock connected, force free-running mode"),"\n").concat(u?"\n            // Rate CV input: 0-1 maps to 0.5-20 Hz (exponential for musical feel)\n            ".concat(d?"if (currentBank == ".concat(d,") {"):"","\n            float rateCV = ").concat(u,";\n            arp").concat(n,"_rate_hz = 0.5 + rateCV * rateCV * 19.5; // Quadratic curve: 0.5Hz at 0, ~20Hz at 1\n            ").concat(d?"}":"","\n"):"","\n").concat(p?"\n            // Pattern CV input: 0-1 maps to patterns 0-5\n            ".concat(f?"if (currentBank == ".concat(f,") {"):"","\n            float patternCV = ").concat(p,";\n            arp").concat(n,"_pattern = (int)(patternCV * 5.99); // 0=up, 1=down, 2=updown, 3=downup, 4=random, 5=asplayed\n            if (arp").concat(n,"_pattern > 5) arp").concat(n,"_pattern = 5;\n            ").concat(f?"}":"","\n"):"","\n").concat(m?"\n            // Length/duty cycle CV input: 0-1 maps to gate length 0.1-1.0 (10%-100%)\n            ".concat(_?"if (currentBank == ".concat(_,") {"):"","\n            float lengthCV = ").concat(m,";\n            arp").concat(n,"_gate_length = 0.1 + lengthCV * 0.9; // 10% at 0, 100% at 1\n            ").concat(_?"}":"","\n"):"","\n").concat(g?"\n            // Hold button: short press toggles hold mode on/off\n            // LED solid when hold is active, off when inactive\n            static bool arp".concat(n,"_hold_btn_last = false;\n            bool arp").concat(n,"_hold_btn_current = ").concat(g,";\n\n            // Falling edge - toggle hold on button release\n            if (!arp").concat(n,"_hold_btn_current && arp").concat(n,"_hold_btn_last) {\n                arp").concat(n,"_hold_input = !arp").concat(n,"_hold_input;\n                // When turning OFF hold, clear all latched notes and stop\n                if (!arp").concat(n,"_hold_input) {\n                    arp").concat(n,"_note_count = 0;\n                    arp").concat(n,"_play_order_count = 0;\n                    arp").concat(n,"_playing = false;\n                    arp").concat(n,"_out_gate = 0.0;\n                }\n            }\n            arp").concat(n,"_hold_btn_last = arp").concat(n,"_hold_btn_current;\n").concat(h?"\n            // LED feedback: solid when hold is active\n            btn".concat(h,"_ledState = arp").concat(n,"_hold_input;"):"","\n"):"","\n\n            // Clock/rate handling\n            bool clockEdge = false;\n            if (arp").concat(n,"_sync_mode) {\n                // Sync to external clock - check for rising edge\n                bool currentClock = (arp").concat(n,"_clock_pulse > 0.5);\n                if (currentClock && !arp").concat(n,"_last_clock) {\n                    arp").concat(n,"_clock_counter++;\n                    if (arp").concat(n,"_clock_counter >= arp").concat(n,"_clock_div) {\n                        arp").concat(n,"_clock_counter = 0;\n                        clockEdge = true;\n                    }\n                }\n                arp").concat(n,"_last_clock = currentClock;\n            } else {\n                // Free-running rate\n                unsigned long now = millis();\n                if (now - arp").concat(n,"_last_step_time >= arp").concat(n,"_step_interval_ms) {\n                    // Apply swing on even steps\n                    float swingOffset = 0.0;\n                    if (arp").concat(n,"_current_step % 2 == 1) {\n                        swingOffset = arp").concat(n,"_step_interval_ms * arp").concat(n,"_swing;\n                    }\n                    if (now - arp").concat(n,"_last_step_time >= arp").concat(n,"_step_interval_ms + swingOffset) {\n                        arp").concat(n,"_last_step_time = now;\n                        clockEdge = true;\n                    }\n                }\n                // Update step interval from rate\n                arp").concat(n,"_step_interval_ms = 1000.0 / arp").concat(n,"_rate_hz;\n            }\n\n            // Process MIDI note on/off events\n            bool holdActive = arp").concat(n,"_hold || arp").concat(n,"_hold_input;\n").concat(o,"\n\n            // Step sequencer on clock edge\n            if (clockEdge && arp").concat(n,"_playing && arp").concat(n,"_note_count > 0) {\n                // Get note based on pattern\n                int noteIndex = 0;\n                int totalNotes = arp").concat(n,"_note_count * arp").concat(n,"_octaves;\n\n                switch (arp").concat(n,"_pattern) {\n                    case 0: // Up\n                        noteIndex = arp").concat(n,"_current_step % arp").concat(n,"_note_count;\n                        arp").concat(n,"_current_octave = (arp").concat(n,"_current_step / arp").concat(n,"_note_count) % arp").concat(n,"_octaves;\n                        break;\n                    case 1: // Down\n                        noteIndex = (arp").concat(n,"_note_count - 1) - (arp").concat(n,"_current_step % arp").concat(n,"_note_count);\n                        arp").concat(n,"_current_octave = (arp").concat(n,"_octaves - 1) - ((arp").concat(n,"_current_step / arp").concat(n,"_note_count) % arp").concat(n,"_octaves);\n                        break;\n                    case 2: // Up-Down\n                        {\n                            int cycleLength = (arp").concat(n,"_note_count * 2) - 2;\n                            if (cycleLength < 1) cycleLength = 1;\n                            int pos = arp").concat(n,"_current_step % cycleLength;\n                            if (pos < arp").concat(n,"_note_count) {\n                                noteIndex = pos;\n                                arp").concat(n,"_direction = 1;\n                            } else {\n                                noteIndex = cycleLength - pos;\n                                arp").concat(n,"_direction = -1;\n                            }\n                        }\n                        break;\n                    case 3: // Down-Up\n                        {\n                            int cycleLength = (arp").concat(n,"_note_count * 2) - 2;\n                            if (cycleLength < 1) cycleLength = 1;\n                            int pos = arp").concat(n,"_current_step % cycleLength;\n                            if (pos < arp").concat(n,"_note_count) {\n                                noteIndex = (arp").concat(n,"_note_count - 1) - pos;\n                                arp").concat(n,"_direction = -1;\n                            } else {\n                                noteIndex = pos - arp").concat(n,"_note_count + 1;\n                                arp").concat(n,"_direction = 1;\n                            }\n                        }\n                        break;\n                    case 4: // Random\n                        noteIndex = random(0, arp").concat(n,"_note_count);\n                        arp").concat(n,"_current_octave = random(0, arp").concat(n,"_octaves);\n                        break;\n                    case 5: // As-played\n                        if (arp").concat(n,"_play_order_count > 0) {\n                            uint8_t playNote = arp").concat(n,"_play_order[arp").concat(n,"_current_step % arp").concat(n,"_play_order_count];\n                            // Find this note in the sorted array to get velocity\n                            for (int i = 0; i < arp").concat(n,"_note_count; i++) {\n                                if (arp").concat(n,"_notes[i] == playNote) {\n                                    noteIndex = i;\n                                    break;\n                                }\n                            }\n                        }\n                        break;\n                }\n\n                // Get the note and apply octave offset\n                uint8_t outNote = arp").concat(n,"_notes[noteIndex] + (arp").concat(n,"_current_octave * 12);\n                uint8_t outVelocity = arp").concat(n,"_velocities[noteIndex];\n\n                // Apply velocity mode\n                switch (arp").concat(n,"_velocity_mode) {\n                    case 1: // Fixed\n                        outVelocity = arp").concat(n,"_fixed_velocity;\n                        break;\n                    case 2: // Accent\n                        if (arp").concat(n,"_current_step % 4 == 0) {\n                            outVelocity = min(127, (int)(outVelocity * arp").concat(n,"_accent_amount));\n                        }\n                        break;\n                }\n\n                // Set outputs\n                arp").concat(n,"_out_note = (outNote - 48.0) / 48.0; // Convert to 0-1 range\n                arp").concat(n,"_out_velocity = outVelocity / 127.0;\n                arp").concat(n,"_out_gate = 1.0;\n                arp").concat(n,"_gate_start = millis();\n                arp").concat(n,"_gate_active = true;\n                // Capture gate duration at note start (not dynamically) to prevent timing glitches\n                arp").concat(n,"_gate_duration_ms = arp").concat(n,"_step_interval_ms * arp").concat(n,"_gate_length;\n\n                // Advance step\n                arp").concat(n,"_current_step++;\n                if (arp").concat(n,"_current_step >= totalNotes) {\n                    arp").concat(n,"_current_step = 0;\n                }\n            }\n\n            // Handle gate off timing - use pre-calculated duration\n            if (arp").concat(n,"_gate_active) {\n                if (millis() - arp").concat(n,"_gate_start >= arp").concat(n,"_gate_duration_ms) {\n                    arp").concat(n,"_out_gate = 0.0;\n                    arp").concat(n,"_gate_active = false;\n                }\n            }\n        }\n")}},{key:"generateMIDILooperCode",value:function(e,n,t){var a,o=this,c=e.params.bank||1,r="0.0",i="0.0",l="1.0",s=null,u=!1,d=null,p="internal",f=Me(t);try{var m=function(){var n=a.value;if(n.to.id==="".concat(e.id,":note")){var t=n.from.id.split(":")[0],c=(n.from.port,o.connectionResolver.modules.find(function(e){return e.id===t}));if(c){var f,m=(null===(f=t.match(/\d+$/))||void 0===f?void 0:f[0])||"1";"MIDIIn"===c.type?(r="midiin".concat(m,"_note"),i="midiin".concat(m,"_gate ? 1.0f : 0.0f"),l="midiin".concat(m,"_velocity"),d=m):"Arpeggiator"===c.type?r="arp".concat(m,"_out_note"):"HarmonicSequencer"===c.type&&(r="seq".concat(m,"_pitch_sum"))}}if(n.to.id==="".concat(e.id,":gate")){var _=n.from.id.split(":")[0],g=o.connectionResolver.modules.find(function(e){return e.id===_});if(g){var h,v=(null===(h=_.match(/\d+$/))||void 0===h?void 0:h[0])||"1";"MIDIIn"===g.type?i="midiin".concat(v,"_gate ? 1.0f : 0.0f"):"Clock"===g.type&&(i="clock".concat(v,"_out1"))}}if(n.to.id==="".concat(e.id,":velocity")){var b=n.from.id.split(":")[0],y=o.connectionResolver.modules.find(function(e){return e.id===b});if(y){var k,x=(null===(k=b.match(/\d+$/))||void 0===k?void 0:k[0])||"1";"MIDIIn"===y.type&&(l="midiin".concat(x,"_velocity"))}}if(n.to.id==="".concat(e.id,":clock")){var S=n.from.id.split(":")[0],E=(n.from.port,o.connectionResolver.modules.find(function(e){return e.id===S}));if(E){var P,w=(null===(P=S.match(/\d+$/))||void 0===P?void 0:P[0])||"1";u=!0,"Clock"===E.type?(s="clock".concat(w,"_tick96"),p="clock_module"):"MIDIIn"===E.type&&(s="midiin".concat(w,"_clock_tick"),p="midi")}}};for(f.s();!(a=f.n()).done;)m()}catch(e){f.e(e)}finally{f.f()}var _=d&&!u;return"\n        // MIDI Looper ".concat(n," processing (Bank ").concat(c,")\n        // Btn1=state/clear, Btn2=scale-lock | Pot1=velocity, Pot2=transpose, Pot3=timing rand, Pot4=pitch rand\n        // Clock: ").concat("internal"===p?_?"Internal (auto-sync to MIDI clock if present)":"Internal only":"midi"===p?"MIDI clock (24PPQ with fallback)":"Clock module (96PPQ)","\n\n        // Read buttons from MCP23017 (rate-limited to avoid I2S interference)\n        {\n            static unsigned long midiloop").concat(n,"_lastBtnRead = 0;\n            if (millis() - midiloop").concat(n,"_lastBtnRead > 20) { // Read every 20ms\n                midiloop").concat(n,"_lastBtnRead = millis();\n                uint16_t mcpInputs = mcp.readGPIOAB();\n                btn1_state = !(mcpInputs & (1 << 2)); // GPA2 - active low (v1.0 mapping)\n                btn2_state = !(mcpInputs & (1 << 1)); // GPA1 - active low\n                btn3_state = !(mcpInputs & (1 << 0)); // GPA0 - active low\n                btn4_state = !(mcpInputs & (1 << 3)); // GPA3 - active low\n            }\n        }\n\n        // Read pots and apply soft takeover (rate-limited)\n        {\n            static unsigned long midiloop").concat(n,"_lastPotRead = 0;\n            static bool midiloop").concat(n,"_firstBankEntry = true;\n\n            if (currentBank == MIDILOOP").concat(n,"_BANK && millis() - midiloop").concat(n,"_lastPotRead > 10) {\n                midiloop").concat(n,"_lastPotRead = millis();\n\n                // Read pots (GPIO4-7)\n                float pot_raw[4];\n                pot_raw[0] = analogRead(4) / 4095.0f;\n                pot_raw[1] = analogRead(5) / 4095.0f;\n                pot_raw[2] = analogRead(6) / 4095.0f;\n                pot_raw[3] = analogRead(7) / 4095.0f;\n\n                // First time entering this bank - initialize to physical position immediately\n                if (midiloop").concat(n,"_firstBankEntry) {\n                    pot1_value = pot_raw[0];\n                    pot2_value = pot_raw[1];\n                    pot3_value = pot_raw[2];\n                    pot4_value = pot_raw[3];\n                    pot1_physical = pot_raw[0];\n                    pot2_physical = pot_raw[1];\n                    pot3_physical = pot_raw[2];\n                    pot4_physical = pot_raw[3];\n                    pot1_taken_over = true;\n                    pot2_taken_over = true;\n                    pot3_taken_over = true;\n                    pot4_taken_over = true;\n                    midiloop").concat(n,"_firstBankEntry = false;\n                } else {\n                    // Smooth physical readings\n                    const float smooth_factor = 0.8f;\n                    pot1_physical = pot1_physical * smooth_factor + pot_raw[0] * (1.0f - smooth_factor);\n                    pot2_physical = pot2_physical * smooth_factor + pot_raw[1] * (1.0f - smooth_factor);\n                    pot3_physical = pot3_physical * smooth_factor + pot_raw[2] * (1.0f - smooth_factor);\n                    pot4_physical = pot4_physical * smooth_factor + pot_raw[3] * (1.0f - smooth_factor);\n\n                    // Soft takeover: update value when physical pot crosses within threshold\n                    const float takeover_threshold = 0.03f;\n                    if (pot1_taken_over || fabs(pot1_physical - pot1_value) < takeover_threshold) {\n                        pot1_value = pot1_physical;\n                        pot1_taken_over = true;\n                    }\n                    if (pot2_taken_over || fabs(pot2_physical - pot2_value) < takeover_threshold) {\n                        pot2_value = pot2_physical;\n                        pot2_taken_over = true;\n                    }\n                    if (pot3_taken_over || fabs(pot3_physical - pot3_value) < takeover_threshold) {\n                        pot3_value = pot3_physical;\n                        pot3_taken_over = true;\n                    }\n                    if (pot4_taken_over || fabs(pot4_physical - pot4_value) < takeover_threshold) {\n                        pot4_value = pot4_physical;\n                        pot4_taken_over = true;\n                    }\n                }\n            } else if (currentBank != MIDILOOP").concat(n,"_BANK) {\n                midiloop").concat(n,"_firstBankEntry = true;  // Reset for next bank entry\n            }\n        }\n\n        if (currentBank == MIDILOOP").concat(n,"_BANK) {\n            // === AUTO-MAPPED HARDWARE (only in this bank) ===\n\n            // Copy button states (already read above)\n            midiloop").concat(n,"_btn1_state = btn1_state;   // Btn1: state cycle + long-hold clear\n            midiloop").concat(n,"_btn2_state = btn2_state;   // Btn2: scale-lock modifier\n\n            // Read pots (already updated above with soft takeover)\n            midiloop").concat(n,"_velocity_scale = pot1_value;     // Pot1: velocity 0-1\n            midiloop").concat(n,"_timing_random = pot3_value;      // Pot3: timing randomization 0-1\n            midiloop").concat(n,"_pitch_random = pot4_value;       // Pot4: pitch randomization 0-1\n\n            // === TRANSPOSE CONTROL (Pot2 + Btn2 modifier) ===\n            int pot2_raw = (int)(pot2_value * 48.0);  // 0-48 range\n            midiloop").concat(n,"_scale_lock = midiloop").concat(n,"_btn2_state;  // Btn2 held = scale-step mode\n\n            if (midiloop").concat(n,"_scale_lock) {\n                // Scale-step mode: -7 to +7 scale degrees\n                int scaleDegree = (int)(pot2_value * 14.0) - 7;\n                // Convert scale degree to semitones using detected key\n                const int majorScale[7] = {0, 2, 4, 5, 7, 9, 11};\n                const int minorScale[7] = {0, 2, 3, 5, 7, 8, 10};\n                const int* scale = midiloop").concat(n,"_detected_minor ? minorScale : majorScale;\n\n                if (scaleDegree >= 0) {\n                    int octaves = scaleDegree / 7;\n                    int degree = scaleDegree % 7;\n                    midiloop").concat(n,"_transpose = octaves * 12 + scale[degree];\n                } else {\n                    int absD = -scaleDegree;\n                    int octaves = (absD - 1) / 7 + 1;\n                    int degree = 7 - ((absD - 1) % 7) - 1;\n                    midiloop").concat(n,"_transpose = -octaves * 12 + scale[degree];\n                }\n            } else {\n                // Chromatic mode: -24 to +24 semitones\n                midiloop").concat(n,"_transpose = pot2_raw - 24;\n            }\n\n            // === BUTTON 1 STATE MACHINE ===\n            bool btn1_rising = midiloop").concat(n,"_btn1_state && !midiloop").concat(n,"_btn1_last;\n            bool btn1_falling = !midiloop").concat(n,"_btn1_state && midiloop").concat(n,"_btn1_last;\n\n            if (btn1_rising) {\n                midiloop").concat(n,"_btn1_press_time = millis();\n            }\n\n            if (btn1_falling) {\n                unsigned long holdTime = millis() - midiloop").concat(n,"_btn1_press_time;\n\n                if (holdTime >= 500) {\n                    // Long hold: CLEAR loop\n                    midiloop").concat(n,"_event_count = 0;\n                    midiloop").concat(n,"_state = 0;  // Armed\n                    midiloop").concat(n,"_playhead = 0;\n                    midiloop").concat(n,"_out_playing = 0.0;\n                    midiloop").concat(n,"_out_recording = 0.0;\n                    for (int i = 0; i < 12; i++) midiloop").concat(n,"_pitch_histogram[i] = 0;\n                } else {\n                    // Short tap: cycle state\n                    switch (midiloop").concat(n,"_state) {\n                        case 0: // Armed -> Count-in (or direct record if no count-in)\n                            if (midiloop").concat(n,"_count_in_bars > 0) {\n                                midiloop").concat(n,"_state = 1;\n                                midiloop").concat(n,"_count_in_tick = 0;\n                            } else {\n                                midiloop").concat(n,"_state = 2;\n                                midiloop").concat(n,"_playhead = 0;\n                                midiloop").concat(n,"_out_recording = 1.0;\n                            }\n                            break;\n                        case 1: // Count-in -> Skip to record\n                            midiloop").concat(n,"_state = 2;\n                            midiloop").concat(n,"_playhead = 0;\n                            midiloop").concat(n,"_out_recording = 1.0;\n                            break;\n                        case 2: // Recording -> Playing\n                            midiloop").concat(n,"_state = 3;\n                            midiloop").concat(n,"_out_recording = 0.0;\n                            midiloop").concat(n,"_out_playing = 1.0;\n                            break;\n                        case 3: // Playing -> Overdub\n                            midiloop").concat(n,"_state = 4;\n                            midiloop").concat(n,"_out_recording = 1.0;\n                            break;\n                        case 4: // Overdub -> Playing\n                            midiloop").concat(n,"_state = 3;\n                            midiloop").concat(n,"_out_recording = 0.0;\n                            break;\n                        case 5: // Stopped -> Armed\n                            midiloop").concat(n,"_state = 0;\n                            break;\n                    }\n                }\n            }\n            midiloop").concat(n,"_btn1_last = midiloop").concat(n,"_btn1_state;\n            // Note: LED feedback is now handled in updateNeoPixels() to avoid being cleared\n        }\n\n        // === CLOCK AND PLAYBACK (runs regardless of bank) ===\n        {\n            // Update inputs from connections\n            midiloop").concat(n,"_note_input = ").concat(r,";\n            midiloop").concat(n,"_gate_input = ").concat(i,";\n            // Only update velocity on note-on (gate rising edge) to preserve last velocity\n            if (midiloop").concat(n,"_gate_input > 0.5 && !midiloop").concat(n,"_last_gate) {\n                midiloop").concat(n,"_velocity_input = ").concat(l,";\n            }\n").concat("internal"!==p||_?"internal"===p&&_?"\n            // Internal clock by default, auto-sync to MIDI clock if present\n            bool clockEdge = false;\n            int ticksPerPulse = 1;  // Default: internal 96 PPQ\n\n            // Check for optional MIDI clock sync from MIDIIn\n            float optionalMidiClock = midiin".concat(d,"_clock_tick;\n            bool midiClockTick = (optionalMidiClock > 0.5);\n\n            if (midiClockTick && !midiloop").concat(n,"_last_clock) {\n                // MIDI clock received - sync to it\n                clockEdge = true;\n                ticksPerPulse = 4;  // MIDI 24PPQ  96PPQ\n                midiloop").concat(n,"_last_ext_clock_time = millis();\n                midiloop").concat(n,"_using_internal_clock = false;\n            }\n            midiloop").concat(n,"_last_clock = midiClockTick;\n\n            // Use internal clock when no MIDI clock present\n            if (!clockEdge) {\n                if (midiloop").concat(n,"_using_internal_clock ||\n                    millis() - midiloop").concat(n,"_last_ext_clock_time > MIDILOOP").concat(n,"_EXT_CLOCK_TIMEOUT) {\n                    midiloop").concat(n,"_using_internal_clock = true;\n                    // Process multiple ticks per control cycle to maintain proper tempo\n                    unsigned long now_us = micros();\n                    int ticksToProcess = 0;\n                    while (now_us - midiloop").concat(n,"_last_internal_tick_us >= MIDILOOP").concat(n,"_TICK_INTERVAL_US) {\n                        midiloop").concat(n,"_last_internal_tick_us += MIDILOOP").concat(n,"_TICK_INTERVAL_US;\n                        ticksToProcess++;\n                        if (ticksToProcess >= 4) break;  // Cap at 4 ticks per cycle\n                    }\n                    if (ticksToProcess > 0) {\n                        clockEdge = true;\n                        ticksPerPulse = ticksToProcess;\n                    }\n                }\n            }"):"midi"===p?"\n            // MIDI clock connected - sync to external, fallback to internal\n            midiloop".concat(n,"_clock_input = ").concat(s,";\n\n            bool clockEdge = false;\n            int ticksPerPulse = 4;  // MIDI 24PPQ  96PPQ\n\n            // Check for external MIDI clock\n            bool currentClock = (midiloop").concat(n,"_clock_input > 0.5);\n            if (currentClock && !midiloop").concat(n,"_last_clock) {\n                clockEdge = true;\n                midiloop").concat(n,"_last_ext_clock_time = millis();\n                midiloop").concat(n,"_using_internal_clock = false;\n            }\n            midiloop").concat(n,"_last_clock = currentClock;\n\n            // Fallback to internal clock if no MIDI clock received for 500ms\n            if (!clockEdge) {\n                if (millis() - midiloop").concat(n,"_last_ext_clock_time > MIDILOOP").concat(n,"_EXT_CLOCK_TIMEOUT) {\n                    midiloop").concat(n,"_using_internal_clock = true;\n                    // Process multiple ticks per control cycle to maintain proper tempo\n                    unsigned long now_us = micros();\n                    int ticksToProcess = 0;\n                    while (now_us - midiloop").concat(n,"_last_internal_tick_us >= MIDILOOP").concat(n,"_TICK_INTERVAL_US) {\n                        midiloop").concat(n,"_last_internal_tick_us += MIDILOOP").concat(n,"_TICK_INTERVAL_US;\n                        ticksToProcess++;\n                        if (ticksToProcess >= 4) break;  // Cap at 4 ticks per cycle\n                    }\n                    if (ticksToProcess > 0) {\n                        clockEdge = true;\n                        ticksPerPulse = ticksToProcess;\n                    }\n                }\n            }"):"\n            // Clock module connected - sync to external clock\n            midiloop".concat(n,"_clock_input = ").concat(s,";\n\n            bool clockEdge = false;\n            int ticksPerPulse = 1;  // Clock module outputs 96 PPQ\n\n            // Check for clock module tick\n            bool currentClock = (midiloop").concat(n,"_clock_input > 0.5);\n            if (currentClock && !midiloop").concat(n,"_last_clock) {\n                clockEdge = true;\n            }\n            midiloop").concat(n,"_last_clock = currentClock;"):"\n            // No external clock connected - use internal clock only\n            // Process multiple ticks per control cycle to maintain proper tempo\n            // (control runs at 100Hz = 10ms, but 100 BPM needs 160 ticks/sec = 6.25ms/tick)\n            unsigned long now_us = micros();\n            int ticksToProcess = 0;\n\n            while (now_us - midiloop".concat(n,"_last_internal_tick_us >= MIDILOOP").concat(n,"_TICK_INTERVAL_US) {\n                midiloop").concat(n,"_last_internal_tick_us += MIDILOOP").concat(n,"_TICK_INTERVAL_US;\n                ticksToProcess++;\n                if (ticksToProcess >= 4) break;  // Cap at 4 ticks per cycle to prevent runaway\n            }\n\n            bool clockEdge = (ticksToProcess > 0);\n            int ticksPerPulse = ticksToProcess;  // Process all accumulated ticks"),"\n\n            // Process clock tick (advance by ticksPerPulse for MIDI clock compatibility)\n            if (clockEdge) {\n                for (int tickStep = 0; tickStep < ticksPerPulse; tickStep++) {\n                    switch (midiloop").concat(n,"_state) {\n                        case 1: // Count-in\n                            midiloop").concat(n,"_count_in_tick++;\n                            if (midiloop").concat(n,"_count_in_tick >= midiloop").concat(n,"_count_in_bars * 4 * MIDILOOP").concat(n,"_PPQ) {\n                                midiloop").concat(n,"_state = 2;\n                                midiloop").concat(n,"_playhead = 0;\n                                midiloop").concat(n,"_out_recording = 1.0;\n                            }\n                            if (midiloop").concat(n,"_count_in_tick % MIDILOOP").concat(n,"_PPQ == 0) {\n                                midiloop").concat(n,"_out_beat = 1.0;\n                            }\n                            break;\n\n                        case 2: // Recording\n                        case 4: // Overdub\n                            midiloop").concat(n,"_playhead++;\n                            if (midiloop").concat(n,"_playhead >= midiloop").concat(n,"_loop_ticks) {\n                                midiloop").concat(n,"_playhead = 0;\n                                if (midiloop").concat(n,"_state == 2) {\n                                    midiloop").concat(n,"_state = 3;\n                                    midiloop").concat(n,"_out_recording = 0.0;\n                                    midiloop").concat(n,"_out_playing = 1.0;\n                                    // Key detection after first recording\n                                    const float majorProfile[12] = {6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88};\n                                    const float minorProfile[12] = {6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17};\n                                    float bestCorr = -999.0;\n                                    int bestKey = 0;\n                                    bool bestMinor = false;\n                                    for (int key = 0; key < 12; key++) {\n                                        float majorCorr = 0.0, minorCorr = 0.0;\n                                        for (int i = 0; i < 12; i++) {\n                                            int rotatedIdx = (i + key) % 12;\n                                            majorCorr += midiloop").concat(n,"_pitch_histogram[rotatedIdx] * majorProfile[i];\n                                            minorCorr += midiloop").concat(n,"_pitch_histogram[rotatedIdx] * minorProfile[i];\n                                        }\n                                        if (majorCorr > bestCorr) { bestCorr = majorCorr; bestKey = key; bestMinor = false; }\n                                        if (minorCorr > bestCorr) { bestCorr = minorCorr; bestKey = key; bestMinor = true; }\n                                    }\n                                    midiloop").concat(n,"_detected_key = bestKey;\n                                    midiloop").concat(n,"_detected_minor = bestMinor;\n                                    midiloop").concat(n,"_key_confidence = bestCorr / 100.0;\n                                }\n                            }\n                            if (midiloop").concat(n,"_playhead % MIDILOOP").concat(n,"_PPQ == 0) {\n                                midiloop").concat(n,"_out_beat = 1.0;\n                            }\n                            break;\n\n                        case 3: // Playing\n                            midiloop").concat(n,"_playhead++;\n                            if (midiloop").concat(n,"_playhead >= midiloop").concat(n,"_loop_ticks) {\n                                midiloop").concat(n,"_playhead = 0;\n                            }\n                            if (midiloop").concat(n,"_playhead % MIDILOOP").concat(n,"_PPQ == 0) {\n                                midiloop").concat(n,"_out_beat = 1.0;\n                            }\n                            break;\n                    }\n                }\n            }\n\n            // Clear beat output after flash\n            if (midiloop").concat(n,"_out_beat > 0.0 && !clockEdge) {\n                midiloop").concat(n,"_out_beat = 0.0;\n            }\n\n            // === NOTE INPUT & RECORDING ===\n            bool gateOn = midiloop").concat(n,"_gate_input > 0.5;\n            bool noteOn = gateOn && !midiloop").concat(n,"_last_gate;\n            bool noteOff = !gateOn && midiloop").concat(n,"_last_gate;\n\n            // Track the currently held note for accurate note-off recording\n            static uint8_t midiloop").concat(n,"_held_note = 0;\n\n            // Round to nearest integer to avoid float precision truncation errors\n            uint8_t midiNote = (uint8_t)(48.0 + midiloop").concat(n,"_note_input * 48.0 + 0.5);\n            uint8_t velocity = (uint8_t)(midiloop").concat(n,"_velocity_input * 127.0 + 0.5);\n\n            // Record note events\n            if ((midiloop").concat(n,"_state == 2 || midiloop").concat(n,"_state == 4) && midiloop").concat(n,"_event_count < MIDILOOP").concat(n,"_MAX_EVENTS) {\n                if (noteOn) {\n                    // Quantize note-on timing if enabled\n                    int tick = midiloop").concat(n,"_playhead;\n                    if (midiloop").concat(n,"_quantize_ticks > 0) {\n                        tick = ((tick + midiloop").concat(n,"_quantize_ticks/2) / midiloop").concat(n,"_quantize_ticks) * midiloop").concat(n,"_quantize_ticks;\n                    }\n                    midiloop").concat(n,"_held_note = midiNote;  // Remember which note is being held\n                    midiloop").concat(n,"_events[midiloop").concat(n,"_event_count].tick = tick;\n                    midiloop").concat(n,"_events[midiloop").concat(n,"_event_count].type = 1;\n                    midiloop").concat(n,"_events[midiloop").concat(n,"_event_count].note = midiNote;\n                    midiloop").concat(n,"_events[midiloop").concat(n,"_event_count].velocity = velocity;\n                    midiloop").concat(n,"_event_count++;\n                    midiloop").concat(n,"_pitch_histogram[midiNote % 12]++;\n                }\n                if (noteOff) {\n                    // Note-off: use exact playhead position (NO quantization) to preserve note length\n                    int tick = midiloop").concat(n,"_playhead;\n                    midiloop").concat(n,"_events[midiloop").concat(n,"_event_count].tick = tick;\n                    midiloop").concat(n,"_events[midiloop").concat(n,"_event_count].type = 0;\n                    midiloop").concat(n,"_events[midiloop").concat(n,"_event_count].note = midiloop").concat(n,"_held_note;\n                    midiloop").concat(n,"_events[midiloop").concat(n,"_event_count].velocity = 0;\n                    midiloop").concat(n,"_event_count++;\n                }\n            }\n\n            // Update held note tracking even when not recording (for pass-through)\n            if (noteOn) {\n                midiloop").concat(n,"_held_note = midiNote;\n            }\n\n            midiloop").concat(n,"_last_gate = gateOn;\n\n            // Pass-through live input (with transpose, RAW velocity from MIDI - no scaling)\n            // Only control gate during recording/armed states - during playback, let playback control gate\n            if (midiloop").concat(n,"_pass_through && (midiloop").concat(n,"_state <= 2 || midiloop").concat(n,"_state == 4)) {\n                // States 0=armed, 1=count-in, 2=recording, 4=overdub: pass-through controls gate\n                if (gateOn) {\n                    int transposedNote = midiNote + midiloop").concat(n,"_transpose;\n                    transposedNote = constrain(transposedNote, 0, 127);\n                    midiloop").concat(n,"_out_note = (transposedNote - 48.0) / 48.0;\n                    midiloop").concat(n,"_out_gate = 1.0;\n                    float passVel = ").concat(l,";\n                    midiloop").concat(n,"_out_velocity = (passVel > 0.01) ? passVel : 1.0;  // Default to full if not set\n                } else {\n                    midiloop").concat(n,"_out_gate = 0.0; // Gate off when note released\n                }\n            } else if (midiloop").concat(n,"_pass_through && midiloop").concat(n,"_state == 3 && gateOn) {\n                // State 3=playing: live input overrides playback (for jamming along)\n                int transposedNote = midiNote + midiloop").concat(n,"_transpose;\n                transposedNote = constrain(transposedNote, 0, 127);\n                midiloop").concat(n,"_out_note = (transposedNote - 48.0) / 48.0;\n                midiloop").concat(n,"_out_gate = 1.0;\n                float passVel = ").concat(l,";\n                midiloop").concat(n,"_out_velocity = (passVel > 0.01) ? passVel : 1.0;  // Default to full if not set\n            }\n            // Note: During playback (state 3) with no live input, gate is controlled by playback section below\n\n            // === PLAYBACK with transpose and randomization ===\n            // Track playhead range for this tick (handles clock multiplier skipping ticks)\n            static int midiloop").concat(n,"_prev_playhead = -1;\n            static int midiloop").concat(n,"_active_note_count = 0;  // Count of active notes (for legato)\n            static uint8_t midiloop").concat(n,"_last_note = 0;      // Last note played (for pitch output)\n            int playhead_start = midiloop").concat(n,"_prev_playhead + 1;\n            int playhead_end = midiloop").concat(n,"_playhead;\n\n            // Handle wrap-around at loop boundary (only during playback/overdub states)\n            if ((midiloop").concat(n,"_state == 3 || midiloop").concat(n,"_state == 4) && playhead_start > playhead_end) {\n                playhead_start = 0;  // Just wrapped, start from beginning\n                midiloop").concat(n,"_active_note_count = 0;  // Reset note count at loop start\n                midiloop").concat(n,"_out_gate = 0.0;         // Clean gate state at loop boundary\n            }\n\n            if (midiloop").concat(n,"_state == 3 || midiloop").concat(n,"_state == 4) {\n                // Process events in tick order to handle note-on/note-off correctly\n                // First pass: find all events in range and sort by tick\n                for (int i = 0; i < midiloop").concat(n,"_event_count; i++) {\n                    int eventTick = midiloop").concat(n,"_events[i].tick;\n\n                    // Timing randomization (only for note-on events to keep note lengths intact)\n                    if (midiloop").concat(n,"_timing_random > 0.0 && midiloop").concat(n,"_events[i].type == 1) {\n                        int jitter = (int)(midiloop").concat(n,"_timing_random * 12.0 * ((random(0, 1000) / 500.0) - 1.0));\n                        eventTick += jitter;\n                        if (eventTick < 0) eventTick += midiloop").concat(n,"_loop_ticks;\n                        if (eventTick >= midiloop").concat(n,"_loop_ticks) eventTick -= midiloop").concat(n,"_loop_ticks;\n                    }\n\n                    // Check if event falls within the tick range we're processing\n                    bool inRange = (eventTick >= playhead_start && eventTick <= playhead_end);\n\n                    if (inRange) {\n                        uint8_t eventNote = midiloop").concat(n,"_events[i].note;\n                        int playNote = eventNote;\n\n                        // Apply transpose\n                        playNote += midiloop").concat(n,"_transpose;\n\n                        // Pitch randomization within detected key (only for note-on)\n                        if (midiloop").concat(n,"_events[i].type == 1 && midiloop").concat(n,"_pitch_random > 0.0 && (random(0, 1000) / 1000.0) < midiloop").concat(n,"_pitch_random) {\n                            const int majorScale[7] = {0, 2, 4, 5, 7, 9, 11};\n                            const int minorScale[7] = {0, 2, 3, 5, 7, 8, 10};\n                            const int* scale = midiloop").concat(n,"_detected_minor ? minorScale : majorScale;\n                            int pitchClass = playNote % 12;\n                            int octave = playNote / 12;\n                            int keyRoot = midiloop").concat(n,"_detected_key;\n                            int scaleDegree = 0, minDist = 12;\n                            for (int d = 0; d < 7; d++) {\n                                int scaleNote = (keyRoot + scale[d]) % 12;\n                                int dist = abs(pitchClass - scaleNote);\n                                if (dist > 6) dist = 12 - dist;\n                                if (dist < minDist) { minDist = dist; scaleDegree = d; }\n                            }\n                            int shift = random(-1, 2);\n                            scaleDegree = (scaleDegree + shift + 7) % 7;\n                            playNote = octave * 12 + keyRoot + scale[scaleDegree];\n                        }\n\n                        playNote = constrain(playNote, 0, 127);\n\n                        if (midiloop").concat(n,"_events[i].type == 1) {\n                            // Note-on: trigger and increment active note count\n                            midiloop").concat(n,"_out_note = (playNote - 48.0) / 48.0;\n                            midiloop").concat(n,"_out_gate = 1.0;\n                            midiloop").concat(n,"_out_velocity = (midiloop").concat(n,"_events[i].velocity / 127.0) * midiloop").concat(n,"_velocity_scale;\n                            midiloop").concat(n,"_active_note_count++;\n                            midiloop").concat(n,"_last_note = eventNote;\n                        } else {\n                            // Note-off: decrement count, gate off only when all notes released\n                            midiloop").concat(n,"_active_note_count--;\n                            if (midiloop").concat(n,"_active_note_count <= 0) {\n                                midiloop").concat(n,"_out_gate = 0.0;\n                                midiloop").concat(n,"_active_note_count = 0;  // Clamp to 0\n                            }\n                        }\n                    }\n                }\n            }\n\n            midiloop").concat(n,"_prev_playhead = midiloop").concat(n,"_playhead;\n        }\n")}}])&&Ae(e.prototype,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function Te(e){return Te="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Te(e)}function Fe(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,Ne(a.key),a)}}function Ne(e){var n=function(e){if("object"!=Te(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=Te(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==Te(n)?n:n+""}var ze=function(){return e=function e(n){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.connectionResolver=n,this.pinMapper=ie,this.declaredButtons=new Set},(n=[{key:"generateIncludes",value:function(e){return[]}},{key:"generateGlobalVariables",value:function(e,n,t){switch(e.type){case"GateIn":var a=e.params.index||1,o=1===a?4:5,c=e.params.mode||"trigger";return e.params.trigger_hold_ms,"\n// ".concat(t.label," ").concat(n," - Gate In ").concat(a," (LTV816 optoisolator on MCP23017 GPA").concat(o,")\nconst int GATEIN_PIN_").concat(n," = ").concat(o,"; // MCP23017 GPA").concat(o,"\nbool gatein").concat(n,"_state = false;\nbool gatein").concat(n,"_lastState = false;\nbool gatein").concat(n,"_trigger = false;\nconst char* gatein").concat(n,'_mode = "').concat(c,'"; // "gate" or "trigger"\nunsigned long gatein').concat(n,"_trigHoldUntil = 0; // Latch trigger for reliable sampling\n");case"Pot":default:return"";case"LEDButton":var r=e.params.index||1,i=this.pinMapper.getMCPButtonPin(r-1),l=this.pinMapper.getMCPButtonLEDPin(r-1);return"\n// ".concat(t.label," ").concat(n," (Physical Button ").concat(r,")\nconst int BTN_PIN_").concat(n," = ").concat(i,"; // MCP23017 pin ").concat(i,"\nconst int LED_PIN_").concat(n," = ").concat(l,"; // MCP23017 pin ").concat(l,"\nbool btn").concat(r,"_pressed = false;\nvolatile bool btn").concat(r,"_gate = false;     // Raw gate signal for modular connections\nfloat btn").concat(r,"_output = 0.0;             // Normalized output for control connections\nbool btn").concat(r,"_lastState = false;\nbool btn").concat(r,"_state = false;\nbool btn").concat(r,"_ledState = false;\nunsigned long btn").concat(r,"_lastDebounce = 0;\nconst unsigned long btn").concat(r,"_debounceDelay = 50;\nfloat btn").concat(r,"_sampleIn = 0.0;  // Sample & hold input\nfloat btn").concat(r,"_sampleOut = 0.0; // Sample & hold output (held value)\n");case"Encoder":var s=this.pinMapper.getEncoderPins();return"\n// ".concat(t.label," ").concat(n,"\nconst int ENC_A_PIN_").concat(n," = ").concat(s.A,"; // GPIO").concat(s.A,"\nconst int ENC_B_PIN_").concat(n," = ").concat(s.B,"; // GPIO").concat(s.B,"\nconst int ENC_BTN_PIN_").concat(n," = ").concat(s.BTN,"; // GPIO").concat(s.BTN,"\nvolatile int enc").concat(n,"_position = 0;\nint enc").concat(n,"_lastPosition = 0;\nbool enc").concat(n,"_buttonPressed = false;\nbool enc").concat(n,"_lastButtonState = false;\nvolatile float enc").concat(n,"_value = 0.0; // Normalized 0-1 value\n");case"GateOut":var u=e.params.index||1,d=this.pinMapper.getGateOutPin(u-1);return"\n// ".concat(t.label," ").concat(n," - Gate Out ").concat(u,"\nconst int GATE_PIN_").concat(n," = ").concat(d,"; // GPIO").concat(d," (PWM capable for CV)\nbool gate").concat(n,"_state = false;\n");case"MIDIIn":var p=e.params.channel||0;return"\n// ".concat(t.label," ").concat(n," - UART1 on GPIO44 (TLP2361 optocoupler)\nHardwareSerial MIDISerial").concat(n,"(1); // UART1\nuint8_t midiin").concat(n,"_channel = ").concat(p,"; // 0 = omni, 1-16 = specific channel\nfloat midiin").concat(n,"_note = 0.0;      // 0-1 normalized (C3-C7 range, MIDI 48-96)\nfloat midiin").concat(n,"_velocity = 0.0;  // 0-1 normalized (0-127)\nbool midiin").concat(n,"_gate = false;     // Note on/off gate (for mono synths)\nuint8_t midiin").concat(n,"_lastNote = 0;  // Track last note for note-off matching\nunsigned long midiin").concat(n,"_lastRx = 0; // Timestamp for LED feedback\n// Running status state machine\nuint8_t midiin").concat(n,"_runningStatus = 0;\nuint8_t midiin").concat(n,"_dataBuf[2];\nuint8_t midiin").concat(n,"_dataIdx = 0;\nuint8_t midiin").concat(n,"_dataNeeded = 0;\n// MIDI Clock (24 PPQ)\nfloat midiin").concat(n,"_clock_tick = 0.0;    // Pulses on each clock (0xF8)\nbool midiin").concat(n,"_running = false;       // Transport running (Start/Continue sets, Stop clears)\nfloat midiin").concat(n,"_start = 0.0;          // Pulses on Start message (0xFA)\nfloat midiin").concat(n,"_stop = 0.0;           // Pulses on Stop message (0xFC)\nuint32_t midiin").concat(n,"_clock_count = 0;   // 24 PPQ counter (resets on Start)\n// Polyphonic note event queue (for PolyOscillator)\n#define MIDIIN").concat(n,"_EVENT_QUEUE_SIZE 16\nstruct MidiEvent").concat(n," {\n    uint8_t note;\n    uint8_t velocity;\n    bool isNoteOn;\n};\nMidiEvent").concat(n," midiin").concat(n,"_eventQueue[MIDIIN").concat(n,"_EVENT_QUEUE_SIZE];\nvolatile uint8_t midiin").concat(n,"_eventHead = 0;\nvolatile uint8_t midiin").concat(n,"_eventTail = 0;\n");case"MIDIOut":for(var f=e.params.channel||1,m=e.params.num_cc||1,_=e.params.cc_numbers||[1,2,3,4,5,6,7,8],g="",h=1;h<=m;h++){var v=_[h-1]||h;g+="const uint8_t midiout".concat(n,"_cc").concat(h,"_number = ").concat(v,"; // CC").concat(v,"\n")}return"\n// ".concat(t.label," ").concat(n," - UART1 (TXD1/RXD1) for MIDI output\nHardwareSerial MIDIOutSerial").concat(n,"(1); // UART1 (TX=GPIO43)\nuint8_t midiout").concat(n,"_channel = ").concat(f,"; // MIDI channel (1-16)\nconst uint8_t midiout").concat(n,"_num_cc = ").concat(m,"; // Number of active CC ports\n").concat(g,"\n// State tracking\nuint8_t midiout").concat(n,"_lastNote = 0;    // Last sent note (for note-off)\nbool midiout").concat(n,"_lastGate = false;   // Last gate state\nfloat midiout").concat(n,"_lastVelocity = 0.0; // Last velocity\nfloat midiout").concat(n,"_lastCC[8] = {0.0}; // Last CC values (for change detection)\nunsigned long midiout").concat(n,"_lastTx = 0; // Timestamp for LED feedback\n// MIDI Clock output (24 PPQ)\nfloat midiout").concat(n,"_clock_in = 0.0;     // Clock tick input\nfloat midiout").concat(n,"_start_in = 0.0;     // Start input\nfloat midiout").concat(n,"_stop_in = 0.0;      // Stop input\nbool midiout").concat(n,"_last_clock = false;  // For edge detection\nbool midiout").concat(n,"_last_start = false;  // For edge detection\nbool midiout").concat(n,"_last_stop = false;   // For edge detection\n");case"USBMIDIIn":var b=e.params.channel||0;return"\n// ".concat(t.label," ").concat(n," - USB MIDI Input (GPIO19/20, class-compliant)\nuint8_t usbmidiin").concat(n,"_channel = ").concat(b,"; // 0 = omni, 1-16 = specific channel\nfloat usbmidiin").concat(n,"_note = 0.0;      // 0-1 normalized (C3-C7 range, MIDI 48-96)\nfloat usbmidiin").concat(n,"_velocity = 0.0;  // 0-1 normalized (0-127)\nbool usbmidiin").concat(n,"_gate = false;     // Note on/off gate\nuint8_t usbmidiin").concat(n,"_lastNote = 0;  // Track last note for note-off matching\n");case"BLEMIDIIn":var y=e.params.channel||0,k=e.params.device_name||"FP-10",x=!1!==e.params.auto_reconnect;return"\n// ".concat(t.label," ").concat(n,' - BLE MIDI Input (Bluetooth Low Energy)\n// Target device: "').concat(k,'"\nconst char* blemidi').concat(n,'_deviceName = "').concat(k,'";\nuint8_t blemidi').concat(n,"_channel = ").concat(y,"; // 0 = omni, 1-16 = specific channel\nfloat blemidi").concat(n,"_note = 0.0;      // 0-1 normalized (C3-C7 range, MIDI 48-96)\nfloat blemidi").concat(n,"_velocity = 0.0;  // 0-1 normalized (0-127)\nbool blemidi").concat(n,"_gate = false;     // Note on/off gate\nuint8_t blemidi").concat(n,"_lastNote = 0;  // Track last note for note-off matching\nbool blemidi").concat(n,"_autoReconnect = ").concat(x,";\n\n// BLE MIDI state\nBLEClient* blemidi").concat(n,"_client = nullptr;\nBLERemoteCharacteristic* blemidi").concat(n,"_char = nullptr;\nbool blemidi").concat(n,"_connected = false;\nbool blemidi").concat(n,"_scanning = false;\nunsigned long blemidi").concat(n,"_lastScanTime = 0;\nconst unsigned long blemidi").concat(n,"_scanInterval = 5000; // Retry scan every 5s if disconnected\n\n// BLE MIDI packet parsing state\nuint8_t blemidi").concat(n,"_runningStatus = 0;\nuint16_t blemidi").concat(n,"_timestamp = 0;\n");case"USBMIDIOut":for(var S=e.params.num_outputs||1,E="",P=1;P<=S;P++){var w=e.params["ch_".concat(P)]||P,C=e.params["cc_".concat(P)]||P;E+="const uint8_t usbmidiout".concat(n,"_ch").concat(P," = ").concat(w,"; // Output ").concat(P,"  MIDI channel ").concat(w,"\n"),E+="const uint8_t usbmidiout".concat(n,"_cc").concat(P,"_number = ").concat(C,"; // Output ").concat(P," CC number\n")}var I="";return I+="uint8_t usbmidiout".concat(n,"_lastNote[").concat(S,"] = {0}; // Last sent notes\n"),I+="bool usbmidiout".concat(n,"_lastGate[").concat(S,"] = {false}; // Last gate states\n"),I+="float usbmidiout".concat(n,"_lastVelocity[").concat(S,"] = {0.0}; // Last velocities\n"),I+="float usbmidiout".concat(n,"_lastCC[").concat(S,"] = {0.0}; // Last CC values\n"),"\n// ".concat(t.label," ").concat(n," - USB MIDI Output with multi-channel routing\nconst uint8_t usbmidiout").concat(n,"_num_outputs = ").concat(S,"; // Number of active output groups\n").concat(E,"\n// State tracking (per-output)\n").concat(I,"\n")}}},{key:"generateSetupCode",value:function(e,n){switch(e.type){case"Pot":return"\n    // Pot ".concat(n," setup\n    pinMode(POT_PIN_").concat(n,", INPUT);\n");case"LEDButton":return"\n    // LEDButton ".concat(n," setup (MCP23017 pins configured in base setup)\n");case"Encoder":return"\n    // Encoder ".concat(n," setup\n    pinMode(ENC_A_PIN_").concat(n,", INPUT_PULLUP);\n    pinMode(ENC_B_PIN_").concat(n,", INPUT_PULLUP);\n    pinMode(ENC_BTN_PIN_").concat(n,", INPUT_PULLUP);\n\n    // Attach interrupt for encoder\n    attachInterrupt(digitalPinToInterrupt(ENC_A_PIN_").concat(n,"), []() {\n        if (digitalRead(ENC_A_PIN_").concat(n,") != digitalRead(ENC_B_PIN_").concat(n,")) {\n            enc").concat(n,"_position++;\n        } else {\n            enc").concat(n,"_position--;\n        }\n    }, CHANGE);\n");case"GateOut":return"\n    // GateOut ".concat(n," setup\n    pinMode(GATE_PIN_").concat(n,", OUTPUT);\n    digitalWrite(GATE_PIN_").concat(n,", LOW);\n");case"GateIn":return"\n    // GateIn ".concat(n," setup (MCP23017 pin configured in base setup as INPUT_PULLUP)\n");case"MIDIIn":return"\n    // MIDIIn ".concat(n," setup - UART1 at 31250 baud (MIDI standard)\n    MIDISerial").concat(n,'.begin(31250, SERIAL_8N1, 44, -1); // RX=GPIO44, TX=not used\n    Serial.println("MIDI In ').concat(n,' initialized on UART1 (31250 baud, RX=GPIO44)");\n');case"MIDIOut":return"\n    // MIDIOut ".concat(n," setup - UART1 at 31250 baud (MIDI standard)\n    // TX=GPIO43 (v1.0 confirmed), RX not used for output-only\n    MIDIOutSerial").concat(n,'.begin(31250, SERIAL_8N1, -1, 43); // RX=-1 (not used), TX=GPIO43\n    Serial.println("MIDI Out ').concat(n,' initialized on UART1 (31250 baud, TX=GPIO43)");\n');case"USBMIDIIn":return"\n    // USBMIDIIn ".concat(n,' setup - Initialized globally with USB.begin()\n    Serial.println("USB MIDI In ').concat(n,' ready (class-compliant, GPIO19/20)");\n');case"BLEMIDIIn":return"\n    // BLEMIDIIn ".concat(n,' setup - Initialize BLE and start scanning\n    BLEDevice::init("Soniphorm-Gen");\n    Serial.print("BLE MIDI In ').concat(n,": Searching for device '\");\n    Serial.print(blemidi").concat(n,'_deviceName);\n    Serial.println("\'...");\n    blemidi').concat(n,"_lastScanTime = millis();\n");case"USBMIDIOut":return"\n    // USBMIDIOut ".concat(n,' setup - Initialized globally with USB.begin()\n    Serial.println("USB MIDI Out ').concat(n,' ready (multi-channel routing)");\n');default:return""}}},{key:"generateControlCode",value:function(e,n,t){switch(e.type){case"Pot":return this.generatePotCode(e,n);case"LEDButton":return this.generateButtonCode(e,n,t);case"Encoder":return this.generateEncoderCode(e,n);case"GateOut":return this.generateGateOutCode(e,n,t);case"GateIn":return this.generateGateInCode(e,n);case"MIDIIn":return this.generateMIDIInCode(e,n);case"MIDIOut":return this.generateMIDIOutCode(e,n,t);case"USBMIDIIn":return this.generateUSBMIDIInCode(e,n);case"USBMIDIOut":return this.generateUSBMIDIOutCode(e,n,t);case"BLEMIDIIn":return this.generateBLEMIDIInCode(e,n);default:return""}}},{key:"generatePotCode",value:function(e,n){return"\n        // Pot ".concat(n," reading with jitter reduction\n        int rawValue = analogRead(POT_PIN_").concat(n,");\n        float newValue = rawValue / 4095.0; // Convert to 0-1 range (12-bit ADC)\n\n        // Deadband filtering: ignore tiny changes (< 0.005 = ~20 ADC counts)\n        float deadband = 0.005;\n        if (abs(newValue - pot").concat(n,"_smoothed) > deadband) {\n            // Apply smoothing to reduce noise\n            pot").concat(n,"_smoothed = (POT_SMOOTH_FACTOR_").concat(n," * newValue) +\n                                  ((1.0 - POT_SMOOTH_FACTOR_").concat(n,") * pot").concat(n,"_smoothed);\n        }\n        pot").concat(n,"_value = pot").concat(n,"_smoothed;\n")}},{key:"generateButtonCode",value:function(e,n,t){var a="btn".concat(n);if(this.declaredButtons.has(a))return"";this.declaredButtons.add(a);var o=t.some(function(n){return n.from.id.includes("".concat(e.id,":"))&&"pressed"===n.from.port});return"\n        // LEDButton ".concat(n," processing - hasLEDConnection: ").concat(o,"\n        {\n            // Read button state from MCP23017\n            bool buttonState = !mcp.digitalRead(BTN_PIN_").concat(n,"); // Active low\n            \n            // Debounce button\n            if (buttonState != btn").concat(n,"_lastState) {\n                btn").concat(n,"_lastDebounce = millis();\n            }\n            \n            if ((millis() - btn").concat(n,"_lastDebounce) > btn").concat(n,"_debounceDelay) {\n                if (buttonState != btn").concat(n,"_pressed) {\n                    btn").concat(n,"_pressed = buttonState;\n                    btn").concat(n,"_gate = buttonState;  // Raw gate signal always follows button state\n\n                    // Update LED state\n                    ").concat(o?"\n                    if (btn".concat(n,"_pressed) {\n                        btn").concat(n,"_ledState = !btn").concat(n,"_ledState;\n                        mcp.digitalWrite(LED_PIN_").concat(n,", btn").concat(n,"_ledState);\n                    }"):"\n                    mcp.digitalWrite(LED_PIN_".concat(n,", btn").concat(n,"_pressed);"),"\n                }\n            }\n            \n            btn").concat(n,"_lastState = buttonState;\n        }\n")}},{key:"generateEncoderCode",value:function(e,n){return"\n        // Encoder ".concat(n," processing\n        {\n            // Check for position changes\n            if (enc").concat(n,"_position != enc").concat(n,"_lastPosition) {\n                // Convert encoder position to normalized value\n                // Assuming +/- 100 encoder steps for full range\n                float normalizedPos = (enc").concat(n,"_position % 200) / 200.0;\n                if (normalizedPos < 0) normalizedPos += 1.0;\n                enc").concat(n,"_value = normalizedPos;\n                \n                enc").concat(n,"_lastPosition = enc").concat(n,"_position;\n            }\n            \n            // Read button state\n            bool buttonState = !digitalRead(ENC_BTN_PIN_").concat(n,"); // Active low\n            if (buttonState != enc").concat(n,"_lastButtonState) {\n                enc").concat(n,"_buttonPressed = buttonState;\n                enc").concat(n,"_lastButtonState = buttonState;\n            }\n        }\n")}},{key:"generateGateOutCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"in"===n.to.port}),o="false";if(a){var c=a.from.id.split(":")[0],r=this.connectionResolver.modules.find(function(e){return e.id===c});if(r){var i,l=(null===(i=c.match(/\d+$/))||void 0===i?void 0:i[0])||"1";switch(r.type){case"Clock":o="clock".concat(l,"_output");break;case"LEDButton":o="btn".concat(l,"_pressed");break;case"ADSR":o="(adsr".concat(l,"_output > 0.1)")}}}return e.params.pin,"\n        // GateOut ".concat(n," processing\n        {\n            bool gateSignal = ").concat(o,";\n\n            if (gateSignal != gate").concat(n,"_state) {\n                gate").concat(n,"_state = gateSignal;\n                digitalWrite(GATE_PIN_").concat(n,", gateSignal ? HIGH : LOW);\n            }\n\n            // Update LED state for visual feedback\n            // GPIO10 (Gate 3)  led_gateout1_active\n            // GPIO11 (Gate 4)  led_gateout2_active\n            if (GATE_PIN_").concat(n," == 10) {\n                led_gateout1_active = gate").concat(n,"_state;\n            } else if (GATE_PIN_").concat(n," == 11) {\n                led_gateout2_active = gate").concat(n,"_state;\n            }\n        }\n")}},{key:"generateGateInCode",value:function(e,n){var t=e.params.trigger_hold_ms||30;return"\n        // GateIn ".concat(n," processing (LTV816 optoisolator input)\n        {\n            // Extract pin state from batch read (bit GATEIN_PIN_").concat(n," of inputs)\n            bool rawPin = (inputs & (1 << GATEIN_PIN_").concat(n,")) != 0;\n            bool gateInput = !rawPin;  // Active low from optoisolator\n\n            // Rising edge detection (immediate, no debounce - piezo pulses are brief!)\n            if (gateInput && !gatein").concat(n,"_lastState) {\n                gatein").concat(n,"_state = true;\n\n                // LATCH trigger for ").concat(t,"ms so control sampling (10ms rate) can catch it\n                if (strcmp(gatein").concat(n,'_mode, "trigger") == 0) {\n                    gatein').concat(n,"_trigger = true;\n                    gatein").concat(n,"_trigHoldUntil = millis() + ").concat(t,";\n                }\n            }\n            // Falling edge detection\n            else if (!gateInput && gatein").concat(n,"_lastState) {\n                gatein").concat(n,"_state = false;\n            }\n\n            // Auto-clear trigger after hold time\n            if (gatein").concat(n,"_trigger && millis() > gatein").concat(n,"_trigHoldUntil) {\n                gatein").concat(n,"_trigger = false;\n            }\n\n            gatein").concat(n,"_lastState = gateInput;\n\n            // Update LED state for visual feedback\n            // GPA4 (pin 4) = Gate In 1  led_gatein1_active\n            // GPA5 (pin 5) = Gate In 2  led_gatein2_active\n            if (GATEIN_PIN_").concat(n," == 4) {\n                led_gatein1_active = gatein").concat(n,"_state;\n            } else if (GATEIN_PIN_").concat(n," == 5) {\n                led_gatein2_active = gatein").concat(n,"_state;\n            }\n        }\n")}},{key:"generateMIDIInCode",value:function(e,n){return e.params.channel,"\n        // MIDIIn ".concat(n," processing - Byte-by-byte state machine with running status\n        {\n            // Clear clock pulse outputs (they pulse for one control cycle)\n            midiin").concat(n,"_clock_tick = 0.0;\n            midiin").concat(n,"_start = 0.0;\n            midiin").concat(n,"_stop = 0.0;\n\n            while (MIDISerial").concat(n,".available()) {\n                uint8_t b = MIDISerial").concat(n,".read();\n\n                // Flash LED on any MIDI receive\n                midiin").concat(n,"_lastRx = millis();\n                led_midiin_active = true;\n                led_midiin_time = millis();\n\n                // Real-time messages (0xF8-0xFF) - handle clock, then continue\n                if (b >= 0xF8) {\n                    switch (b) {\n                        case 0xF8:  // MIDI Clock tick (24 PPQ)\n                            midiin").concat(n,"_clock_tick = 1.0;\n                            if (midiin").concat(n,"_running) {\n                                midiin").concat(n,"_clock_count++;\n                            }\n                            break;\n                        case 0xFA:  // Start\n                            midiin").concat(n,"_start = 1.0;\n                            midiin").concat(n,"_running = true;\n                            midiin").concat(n,"_clock_count = 0;  // Reset on Start\n                            break;\n                        case 0xFB:  // Continue\n                            midiin").concat(n,"_running = true;\n                            break;\n                        case 0xFC:  // Stop\n                            midiin").concat(n,"_stop = 1.0;\n                            midiin").concat(n,"_running = false;\n                            break;\n                    }\n                    continue;\n                }\n\n                // Status byte (bit 7 set)\n                if (b & 0x80) {\n                    // System messages (0xF0-0xF7) - reset running status\n                    if (b >= 0xF0) {\n                        midiin").concat(n,"_runningStatus = 0;\n                        midiin").concat(n,"_dataNeeded = 0;\n                        midiin").concat(n,"_dataIdx = 0;\n                        continue;\n                    }\n                    // Channel voice message - set up for data bytes\n                    midiin").concat(n,"_runningStatus = b;\n                    midiin").concat(n,"_dataIdx = 0;\n                    uint8_t msgType = b & 0xF0;\n                    // Program Change (0xC0) and Channel Pressure (0xD0) need 1 byte\n                    if (msgType == 0xC0 || msgType == 0xD0) {\n                        midiin").concat(n,"_dataNeeded = 1;\n                    } else {\n                        midiin").concat(n,"_dataNeeded = 2; // Note On/Off, CC, Pitch Bend, etc.\n                    }\n                    continue;\n                }\n\n                // Data byte - process with running status\n                if (midiin").concat(n,"_runningStatus >= 0x80 && midiin").concat(n,"_runningStatus <= 0xEF) {\n                    midiin").concat(n,"_dataBuf[midiin").concat(n,"_dataIdx++] = b;\n\n                    if (midiin").concat(n,"_dataIdx >= midiin").concat(n,"_dataNeeded) {\n                        // Complete message - process it\n                        uint8_t status = midiin").concat(n,"_runningStatus;\n                        uint8_t msgType = status & 0xF0;\n                        uint8_t rxChannel = (status & 0x0F) + 1;\n\n                        // Check channel filter (0 = omni)\n                        if (midiin").concat(n,"_channel == 0 || midiin").concat(n,"_channel == rxChannel) {\n                            if (msgType == 0x90 || msgType == 0x80) {\n                                uint8_t note = midiin").concat(n,"_dataBuf[0];\n                                uint8_t velocity = midiin").concat(n,"_dataBuf[1];\n                                bool isNoteOn = (msgType == 0x90) && (velocity > 0);\n\n                                // Push to event queue for polyphonic modules\n                                uint8_t nextHead = (midiin").concat(n,"_eventHead + 1) % MIDIIN").concat(n,"_EVENT_QUEUE_SIZE;\n                                if (nextHead != midiin").concat(n,"_eventTail) { // Queue not full\n                                    midiin").concat(n,"_eventQueue[midiin").concat(n,"_eventHead].note = note;\n                                    midiin").concat(n,"_eventQueue[midiin").concat(n,"_eventHead].velocity = velocity;\n                                    midiin").concat(n,"_eventQueue[midiin").concat(n,"_eventHead].isNoteOn = isNoteOn;\n                                    midiin").concat(n,"_eventHead = nextHead;\n                                }\n\n                                // Also update mono outputs for mono synths\n                                if (isNoteOn) {\n                                    midiin").concat(n,"_lastNote = note;\n                                    midiin").concat(n,"_gate = true;\n                                    float normalizedNote = (note - 48.0) / 48.0;\n                                    midiin").concat(n,"_note = constrain(normalizedNote, 0.0, 1.0);\n                                    midiin").concat(n,"_velocity = velocity / 127.0;\n                                } else {\n                                    if (note == midiin").concat(n,"_lastNote) {\n                                        midiin").concat(n,"_gate = false;\n                                    }\n                                }\n                            }\n                        }\n                        // Reset for next message (running status persists)\n                        midiin").concat(n,"_dataIdx = 0;\n                    }\n                }\n            }\n\n            // Auto-clear LED after 50ms\n            if (led_midiin_active && (millis() - midiin").concat(n,"_lastRx > 50)) {\n                led_midiin_active = false;\n            }\n        }\n")}},{key:"generateMIDIOutCode",value:function(e,n,t){var a=this,o=e.params.num_cc||1,c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"note"===n.to.port}),r="0.0",i="false",l="0.8",s=!1;if(c){var u=c.from.id.split(":")[0],d=c.from.port,p=this.connectionResolver.modules.find(function(e){return e.id===u});if(p){var f,m=(null===(f=u.match(/\d+$/))||void 0===f?void 0:f[0])||"1";"HarmonicSequencer"===p.type?"note"!==d&&"pitch_sum"!==d||(r="seq".concat(m,"_pitch_sum"),i="seq".concat(m,"_gate_sum"),l="seq".concat(m,"_velocity_sum"),s=!0):"MIDIIn"===p.type?"note"===d&&(r="midiin".concat(m,"_note"),i="midiin".concat(m,"_gate"),l="midiin".concat(m,"_velocity"),s=!0):"Arpeggiator"===p.type?"note_out"===d&&(r="arp".concat(m,"_out_note"),i="arp".concat(m,"_out_gate"),l="arp".concat(m,"_out_velocity"),s=!0):"MIDILooper"===p.type&&"note_out"===d&&(r="midiloop".concat(m,"_out_note"),i="midiloop".concat(m,"_out_gate"),l="midiloop".concat(m,"_out_velocity"),s=!0)}}var _=function(n){var o,c=t.find(function(t){return t.to.id.includes("".concat(e.id,":"))&&t.to.port===n});if(!c)return null;var r=c.from.id.split(":")[0],i=c.from.port,l=a.connectionResolver.modules.find(function(e){return e.id===r});if(!l)return null;var s=(null===(o=r.match(/\d+$/))||void 0===o?void 0:o[0])||"1";switch(l.type){case"MIDIIn":if("note"===i)return"midiin".concat(s,"_note");if("gate"===i)return"midiin".concat(s,"_gate");if("velocity"===i)return"midiin".concat(s,"_velocity");break;case"HarmonicSequencer":if("pitch_sum"===i)return"seq".concat(s,"_pitch_sum");if("gate_sum"===i)return"seq".concat(s,"_gate_sum");if("velocity_sum"===i)return"seq".concat(s,"_velocity_sum");if("pitch_hz"===i)return"seq".concat(s,"_pitch_hz");if(i.startsWith("pitch_step")){var u=i.replace("pitch_step","");return"seq".concat(s,"_pitch_step").concat(u)}if(i.startsWith("gate_step")){var d=i.replace("gate_step","");return"seq".concat(s,"_gate_step").concat(d)}if(i.startsWith("velocity_step")){var p=i.replace("velocity_step","");return"seq".concat(s,"_velocity_step").concat(p)}break;case"Pot":return"pot".concat(s,"_value");case"ADSR":return"adsr".concat(s,"_output");case"LFO":return"lfo".concat(s,"_output");case"Scale":return"scale".concat(s,"_output");case"Arpeggiator":if("note_out"===i)return"arp".concat(s,"_out_note");if("gate_out"===i)return"arp".concat(s,"_out_gate");if("velocity_out"===i)return"arp".concat(s,"_out_velocity");break;case"MIDILooper":if("note_out"===i)return"midiloop".concat(s,"_out_note");if("gate_out"===i)return"midiloop".concat(s,"_out_gate");if("velocity_out"===i)return"midiloop".concat(s,"_out_velocity");if("playing"===i)return"midiloop".concat(s,"_out_playing");if("recording"===i)return"midiloop".concat(s,"_out_recording");if("beat"===i)return"midiloop".concat(s,"_out_beat");break;case"Clock":if("tick24"===i)return"clock".concat(s,"_tick24");if("start"===i)return"clock".concat(s,"_start");if("stop"===i)return"clock".concat(s,"_stop");if("running"===i)return"clock".concat(s,"_running");break;case"MIDIIn":if("note"===i)return"midiin".concat(s,"_note");if("gate"===i)return"midiin".concat(s,"_gate");if("velocity"===i)return"midiin".concat(s,"_velocity");if("clock_tick"===i)return"midiin".concat(s,"_clock_tick");if("start"===i)return"midiin".concat(s,"_start");if("stop"===i)return"midiin".concat(s,"_stop");if("running"===i)return"midiin".concat(s,"_running");break;default:return null}return null};s||(r=_("note")||"0.0",i=_("gate")||"false",l=_("velocity")||"0.8");for(var g="",h=1;h<=o;h++){var v=_("cc_".concat(h))||"0.0";g+="\n            // Read CC ".concat(h," input\n            float cc").concat(h,"_value = ").concat(v,";\n            uint8_t cc").concat(h,"_midi = constrain((int)(cc").concat(h,"_value * 127.0), 0, 127);\n\n            // Send CC if value changed (threshold: 1/127 = ~0.008)\n            if (abs(cc").concat(h,"_value - midiout").concat(n,"_lastCC[").concat(h-1,"]) > 0.008) {\n                midiout").concat(n,"_lastCC[").concat(h-1,"] = cc").concat(h,"_value;\n                // MIDI CC message: 0xB0 + channel, CC number, value\n                uint8_t ccMsg[3] = {\n                    (uint8_t)(0xB0 | (midiout").concat(n,"_channel - 1)),\n                    midiout").concat(n,"_cc").concat(h,"_number,\n                    cc").concat(h,"_midi\n                };\n                MIDIOutSerial").concat(n,".write(ccMsg, 3);\n                midiout").concat(n,"_lastTx = millis();\n                led_midiout_active = true;\n            }\n")}var b=_("clock")||"0.0",y=_("start")||"0.0",k=_("stop")||"0.0";return"\n        // MIDIOut ".concat(n," processing - Send MIDI messages (31250 baud)\n        {\n            // Read note, gate, velocity inputs\n            float noteCV = ").concat(r,"; // 0-1 CV (C3-C7 = MIDI 48-96)\n            bool gateSignal = ").concat(i,";\n            float velocityCV = ").concat(l,"; // 0-1 velocity\n\n            // Convert note CV to MIDI note number (C3-C7 range)\n            uint8_t midiNote = constrain(48 + (int)(noteCV * 48.0), 0, 127);\n            uint8_t midiVelocity = constrain((int)(velocityCV * 127.0), 1, 127);\n\n            // Gate rising edge: Send Note On\n            if (gateSignal && !midiout").concat(n,"_lastGate) {\n                midiout").concat(n,"_lastNote = midiNote;\n                midiout").concat(n,"_lastVelocity = velocityCV;\n\n                // MIDI Note On: 0x90 + channel, note, velocity\n                uint8_t noteOnMsg[3] = {\n                    (uint8_t)(0x90 | (midiout").concat(n,"_channel - 1)),\n                    midiNote,\n                    midiVelocity\n                };\n                MIDIOutSerial").concat(n,".write(noteOnMsg, 3);\n                midiout").concat(n,"_lastTx = millis();\n                led_midiout_active = true;\n            }\n            // Gate falling edge: Send Note Off\n            else if (!gateSignal && midiout").concat(n,"_lastGate) {\n                // MIDI Note Off: 0x80 + channel, note, 0\n                uint8_t noteOffMsg[3] = {\n                    (uint8_t)(0x80 | (midiout").concat(n,"_channel - 1)),\n                    midiout").concat(n,"_lastNote,\n                    0\n                };\n                MIDIOutSerial").concat(n,".write(noteOffMsg, 3);\n                midiout").concat(n,"_lastTx = millis();\n                led_midiout_active = true;\n            }\n\n            midiout").concat(n,"_lastGate = gateSignal;\n\n            // MIDI Clock output (24 PPQ)\n            midiout").concat(n,"_clock_in = ").concat(b,";\n            midiout").concat(n,"_start_in = ").concat(y,";\n            midiout").concat(n,"_stop_in = ").concat(k,";\n\n            // Clock tick: Send on rising edge\n            bool clockHigh = (midiout").concat(n,"_clock_in > 0.5);\n            if (clockHigh && !midiout").concat(n,"_last_clock) {\n                MIDIOutSerial").concat(n,".write((uint8_t)0xF8);  // MIDI Clock\n                midiout").concat(n,"_lastTx = millis();\n                led_midiout_active = true;\n            }\n            midiout").concat(n,"_last_clock = clockHigh;\n\n            // Start: Send on rising edge\n            bool startHigh = (midiout").concat(n,"_start_in > 0.5);\n            if (startHigh && !midiout").concat(n,"_last_start) {\n                MIDIOutSerial").concat(n,".write((uint8_t)0xFA);  // MIDI Start\n                midiout").concat(n,"_lastTx = millis();\n                led_midiout_active = true;\n            }\n            midiout").concat(n,"_last_start = startHigh;\n\n            // Stop: Send on rising edge\n            bool stopHigh = (midiout").concat(n,"_stop_in > 0.5);\n            if (stopHigh && !midiout").concat(n,"_last_stop) {\n                MIDIOutSerial").concat(n,".write((uint8_t)0xFC);  // MIDI Stop\n                midiout").concat(n,"_lastTx = millis();\n                led_midiout_active = true;\n            }\n            midiout").concat(n,"_last_stop = stopHigh;\n            ").concat(g,"\n            // Auto-clear LED after 50ms\n            if (led_midiout_active && (millis() - midiout").concat(n,"_lastTx > 50)) {\n                led_midiout_active = false;\n            }\n        }\n")}},{key:"generateUSBMIDIInCode",value:function(e,n){return e.params.channel,"\n        // USBMIDIIn ".concat(n," processing - Parse USB MIDI messages\n        {\n            midiEventPacket_t rx;\n            while (usbMIDI.read(&rx)) {\n                // Parse Note On/Off messages (header 0x09 = note on, 0x08 = note off)\n                if (rx.header == 0x09 || rx.header == 0x08) {\n                    uint8_t rxChannel = (rx.byte1 & 0x0F) + 1; // Extract channel (1-16)\n                    uint8_t note = rx.byte2;\n                    uint8_t velocity = rx.byte3;\n\n                    // Check channel filter (0 = omni)\n                    if (usbmidiin").concat(n,"_channel == 0 || usbmidiin").concat(n,"_channel == rxChannel) {\n                        bool isNoteOn = (rx.header == 0x09) && (velocity > 0);\n\n                        if (isNoteOn) {\n                            // Note On: Update pitch and velocity\n                            usbmidiin").concat(n,"_lastNote = note;\n                            usbmidiin").concat(n,"_gate = true;\n\n                            // Normalize note to 0-1 (C3-C7 = MIDI 48-96)\n                            float normalizedNote = (note - 48.0) / 48.0;\n                            usbmidiin").concat(n,"_note = constrain(normalizedNote, 0.0, 1.0);\n\n                            // Normalize velocity to 0-1\n                            usbmidiin").concat(n,"_velocity = velocity / 127.0;\n                        } else {\n                            // Note Off: Clear gate only if it matches last note\n                            if (note == usbmidiin").concat(n,"_lastNote) {\n                                usbmidiin").concat(n,"_gate = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n")}},{key:"generateUSBMIDIOutCode",value:function(e,n,t){for(var a=this,o=e.params.num_outputs||1,c=function(n){var o,c=t.find(function(t){return t.to.id.includes("".concat(e.id,":"))&&t.to.port===n});if(!c)return null;var r=c.from.id.split(":")[0],i=c.from.port,l=a.connectionResolver.modules.find(function(e){return e.id===r});if(!l)return null;var s=(null===(o=r.match(/\\d+$/))||void 0===o?void 0:o[0])||"1";switch(l.type){case"USBMIDIIn":if("note"===i)return"usbmidiin".concat(s,"_note");if("gate"===i)return"usbmidiin".concat(s,"_gate");if("velocity"===i)return"usbmidiin".concat(s,"_velocity");break;case"MIDIIn":if("note"===i)return"midiin".concat(s,"_note");if("gate"===i)return"midiin".concat(s,"_gate");if("velocity"===i)return"midiin".concat(s,"_velocity");break;case"Pot":return"pot".concat(s,"_value");case"ADSR":return"adsr".concat(s,"_output");case"LFO":return"lfo".concat(s,"_output");case"Scale":return"scale".concat(s,"_output");case"HarmonicSequencer":if("pitch_sum"===i)return"seq".concat(s,"_pitch_sum");if("pitch_hz"===i)return"seq".concat(s,"_pitch_hz");if("gate_sum"===i)return"seq".concat(s,"_gate_sum");break;default:return null}return null},r="",i=1;i<=o;i++){var l=c("note_".concat(i))||"0.0",s=c("gate_".concat(i))||"false",u=c("velocity_".concat(i))||"0.8",d=c("cc_".concat(i))||"0.0";r+="\n            // Output ".concat(i,"  MIDI Channel ").concat(e.params["ch_".concat(i)]||i,"\n            {\n                float noteCV = ").concat(l,"; // 0-1 CV (C3-C7 = MIDI 48-96)\n                bool gateSignal = ").concat(s,";\n                float velocityCV = ").concat(u,"; // 0-1 velocity\n                float ccValue = ").concat(d,"; // 0-1 CC value\n\n                // Convert note CV to MIDI note number (C3-C7 range)\n                uint8_t midiNote = constrain(48 + (int)(noteCV * 48.0), 0, 127);\n                uint8_t midiVelocity = constrain((int)(velocityCV * 127.0), 1, 127);\n                uint8_t midiCC = constrain((int)(ccValue * 127.0), 0, 127);\n\n                // Gate rising edge: Send Note On\n                if (gateSignal && !usbmidiout").concat(n,"_lastGate[").concat(i-1,"]) {\n                    usbmidiout").concat(n,"_lastNote[").concat(i-1,"] = midiNote;\n                    usbmidiout").concat(n,"_lastVelocity[").concat(i-1,"] = velocityCV;\n\n                    // USB MIDI Note On packet\n                    midiEventPacket_t noteOn = {0x09, (uint8_t)(0x90 | (usbmidiout").concat(n,"_ch").concat(i," - 1)), midiNote, midiVelocity};\n                    usbMIDI.writePacket(&noteOn);\n                }\n                // Gate falling edge: Send Note Off\n                else if (!gateSignal && usbmidiout").concat(n,"_lastGate[").concat(i-1,"]) {\n                    // USB MIDI Note Off packet\n                    midiEventPacket_t noteOff = {0x08, (uint8_t)(0x80 | (usbmidiout").concat(n,"_ch").concat(i," - 1)), usbmidiout").concat(n,"_lastNote[").concat(i-1,"], 0};\n                    usbMIDI.writePacket(&noteOff);\n                }\n                // Pitch change while gate is high (legato): Send Note Off + Note On\n                else if (gateSignal && usbmidiout").concat(n,"_lastGate[").concat(i-1,"] && midiNote != usbmidiout").concat(n,"_lastNote[").concat(i-1,"]) {\n                    // Note Off for previous note\n                    midiEventPacket_t noteOff = {0x08, (uint8_t)(0x80 | (usbmidiout").concat(n,"_ch").concat(i," - 1)), usbmidiout").concat(n,"_lastNote[").concat(i-1,"], 0};\n                    usbMIDI.writePacket(&noteOff);\n\n                    // Note On for new note\n                    usbmidiout").concat(n,"_lastNote[").concat(i-1,"] = midiNote;\n                    usbmidiout").concat(n,"_lastVelocity[").concat(i-1,"] = velocityCV;\n                    midiEventPacket_t noteOn = {0x09, (uint8_t)(0x90 | (usbmidiout").concat(n,"_ch").concat(i," - 1)), midiNote, midiVelocity};\n                    usbMIDI.writePacket(&noteOn);\n                }\n\n                usbmidiout").concat(n,"_lastGate[").concat(i-1,"] = gateSignal;\n\n                // Send CC if value changed (threshold: 1/127 = ~0.008)\n                if (abs(ccValue - usbmidiout").concat(n,"_lastCC[").concat(i-1,"]) > 0.008) {\n                    usbmidiout").concat(n,"_lastCC[").concat(i-1,"] = ccValue;\n\n                    // USB MIDI CC packet\n                    midiEventPacket_t cc = {0x0B, (uint8_t)(0xB0 | (usbmidiout").concat(n,"_ch").concat(i," - 1)), usbmidiout").concat(n,"_cc").concat(i,"_number, midiCC};\n                    usbMIDI.writePacket(&cc);\n                }\n            }\n")}return"\n        // USBMIDIOut ".concat(n," processing - Send USB MIDI to ").concat(o," channel(s)\n        {").concat(r,"\n        }\n")}},{key:"generateBLEMIDIInCode",value:function(e,n){return e.params.channel,"\n        // BLEMIDIIn ".concat(n," processing - BLE MIDI client with auto-reconnect\n        {\n            // Check connection status and handle reconnection\n            if (!blemidi").concat(n,"_connected) {\n                // Periodic scan for target device\n                if (millis() - blemidi").concat(n,"_lastScanTime > blemidi").concat(n,"_scanInterval) {\n                    blemidi").concat(n,"_lastScanTime = millis();\n\n                    if (!blemidi").concat(n,"_scanning) {\n                        blemidi").concat(n,"_scanning = true;\n\n                        // Scan for BLE MIDI devices\n                        BLEScan* pScan = BLEDevice::getScan();\n                        pScan->setActiveScan(true);\n                        pScan->setInterval(100);\n                        pScan->setWindow(99);\n                        BLEScanResults* pResults = pScan->start(2, false); // 2 second scan\n\n                        // Look for target device\n                        if (pResults != nullptr) {\n                        for (int i = 0; i < pResults->getCount(); i++) {\n                            BLEAdvertisedDevice device = pResults->getDevice(i);\n                            if (device.haveName() && strcmp(device.getName().c_str(), blemidi").concat(n,'_deviceName) == 0) {\n                                Serial.print("BLE MIDI: Found ");\n                                Serial.println(blemidi').concat(n,"_deviceName);\n\n                                // Connect to device\n                                if (blemidi").concat(n,"_client == nullptr) {\n                                    blemidi").concat(n,"_client = BLEDevice::createClient();\n                                }\n\n                                if (blemidi").concat(n,"_client->connect(&device)) {\n                                    // Find MIDI service (standard BLE MIDI UUID)\n                                    BLERemoteService* pService = blemidi").concat(n,'_client->getService(BLEUUID("03b80e5a-ede8-4b33-a751-6ce34ec4c700"));\n                                    if (pService != nullptr) {\n                                        // Find MIDI characteristic\n                                        blemidi').concat(n,'_char = pService->getCharacteristic(BLEUUID("7772e5db-3868-4112-a1a9-f2669d106bf3"));\n                                        if (blemidi').concat(n,"_char != nullptr && blemidi").concat(n,"_char->canNotify()) {\n                                            // Register notification callback\n                                            blemidi").concat(n,"_char->registerForNotify([](BLERemoteCharacteristic* pChar, uint8_t* pData, size_t length, bool isNotify) {\n                                                blemidi_parsePacket").concat(n,"(pData, length);\n                                            });\n                                            blemidi").concat(n,'_connected = true;\n                                            Serial.println("BLE MIDI: Connected and subscribed!");\n                                        }\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                        } // if pResults != nullptr\n                        pScan->clearResults();\n                        blemidi').concat(n,"_scanning = false;\n                    }\n                }\n            } else {\n                // Check if still connected\n                if (blemidi").concat(n,"_client != nullptr && !blemidi").concat(n,"_client->isConnected()) {\n                    blemidi").concat(n,'_connected = false;\n                    Serial.println("BLE MIDI: Disconnected, will retry...");\n                }\n            }\n        }\n')}},{key:"generateBLEMIDIHelpers",value:function(e,n){return e.params.channel,"\n// BLE MIDI ".concat(n," packet parser - called from notification callback\nvoid blemidi_parsePacket").concat(n,"(uint8_t* data, size_t length) {\n    if (length < 3) return; // Minimum: header + timestamp + status\n\n    // BLE MIDI packet format:\n    // Byte 0: Header (bit 7 set, bits 0-5 = timestamp high)\n    // Byte 1: Timestamp low (bit 7 set)\n    // Byte 2+: MIDI data with optional timestamps\n\n    size_t pos = 0;\n\n    // Skip header byte\n    if (!(data[pos] & 0x80)) return;\n    blemidi").concat(n,"_timestamp = (data[pos] & 0x3F) << 7;\n    pos++;\n\n    while (pos < length) {\n        uint8_t b = data[pos];\n\n        // Timestamp byte (bit 7 set, not a status byte pattern)\n        if ((b & 0x80) && pos < length - 1) {\n            // Check if this looks like a timestamp (next byte is status or data)\n            uint8_t next = data[pos + 1];\n            if (next >= 0x80 && next <= 0xEF) {\n                // This is a timestamp, next is status\n                blemidi").concat(n,"_timestamp = (blemidi").concat(n,"_timestamp & 0x1F80) | (b & 0x7F);\n                pos++;\n                continue;\n            }\n        }\n\n        // Status byte\n        if (b >= 0x80 && b <= 0xEF) {\n            blemidi").concat(n,"_runningStatus = b;\n            pos++;\n            continue;\n        }\n\n        // Data bytes - process based on running status\n        if (blemidi").concat(n,"_runningStatus >= 0x80 && blemidi").concat(n,"_runningStatus <= 0xEF) {\n            uint8_t msgType = blemidi").concat(n,"_runningStatus & 0xF0;\n            uint8_t rxChannel = (blemidi").concat(n,"_runningStatus & 0x0F) + 1;\n\n            // Check channel filter (0 = omni)\n            bool channelMatch = (blemidi").concat(n,"_channel == 0 || blemidi").concat(n,"_channel == rxChannel);\n\n            if (msgType == 0x90 || msgType == 0x80) {\n                // Note On/Off - need 2 data bytes\n                if (pos + 1 < length) {\n                    uint8_t note = data[pos] & 0x7F;\n                    uint8_t velocity = data[pos + 1] & 0x7F;\n                    pos += 2;\n\n                    bool isNoteOn = (msgType == 0x90) && (velocity > 0);\n\n                    if (channelMatch) {\n                        if (isNoteOn) {\n                            blemidi").concat(n,"_lastNote = note;\n                            blemidi").concat(n,"_gate = true;\n                            // Normalize note to 0-1 (C3-C7 = MIDI 48-96)\n                            float normalizedNote = (note - 48.0f) / 48.0f;\n                            blemidi").concat(n,"_note = constrain(normalizedNote, 0.0f, 1.0f);\n                            blemidi").concat(n,"_velocity = velocity / 127.0f;\n                        } else {\n                            // Note Off - only release if it matches last note (mono behavior)\n                            if (note == blemidi").concat(n,"_lastNote) {\n                                blemidi").concat(n,"_gate = false;\n                            }\n                        }\n                    }\n                } else {\n                    break; // Incomplete message\n                }\n            } else if (msgType == 0xB0) {\n                // Control Change - need 2 data bytes\n                if (pos + 1 < length) {\n                    // uint8_t cc = data[pos] & 0x7F;\n                    // uint8_t value = data[pos + 1] & 0x7F;\n                    pos += 2;\n                    // CC handling can be added here if needed\n                } else {\n                    break;\n                }\n            } else if (msgType == 0xC0 || msgType == 0xD0) {\n                // Program Change or Channel Pressure - 1 data byte\n                pos++;\n            } else if (msgType == 0xE0) {\n                // Pitch Bend - 2 data bytes\n                if (pos + 1 < length) {\n                    pos += 2;\n                } else {\n                    break;\n                }\n            } else {\n                pos++; // Unknown, skip\n            }\n        } else {\n            pos++; // No running status, skip\n        }\n    }\n}\n")}},{key:"generateProcessingCode",value:function(e,n,t){return this.generateControlCode(e,n,t)}}])&&Fe(e.prototype,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function Ge(e){return Ge="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Ge(e)}function qe(e,n){var t="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=Ve(e))||n&&e&&"number"==typeof e.length){t&&(e=t);var a=0,o=function(){};return{s:o,n:function(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function(e){throw e},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var c,r=!0,i=!1;return{s:function(){t=t.call(e)},n:function(){var e=t.next();return r=e.done,e},e:function(e){i=!0,c=e},f:function(){try{r||null==t.return||t.return()}finally{if(i)throw c}}}}function Ue(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,c,r,i=[],l=!0,s=!1;try{if(c=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=c.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(r=t.return(),Object(r)!==r))return}finally{if(s)throw o}}return i}}(e,n)||Ve(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function We(e){return function(e){if(Array.isArray(e))return He(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||Ve(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Ve(e,n){if(e){if("string"==typeof e)return He(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?He(e,n):void 0}}function He(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}function je(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function Ke(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?je(Object(t),!0).forEach(function(n){$e(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):je(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function Ye(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,Xe(a.key),a)}}function $e(e,n,t){return(n=Xe(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function Xe(e){var n=function(e){if("object"!=Ge(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=Ge(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==Ge(n)?n:n+""}var Ze=function(){function e(n,t){var a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e);var o=this.resolvePanelConnections(n,t),c=o.modules,r=o.connections;this.modules=c,this.connections=this.resolveGroupConnections(r,a),this.groups=a,this.audioChain=[],this.controlChain=[],this.includes=new Set,this.globalVariables=[],this.moduleClasses=[],this.setupCode=[],this.loopCode=[],this.potConnectionCode=[],this.controlConnectionCode=[],this.declaredPots=new Set,this.declaredButtons=new Set,this.updateAudioCode=[],this.modularInstances=new Map,this.connectionResolver=new ae(this.modules,this.connections),this.pinMapper=ie,this.baseTemplate=be,this.audioModules=new Pe(this.connectionResolver),this.sampleModules=new Re(this.connectionResolver),this.controlModules=new Be(this.connectionResolver),this.hardwareModules=new ze(this.connectionResolver)}return n=e,(t=[{key:"resolvePanelConnections",value:function(n,t){var a=new Map,o=[];t.forEach(function(n){var t=Ke({},n),c=n.from.id.split(":")[0];if(c.startsWith("panel_")){var r=e.PANEL_PORT_MAP[c];if(r){a.has(r.virtualId)||a.set(r.virtualId,{id:r.virtualId,type:r.type,x:0,y:0,params:{index:r.index||1,bank:n.from.bank||1,_panelGenerated:!0}});var i=n.from.id.split(":"),l=("panel_midiIn"===c||"panel_midiOut"===c)&&i.length>1?i[1]:r.port;t.from={id:"".concat(r.virtualId,":").concat(l),port:l,kind:r.kind,bank:n.from.bank||1}}}var s=n.to.id.split(":")[0];if(s.startsWith("panel_")){var u=e.PANEL_PORT_MAP[s];if(u){a.has(u.virtualId)||a.set(u.virtualId,{id:u.virtualId,type:u.type,x:0,y:0,params:{index:u.index||1,bank:n.to.bank||1,_panelGenerated:!0}});var d=n.to.id.split(":"),p=("panel_midiIn"===s||"panel_midiOut"===s)&&d.length>1?d[1]:u.port;t.to={id:"".concat(u.virtualId,":").concat(p),port:p,kind:u.kind,bank:n.to.bank||1}}}o.push(t)});var c=[].concat(We(n),We(a.values()));return console.log("Panel resolution: Created virtual modules:",Array.from(a.keys())),console.log("Panel resolution: Total modules after:",c.length),{modules:c,connections:o}}},{key:"resolveGroupConnections",value:function(e,n){return n&&0!==n.length?e.map(function(e){var t=Ke({},e),a=e.from.id.split(":")[0],o=n.find(function(e){return e.id===a});if(o){var c,r=e.from.id,i=e.from.port,l=null===(c=o.outputPorts)||void 0===c?void 0:c.find(function(e){return"".concat(o.id,":out_").concat(e.sourcePort)===r||i==="out_".concat(e.port)});l&&(t.from={id:"".concat(l.sourceModuleId,":").concat(l.sourcePort),port:l.sourcePort,kind:e.from.kind})}var s=e.to.id.split(":")[0],u=n.find(function(e){return e.id===s});if(u){var d,p=e.to.id,f=e.to.port,m=null===(d=u.inputPorts)||void 0===d?void 0:d.find(function(e){return"".concat(u.id,":in_").concat(e.targetPort)===p||f==="in_".concat(e.port)});m&&(t.to={id:"".concat(m.targetModuleId,":").concat(m.targetPort),port:m.targetPort,kind:e.to.kind})}return t}):e}},{key:"getPotReference",value:function(e){var n=this.modules.find(function(n){return n.id===e});if(n&&"Pot"===n.type){var t=n.params.index||1;return n.params.bank,"pot".concat(t)}return console.warn("getPotReference called with non-Pot module: ".concat(e)),null}},{key:"generateBankAwareAssignment",value:function(e,n){var t=this.modules.find(function(n){return n.id===e});if(!t||"Pot"!==t.type)return"        // WARNING: Invalid pot reference for ".concat(e);var a=t.params.bank||1;return t.params.locked?"        ".concat(n," // Pot").concat(t.params.index," (LOCKED across all banks)"):"        if (currentBank == ".concat(a,") { ").concat(n," } // Pot").concat(t.params.index," Bank ").concat(a)}},{key:"generateBankAwareButtonAssignment",value:function(e,n){var t=this.modules.find(function(n){return n.id===e});if(!t||"LEDButton"!==t.type)return"        // WARNING: Invalid button reference for ".concat(e);var a=t.params.bank||1;return t.params.locked?"        ".concat(n," // Button").concat(t.params.index," (LOCKED)"):"        if (currentBank == ".concat(a,") { ").concat(n," } // Button").concat(t.params.index," Bank ").concat(a)}},{key:"getButtonReference",value:function(e){var n,t=this.modules.find(function(n){return n.id===e});if(t&&"LEDButton"===t.type){var a=t.params&&t.params.index?t.params.index:1;return"btn".concat(a)}var o=(null===(n=e.match(/\d+$/))||void 0===n?void 0:n[0])||"1";return"btn".concat(o)}},{key:"getWaveTypeIndex",value:function(e){switch(e.toLowerCase()){case"sine":default:return 0;case"sawtooth":case"saw":return 1;case"square":return 2;case"triangle":case"tri":return 3}}},{key:"generate",value:function(){return console.log("Starting code generation..."),console.log("Modules:",this.modules),console.log("Connections:",this.connections),this.analyzeModules(),this.resolveAudioChain(),this.resolveControlChain(),this.generateIncludes(),this.generateModuleClasses(),this.generateVariables(),this.generateGlobalFunctions(),this.generateSetup(),this.generateLoop(),console.log("Audio chain:",this.audioChain),console.log("Control chain:",this.controlChain),console.log("Hardware modules:",this.hardwareModules),this.assembleCode()}},{key:"analyzeModules",value:function(){}},{key:"generateModuleClasses",value:function(){var e=this,n={Looper:$,BPMLooper:X};this.modules.filter(function(e){return n[e.type]}).forEach(function(t,a){var o=n[t.type];if(o&&o.generateClass){var c=o.generateClass(t.id||a,t.params||{});e.moduleClasses.push(c);var r=(t.id||"".concat(t.type).concat(a)).toLowerCase(),i="".concat(t.type,"_").concat(t.id||a);if(e.moduleClasses.push("\n// Instance of ".concat(t.type," module\n").concat(i," ").concat(r,";\nfloat ").concat(r,"_inputL = 0.0f;\nfloat ").concat(r,"_inputR = 0.0f;\n")),e.modularInstances.set(t.id||"".concat(t.type).concat(a),{instanceName:r,moduleId:t.id||a,type:t.type,originalIndex:a}),o.generateIncludes){var l=o.generateIncludes();l&&e.includes.add(l)}console.log("Generated class and instance for ".concat(t.type," module"))}})}},{key:"resolveAudioChain",value:function(){this.audioChain=this.connectionResolver.resolveAudioChain();var e=new Set;this.audioChain=this.audioChain.filter(function(n){return e.has(n.id)?(console.warn("Removing duplicate ".concat(n.type," ").concat(n.id," from audioChain")),!1):(e.add(n.id),!0)})}},{key:"resolveControlChain",value:function(){var e=this.modules.filter(function(e){return["ADSR","Scale","LFO","Clock","HarmonicSequencer","Automation","Arpeggiator","MIDILooper"].includes(e.type)});this.controlChain=this.topologicalSortControl(e)}},{key:"topologicalSortControl",value:function(e){var n=this,t=[],a=new Set,o=new Set,c=function(r){o.has(r.id)?console.warn("Circular dependency detected in control modules"):a.has(r.id)||(o.add(r.id),n.connections.filter(function(e){return e.to&&"string"==typeof e.to?e.to===r.id:!(!e.to||!e.to.id)&&e.to.id.startsWith(r.id+":")}).map(function(e){return e.from&&"string"==typeof e.from?e.from:e.from&&e.from.id?e.from.id.split(":")[0]:null}).map(function(n){return e.find(function(e){return e.id===n})}).filter(Boolean).forEach(function(e){return c(e)}),o.delete(r.id),a.add(r.id),t.push(r))};return e.forEach(function(e){return c(e)}),t}},{key:"generateIncludes",value:function(){var e=this;this.baseTemplate.generateIncludes().forEach(function(n){e.includes.add(n)}),this.modules.forEach(function(n){switch(e.audioModules.generateIncludes(n.type).forEach(function(n){return e.includes.add(n)}),e.controlModules.generateIncludes(n.type).forEach(function(n){return e.includes.add(n)}),n.type){case"Filter":case"GranularSynth":case"GranularPSRAM":case"GranularDense":e.includes.add("#include <math.h>");break;case"Looper":case"BPMLooper":e.includes.add("#include <cstring>");break;case"AdvancedLooper":e.includes.add("#include <SPIFFS.h>"),e.includes.add("#include <SD.h>"),e.includes.add("#include <esp_heap_caps.h>"),e.includes.add('#include "driver/i2s.h"'),e.includes.add("#include <cstring>");break;case"MIDIIn":case"MIDIOut":break;case"USBMIDIIn":case"USBMIDIOut":e.includes.add('#include "USB.h"'),e.includes.add('#include "USBMIDI.h"');break;case"BLEMIDIIn":e.includes.add("#include <BLEDevice.h>"),e.includes.add("#include <BLEUtils.h>"),e.includes.add("#include <BLEScan.h>"),e.includes.add("#include <BLEAdvertisedDevice.h>");break;case"SDPlayer":case"SamplePlayer":case"KickDrum":case"SnareDrum":case"AudioRecorder":e.includes.add("#include <SD.h>"),e.includes.add("#include <FS.h>"),e.includes.add("#include <SPI.h>")}})}},{key:"generateVariables",value:function(){var e=this;this.globalVariables.push("\n// I2S Configuration for PCM5102A DAC\nstatic const int I2S_BCLK = ".concat(Z.I2S_BCLK,";\nstatic const int I2S_LRCK = ").concat(Z.I2S_LRCK,";\nstatic const int I2S_DATA = ").concat(Z.I2S_DATA,";\nstatic const int SAMPLE_RATE = ").concat(Z.SAMPLE_RATE,";\nstatic const int BUFFER_SIZE = ").concat(Z.BUFFER_SIZE,";\n        ")),this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type})&&this.globalVariables.push('\n// WAV File Structure (only included when Sample Player modules are present)\nstruct WAVHeader {\n    char riff[4];           // "RIFF"\n    uint32_t fileSize;      // File size - 8\n    char wave[4];           // "WAVE"\n    char fmt[4];            // "fmt "\n    uint32_t fmtSize;       // Format chunk size\n    uint16_t audioFormat;   // Audio format (1 = PCM)\n    uint16_t numChannels;   // Number of channels\n    uint32_t sampleRate;    // Sample rate\n    uint32_t byteRate;      // Byte rate\n    uint16_t blockAlign;    // Block align\n    uint16_t bitsPerSample; // Bits per sample\n    char data[4];           // "data"\n    uint32_t dataSize;      // Data size\n};\n\n// Double Buffer WAV Player Class - Eliminates audio gaps and stuttering\n#define CHUNK_SIZE (16 * 1024)  // 16KB chunks - sector aligned, ~0.09 seconds\n\n// Polyphonic Sample Player with PSRAM caching (2MB optimized)\n#define MAX_VOICES 8                    // Maximum possible voices (will be limited per module)\n#define VOICE_CACHE_SIZE 1024           // 1024 samples per voice cache (internal RAM)\n#define AUDIO_BLOCK_SIZE 256            // Audio processing block size\n#define MAX_PSRAM_SAMPLES (1536 * 1024) // 1.5MB for sample storage\n#define SAMPLE_POOL_SIZE 32             // Maximum 32 different samples loaded\n\n// Ring buffer for credit-based file transfers\n#define RING_BUFFER_SIZE 262144         // 256KB ring buffer in PSRAM\n\nstruct Voice {\n    // PSRAM sample reference\n    int16_t* psramData;              // Pointer to PSRAM sample data\n    uint32_t totalFrames;            // Total frames in this sample (mono or stereo pairs)\n    uint32_t startFrame;             // Start position (0.0-1.0 * totalFrames)\n    uint32_t endFrame;               // End position (0.0-1.0 * totalFrames)\n    uint8_t channels;                // 1=mono, 2=stereo\n    \n    // Playback state (16.16 fixed point for smooth pitch control)\n    uint32_t phase;                  // Current playback position (16.16 fixed point)\n    uint32_t phaseInc;               // Phase increment per sample (pitch * 65536)\n    bool active;                     // Voice is currently playing\n    bool gateOn;                     // Gate signal is high\n    \n    // Hot cache in internal RAM (never blocks PSRAM)\n    alignas(32) int16_t cache[VOICE_CACHE_SIZE]; // 32-byte aligned for DMA efficiency\n    uint32_t cacheBase;              // Which part of sample is cached (frame number)\n    uint32_t cacheFrames;            // How many frames are valid in cache\n    bool cacheValid;                 // Cache contains valid data\n    \n    // Mixing parameters\n    int32_t gainL;                   // Left gain (Q15 format: 0-32767)\n    int32_t gainR;                   // Right gain (Q15 format: 0-32767)\n    \n    // Envelope for click-free triggering\n    uint32_t envPhase;               // Envelope phase (16.16 fixed point)\n    uint32_t envInc;                 // Envelope increment (attack/release speed)\n    bool envAttack;                  // true=attack, false=release\n    \n    // Constructor\n    Voice() : psramData(nullptr), totalFrames(0), startFrame(0), endFrame(0), channels(2),\n              phase(0), phaseInc(65536), active(false), gateOn(false),\n              cacheBase(0), cacheFrames(0), cacheValid(false),\n              gainL(32767), gainR(32767), envPhase(0), envInc(0), envAttack(false) {\n        memset(cache, 0, sizeof(cache));\n    }\n};\n\nstruct SampleEntry {\n    int16_t* psramData;              // PSRAM allocation for this sample\n    uint32_t totalFrames;            // Total frames in sample\n    uint8_t channels;                // 1=mono, 2=stereo\n    String filename;                 // Original filename for reference\n    uint32_t sizeBytes;              // Size in bytes (for memory management)\n    bool loaded;                     // Successfully loaded into PSRAM\n    \n    SampleEntry() : psramData(nullptr), totalFrames(0), channels(2), \n                    sizeBytes(0), loaded(false) {}\n};\n\nclass PolyphonicSamplePlayer {\nprivate:\n    Voice voices[MAX_VOICES];\n    SampleEntry samplePool[SAMPLE_POOL_SIZE];\n    uint32_t usedPSRAM;              // Track PSRAM usage\n    int activeVoiceCount;            // Configurable voice limit (1-8)\n    \n    // Mix buffers in internal RAM (never PSRAM - for I2S DMA)\n    alignas(32) int32_t mixBufferL[AUDIO_BLOCK_SIZE];\n    alignas(32) int32_t mixBufferR[AUDIO_BLOCK_SIZE];\n    alignas(32) int16_t outputBuffer[AUDIO_BLOCK_SIZE * 2]; // Interleaved L/R\n    \n    // Voice allocation\n    int findFreeVoice() {\n        for (int i = 0; i < activeVoiceCount; i++) {\n            if (!voices[i].active) return i;\n        }\n        // Steal oldest voice (voice 0 is oldest)\n        return 0;\n    }\n    \n    // Ensure voice cache contains the data needed for next block\n    void ensureVoiceCache(Voice& v) {\n        if (!v.active || !v.psramData) return;\n        \n        uint32_t neededStart = v.phase >> 16;  // Current frame position\n        uint32_t neededEnd = neededStart + (AUDIO_BLOCK_SIZE * 2); // Worst case: 2x pitch up\n        \n        // Check if cache already contains needed data\n        if (v.cacheValid && neededStart >= v.cacheBase && \n            neededEnd < (v.cacheBase + v.cacheFrames)) {\n            return; // Cache hit - no reload needed\n        }\n        \n        // Cache miss - reload from PSRAM\n        uint32_t cacheStart = neededStart;\n        uint32_t cacheDuration = VOICE_CACHE_SIZE / v.channels;\n        \n        // Handle loop wrapping\n        if (v.endFrame > v.startFrame) {\n            uint32_t loopLength = v.endFrame - v.startFrame;\n            if (cacheStart >= v.endFrame) {\n                cacheStart = v.startFrame + ((cacheStart - v.startFrame) % loopLength);\n            }\n            \n            // Don\'t cache beyond end position\n            uint32_t maxEnd = min(cacheStart + cacheDuration, v.endFrame);\n            cacheDuration = maxEnd - cacheStart;\n        }\n        \n        // Clamp to sample bounds\n        cacheStart = min(cacheStart, v.totalFrames);\n        cacheDuration = min(cacheDuration, v.totalFrames - cacheStart);\n        cacheDuration = min(cacheDuration, (uint32_t)VOICE_CACHE_SIZE / v.channels);\n        \n        // Copy from PSRAM to cache (this is the only PSRAM read per voice per block)\n        if (cacheDuration > 0) {\n            uint32_t samplesToCopy = cacheDuration * v.channels;\n            memcpy(v.cache, v.psramData + (cacheStart * v.channels), \n                   samplesToCopy * sizeof(int16_t));\n            \n            v.cacheBase = cacheStart;\n            v.cacheFrames = cacheDuration;\n            v.cacheValid = true;\n        }\n    }\n    \n    // Linear interpolation for smooth pitch control\n    inline int16_t lerp16(const int16_t* buf, uint32_t frac16, uint32_t i0, uint32_t maxSamples) {\n        if (i0 + 1 >= maxSamples) return buf[i0];\n        \n        int32_t a = buf[i0];\n        int32_t b = buf[i0 + 1];\n        int32_t t = frac16 & 0xFFFF;  // 0..65535\n        return (int16_t)((a * (65536 - t) + b * t) >> 16);\n    }\n    \npublic:\n    PolyphonicSamplePlayer() : usedPSRAM(0), activeVoiceCount(6) {\n        // Initialize sample pool\n        for (int i = 0; i < SAMPLE_POOL_SIZE; i++) {\n            samplePool[i] = SampleEntry();\n        }\n        \n        // Clear mix buffers\n        memset(mixBufferL, 0, sizeof(mixBufferL));\n        memset(mixBufferR, 0, sizeof(mixBufferR));\n        memset(outputBuffer, 0, sizeof(outputBuffer));\n    }\n    \n    // Set maximum concurrent voices (1-8)\n    void setVoiceCount(int voiceCount) {\n        activeVoiceCount = constrain(voiceCount, 1, MAX_VOICES);\n        Serial.printf("Voice count set to: %d\\n", activeVoiceCount);\n    }\n    \n    int getVoiceCount() const { return activeVoiceCount; }\n    \n    // Load sample into PSRAM pool\n    bool loadSample(int sampleIndex, const String& filename) {\n        if (sampleIndex < 0 || sampleIndex >= SAMPLE_POOL_SIZE) return false;\n        \n        SampleEntry& entry = samplePool[sampleIndex];\n        \n        // Free existing sample if present\n        if (entry.loaded && entry.psramData) {\n            heap_caps_free(entry.psramData);\n            usedPSRAM -= entry.sizeBytes;\n            entry.loaded = false;\n        }\n        \n        // Open WAV file\n        File wavFile = SD.open(filename);\n        if (!wavFile) return false;\n        \n        // Read WAV header\n        WAVHeader header;\n        if (wavFile.read((uint8_t*)&header, sizeof(header)) != sizeof(header)) {\n            wavFile.close();\n            return false;\n        }\n        \n        // Validate WAV format\n        if (strncmp(header.riff, "RIFF", 4) != 0 || \n            strncmp(header.wave, "WAVE", 4) != 0 ||\n            header.audioFormat != 1 || \n            header.bitsPerSample != 16) {\n            wavFile.close();\n            return false;\n        }\n        \n        // Calculate sample size\n        uint32_t totalSamples = header.dataSize / sizeof(int16_t);\n        uint32_t totalFrames = totalSamples / header.numChannels;\n        uint32_t sizeBytes = header.dataSize;\n        \n        // Check PSRAM budget\n        if (usedPSRAM + sizeBytes > MAX_PSRAM_SAMPLES * sizeof(int16_t)) {\n            wavFile.close();\n            return false; // Not enough PSRAM\n        }\n        \n        // Allocate PSRAM\n        int16_t* psramBuffer = (int16_t*)heap_caps_malloc(sizeBytes, MALLOC_CAP_SPIRAM);\n        if (!psramBuffer) {\n            wavFile.close();\n            return false;\n        }\n        \n        // Load entire sample into PSRAM\n        size_t bytesRead = wavFile.read((uint8_t*)psramBuffer, sizeBytes);\n        wavFile.close();\n        \n        if (bytesRead != sizeBytes) {\n            heap_caps_free(psramBuffer);\n            return false;\n        }\n        \n        // Update sample entry\n        entry.psramData = psramBuffer;\n        entry.totalFrames = totalFrames;\n        entry.channels = header.numChannels;\n        entry.filename = filename;\n        entry.sizeBytes = sizeBytes;\n        entry.loaded = true;\n        usedPSRAM += sizeBytes;\n        \n        return true;\n    }\n    \n    // Trigger voice with sample\n    void triggerVoice(int sampleIndex, float pitch = 1.0f, float startPos = 0.0f, \n                     float endPos = 1.0f, float gainL = 1.0f, float gainR = 1.0f) {\n        if (sampleIndex < 0 || sampleIndex >= SAMPLE_POOL_SIZE) return;\n        if (!samplePool[sampleIndex].loaded) return;\n        \n        int voiceIndex = findFreeVoice();\n        Voice& v = voices[voiceIndex];\n        SampleEntry& sample = samplePool[sampleIndex];\n        \n        // Set up voice parameters\n        v.psramData = sample.psramData;\n        v.totalFrames = sample.totalFrames;\n        v.channels = sample.channels;\n        v.startFrame = (uint32_t)(startPos * sample.totalFrames);\n        v.endFrame = (uint32_t)(endPos * sample.totalFrames);\n        if (v.endFrame <= v.startFrame) v.endFrame = sample.totalFrames;\n        \n        // Set playback parameters\n        v.phase = v.startFrame << 16; // Start at begin position\n        v.phaseInc = (uint32_t)(pitch * 65536.0f); // Fixed point pitch\n        v.gainL = (int32_t)(gainL * 32767.0f);\n        v.gainR = (int32_t)(gainR * 32767.0f);\n        \n        // Initialize envelope for click-free start\n        v.envPhase = 0;\n        v.envInc = 65536 / 64; // 64-sample attack\n        v.envAttack = true;\n        \n        // Mark voice as active\n        v.active = true;\n        v.gateOn = true;\n        v.cacheValid = false; // Force cache reload\n    }\n    \n    // Release voice (envelope-based)\n    void releaseVoice(int voiceIndex) {\n        if (voiceIndex < 0 || voiceIndex >= MAX_VOICES) return;\n        \n        Voice& v = voices[voiceIndex];\n        if (v.active) {\n            v.gateOn = false;\n            v.envAttack = false;\n            v.envInc = 65536 / 128; // 128-sample release\n        }\n    }\n    \n    // Release all active voices (for button release behavior)\n    void releaseAllVoices() {\n        for (int i = 0; i < activeVoiceCount; i++) {\n            if (voices[i].active && voices[i].gateOn) {\n                voices[i].gateOn = false;\n                voices[i].envAttack = false; \n                voices[i].envInc = 65536 / 128; // 128-sample release\n            }\n        }\n    }\n    \n    // Get number of active voices\n    int getActiveVoices() {\n        int count = 0;\n        for (int i = 0; i < activeVoiceCount; i++) {\n            if (voices[i].active) count++;\n        }\n        return count;\n    }\n    \n    // Check if voice is active\n    bool isVoiceActive(int voiceIndex) {\n        if (voiceIndex < 0 || voiceIndex >= activeVoiceCount) return false;\n        return voices[voiceIndex].active;\n    }\n    \n    // Sustain voice (prevent auto-release)\n    void sustainVoice(int voiceIndex) {\n        if (voiceIndex < 0 || voiceIndex >= activeVoiceCount) return;\n        Voice& v = voices[voiceIndex];\n        if (v.active) {\n            v.gateOn = true;  // Keep gate on\n            if (!v.envAttack && v.envPhase < 65536) {\n                v.envAttack = true; // Resume attack if needed\n            }\n        }\n    }\n    \n    // Render audio block (main audio processing)\n    void renderBlock() {\n        // Clear mix buffers\n        memset(mixBufferL, 0, sizeof(mixBufferL));\n        memset(mixBufferR, 0, sizeof(mixBufferR));\n        \n        // Process each active voice\n        for (int v = 0; v < activeVoiceCount; v++) {\n            Voice& voice = voices[v];\n            if (!voice.active) continue;\n            \n            // Ensure cache contains needed data (only PSRAM access per voice)\n            ensureVoiceCache(voice);\n            \n            // Render voice into mix buffer\n            for (int n = 0; n < AUDIO_BLOCK_SIZE; n++) {\n                // Update envelope\n                if (voice.envAttack) {\n                    voice.envPhase += voice.envInc;\n                    if (voice.envPhase >= 65536) {\n                        voice.envPhase = 65536;\n                        voice.envAttack = false;\n                    }\n                } else if (!voice.gateOn) {\n                    if (voice.envPhase > voice.envInc) {\n                        voice.envPhase -= voice.envInc;\n                    } else {\n                        voice.envPhase = 0;\n                        voice.active = false; // Voice finished\n                        break;\n                    }\n                }\n                \n                // Get current frame position\n                uint32_t currentFrame = voice.phase >> 16;\n                \n                // Check loop bounds\n                if (currentFrame >= voice.endFrame) {\n                    if (voice.gateOn) {\n                        // Loop back to start\n                        uint32_t loopLength = voice.endFrame - voice.startFrame;\n                        if (loopLength > 0) {\n                            currentFrame = voice.startFrame + ((currentFrame - voice.startFrame) % loopLength);\n                            voice.phase = (currentFrame << 16) | (voice.phase & 0xFFFF);\n                        }\n                    } else {\n                        // Stop voice if gate is off\n                        voice.active = false;\n                        break;\n                    }\n                }\n                \n                // Read from cache with interpolation\n                if (voice.cacheValid && currentFrame >= voice.cacheBase && \n                    currentFrame < voice.cacheBase + voice.cacheFrames) {\n                    \n                    uint32_t cacheIndex = (currentFrame - voice.cacheBase) * voice.channels;\n                    uint32_t maxCacheSamples = voice.cacheFrames * voice.channels;\n                    \n                    int16_t sampleL, sampleR;\n                    \n                    if (voice.channels == 2) {\n                        // Stereo\n                        sampleL = lerp16(voice.cache, voice.phase, cacheIndex, maxCacheSamples);\n                        sampleR = lerp16(voice.cache, voice.phase, cacheIndex + 1, maxCacheSamples);\n                    } else {\n                        // Mono to stereo\n                        sampleL = sampleR = lerp16(voice.cache, voice.phase, cacheIndex, maxCacheSamples);\n                    }\n                    \n                    // Apply envelope and gain, mix into buffer\n                    int32_t env = voice.envPhase;\n                    int32_t mixL = (sampleL * voice.gainL * env) >> 12; // >> 12 for balanced headroom\n                    int32_t mixR = (sampleR * voice.gainR * env) >> 12;\n                    \n                    mixBufferL[n] += mixL;\n                    mixBufferR[n] += mixR;\n                }\n                \n                // Advance phase\n                voice.phase += voice.phaseInc;\n            }\n        }\n        \n        // Convert to output format with saturation\n        for (int n = 0; n < AUDIO_BLOCK_SIZE; n++) {\n            int32_t L = mixBufferL[n];\n            int32_t R = mixBufferR[n];\n            \n            // Saturate to 16-bit range\n            if (L > 32767) L = 32767;\n            else if (L < -32768) L = -32768;\n            if (R > 32767) R = 32767;\n            else if (R < -32768) R = -32768;\n            \n            outputBuffer[n * 2] = (int16_t)L;\n            outputBuffer[n * 2 + 1] = (int16_t)R;\n        }\n    }\n    \n    // Get next stereo sample (for compatibility with existing code)\n    void getStereoSample(float& left, float& right) {\n        static int blockIndex = 0;\n        static bool blockReady = false;\n        \n        // Render new block when needed\n        if (!blockReady || blockIndex >= AUDIO_BLOCK_SIZE) {\n            renderBlock();\n            blockIndex = 0;\n            blockReady = true;\n        }\n        \n        // Return current sample from block\n        left = outputBuffer[blockIndex * 2] / 32767.0f;\n        right = outputBuffer[blockIndex * 2 + 1] / 32767.0f;\n        blockIndex++;\n    }\n    \n    // Memory usage info\n    uint32_t getPSRAMUsage() const { return usedPSRAM; }\n    uint32_t getPSRAMFree() const { return MAX_PSRAM_SAMPLES * sizeof(int16_t) - usedPSRAM; }\n    int getActiveVoices() const {\n        int count = 0;\n        for (int i = 0; i < activeVoiceCount; i++) {\n            if (voices[i].active) count++;\n        }\n        return count;\n    }\n};\n\nclass MinimalWAVPlayer {\nprivate:\n    File wavFile;\n    WAVHeader header;\n    \n    // Double buffering for seamless playback\n    int16_t* bufferA;\n    int16_t* bufferB;\n    int16_t* playingBuffer;       // Currently being played\n    int16_t* loadingBuffer;       // Being loaded in background\n    \n    uint32_t totalDataBytes;      // Total bytes in WAV data section\n    uint32_t filePosition;        // Current position in file (bytes from start of data)\n    uint32_t playingSamples;      // Samples in currently playing buffer\n    uint32_t playPosition;        // Current play position within playing buffer (legacy)\n    float fractionalPosition;     // Fractional position for pitch control\n    \n    bool isPlaying;\n    bool fileEnded;\n    uint16_t channels;\n    \n    // Control variables for new functionality\n    float playbackSpeed;          // Playback speed multiplier (0.1 to 4.0)\n    float startPosition;          // Start position (0.0 to 1.0)  \n    float endPosition;            // End position (0.0 to 1.0)\n    \n    // Background loading task\n    TaskHandle_t loaderTaskHandle;\n    SemaphoreHandle_t bufferMutex;\n    volatile bool loadingBufferReady;\n    volatile uint32_t loadingBufferSamples;\n    \npublic:\n    MinimalWAVPlayer() : bufferA(nullptr), bufferB(nullptr), totalDataBytes(0), filePosition(0),\n                         playingSamples(0), playPosition(0), fractionalPosition(0.0f), isPlaying(false),\n                         fileEnded(false), channels(2), playbackSpeed(1.0f), startPosition(0.0f), \n                         endPosition(1.0f), loaderTaskHandle(NULL), loadingBufferReady(false), \n                         loadingBufferSamples(0) {\n        \n        // Allocate double buffers\n        bufferA = (int16_t*)heap_caps_malloc(CHUNK_SIZE, MALLOC_CAP_SPIRAM);\n        bufferB = (int16_t*)heap_caps_malloc(CHUNK_SIZE, MALLOC_CAP_SPIRAM);\n        \n        if (!bufferA || !bufferB) {\n            if (bufferA) free(bufferA);\n            if (bufferB) free(bufferB);\n            bufferA = (int16_t*)malloc(CHUNK_SIZE);\n            bufferB = (int16_t*)malloc(CHUNK_SIZE);\n        }\n        \n        if (bufferA && bufferB) {\n            playingBuffer = bufferA;\n            loadingBuffer = bufferB;\n            bufferMutex = xSemaphoreCreateMutex();\n        }\n    }\n    \n    bool loadFile(const String& filename) {\n        if (!bufferA || !bufferB) return false;\n        \n        // Stop any existing playback\n        stop();\n        \n        // Close any existing file\n        if (wavFile) {\n            wavFile.close();\n        }\n        \n        // Reset all state\n        filePosition = 0;\n        playingSamples = 0;\n        playPosition = 0;\n        fractionalPosition = 0.0f;\n        isPlaying = false;\n        fileEnded = false;\n        loadingBufferReady = false;\n        \n        wavFile = SD.open(filename);\n        if (!wavFile) {\n            return false;\n        }\n        \n        // Read WAV header\n        if (wavFile.read((uint8_t*)&header, sizeof(WAVHeader)) != sizeof(WAVHeader)) {\n            wavFile.close();\n            return false;\n        }\n        \n        // Validate WAV file\n        if (strncmp(header.riff, "RIFF", 4) != 0 || strncmp(header.wave, "WAVE", 4) != 0) {\n            wavFile.close();\n            return false;\n        }\n        \n        channels = header.numChannels;\n        totalDataBytes = header.dataSize;\n        \n        // Load first buffer synchronously\n        loadFirstBuffer();\n        \n        return true;\n    }\n    \n    void play() {\n        if (bufferA && bufferB && playingSamples > 0 && !fileEnded) {\n            isPlaying = true;\n            playPosition = 0;\n            fractionalPosition = 0.0f;\n            \n            // Start background loading task\n            startBackgroundLoader();\n        }\n    }\n    \n    void stop() {\n        isPlaying = false;\n        \n        // Kill background loader task\n        if (loaderTaskHandle) {\n            vTaskDelete(loaderTaskHandle);\n            loaderTaskHandle = NULL;\n        }\n    }\n    \n    bool playing() { \n        return isPlaying && !fileEnded;\n    }\n    \n    // Pitch control methods\n    void setPlaybackSpeed(float speed) {\n        playbackSpeed = constrain(speed, 0.1f, 4.0f); // Limit to reasonable range\n    }\n    \n    // Sample section control methods\n    void setStartPosition(float pos) {\n        startPosition = constrain(pos, 0.0f, 1.0f);\n    }\n    \n    void setEndPosition(float pos) {\n        endPosition = constrain(pos, 0.0f, 1.0f);\n    }\n    \n    // Convenience method for mono output\n    float nextSample() {\n        float left, right;\n        getStereoSample(left, right);\n        return (left + right) * 0.5f; // Mix to mono\n    }\n    \n    // Load first buffer synchronously\n    void loadFirstBuffer() {\n        if (!wavFile || filePosition >= totalDataBytes) return;\n        \n        uint32_t bytesToRead = CHUNK_SIZE;\n        if (bytesToRead > totalDataBytes) {\n            bytesToRead = totalDataBytes;\n        }\n        \n        size_t bytesRead = wavFile.read((uint8_t*)playingBuffer, bytesToRead);\n        playingSamples = bytesRead / sizeof(int16_t);\n        playPosition = 0;\n        fractionalPosition = 0.0f;\n        filePosition += bytesRead;\n        \n        if (bytesRead < CHUNK_SIZE) {\n            memset((uint8_t*)playingBuffer + bytesRead, 0, CHUNK_SIZE - bytesRead);\n        }\n    }\n    \n    // Background loading task (static method)\n    static void backgroundLoaderTask(void* param) {\n        MinimalWAVPlayer* player = (MinimalWAVPlayer*)param;\n        \n        while (player->isPlaying && !player->fileEnded) {\n            // Only load if loading buffer is empty and we need more data\n            if (!player->loadingBufferReady && player->filePosition < player->totalDataBytes) {\n                player->loadNextBufferBackground();\n            }\n            \n            vTaskDelay(5); // 5ms delay\n        }\n        \n        player->loaderTaskHandle = NULL;\n        vTaskDelete(NULL);\n    }\n    \n    void startBackgroundLoader() {\n        if (loaderTaskHandle == NULL) {\n            xTaskCreatePinnedToCore(backgroundLoaderTask, "BGLoader", 4096, this, 1, &loaderTaskHandle, 0);\n        }\n    }\n    \n    void loadNextBufferBackground() {\n        if (!wavFile || filePosition >= totalDataBytes) {\n            fileEnded = true;\n            return;\n        }\n        \n        uint32_t bytesToRead = CHUNK_SIZE;\n        uint32_t remainingBytes = totalDataBytes - filePosition;\n        if (bytesToRead > remainingBytes) {\n            bytesToRead = remainingBytes;\n        }\n        \n        // Read into loading buffer\n        size_t bytesRead = wavFile.read((uint8_t*)loadingBuffer, bytesToRead);\n        filePosition += bytesRead;\n        \n        if (bytesRead < CHUNK_SIZE) {\n            memset((uint8_t*)loadingBuffer + bytesRead, 0, CHUNK_SIZE - bytesRead);\n        }\n        \n        // Atomically update ready status\n        if (xSemaphoreTake(bufferMutex, portMAX_DELAY)) {\n            loadingBufferSamples = bytesRead / sizeof(int16_t);\n            loadingBufferReady = true;\n            xSemaphoreGive(bufferMutex);\n        }\n    }\n    \n    // Get stereo sample - Double buffered, NEVER blocks, with pitch control and start/end positions\n    void getStereoSample(float& left, float& right, float pitchRatio = 0.0) {\n        left = 0.0f;\n        right = 0.0f;\n        \n        if (!isPlaying || !playingBuffer || fileEnded) {\n            // Debug: Print why no audio\n            static unsigned long lastNoAudioDebug = 0;\n            if (millis() - lastNoAudioDebug > 2000) {\n                lastNoAudioDebug = millis();\n                Serial.printf("No audio: isPlaying=%d, playingBuffer=%p, fileEnded=%d\\n", \n                             isPlaying, playingBuffer, fileEnded);\n            }\n            return;\n        }\n        \n        // Use internal playbackSpeed if no external pitch ratio provided\n        if (pitchRatio == 0.0) {\n            pitchRatio = playbackSpeed;\n        }\n        \n        // TODO: Implement start/end position support later\n        // For now, just play the full file to get basic audio working\n        // The complex file position tracking was breaking audio output\n        \n        // Check if we need to switch to the next buffer\n        // For stereo: fractionalPosition is in frames, playingSamples is individual samples\n        // For mono: fractionalPosition is in samples, playingSamples is individual samples\n        uint32_t maxFrames = (channels == 2) ? playingSamples / 2 : playingSamples;\n        if (fractionalPosition >= maxFrames) {\n            // Try to swap to the loading buffer if it\'s ready\n            if (loadingBufferReady && xSemaphoreTake(bufferMutex, 0)) {\n                // Swap buffers: loading becomes playing\n                int16_t* temp = playingBuffer;\n                playingBuffer = loadingBuffer;\n                loadingBuffer = temp;\n                \n                playingSamples = loadingBufferSamples;\n                fractionalPosition = 0.0f;\n                loadingBufferReady = false;\n                \n                xSemaphoreGive(bufferMutex);\n            } else {\n                // No ready buffer available - output silence (seamless gap)\n                if (filePosition >= totalDataBytes) {\n                    fileEnded = true;\n                }\n                return;\n            }\n        }\n        \n        // Read from playing buffer with pitch control (fractional sample reading)\n        if (channels == 2) {\n            // Stereo: fractionalPosition indexes sample pairs (L,R)\n            uint32_t frameIndex = (uint32_t)fractionalPosition; // Current stereo frame\n            uint32_t maxStereoFrames = playingSamples / 2;\n            \n            if (frameIndex < maxStereoFrames) {\n                uint32_t sampleL = frameIndex * 2;     // Left sample index\n                uint32_t sampleR = frameIndex * 2 + 1; // Right sample index\n                \n                // Always use simple sample reading - no interpolation for now\n                // This eliminates interpolation glitches while keeping pitch control working\n                left = playingBuffer[sampleL] / 32767.0f;\n                right = playingBuffer[sampleR] / 32767.0f;\n                \n                fractionalPosition += pitchRatio; // Advance by one frame\n                \n                // Debug: Print audio output occasionally\n                static unsigned long lastAudioDebug = 0;\n                static int audioSampleCount = 0;\n                audioSampleCount++;\n                if (millis() - lastAudioDebug > 2000) {\n                    lastAudioDebug = millis();\n                    Serial.printf("Audio OK: L=%.3f, R=%.3f, frame=%d/%d, fPos=%.2f, samples=%d\\n", \n                                 left, right, frameIndex, maxStereoFrames, fractionalPosition, audioSampleCount);\n                    audioSampleCount = 0;\n                }\n            } else {\n                left = right = 0.0f; // Silence if out of bounds\n                \n                // Debug: Print bounds issue\n                static unsigned long lastBoundsDebug = 0;\n                if (millis() - lastBoundsDebug > 2000) {\n                    lastBoundsDebug = millis();\n                    Serial.printf("Audio bounds: frame=%d >= maxFrames=%d, playingSamples=%d\\n", \n                                 frameIndex, maxStereoFrames, playingSamples);\n                }\n            }\n        } else {\n            // Mono to stereo with pitch control\n            uint32_t sampleIndex = (uint32_t)fractionalPosition;\n            if (sampleIndex < playingSamples) {\n                float mono;\n                \n                // Always use simple sample reading - no interpolation for now\n                // This eliminates interpolation glitches while keeping pitch control working\n                mono = playingBuffer[sampleIndex] / 32767.0f;\n                \n                left = mono;\n                right = mono;\n                fractionalPosition += pitchRatio; // Advance by pitch ratio\n                \n                // Debug: Print mono audio output occasionally\n                static unsigned long lastMonoDebug = 0;\n                static int monoSampleCount = 0;\n                monoSampleCount++;\n                if (millis() - lastMonoDebug > 2000) {\n                    lastMonoDebug = millis();\n                    Serial.printf("Mono OK: %.3f, idx=%d/%d, fPos=%.2f, samples=%d\\n", \n                                 mono, sampleIndex, playingSamples, fractionalPosition, monoSampleCount);\n                    monoSampleCount = 0;\n                }\n            } else {\n                left = right = 0.0f; // Silence if out of bounds\n                \n                // Debug: Print mono bounds issue\n                static unsigned long lastMonoBoundsDebug = 0;\n                if (millis() - lastMonoBoundsDebug > 2000) {\n                    lastMonoBoundsDebug = millis();\n                    Serial.printf("Mono bounds: idx=%d >= samples=%d\\n", sampleIndex, playingSamples);\n                }\n            }\n        }\n    }\n};\n            '),this.globalVariables.push("\n// MCP23017 Pin Definitions for LED Bank Indicators\n// CORRECTED v1.0 hardware mapping (CLAUDE.md verified)\n#define GATE1_LED_PIN 7    // GPA7: Gate 1 LED (Bank 1 indicator)\n#define GATE2_LED_PIN 6    // GPA6: Gate 2 LED (Bank 2 indicator)\n#define GATE3_LED_PIN 8    // GPB0: Gate 3 LED (Bank 5 indicator)\n#define GATE4_LED_PIN 9    // GPB1: Gate 4 LED (Bank 6 indicator)\n// Bank 3 indicator: MIDI-IN LED (GPA5)\n// Bank 4 indicator: MIDI-OUT LED (GPA4)\n// NOTE: GPB2/GPB3 are AUDIO SWITCHES (active-LOW), NOT LEDs!\n\n// Banking System Variables\nint currentBank = 1;           // Current active bank (1-6)\nconst int MAX_BANKS = 6;       // Maximum number of banks\nint activeBanks = 1;           // Number of banks actually used in this patch\nbool showingBankIndicator = false;      // Bank indicator LED state\nunsigned long bankIndicatorTime = 0;    // Bank indicator timing\nint lastEncoderA = HIGH;               // Encoder A state tracking\nbool lastEncoderBtn = false;           // Encoder button state tracking\nbool encoderBtn = false;               // Current encoder button state (updated in updateHardware, used in processAudio)\nunsigned long encoderBtnPressTime = 0; // Encoder button press timestamp for long-press detection\nbool encoderBtnLongPressHandled = false; // Prevent double-triggering on long press\nbool enc1_buttonLongPressed = false;   // Encoder button held for >1s (exposed for Automation mode select)\n\n// Functional LED feedback (active when NOT showing bank indicator)\nbool led_gatein1_active = false;  // Gate In 1 detected\nbool led_gatein2_active = false;  // Gate In 2 detected\nbool led_gateout1_active = false; // Gate Out 1 (Gate 3) active\nbool led_gateout2_active = false; // Gate Out 2 (Gate 4) active\nbool led_midiin_active = false;   // MIDI In activity\nbool led_midiout_active = false;  // MIDI Out activity\nunsigned long led_midiin_time = 0;    // MIDI In LED flash timer\nunsigned long led_midiout_time = 0;   // MIDI Out LED flash timer\n\n// Audio buffers\nfloat leftBuffer[BUFFER_SIZE];\nfloat rightBuffer[BUFFER_SIZE];\n".concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"int32_t i2sBuffer[BUFFER_SIZE * 2]; // I2S output buffer (32-bit for PCM1802 compatibility)":"int16_t i2sBuffer[BUFFER_SIZE * 2]; // I2S output buffer (16-bit)","\n").concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"int32_t i2sInputBuffer[BUFFER_SIZE * 2]; // I2S input for PCM1802 (32-bit stereo interleaved)\n":"","        ")),this.globalVariables.push("\n".concat(_e.generateDriverCode(),"\n\nuint16_t inputs = 0x3F;  // Global variable for MCP23017 inputs\nunsigned long lastMcpRead = 0;\nunsigned long lastMcpWrite = 0;\n\n").concat(this.modules.some(function(e){return"USBMIDIIn"===e.type||"USBMIDIOut"===e.type})?"// USB MIDI (GPIO19/20)\nUSBMIDI usbMIDI;\n\n":"").concat(de.generateDriverCode(),"\n        ")),console.log("=== generateVariables() - Processing modules:",this.modules.map(function(e){return"".concat(e.type).concat(e.id)})),this.modules.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";console.log("  Processing module: ".concat(n.type,' id="').concat(n.id,'" -> instanceNum="').concat(o,'"')),e.generateModuleVariables(n,o)})}},{key:"generateModuleVariables",value:function(e,n){var t=O[e.type];if(t){var a=this.audioModules.generateGlobalVariables(e,n,t);if(a)this.globalVariables.push(a);else{var o=this.controlModules.generateGlobalVariables(e,n,t);if(o){if(this.globalVariables.push(o),"MIDILooper"===e.type)for(var c=1;c<=4;c++)if(this.declaredButtons.has(c)||(this.declaredButtons.add(c),this.globalVariables.push("\n// Button ".concat(c," state (auto-declared for MIDILooper)\nbool btn").concat(c,"_state = false;\nbool btn").concat(c,"_lastState = false;\nbool btn").concat(c,"_pressed = false;\n                        "))),!this.declaredPots.has(c)){this.declaredPots.add(c);var r=[4,5,6,7][c-1];this.globalVariables.push("\n// Pot ".concat(c," (auto-declared for MIDILooper)\nconst int pot").concat(c,"_pin = ").concat(r,";\nfloat pot").concat(c,"_value = 0.0;\nfloat pot").concat(c,"_physical = 0.0;\nfloat pot").concat(c,"_target = 0.0;\nbool pot").concat(c,"_taken_over = false;\nfloat pot").concat(c,"_last_bank_change = 0.0;\n                        "))}}else{var i=this.sampleModules.generateGlobalVariables(e,n,t);if(i)this.globalVariables.push(i);else{var l=this.hardwareModules.generateGlobalVariables(e,n,t);if(l)this.globalVariables.push(l);else switch(e.type){case"Wavetable":for(var s=e.params.wavetables||[],u=512,d="",p=0;p<4;p++){var f=s[p];if(f&&f.length>0)d+="\n// Wavetable ".concat(p+1," data (").concat(f.length," samples)\nconst float wavetable").concat(n,"_").concat(p,"[").concat(u,"] = {\n    ").concat(Array.from(f).map(function(e,n){var t=e.toFixed(6)+"f";return n%8==0&&n>0?"\n    "+t:t}).join(", "),"\n};");else{var m=void 0,_=void 0;switch(p){case 0:m=Array.from({length:u},function(e,n){return Math.sin(n/u*2*Math.PI)}),_="sine wave - default";break;case 1:m=Array.from({length:u},function(e,n){return n/u*2-1}),_="sawtooth wave - default";break;case 2:m=Array.from({length:u},function(e,n){return n<256?1:-1}),_="square wave - default";break;case 3:m=Array.from({length:u},function(e,n){var t=n/u;return t<.5?4*t-1:3-4*t}),_="triangle wave - default"}d+="\n// Wavetable ".concat(p+1," data (").concat(_,")\nconst float wavetable").concat(n,"_").concat(p,"[").concat(u,"] = {\n    ").concat(m.map(function(e,n){var t=e.toFixed(6)+"f";return n%8==0&&n>0?"\n    "+t:t}).join(", "),"\n};")}}this.globalVariables.push("\n// ".concat(t.label," ").concat(n,"\n").concat(d,"\n\n// Wavetable oscillator variables\nfloat wavetable").concat(n,"_phase = 0.0;\nfloat wavetable").concat(n,"_freq = ").concat(e.params.freq||440,";\nfloat wavetable").concat(n,"_gain = ").concat(e.params.gain||.25,";\nfloat wavetable").concat(n,"_gate = 0.0; // Default gate OFF (controlled by MIDI/button connections)\nfloat wavetable").concat(n,"_fm_amount = ").concat(e.params.fm_amount||0,";\nfloat wavetable").concat(n,"_fm_ratio = ").concat(e.params.fm_ratio||1,";\nfloat wavetable").concat(n,"_fm_ratio_cv = 0.0; // CV control for FM ratio (0-1)\nfloat wavetable").concat(n,"_pitch_amount = ").concat(e.params.pitch_range||24,"; // Pitch CV range in semitones\nfloat wavetable").concat(n,"_pitch_smooth = 0.5; // Smoothed pitch CV to prevent artifacts (0-1)\nint wavetable").concat(n,"_current_table = ").concat(e.params.current_table||0,";\nfloat watetable").concat(n,"_output = 0.0; // Mono output\nfloat wavetable").concat(n,"_outputL = 0.0;\nfloat wavetable").concat(n,"_outputR = 0.0;\nconst int wavetable").concat(n,"_table_size = ").concat(u,";\nconst float wavetable").concat(n,"_sample_rate_inv = 1.0 / ").concat(Z.SAMPLE_RATE,".0;\n                "));break;case"Filter":this.globalVariables.push("\n// ".concat(t.label," ").concat(n,"\nfloat filter").concat(n,"_cutoff = ").concat(e.params.cutoff||1e3,";\nfloat filter").concat(n,"_resonance = ").concat(e.params.resonance||.5,";\nfloat filter").concat(n,"_x1 = 0.0, filter").concat(n,"_x2 = 0.0;\nfloat filter").concat(n,"_y1 = 0.0, filter").concat(n,"_y2 = 0.0;\nfloat filter").concat(n,"_input = 0.0;\nfloat filter").concat(n,"_inputL = 0.0;\nfloat filter").concat(n,"_inputR = 0.0;\nfloat filter").concat(n,"_output = 0.0;\nfloat filter").concat(n,"_outputL = 0.0;\nfloat filter").concat(n,"_outputR = 0.0;\n                "));break;case"VCA":this.globalVariables.push("\n// ".concat(t.label," ").concat(n,"\nfloat vca").concat(n,"_gain = ").concat(e.params.gain||1,";\nfloat vca").concat(n,"_inputL = 0.0;\nfloat vca").concat(n,"_inputR = 0.0;\nfloat vca").concat(n,"_outputL = 0.0;\nfloat vca").concat(n,"_outputR = 0.0;\n                "));break;case"Reverb":this.globalVariables.push("\n// ".concat(t.label," ").concat(n,"\nfloat reverb").concat(n,"_mix = ").concat(e.params.mix||.25,";\nfloat reverb").concat(n,"_size = ").concat(e.params.size||.5,";\nfloat reverb").concat(n,"_damp = ").concat(e.params.damp||.4,";\nfloat reverb").concat(n,"_inputL = 0.0;\nfloat reverb").concat(n,"_inputR = 0.0;\nfloat reverb").concat(n,"_outputL = 0.0;\nfloat reverb").concat(n,"_outputR = 0.0;\n                "));break;case"GranularSynth":var g=Math.floor(.5*Z.SAMPLE_RATE);this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Granular Synthesis Engine\nconst int granular").concat(moduleIndex,"_buffer_size = ").concat(g,"; // 0.5 seconds at 44.1kHz\nfloat granular").concat(moduleIndex,"_buffer_L[").concat(g,"];\nfloat granular").concat(moduleIndex,"_buffer_R[").concat(g,"];\nint granular").concat(moduleIndex,"_write_pos = 0;\nfloat granular").concat(moduleIndex,"_grain_density = ").concat(e.params.grain_density||8,";\nfloat granular").concat(moduleIndex,"_grain_size_ms = ").concat(e.params.grain_size_ms||50,";\nfloat granular").concat(moduleIndex,"_position = ").concat(e.params.position||.5,";\nfloat granular").concat(moduleIndex,"_position_spread = ").concat(e.params.position_spread||.2,";\nfloat granular").concat(moduleIndex,"_pitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(moduleIndex,"_pitch_spread = ").concat(e.params.pitch_spread||.1,";\nfloat granular").concat(moduleIndex,"_dry_wet = ").concat(e.params.dry_wet||1,";\n\n// 4 concurrent grain players for richer textures\nstruct Grain {\n    bool active;\n    float position;\n    float size_samples;\n    float pitch_ratio;\n    float envelope_pos;\n    float envelope_inc;\n    int samples_remaining;\n};\n\nGrain granular").concat(moduleIndex,"_grains[4];\nfloat granular").concat(moduleIndex,"_outputL = 0.0;\nfloat granular").concat(moduleIndex,"_outputR = 0.0;\nint granular").concat(moduleIndex,"_samples_since_grain = 0;\n                "));break;case"ADSR":this.globalVariables.push("\n// ".concat(t.label," ").concat(n,"\nfloat adsr").concat(n,"_attack = ").concat((e.params.attack_ms||10)/1e3,"; // Convert ms to seconds\nfloat adsr").concat(n,"_decay = ").concat((e.params.decay_ms||120)/1e3,"; // Convert ms to seconds\nfloat adsr").concat(n,"_sustain = ").concat(e.params.sustain||.6,"; // Already 0-1 range\nfloat adsr").concat(n,"_release = ").concat((e.params.release_ms||200)/1e3,"; // Convert ms to seconds\nfloat adsr").concat(n,"_timescale = ").concat(e.params.timescale||1,"; // Timing scale multiplier\nfloat adsr").concat(n,"_level = 0.0;\nint adsr").concat(n,"_stage = 0; // 0=idle, 1=attack, 2=decay, 3=sustain, 4=release\nbool adsr").concat(n,"_gate = false;\nbool adsr").concat(n,"_lastGate = false;\nfloat adsr").concat(n,"_output = 0.0;\nfloat adsr").concat(n,"_stageTime = 0.0; // Time within current stage\n// Curve types: ").concat(e.params.attack_curve||"linear",", ").concat(e.params.decay_curve||"exp",", ").concat(e.params.release_curve||"exp","\n                "));break;case"Scale":break;case"Pot":var h=e.params.index||1;if(!this.declaredPots.has(h)){this.declaredPots.add(h);var v=Z.ANALOG_PINS[h-1]||Z.ANALOG_PINS[0];this.globalVariables.push("\n// ".concat(t.label," ").concat(h,"\nconst int pot").concat(h,"_pin = ").concat(v,";\nfloat pot").concat(h,"_value = 0.0;\nfloat pot").concat(h,"_physical = 0.0;     // Current physical pot position\nfloat pot").concat(h,"_target = 0.0;       // Target value when bank becomes active\nbool pot").concat(h,"_taken_over = false;  // Has pot taken over after bank change\nfloat pot").concat(h,"_last_bank_change = 0.0; // Time of last bank change for this pot\n                    "))}break;case"GranularPSRAM":Math.floor(4*Z.SAMPLE_RATE),this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - PSRAM Granular Synthesis Engine\nint granular").concat(moduleIndex,"_buffer_size; // Set dynamically based on available memory\nfloat* granular").concat(moduleIndex,"_buffer_L; // PSRAM allocation\nfloat* granular").concat(moduleIndex,"_buffer_R; // PSRAM allocation\nint granular").concat(moduleIndex,"_write_pos = 0;\nfloat granular").concat(moduleIndex,"_grain_density = ").concat(e.params.grain_density||8,";\nfloat granular").concat(moduleIndex,"_grain_size_ms = ").concat(e.params.grain_size_ms||100,";\nfloat granular").concat(moduleIndex,"_position = ").concat(e.params.position||.5,";\nfloat granular").concat(moduleIndex,"_position_spread = ").concat(e.params.position_spread||.2,";\nfloat granular").concat(moduleIndex,"_pitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(moduleIndex,"_pitch_spread = ").concat(e.params.pitch_spread||.1,";\nfloat granular").concat(moduleIndex,"_dry_wet = ").concat(e.params.dry_wet||.5,";\nfloat granular").concat(moduleIndex,"_freeze = ").concat(e.params.freeze||0,";\n\n// 8 concurrent grain players for rich textures\nstruct Grain {\n    bool active;\n    float position;\n    float size_samples;\n    float pitch_ratio;\n    float envelope_pos;\n    float envelope_inc;\n    int samples_remaining;\n};\n\nGrain granular").concat(moduleIndex,"_grains[8];\nfloat granular").concat(moduleIndex,"_outputL = 0.0;\nfloat granular").concat(moduleIndex,"_outputR = 0.0;\nint granular").concat(moduleIndex,"_samples_since_grain = 0;\n\n// Runtime variables for control and audio processing\nfloat granular").concat(moduleIndex,"_inputL = 0.0;\nfloat granular").concat(moduleIndex,"_inputR = 0.0;\nfloat granular").concat(moduleIndex,"_currentDensity = ").concat(e.params.grain_density||8,";\nfloat granular").concat(moduleIndex,"_currentSize = ").concat(e.params.grain_size_ms||100,";\nfloat granular").concat(moduleIndex,"_currentPosition = ").concat(e.params.position||.5,";\nfloat granular").concat(moduleIndex,"_currentPitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(moduleIndex,"_currentDryWet = ").concat(e.params.dry_wet||.5,";\nfloat granular").concat(moduleIndex,"_currentFreeze = ").concat(e.params.freeze||0,";\n                "));break;case"Looper_OLD_DISABLED":var b=Z.SAMPLE_RATE,y=16*b,k=this.modules[n],x=[];this.connections.forEach(function(e){if(e.to.id==="".concat(k.id,":btn1")||e.to.id==="".concat(k.id,":btn2")||e.to.id==="".concat(k.id,":btn3")||e.to.id==="".concat(k.id,":btn4")){var n=e.to.id.split(":")[1],t=parseInt(n.replace("btn",""));x.push(t)}}),x.sort();var S=x.length;this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - BPM-Synced Multi-track Looper with PSRAM\n// Connected buttons: ").concat(x.length>0?x.join(", "):"none"," (").concat(S," active tracks)\nclass Looper_").concat(n," {\nprivate:\n  static constexpr int NUM_TRACKS = ").concat(Math.max(1,S),"; // Dynamic track count\n  static constexpr int MAX_LOOP_SAMPLES = ").concat(y,";\n  \n  struct Track {\n    float* bufferL = nullptr;\n    float* bufferR = nullptr;\n    int length = 0;           // Length in samples (0 = not set yet)\n    int writePos = 0;\n    float readPosFloat = 0.0f;\n    \n    // State machine\n    enum State { EMPTY, RECORDING, PLAYING, OVERDUBBING, MUTED };\n    State state = EMPTY;\n    \n    // Track-specific parameters\n    int divider = 1;           // Beat division for tracks 2-4\n    bool isTrack1 = false;    // Track 1 has different behavior\n    float lastButtonState = 0.0f;\n  };\n  \n  Track tracks[NUM_TRACKS];\n  \n  // BPM sync\n  float bpm = ").concat(e.params.bpm||120,".0f;\n  int barsTrack1 = ").concat(e.params.bars_track1||4,";\n  int divTrack2 = ").concat(e.params.div_track2||4,";\n  int divTrack3 = ").concat(e.params.div_track3||8,";\n  int divTrack4 = ").concat(e.params.div_track4||16,";\n  \n  // Button timing for long press detection\n  unsigned long btnPressTime[4] = {0, 0, 0, 0};\n  static constexpr unsigned long LONG_PRESS_MS = 500; // 500ms for long press\n  bool quantize = ").concat(e.params.quantize||1,";\n  \n  // Global parameters\n  float feedback = ").concat((e.params.feedback||.95).toFixed(2),"f;\n  float mix = ").concat((e.params.mix||1).toFixed(1),"f;\n  \n  // Clock sync\n  float lastClockIn = 0.0f;\n  unsigned long lastClockTime = 0;\n  float clockPeriod = 0.0f;\n  int clockCounter = 0;\n  int beatsPerBar = 4;\n  \n  // Control inputs\n  float clockIn = 0.0f;\n").concat(x.map(function(e){return"  float btn".concat(e,"In = 0.0f;")}).join("\n"),"\n  float clearAllIn = 0.0f;\n  float lastClearAll = 0.0f;\n  \npublic:\n  float outL = 0.0f;\n  float outR = 0.0f;\n").concat(x.map(function(e){return"  float led".concat(e,"Out = 0.0f;")}).join("\n"),'\n  float positionOut = 0.0f;\n  float playingOut = 0.0f;\n\n  void init() {\n    // Allocate PSRAM buffers for each track\n    for (int i = 0; i < NUM_TRACKS; i++) {\n      // Track 1 gets full buffer, others get 1/4\n      int bufferSize = (i == 0) ? MAX_LOOP_SAMPLES : MAX_LOOP_SAMPLES / 4;\n      \n      tracks[i].bufferL = (float*)ps_malloc(bufferSize * sizeof(float));\n      tracks[i].bufferR = (float*)ps_malloc(bufferSize * sizeof(float));\n      \n      if (!tracks[i].bufferL || !tracks[i].bufferR) {\n        Serial.printf("Looper_').concat(n,': Failed to allocate PSRAM for track %d\\n", i);\n        // Fall back to smaller SRAM buffer if PSRAM fails\n        if (!tracks[i].bufferL) {\n          tracks[i].bufferL = (float*)malloc(22050 * sizeof(float)); // 0.5 second fallback\n        }\n        if (!tracks[i].bufferR) {\n          tracks[i].bufferR = (float*)malloc(22050 * sizeof(float));\n        }\n      } else {\n        // Clear buffers\n        memset(tracks[i].bufferL, 0, bufferSize * sizeof(float));\n        memset(tracks[i].bufferR, 0, bufferSize * sizeof(float));\n      }\n    }\n    \n    // Set track properties\n    tracks[0].isTrack1 = true;  // Track 1 has toggle behavior\n    tracks[1].divider = divTrack2;\n    tracks[2].divider = divTrack3;\n    tracks[3].divider = divTrack4;\n    \n    Serial.println("Looper_').concat(n,' initialized with BPM sync");\n  }\n\n  void setControl(int index, float value) {\n    switch(index) {\n      case 0: clockIn = value; break;           // clock input\n').concat(x.map(function(e,n){return"      case ".concat(n+1,": btn").concat(e,"In = value; break;            // button ").concat(e," (track ").concat(n+1,")")}).join("\n"),"\n      case ").concat(x.length+1,": clearAllIn = value; break;        // clear all\n      case 6: feedback = constrain(value, 0.0f, 1.0f); break;\n      case 7: mix = constrain(value, 0.0f, 1.0f); break;\n    }\n  }\n\n  void process(float inL, float inR) {\n    // Clock detection and BPM sync\n    if (clockIn > 0.5f && lastClockIn <= 0.5f) {\n      // Clock rising edge detected\n      unsigned long currentTime = millis();\n      if (lastClockTime > 0) {\n        clockPeriod = currentTime - lastClockTime;\n      }\n      lastClockTime = currentTime;\n      clockCounter++;\n    }\n    lastClockIn = clockIn;\n    \n    // Calculate track lengths based on BPM\n    int samplesPerBeat = (60.0f / bpm) * ").concat(b,";\n    \n    // Handle button inputs for each track\n").concat(x.map(function(e,n){return"    handleButton(".concat(n,", btn").concat(e,"In, samplesPerBeat);")}).join("\n"),"\n    \n    // Clear all tracks\n    if (clearAllIn > 0.5f && lastClearAll <= 0.5f) {\n      for (int i = 0; i < NUM_TRACKS; i++) {\n        clearTrack(i);\n      }\n    }\n    lastClearAll = clearAllIn;\n    \n    // Process audio for all tracks\n    float wetL = 0.0f;\n    float wetR = 0.0f;\n    \n    for (int i = 0; i < NUM_TRACKS; i++) {\n      Track& track = tracks[i];\n      \n      // Recording\n      if (track.state == Track::RECORDING && track.bufferL && track.bufferR) {\n        if (track.writePos < track.length) {\n          track.bufferL[track.writePos] = inL;\n          track.bufferR[track.writePos] = inR;\n          track.writePos++;\n        } else {\n          // Auto-stop at track length\n          track.state = Track::PLAYING;\n          track.writePos = 0;\n        }\n      }\n      \n      // Playback (both PLAYING and MUTED states advance position)\n      if ((track.state == Track::PLAYING || track.state == Track::MUTED) && \n          track.length > 0 && track.bufferL && track.bufferR) {\n        \n        int readIdx = (int)track.readPosFloat;\n        \n        // Only output audio if PLAYING (not MUTED)\n        if (track.state == Track::PLAYING && readIdx < track.length) {\n          wetL += track.bufferL[readIdx] * 0.25f; // Mix 4 tracks\n          wetR += track.bufferR[readIdx] * 0.25f;\n        }\n        \n        // Advance read position (even when muted to stay in sync)\n        track.readPosFloat += 1.0f;\n        if (track.readPosFloat >= track.length) {\n          track.readPosFloat = 0;\n          \n          // Auto-stop recording for tracks 2-4 after predetermined length\n          if (track.state == Track::RECORDING && !track.isTrack1) {\n            track.state = Track::PLAYING;\n            track.writePos = 0;\n          }\n        }\n      }\n      \n      // Update LED outputs\n      float ledValue = 0.0f;\n      switch(track.state) {\n        case Track::RECORDING: ledValue = 1.0f; break;     // Full brightness - recording\n        case Track::PLAYING: ledValue = 0.5f; break;       // Half brightness - playing\n        case Track::MUTED: ledValue = 0.1f; break;         // Dim - muted but has content\n        case Track::EMPTY: ledValue = 0.0f; break;         // Off - empty\n      }\n      \n      // Assign LED output only for connected buttons\n      if (i < ").concat(x.length,") {\n        switch(i) {\n").concat(x.map(function(e,n){return"          case ".concat(n,": led").concat(e,"Out = ledValue; break;")}).join("\n"),"\n        }\n      }\n    }\n    \n    // Mix dry/wet\n    outL = inL * (1.0f - mix) + wetL * mix;\n    outR = inR * (1.0f - mix) + wetR * mix;\n    \n    // Update position output (track 1 position)\n    positionOut = tracks[0].length > 0 ? tracks[0].readPosFloat / tracks[0].length : 0.0f;\n    playingOut = (tracks[0].state == Track::PLAYING || tracks[0].state == Track::OVERDUBBING) ? 1.0f : 0.0f;\n  }\n\nprivate:\n  void handleButton(int trackIndex, float buttonState, int samplesPerBeat) {\n    Track& track = tracks[trackIndex];\n    unsigned long currentTime = millis();\n    \n    // Button press detection\n    if (buttonState > 0.5f && track.lastButtonState <= 0.5f) {\n      // Button pressed - start timing for long press\n      btnPressTime[trackIndex] = currentTime;\n      \n    } else if (buttonState <= 0.5f && track.lastButtonState > 0.5f) {\n      // Button released\n      unsigned long pressDuration = currentTime - btnPressTime[trackIndex];\n      \n      if (pressDuration >= LONG_PRESS_MS) {\n        // Long press - delete/clear track\n        clearTrack(trackIndex);\n      } else {\n        // Short press - handle based on track type and current state\n        if (track.isTrack1) {\n          // Track 1: Toggle recording (manual length)\n          if (track.state == Track::EMPTY) {\n            // Start recording\n            track.state = Track::RECORDING;\n            track.writePos = 0;\n            track.readPosFloat = 0;\n            track.length = 0; // Length not predetermined\n          } else if (track.state == Track::RECORDING) {\n            // Stop recording, set length, start playing\n            track.length = track.writePos;\n            track.state = Track::PLAYING;\n            track.readPosFloat = 0;\n          } else if (track.state == Track::PLAYING) {\n            // Mute\n            track.state = Track::MUTED;\n          } else if (track.state == Track::MUTED) {\n            // Unmute\n            track.state = Track::PLAYING;\n          }\n        } else {\n          // Tracks 2-4: Red Sound Cycloops behavior\n          if (track.state == Track::EMPTY) {\n            // Start recording with predetermined length\n            track.state = Track::RECORDING;\n            track.writePos = 0;\n            track.readPosFloat = 0;\n            // Set predetermined length based on beat divisions\n            int beatsToRecord = beatsPerBar / track.divider;\n            track.length = samplesPerBeat * beatsToRecord;\n            \n            // Auto-stop will happen when writePos reaches length\n          } else if (track.state == Track::PLAYING) {\n            // Mute\n            track.state = Track::MUTED;\n          } else if (track.state == Track::MUTED) {\n            // Unmute\n            track.state = Track::PLAYING;\n          }\n        }\n      }\n      \n      btnPressTime[trackIndex] = 0; // Reset press time\n    }\n    \n    track.lastButtonState = buttonState;\n  }\n  \n  void clearTrack(int trackIndex) {\n    Track& track = tracks[trackIndex];\n    track.state = Track::EMPTY;\n    track.length = 0;\n    track.writePos = 0;\n    track.readPosFloat = 0;\n    \n    // Clear buffer\n    int bufferSize = (trackIndex == 0) ? MAX_LOOP_SAMPLES : MAX_LOOP_SAMPLES / 4;\n    if (track.bufferL && track.bufferR) {\n      memset(track.bufferL, 0, bufferSize * sizeof(float));\n      memset(track.bufferR, 0, bufferSize * sizeof(float));\n    }\n  }\n};\n\n// OLD DISABLED: Instance creation now handled by modular system\n// Looper_").concat(n," looper").concat(n,";\n// float looper").concat(n,"_inputL = 0.0f;\n// float looper").concat(n,"_inputR = 0.0f;\n                "));break;case"GranularDense":Math.floor(2*Z.SAMPLE_RATE),this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Dense Granular Synthesis with 20 Grains\nint granular").concat(moduleIndex,"_buffer_size; // Set dynamically based on available memory\nfloat* granular").concat(moduleIndex,"_buffer_L; // PSRAM allocation\nfloat* granular").concat(moduleIndex,"_buffer_R; // PSRAM allocation\nint granular").concat(moduleIndex,"_write_pos = 0;\nfloat granular").concat(moduleIndex,"_grain_density = ").concat(e.params.grain_density||15,";\nfloat granular").concat(moduleIndex,"_position = ").concat(e.params.position||.5,";\nfloat granular").concat(moduleIndex,"_position_spread = ").concat(e.params.position_spread||.3,";\nfloat granular").concat(moduleIndex,"_pitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(moduleIndex,"_pitch_spread = ").concat(e.params.pitch_spread||.1,";\nfloat granular").concat(moduleIndex,"_dry_wet = ").concat(e.params.dry_wet||1,";\nfloat granular").concat(moduleIndex,"_freeze = ").concat(e.params.freeze||0,";\n\n// Dense grain structure - 20 concurrent 32ms grains for rich textural clouds\nstruct DenseGrain {\n    bool active;\n    float position;\n    float pitch_ratio;\n    float envelope_pos;\n    float envelope_inc;\n    int samples_remaining;\n};\n\nDenseGrain granular").concat(moduleIndex,"_grains[20]; // 20 concurrent grains\nfloat granular").concat(moduleIndex,"_outputL = 0.0;\nfloat granular").concat(moduleIndex,"_outputR = 0.0;\nint granular").concat(moduleIndex,"_samples_since_grain = 0;\n\n// Runtime variables for control and audio processing\nfloat granular").concat(moduleIndex,"_inputL = 0.0;\nfloat granular").concat(moduleIndex,"_inputR = 0.0;\nfloat granular").concat(moduleIndex,"_currentDensity = ").concat(e.params.grain_density||15,";\nfloat granular").concat(moduleIndex,"_currentPosition = ").concat(e.params.position||.5,";\nfloat granular").concat(moduleIndex,"_currentPitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(moduleIndex,"_currentDryWet = ").concat(e.params.dry_wet||1,";\nfloat granular").concat(moduleIndex,"_currentFreeze = ").concat(e.params.freeze||0,";\n                "));break;case"LEDButton":var E=e.params.index||1;this.declaredButtons.has(E)||(this.declaredButtons.add(E),this.globalVariables.push("\n// LEDButton (Physical Button ".concat(E,")\nbool btn").concat(E,"_state = false;\nbool btn").concat(E,"_lastState = false;\nbool btn").concat(E,"_pressed = false;\nbool btn").concat(E,"_gate = false;     // Raw gate signal for modular connections\nfloat btn").concat(E,"_output = 0.0;\nfloat btn").concat(E,"_sampleIn = 0.0;  // Sample & hold input\nfloat btn").concat(E,"_sampleOut = 0.0; // Sample & hold output (held value)\n                    ")));break;case"KickDrum":var P=this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type});this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Layered Drum Synthesizer\n// Oscillator layer\nfloat kick").concat(n,"_osc_phase = 0.0;\nfloat kick").concat(n,"_osc_freq = ").concat(e.params.osc_frequency||60,";\nfloat kick").concat(n,"_osc_level = ").concat(e.params.osc_level||.7,";\n// Oscillator amplitude envelope\nfloat kick").concat(n,"_osc_amp_env = 0.0;\nfloat kick").concat(n,"_osc_amp_attack = ").concat((e.params.osc_amp_attack_ms||1)/1e3,";\nfloat kick").concat(n,"_osc_amp_decay = ").concat((e.params.osc_amp_decay_ms||150)/1e3,";\nfloat kick").concat(n,"_osc_amp_sustain = ").concat(e.params.osc_amp_sustain||.1,";\nfloat kick").concat(n,"_osc_amp_release = ").concat((e.params.osc_amp_release_ms||200)/1e3,";\nint kick").concat(n,"_osc_amp_stage = 0;\nfloat kick").concat(n,"_osc_amp_time = 0.0;\n// Oscillator pitch envelope\nfloat kick").concat(n,"_osc_pitch_env = 0.0;\nfloat kick").concat(n,"_osc_pitch_amount = ").concat(e.params.osc_pitch_amount||.5,";\nfloat kick").concat(n,"_osc_pitch_attack = ").concat((e.params.osc_pitch_attack_ms||1)/1e3,";\nfloat kick").concat(n,"_osc_pitch_decay = ").concat((e.params.osc_pitch_decay_ms||100)/1e3,";\nint kick").concat(n,"_osc_pitch_stage = 0;\nfloat kick").concat(n,"_osc_pitch_time = 0.0;\n\n// Noise layer\nfloat kick").concat(n,"_noise_level = ").concat(e.params.noise_level||.3,";\n// Noise amplitude envelope\nfloat kick").concat(n,"_noise_amp_env = 0.0;\nfloat kick").concat(n,"_noise_amp_attack = ").concat((e.params.noise_amp_attack_ms||1)/1e3,";\nfloat kick").concat(n,"_noise_amp_decay = ").concat((e.params.noise_amp_decay_ms||50)/1e3,";\nint kick").concat(n,"_noise_amp_stage = 0;\nfloat kick").concat(n,"_noise_amp_time = 0.0;\n\n// Layer mute states\nbool kick").concat(n,"_osc_mute = ").concat(e.params.osc_mute||!1,";\nbool kick").concat(n,"_noise_mute = ").concat(e.params.noise_mute||!1,";\nbool kick").concat(n,"_sample_mute = ").concat(e.params.sample_mute||!1,";\n\n// Output mixing\nfloat kick").concat(n,"_output = 0.0;\nbool kick").concat(n,"_trigger = false;\nbool kick").concat(n,"_last_trigger = false;\n                ")),P&&this.globalVariables.push("\n// File transfer variables (only included when Sample Player classes are present)\nbool fileTransferActive".concat(n," = false;\nString transferFilename").concat(n,' = "";\nFile transferFile').concat(n,";\nuint32_t expectedFileSize").concat(n," = 0;\nuint32_t receivedBytes").concat(n," = 0;\n\n// Ring buffer variables for credit-based file transfer\nuint8_t* ringBuffer").concat(n," = NULL;\nvolatile int ringWritePos").concat(n," = 0;\nvolatile int ringReadPos").concat(n," = 0;\nvolatile int ringBufferCount").concat(n," = 0;\nTaskHandle_t sdWriterTaskHandle").concat(n," = NULL;\nportMUX_TYPE ringBufferMux").concat(n," = portMUX_INITIALIZER_UNLOCKED;\n                    "));break;case"DrumDesigner":this.fastSineAdded||(this.globalFunctions=this.globalFunctions||[],this.globalFunctions.push("\n// Fast sine approximation (Bhaskara I's formula) - 5-10x faster than sinf()\n// Accuracy: < 0.002 error across full range (good enough for audio)\ninline float fastSin(float x) {\n    // Normalize to -PI to PI range\n    while (x > PI) x -= 2.0f * PI;\n    while (x < -PI) x += 2.0f * PI;\n\n    // Bhaskara I approximation for -PI to PI\n    // sin(x)  16x( - |x|) / (5 - 4|x|( - |x|))\n    float absX = fabsf(x);\n    float num = 16.0f * x * (PI - absX);\n    float den = 5.0f * PI * PI - 4.0f * absX * (PI - absX);\n    return num / den;\n}\n"),this.fastSineAdded=!0),this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Karplus-Strong Physical Modeling Drum Synthesizer (PSRAM optimized)\n// K-S Delay line allocated in PSRAM (max 8192 samples = 186ms @ 44.1kHz = ~5.4 Hz sub-bass!)\n#define KS_MAX_DELAY_").concat(n," 8192\nfloat* ks").concat(n,"_delayLine = nullptr;  // PSRAM allocation (32KB)\nfloat* ks").concat(n,"_noiseBuffer = nullptr;  // Pre-generated noise for fast excitation (PSRAM, 32KB)\nint ks").concat(n,"_writePos = 0;\nint ks").concat(n,"_delayLength = 512;\nfloat ks").concat(n,"_prevSample = 0.0;\n\n// K-S Parameters\nconst char* ks").concat(n,'_mode = "').concat(e.params.ks_mode||"tonal",'";  // "tonal", "percussive", "noise"\nfloat ks').concat(n,"_pitch = ").concat(e.params.pitch||60,";  // MIDI note\nfloat ks").concat(n,"_fineTune = ").concat(e.params.fine_tune||0,";  // -100 to +100 cents\nfloat ks").concat(n,"_currentFreq = 440.0f;  // Pre-calculated frequency from pitch (updated at control rate to avoid expensive powf)\nfloat ks").concat(n,"_baseSineFreq = 440.0f;  // Pre-calculated base sine frequency (updated at control rate)\nfloat ks").concat(n,"_damping = ").concat(e.params.ks_damping||.995,";  // Decay rate (0.995 = long sustain for bass)\nfloat ks").concat(n,"_stretch = ").concat(e.params.ks_stretch||1,";  // Inharmonicity\nfloat ks").concat(n,"_brightness = ").concat(e.params.ks_brightness||.5,";  // Excitation filter\nfloat ks").concat(n,"_position = ").concat(e.params.ks_position||.5,";  // Strike position (0-1)\nfloat ks").concat(n,"_pitchGainComp = 1.0;  // Pitch-dependent gain compensation for consistent amplitude\n\n// Body Character (simple lowpass filter - replaces heavy comb filters)\nbool ks").concat(n,"_bodyEnabled = ").concat(!1!==e.params.body_enabled,";\nfloat ks").concat(n,"_bodyResonance = ").concat(e.params.body_resonance||.3,";  // Filter resonance (0.3 = subtle warmth)\nfloat ks").concat(n,"_bodySize = ").concat(e.params.body_size||.3,";  // Affects filter cutoff (0.3 = darker, warmer)\nfloat ks").concat(n,"_bodyLpf = 0.0;  // Lowpass filter state\n\n// Level controls for K-S and sine oscillator\nfloat ks").concat(n,"_ksLevel = ").concat(e.params.ks_level||.3,";  // K-S harmonics level (0-1)\nfloat ks").concat(n,"_sineLevel = ").concat(e.params.sine_level||.7,';  // Sine fundamental level (0-1)\n\n// Pitch sweep mode: "none" (no sweep), "sine" (808 style), or "delay" (Boss feedback style)\nconst char* ks').concat(n,'_pitchSweepMode = "').concat(e.params.pitch_sweep_mode||"none",'";\n\n// Sine oscillator for deep bass (hybrid mode with K-S)\nbool ks').concat(n,"_sineEnabled = ").concat(!1!==e.params.sine_enabled,";  // Enable sine bass oscillator\nfloat ks").concat(n,"_sinePhase = 0.0;\nfloat ks").concat(n,"_sinePitchAmount = ").concat(e.params.sine_pitch_amount||2,";  // Octaves of pitch sweep\nfloat ks").concat(n,"_sinePitchDecay = ").concat((e.params.sine_pitch_decay||80)/1e3,";  // Pitch envelope decay time\nint ks").concat(n,"_sinePitchStage = 0;  // 0=idle, 1=attack, 2=decay\nfloat ks").concat(n,"_sinePitchTime = 0.0;\nfloat ks").concat(n,"_sinePitchEnv = 0.0;\n\n// K-S delay sweep variables (Boss delay pitch-drop effect)\nfloat ks").concat(n,"_delayTarget = 0.0f;  // Target delay length (set on trigger)\nfloat ks").concat(n,"_delayCurrent = 0.0f;  // Current delay length (modulated)\nfloat ks").concat(n,"_delaySweepTime = 0.0f;  // Sweep timer\n\n// ADSR Amplitude Envelope\nfloat ks").concat(n,"_ampAttack = ").concat((e.params.amp_attack||1)/1e3,";  // Convert ms to seconds\nfloat ks").concat(n,"_ampDecay = ").concat((e.params.amp_decay||1500)/1e3,";  // 1.5s for bass development\nfloat ks").concat(n,"_ampSustain = ").concat(e.params.amp_sustain||.2,";  // 20% sustain to keep fundamental going\nfloat ks").concat(n,"_ampRelease = ").concat((e.params.amp_release||200)/1e3,";\nint ks").concat(n,"_ampStage = 0;  // 0=idle, 1=attack, 2=decay, 3=sustain, 4=release\nfloat ks").concat(n,"_ampTime = 0.0;\nfloat ks").concat(n,"_ampEnv = 0.0;\n\n// Control inputs\nfloat ks").concat(n,"_gateInput = 0.0;\nfloat ks").concat(n,"_velocityInput = 1.0;\nfloat ks").concat(n,"_pitchCV = 0.0;\nfloat ks").concat(n,"_dampingCV = 0.0;\nfloat ks").concat(n,"_bodyResonanceCV = 0.0;\n\n// Trigger detection\nbool ks").concat(n,"_lastGate = false;\nbool ks").concat(n,"_triggered = false;\n\n// Output\nfloat ks").concat(n,"_outputL = 0.0;\nfloat ks").concat(n,"_outputR = 0.0;\nfloat ks").concat(n,"_outputGain = ").concat(e.params.output_gain||.8,";\nfloat ks").concat(n,"_velocitySensitivity = ").concat(e.params.velocity_sensitivity||.7,";\n                "));break;case"DrumDesigner4":this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - 4-Voice Karplus-Strong Drum Synthesizer\n// Bank ").concat(e.params.bank||1,": Auto-banking (Pot=volume, Button=gate, Button hold + Pot=pitch)\n"));for(var w=1;w<=4;w++)if(this.declaredButtons.has(w)||(this.declaredButtons.add(w),this.globalVariables.push("\n// Button ".concat(w," state (auto-declared for DrumDesigner4)\nbool btn").concat(w,"_state = false;\nbool btn").concat(w,"_lastState = false;\nbool btn").concat(w,"_pressed = false;\n                        "))),!this.declaredPots.has(w)){this.declaredPots.add(w);var C=[4,5,6,7][w-1];this.globalVariables.push("\n// Pot ".concat(w," (auto-declared for DrumDesigner4)\nconst int pot").concat(w,"_pin = ").concat(C,";\nfloat pot").concat(w,"_value = 0.0;\nfloat pot").concat(w,"_physical = 0.0;\nfloat pot").concat(w,"_target = 0.0;\nbool pot").concat(w,"_taken_over = false;\nfloat pot").concat(w,"_last_bank_change = 0.0;\n                        "))}for(var I=1;I<=4;I++)if(!1!==e.params["voice".concat(I,"_enabled")]){var R={pitch:e.params["voice".concat(I,"_pitch")]||60,fineTune:e.params["voice".concat(I,"_fine_tune")]||0,ksDamping:e.params["voice".concat(I,"_ks_damping")]||.6,ksLevel:e.params["voice".concat(I,"_ks_level")]||.3,sineLevel:e.params["voice".concat(I,"_sine_level")]||.7,sineEnabled:!1!==e.params["voice".concat(I,"_sine_enabled")],attack:(e.params["voice".concat(I,"_amp_attack")]||1)/1e3,decay:(e.params["voice".concat(I,"_amp_decay")]||500)/1e3,sustain:e.params["voice".concat(I,"_amp_sustain")]||0,release:(e.params["voice".concat(I,"_amp_release")]||100)/1e3,outputGain:e.params["voice".concat(I,"_output_gain")]||3,volume:e.params["voice".concat(I,"_volume")]||.8};this.globalVariables.push("\n// Voice ".concat(I,": ENABLED\n#define KS_MAX_DELAY_DD4").concat(n,"_V").concat(I," 2048\nfloat* dd4").concat(n,"_v").concat(I,"_delayLine = nullptr;  // PSRAM (8KB)\nfloat* dd4").concat(n,"_v").concat(I,"_noiseBuffer = nullptr;  // PSRAM (8KB)\nint dd4").concat(n,"_v").concat(I,"_writePos = 0;\nint dd4").concat(n,"_v").concat(I,"_delayLength = 512;\nfloat dd4").concat(n,"_v").concat(I,"_prevSample = 0.0f;\nfloat dd4").concat(n,"_v").concat(I,"_pitch = ").concat(R.pitch,";\nfloat dd4").concat(n,"_v").concat(I,"_fineTune = ").concat(R.fineTune,";\nfloat dd4").concat(n,"_v").concat(I,"_currentFreq = 440.0f;\nfloat dd4").concat(n,"_v").concat(I,"_baseSineFreq = 440.0f;\nfloat dd4").concat(n,"_v").concat(I,"_damping = ").concat(R.ksDamping,";\nfloat dd4").concat(n,"_v").concat(I,"_ksLevel = ").concat(R.ksLevel,";\nfloat dd4").concat(n,"_v").concat(I,"_sineLevel = ").concat(R.sineLevel,";\nbool dd4").concat(n,"_v").concat(I,"_sineEnabled = ").concat(R.sineEnabled,";\nfloat dd4").concat(n,"_v").concat(I,"_sinePhase = 0.0f;\nfloat dd4").concat(n,"_v").concat(I,"_attack = ").concat(R.attack,";\nfloat dd4").concat(n,"_v").concat(I,"_decay = ").concat(R.decay,";\nfloat dd4").concat(n,"_v").concat(I,"_sustain = ").concat(R.sustain,";\nfloat dd4").concat(n,"_v").concat(I,"_release = ").concat(R.release,";\nint dd4").concat(n,"_v").concat(I,"_ampStage = 0;\nfloat dd4").concat(n,"_v").concat(I,"_ampTime = 0.0f;\nfloat dd4").concat(n,"_v").concat(I,"_gateInput = 0.0f;\nbool dd4").concat(n,"_v").concat(I,"_lastGate = false;\nfloat dd4").concat(n,"_v").concat(I,"_outputGain = ").concat(R.outputGain,";\nfloat dd4").concat(n,"_v").concat(I,"_volume = ").concat(R.volume,";  // Banking volume control\nfloat dd4").concat(n,"_v").concat(I,"_outL = 0.0f;\nfloat dd4").concat(n,"_v").concat(I,"_outR = 0.0f;\n"))}else this.globalVariables.push("\n// Voice ".concat(I,": DISABLED\nfloat dd4").concat(n,"_v").concat(I,"_outL = 0.0f;\nfloat dd4").concat(n,"_v").concat(I,"_outR = 0.0f;\n"));this.globalVariables.push("\n// Mix outputs\nfloat dd4".concat(n,"_outputMixL = 0.0f;\nfloat dd4").concat(n,"_outputMixR = 0.0f;\n                "));break;case"GateGen":this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Gate Generator with S&H and gate input control\nfloat gate").concat(n,"_length = ").concat(e.params.gate_length||.8,"; // Gate length as fraction of clock period\nbool gate").concat(n,"_use_self_clock = ").concat(e.params.use_self_clock||!0,";\nfloat gate").concat(n,"_self_clock_bpm = ").concat(e.params.self_clock_bpm||120,";\nfloat gate").concat(n,"_probability = ").concat(e.params.probability||1,"; // Probability 0-1\nbool gate").concat(n,"_retrigger = ").concat(e.params.retrigger||!0,";\nbool gate").concat(n,"_sh_enabled = ").concat(e.params.sh_enabled||!0,"; // Sample & Hold enabled\nbool gate").concat(n,"_state = false;\nbool gate").concat(n,"_last_clock = false;\nunsigned long gate").concat(n,"_start_time = 0;\nunsigned long gate").concat(n,"_last_self_clock = 0;\nfloat gate").concat(n,"_output = 0.0;\nfloat gate").concat(n,"_sh_input = 0.0; // Sample & Hold input\nfloat gate").concat(n,"_sh_output = 0.0; // Sample & Hold output (held value)\nfloat gate").concat(n,"_gate_input = 0.0; // Gate input control\nbool gate").concat(n,"_gate_enabled = true; // Gate control state\n                "));break;case"SDPlayer":case"SamplePlayer":this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type})?this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Minimal WAV Player (legacy single-voice)\nMinimalWAVPlayer sdPlayer").concat(n,"_player;\nfloat sdPlayer").concat(n,"_gain = ").concat(e.params.gain||3,";\nfloat sdPlayer").concat(n,"_pitch = ").concat(e.params.pitch||1,";\nbool sdPlayer").concat(n,"_loop = ").concat(e.params.loop||!0,";\nbool sdPlayer").concat(n,"_playing = false;\nint sdPlayer").concat(n,"_currentFile = 1;\nint sdPlayer").concat(n,"_sampleCount = 0;  // Dynamic count of available samples\nString sdPlayer").concat(n,'_currentFileName = "";\nfloat sdPlayer').concat(n,"_triggerThreshold = 0.5;\nbool sdPlayer").concat(n,"_lastTrigger = false;\nfloat sdPlayer").concat(n,"_outputL = 0.0;\nfloat sdPlayer").concat(n,"_outputR = 0.0;\nint sdPlayer").concat(n,"_lastLoadedFile = -1;  // Track loaded sample to avoid unnecessary reloads\n\n// File transfer variables (inline implementation - no external library needed)\nbool fileTransferActive").concat(n," = false;\nString transferFilename").concat(n,' = "";\nFile transferFile').concat(n,";\nuint32_t expectedFileSize").concat(n," = 0;\nuint32_t receivedBytes").concat(n," = 0;\n\n// Ring buffer variables for credit-based file transfer\nuint8_t* ringBuffer").concat(n," = NULL;\nvolatile int ringWritePos").concat(n," = 0;\nvolatile int ringReadPos").concat(n," = 0;\nvolatile int ringBufferCount").concat(n," = 0;\nTaskHandle_t sdWriterTaskHandle").concat(n," = NULL;\nportMUX_TYPE ringBufferMux").concat(n," = portMUX_INITIALIZER_UNLOCKED;\n                        ")):this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Sample Player module disabled (no Sample Player classes available)\nfloat sdPlayer").concat(n,"_outputL = 0.0; // Stub output - always silent\nfloat sdPlayer").concat(n,"_outputR = 0.0; // Stub output - always silent\n                    "))}}}}}}},{key:"calculateActiveBanks",value:function(){var e=this,n=new Set;this.connections.forEach(function(e){e.from&&e.from.bank&&(console.log("DEBUG: Found panel connection from bank ".concat(e.from.bank,": ").concat(e.from.id)),n.add(e.from.bank)),e.to&&e.to.bank&&(console.log("DEBUG: Found panel connection to bank ".concat(e.to.bank,": ").concat(e.to.id)),n.add(e.to.bank))}),this.modules.forEach(function(e){if("Pot"===e.type||"LEDButton"===e.type){var t,a,o=(null===(t=e.params)||void 0===t?void 0:t.bank)||1,c=(null===(a=e.params)||void 0===a?void 0:a.locked)||!1;console.log("DEBUG: Found ".concat(e.type," ").concat(e.id," with bank=").concat(o,", locked=").concat(c)),c?n.add(1):n.add(o)}if("HarmonicSequencer"===e.type){var r,i=(null===(r=e.params)||void 0===r?void 0:r.start_bank)||1;console.log("DEBUG: Found HarmonicSequencer ".concat(e.id," with start_bank=").concat(i)),n.add(i)}if("BPMLooper"===e.type){var l,s=(null===(l=e.params)||void 0===l?void 0:l.start_bank)||1;console.log("DEBUG: Found BPMLooper ".concat(e.id," with start_bank=").concat(s," (uses banks ").concat(s," and ").concat(s+1,")")),n.add(s),n.add(s+1)}if("StereoMixer4"===e.type){var u,d=(null===(u=e.params)||void 0===u?void 0:u.start_bank)||2;console.log("DEBUG: Found StereoMixer4 ".concat(e.id," using banks ").concat(d," and ").concat(d+1)),n.add(d),n.add(d+1)}if("Matrix2x2"===e.type){var p,f=(null===(p=e.params)||void 0===p?void 0:p.start_bank)||1;console.log("DEBUG: Found Matrix2x2 ".concat(e.id," using bank ").concat(f)),n.add(f)}if("Clock"===e.type){var m,_,g=(null===(m=e.params)||void 0===m?void 0:m.bank)||0;0===g&&(g=n.size>0?Math.max.apply(Math,We(n))+1:1,e.params.bank=g),(null===(_=e.params)||void 0===_?void 0:_.use_outputs_5_8)?(console.log("DEBUG: Found Clock ".concat(e.id," using banks ").concat(g," and ").concat(g+1," (outputs 1-8)")),n.add(g),n.add(g+1)):(console.log("DEBUG: Found Clock ".concat(e.id," using bank ").concat(g," (outputs 1-4 only)")),n.add(g))}}),console.log("DEBUG: usedBanks = ".concat(Array.from(n).sort()));var t=n.size>0?Math.max.apply(Math,We(n)):1;return console.log("DEBUG: activeBanks result = ".concat(t)),this.setupCode.push('\n    // DEBUG: Banking calculation\n    Serial.print("DEBUG: Found banks in use: ");'),Array.from(n).sort().forEach(function(n){e.setupCode.push('    Serial.print("'.concat(n,' ");'))}),this.setupCode.push('\n    Serial.println();\n    Serial.print("DEBUG: activeBanks calculated as: ");\n    Serial.println('.concat(t,");\n        ")),t}},{key:"generateGlobalFunctions",value:function(){var e=this;this.modules.filter(function(e){return"AudioRecorder"===e.type}).forEach(function(n){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";e.globalFunctions=e.globalFunctions||[],e.globalFunctions.push("\n// Scan SD card for existing recXXX.wav files and return the highest index found\nint rec".concat(a,'_findHighestFileIndex() {\n    int highestIndex = 0;\n    File root = SD.open("/");\n    if (!root) {\n        Serial.println("[REC').concat(a,'] Failed to open root directory");\n        return 0;\n    }\n\n    File entry = root.openNextFile();\n    while (entry) {\n        if (!entry.isDirectory()) {\n            String filename = String(entry.name());\n            // Check if filename matches pattern "recXXX.wav" (case insensitive)\n            if (filename.startsWith("rec") && filename.endsWith(".wav")) {\n                // Extract number from filename (skip "rec" prefix, stop at ".wav")\n                String numStr = filename.substring(3, filename.length() - 4);\n                int fileNum = numStr.toInt();\n                if (fileNum > highestIndex) {\n                    highestIndex = fileNum;\n                }\n            }\n        }\n        entry.close();\n        entry = root.openNextFile();\n    }\n    root.close();\n\n    Serial.printf("[REC').concat(a,'] Highest existing file index: %d\\n", highestIndex);\n    return highestIndex;\n}\n\n// FreeRTOS SD Writer Task for AudioRecorder ').concat(a," (Core 0, async writes)\nvoid rec").concat(a,'_sdWriterTaskFunc(void* param) {\n    Serial.printf("[REC').concat(a,'] SD writer task started on Core %d\\n", xPortGetCoreID());\n\n    while (1) {\n        // Keep draining blocks even after recording stops (for finalization)\n        if (rec').concat(a,"_buffered > 0) {\n            // Get next block to write\n            size_t idx = rec").concat(a,"_readIdx;\n            uint8_t* block = &rec").concat(a,"_ringBuffer[idx * REC").concat(a,"_BLOCK_SIZE];\n\n            // Write to SD (blocking operation, but we're on Core 0)\n            if (rec").concat(a,"_recFile) {\n                size_t written = rec").concat(a,"_recFile.write(block, REC").concat(a,"_BLOCK_SIZE);\n                if (written != REC").concat(a,'_BLOCK_SIZE) {\n                    Serial.printf("[REC').concat(a,'] SD write error: wrote %d/%d bytes\\n", written, REC').concat(a,"_BLOCK_SIZE);\n                }\n            }\n\n            // Update ring buffer pointers (thread-safe)\n            if (xSemaphoreTake(rec").concat(a,"_bufferMutex, portMAX_DELAY)) {\n                rec").concat(a,"_readIdx = (rec").concat(a,"_readIdx + 1) % REC").concat(a,"_BLOCK_COUNT;\n                rec").concat(a,"_buffered--;\n                xSemaphoreGive(rec").concat(a,"_bufferMutex);\n            }\n        } else {\n            // No data to write, yield to other tasks\n            vTaskDelay(1);  // 1ms delay\n        }\n    }\n}\n\n// FreeRTOS SD Reader Task for AudioRecorder ").concat(a," (Core 0, async reads for streaming playback)\nvoid play").concat(a,'_sdReaderTaskFunc(void* param) {\n    Serial.printf("[PLAY').concat(a,'] SD reader task started on Core %d\\n", xPortGetCoreID());\n\n    while (1) {\n        if (rec').concat(a,"_playing && !rec").concat(a,"_paused && !play").concat(a,"_eofReached) {\n            // Check if ring buffer has space\n            if (play").concat(a,"_buffered < PLAY").concat(a,"_BLOCK_COUNT) {\n                // Read next block from SD file\n                size_t idx = play").concat(a,"_writeIdx;\n                uint8_t* block = &play").concat(a,"_ringBuffer[idx * PLAY").concat(a,"_BLOCK_SIZE];\n\n                size_t bytesRead = 0;\n                if (rec").concat(a,"_playFile) {\n                    bytesRead = rec").concat(a,"_playFile.read(block, PLAY").concat(a,"_BLOCK_SIZE);\n                }\n\n                if (bytesRead > 0) {\n                    // Update ring buffer pointers (thread-safe)\n                    if (xSemaphoreTake(play").concat(a,"_bufferMutex, portMAX_DELAY)) {\n                        play").concat(a,"_writeIdx = (play").concat(a,"_writeIdx + 1) % PLAY").concat(a,"_BLOCK_COUNT;\n                        play").concat(a,"_buffered++;\n                        xSemaphoreGive(play").concat(a,"_bufferMutex);\n                    }\n                } else {\n                    // End of file reached\n                    play").concat(a,'_eofReached = true;\n                    Serial.printf("[PLAY').concat(a,'] SD reader reached EOF\\n");\n                }\n            } else {\n                // Ring buffer full, wait for audio thread to consume\n                vTaskDelay(5);  // 5ms delay\n            }\n        } else {\n            // Not playing or paused, yield to other tasks\n            vTaskDelay(10);  // 10ms delay\n        }\n    }\n}\n'))}),this.modules.filter(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type}).forEach(function(n){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";e.globalFunctions=e.globalFunctions||[],e.globalFunctions.push("\n// Credit-Based Ring Buffer File Transfer for module ".concat(a,"\nvoid handleFileTransfer").concat(a,"() {\n    static String commandBuffer").concat(a,' = "";\n    \n    // Handle serial commands\n    if (!fileTransferActive').concat(a,") {\n        while (Serial.available()) {\n            char c = Serial.read();\n            if (c == '\\n' || c == '\\r') {\n                if (commandBuffer").concat(a,".length() > 0) {\n                    processFileCommand").concat(a,"(commandBuffer").concat(a,");\n                    commandBuffer").concat(a,' = "";\n                }\n            } else {\n                commandBuffer').concat(a," += c;\n                if (commandBuffer").concat(a,".length() > 100) commandBuffer").concat(a,' = "";\n            }\n        }\n    } else {\n        // File transfer mode - ring buffer approach\n        handleFileData').concat(a,"();\n    }\n}\n\n// Ring buffer file data handler for module ").concat(a,"\nvoid handleFileData").concat(a,"() {\n    // Read data from USB into ring buffer (non-blocking)\n    while (Serial.available() && ringBufferSpace").concat(a,"() > 0) {\n        uint8_t byte = Serial.read();\n        ringBuffer").concat(a,"[ringWritePos").concat(a,"] = byte;\n        ringWritePos").concat(a," = (ringWritePos").concat(a," + 1) % RING_BUFFER_SIZE;\n        \n        taskENTER_CRITICAL(&ringBufferMux").concat(a,");\n        ringBufferCount").concat(a,"++;\n        taskEXIT_CRITICAL(&ringBufferMux").concat(a,");\n        \n        receivedBytes").concat(a,"++;\n        \n        // Send credits when we have reasonable space\n        if (ringBufferSpace").concat(a,'() >= 32768) { // 32KB threshold\n            Serial.printf("CREDITS:%d\\n", ringBufferSpace').concat(a,"());\n        }\n        \n        if (receivedBytes").concat(a," >= expectedFileSize").concat(a,") {\n            break; // Transfer complete\n        }\n    }\n}\n\n// Process file transfer commands for module ").concat(a,"\nvoid processFileCommand").concat(a,'(String cmd) {\n    cmd.trim();\n    \n    if (cmd == "SD:STATUS") {\n        Serial.println("SD:READY");\n    } else if (cmd == "SD:LIST" || cmd.startsWith("SD:LIST:")) {\n        // List directory contents: SD:LIST or SD:LIST:/path\n        String path = "/";\n        if (cmd.startsWith("SD:LIST:")) {\n            path = cmd.substring(8);\n            if (path.length() == 0) path = "/";\n        }\n        \n        File root = SD.open(path);\n        if (root && root.isDirectory()) {\n            Serial.print("SD:LIST:START:");\n            Serial.println(path);\n            \n            File file = root.openNextFile();\n            while (file) {\n                String itemName = String(file.name());\n                if (file.isDirectory()) {\n                    Serial.print("SD:DIR:");\n                    Serial.print(itemName);\n                    Serial.print(":");\n                    Serial.println(path + (path.endsWith("/") ? "" : "/") + itemName);\n                } else {\n                    Serial.print("SD:FILE:");\n                    Serial.print(itemName);\n                    Serial.print(":");\n                    Serial.print(file.size());\n                    Serial.print(":");\n                    Serial.println(path + (path.endsWith("/") ? "" : "/") + itemName);\n                }\n                file.close();\n                file = root.openNextFile();\n            }\n            root.close();\n            Serial.println("SD:LIST:END");\n        } else {\n            Serial.println("SD:LIST:ERROR");\n        }\n    } else if (cmd.startsWith("SD:MKDIR:")) {\n        // Create directory: SD:MKDIR:/path/newdir\n        String dirPath = cmd.substring(9);\n        if (SD.mkdir(dirPath)) {\n            Serial.print("SD:MKDIR:OK:");\n            Serial.println(dirPath);\n        } else {\n            Serial.print("SD:MKDIR:ERROR:");\n            Serial.println(dirPath);\n        }\n    } else if (cmd.startsWith("SD:DELETE:")) {\n        // Delete file or directory: SD:DELETE:/path/file\n        String deletePath = cmd.substring(10);\n        if (SD.remove(deletePath)) {\n            Serial.print("SD:DELETE:OK:");\n            Serial.println(deletePath);\n        } else {\n            Serial.print("SD:DELETE:ERROR:");\n            Serial.println(deletePath);\n        }\n    } else if (cmd.startsWith("SD:EXISTS:")) {\n        // Check if file/directory exists: SD:EXISTS:/path\n        String checkPath = cmd.substring(10);\n        if (SD.exists(checkPath)) {\n            File item = SD.open(checkPath);\n            if (item.isDirectory()) {\n                Serial.print("SD:EXISTS:DIR:");\n            } else {\n                Serial.print("SD:EXISTS:FILE:");\n                Serial.print(item.size());\n                Serial.print(":");\n            }\n            Serial.println(checkPath);\n            item.close();\n        } else {\n            Serial.print("SD:EXISTS:NO:");\n            Serial.println(checkPath);\n        }\n    } else if (cmd.startsWith("SD:FILE:")) {\n        // Parse: SD:FILE:filename:size\n        int lastColon = cmd.lastIndexOf(\':\');\n        if (lastColon > 8) {\n            transferFilename').concat(a," = cmd.substring(8, lastColon);\n            expectedFileSize").concat(a," = cmd.substring(lastColon + 1).toInt();\n            \n            // Ensure proper path\n            if (!transferFilename").concat(a,'.startsWith("/")) {\n                transferFilename').concat(a,' = "/" + transferFilename').concat(a,";\n            }\n            if (!transferFilename").concat(a,'.startsWith("/samples")) {\n                transferFilename').concat(a,' = "/samples" + transferFilename').concat(a,';\n            }\n            \n            // Create samples directory if needed\n            if (!SD.exists("/samples")) {\n                SD.mkdir("/samples");\n            }\n            \n            // Open file for writing\n            if (SD.exists(transferFilename').concat(a,")) {\n                SD.remove(transferFilename").concat(a,");\n            }\n            \n            transferFile").concat(a," = SD.open(transferFilename").concat(a,", FILE_WRITE);\n            if (transferFile").concat(a,") {\n                // Initialize ring buffer\n                ringWritePos").concat(a," = 0;\n                ringReadPos").concat(a," = 0;\n                ringBufferCount").concat(a," = 0;\n                receivedBytes").concat(a," = 0;\n                fileTransferActive").concat(a," = true;\n                \n                // Start the SD writer task on Core 1\n                xTaskCreatePinnedToCore(\n                    sdWriterTask").concat(a,',\n                    "SDWriter').concat(a,'",\n                    8192,\n                    NULL,\n                    1, // Priority\n                    &sdWriterTaskHandle').concat(a,",\n                    1  // Core 1\n                );\n                \n                // Send initial credit window\n                int initialCredits = ringBufferSpace").concat(a,'();\n                Serial.printf("SD:READY:%d\\n", initialCredits);\n            } else {\n                Serial.println("SD:FILE:ERROR");\n            }\n        }\n    }\n}\n            ')),e.globalFunctions.push("\n\n// Ring buffer utility functions for module ".concat(a,"\nint ringBufferSpace").concat(a,"() {\n    return RING_BUFFER_SIZE - ringBufferCount").concat(a,";\n}\n\nint ringBufferAvailable").concat(a,"() {\n    return ringBufferCount").concat(a,";\n}\n\n// SD writer task for module ").concat(a," - runs on Core 1\nvoid sdWriterTask").concat(a,"(void* parameter) {\n    uint8_t writeBuffer[16384]; // 16KB write buffer\n    \n    while (fileTransferActive").concat(a,") {\n        int available = ringBufferAvailable").concat(a,"();\n        \n        if (available >= sizeof(writeBuffer) || \n           (available > 0 && receivedBytes").concat(a," >= expectedFileSize").concat(a,")) {\n            \n            // Fill write buffer from ring buffer\n            int toWrite = min(available, (int)sizeof(writeBuffer));\n            for (int i = 0; i < toWrite; i++) {\n                writeBuffer[i] = ringBuffer").concat(a,"[ringReadPos").concat(a,"];\n                ringReadPos").concat(a," = (ringReadPos").concat(a," + 1) % RING_BUFFER_SIZE;\n            }\n            \n            // Write to SD card in large block\n            if (transferFile").concat(a," && toWrite > 0) {\n                transferFile").concat(a,".write(writeBuffer, toWrite);\n                transferFile").concat(a,".flush(); // Ensure data is written\n                \n                // Update ring buffer count atomically\n                taskENTER_CRITICAL(&ringBufferMux").concat(a,");\n                ringBufferCount").concat(a," -= toWrite;\n                taskEXIT_CRITICAL(&ringBufferMux").concat(a,");\n                \n                // Send credits to web app\n                int freeSpace = ringBufferSpace").concat(a,'();\n                if (freeSpace >= 32768) { // Send credits when 32KB+ free\n                    Serial.printf("CREDITS:%d\\n", freeSpace);\n                }\n            }\n            \n            // Check if transfer complete\n            if (receivedBytes').concat(a," >= expectedFileSize").concat(a," && available == 0) {\n                transferFile").concat(a,".close();\n                fileTransferActive").concat(a,' = false;\n                Serial.printf("FILE:COMPLETE:%s\\n", transferFilename').concat(a,".c_str());\n                break;\n            }\n        }\n        \n        vTaskDelay(pdMS_TO_TICKS(10)); // Small delay to prevent busy waiting\n    }\n    \n    // Clean up task\n    sdWriterTaskHandle").concat(a," = NULL;\n    vTaskDelete(NULL);\n}\n            "))}),this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type})&&(this.globalFunctions=this.globalFunctions||[],this.globalFunctions.push('\n// Universal SD Directory Browser - Only included when Sample Player modules are present\nvoid handleSDCommands() {\n    static String sdCommandBuffer = "";\n    \n    while (Serial.available()) {\n        char c = Serial.read();\n        if (c == \'\\n\' || c == \'\\r\') {\n            if (sdCommandBuffer.length() > 0) {\n                processGlobalSDCommand(sdCommandBuffer);\n                sdCommandBuffer = "";\n            }\n        } else {\n            sdCommandBuffer += c;\n            if (sdCommandBuffer.length() > 100) sdCommandBuffer = ""; // Prevent overflow\n        }\n    }\n}\n\n// Process global SD commands\nvoid processGlobalSDCommand(String cmd) {\n    cmd.trim();\n    \n    if (cmd == "SD:STATUS") {\n        Serial.println("SD:READY");\n    } else if (cmd == "SD:LIST" || cmd.startsWith("SD:LIST:")) {\n        // List directory contents: SD:LIST or SD:LIST:/path\n        String path = "/";\n        if (cmd.startsWith("SD:LIST:")) {\n            path = cmd.substring(8);\n            if (path.length() == 0) path = "/";\n        }\n        \n        File root = SD.open(path);\n        if (root && root.isDirectory()) {\n            Serial.print("SD:LIST:START:");\n            Serial.println(path);\n            \n            File file = root.openNextFile();\n            while (file) {\n                String itemName = String(file.name());\n                if (file.isDirectory()) {\n                    Serial.print("SD:DIR:");\n                    Serial.print(itemName);\n                    Serial.print(":");\n                    Serial.println(path + (path.endsWith("/") ? "" : "/") + itemName);\n                } else {\n                    Serial.print("SD:FILE:");\n                    Serial.print(itemName);\n                    Serial.print(":");\n                    Serial.print(file.size());\n                    Serial.print(":");\n                    Serial.println(path + (path.endsWith("/") ? "" : "/") + itemName);\n                }\n                file.close();\n                file = root.openNextFile();\n            }\n            root.close();\n            Serial.println("SD:LIST:END");\n        } else {\n            Serial.println("SD:LIST:ERROR");\n        }\n    } else if (cmd.startsWith("SD:MKDIR:")) {\n        // Create directory: SD:MKDIR:/path/newdir\n        String dirPath = cmd.substring(9);\n        if (SD.mkdir(dirPath)) {\n            Serial.print("SD:MKDIR:OK:");\n            Serial.println(dirPath);\n        } else {\n            Serial.print("SD:MKDIR:ERROR:");\n            Serial.println(dirPath);\n        }\n    } else if (cmd.startsWith("SD:DELETE:")) {\n        // Delete file or directory: SD:DELETE:/path/file\n        String deletePath = cmd.substring(10);\n        if (SD.remove(deletePath)) {\n            Serial.print("SD:DELETE:OK:");\n            Serial.println(deletePath);\n        } else {\n            Serial.print("SD:DELETE:ERROR:");\n            Serial.println(deletePath);\n        }\n    } else if (cmd.startsWith("SD:EXISTS:")) {\n        // Check if file/directory exists: SD:EXISTS:/path\n        String checkPath = cmd.substring(10);\n        if (SD.exists(checkPath)) {\n            File item = SD.open(checkPath);\n            if (item.isDirectory()) {\n                Serial.print("SD:EXISTS:DIR:");\n            } else {\n                Serial.print("SD:EXISTS:FILE:");\n                Serial.print(item.size());\n                Serial.print(":");\n            }\n            Serial.println(checkPath);\n            item.close();\n        } else {\n            Serial.print("SD:EXISTS:NO:");\n            Serial.println(checkPath);\n        }\n    } else if (cmd == "SD:INFO") {\n        // SD card info\n        Serial.print("SD:INFO:SIZE:");\n        Serial.print(SD.cardSize() / 1048576); // MB\n        Serial.print(":USED:");\n        Serial.print(SD.usedBytes() / 1048576); // MB\n        Serial.print(":TYPE:");\n        Serial.println(SD.cardType());\n    }\n}\n        ')),this.globalFunctions=this.globalFunctions||[];var n=this.modules.filter(function(e){return"LEDButton"===e.type}),t=this.modules.filter(function(e){return"Pot"===e.type}),a="\n// Bank colors (RGB)\nstruct BankColor {\n  uint8_t r, g, b;\n};\n\nconst BankColor bankColors[6] = {\n  {255, 0, 0},     // Bank 1: Red\n  {0, 255, 0},     // Bank 2: Green\n  {0, 0, 255},     // Bank 3: Blue\n  {255, 200, 0},   // Bank 4: Yellow\n  {0, 255, 255},   // Bank 5: Cyan\n  {255, 0, 255}    // Bank 6: Magenta\n};\n\nvoid updateNeoPixels() {\n  // Get current bank color (currentBank is 1-based, array is 0-based)\n  BankColor color = bankColors[(currentBank - 1) % 6];\n\n  // Clear all NeoPixels first\n  neoPixels.clear();\n";n.forEach(function(n){var t=n.params.index||1,o=[3,2,1,0][t-1],c=null,r=null,i=null;e.modularInstances.forEach(function(t,a){if("Looper"===t.type){var o=e.modules.find(function(n){return(n.id||"".concat(n.type).concat(e.modules.indexOf(n)))===a});e.connections.find(function(e){return e.from.id===n.id+":press"&&e.to.id===o.id+":record"})&&(c=t.instanceName)}else if("BPMLooper"===t.type){var l=e.modules.find(function(n){return(n.id||"".concat(n.type).concat(e.modules.indexOf(n)))===a});if((n.params.bank||1)===(l.params.start_bank||1)){var s=n.params.index||1;r=t.instanceName,i=s-1}}});var l=e.modules.filter(function(e){return"Automation"===e.type}),s="false";if(l.forEach(function(a){var o=e.modules.findIndex(function(e){return e.id===a.id}),c=e.connections.find(function(e){return e.to.id.includes("".concat(a.id,":"))&&"record_trigger"===e.to.port});c&&c.from.id.split(":")[0]===n.id&&(s="(btn".concat(t,"_gate && automation").concat(o,"_record_trigger)"))}),c)a+="\n  // Button ".concat(t," NeoPixel (LED index ").concat(o,") - Looper control\n  float looperState = ").concat(c,".ledOut;\n  if (looperState < 0.5f) {\n    // EMPTY state: Pulsing red (ready to record)\n    uint8_t pulse = (uint8_t)((sin(millis() / 300.0) + 1.0) * 127.5);\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(pulse, 0, 0));\n  } else if (looperState < 1.5f) {\n    // RECORDING state: Solid red\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(255, 0, 0));\n  } else if (looperState < 2.5f) {\n    // PLAYING state: Solid green (looping)\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(0, 255, 0));\n  } else if (looperState < 3.5f) {\n    // MUTED state: Off\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(0, 0, 0));\n  } else {\n    // OVERDUBBING state: Solid orange (layering audio)\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(255, 128, 0));\n  }\n");else if(r)a+="\n  // Button ".concat(t," NeoPixel (LED index ").concat(o,") - BPM Looper slot ").concat(i+1,"\n  float bpmLooperLed = ").concat(r,".ledOutputs[").concat(i,"];\n  // bpmLooperLed is 0.0-1.0 representing brightness (fade from beat start)\n  uint8_t brightness = (uint8_t)(bpmLooperLed * 255.0f);\n  neoPixels.setPixelColor(").concat(o,", neoPixels.Color(0, brightness, 0)); // Green fade\n");else if(e.checkAudioRecorderButton(n,t)){var u=e.getAudioRecorderForButton(n,t);if(u){var d=u.instanceIndex,p=u.buttonRole;a+="\n  // Button ".concat(t," NeoPixel (LED index ").concat(o,") - AudioRecorder ").concat(p,"\n  float recLed = rec").concat(d,"_led").concat("record"===p?"1":"2",";\n  if (recLed > 0.9f) {\n    // Full brightness: Recording or Playing\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(").concat("record"===p?"255, 0, 0":"0, 255, 0","));\n  } else if (recLed > 0.01f) {\n    // Pulsing: Armed or Paused\n    uint8_t brightness = (uint8_t)(recLed * 255.0f);\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(").concat("record"===p?"brightness, 0, 0":"0, brightness, 0","));\n  } else {\n    // Off\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(0, 0, 0));\n  }\n")}}else{var f=e.connections.find(function(e){return!(e.from.id!==n.id+":press"&&e.from.id!==n.id+":gate"||e.to.id.includes("Automation:record_trigger")||e.to.id.includes("Looper:record"))});a+=f?"\n  // Button ".concat(t," NeoPixel (LED index ").concat(o,") - Gate mode (dim=inactive, bright=active)\n  if (btn").concat(t,"_gate) {\n    // Gate active: Full brightness bank color\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(color.r, color.g, color.b));\n  } else {\n    // Gate inactive: Dim (20% brightness) to show it's in operation but inactive\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(\n      (uint8_t)(color.r * 0.2),\n      (uint8_t)(color.g * 0.2),\n      (uint8_t)(color.b * 0.2)\n    ));\n  }\n"):"\n  // Button ".concat(t," NeoPixel (LED index ").concat(o,")\n  if (").concat(s,") {\n    // Override with red for automation record\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(255, 0, 0));\n  } else {\n    // Use bank color\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(color.r, color.g, color.b));\n  }\n")}}),this.modules.filter(function(e){return"AudioRecorder"===e.type}).forEach(function(e){var n,t=e.params.bank||1,o=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1";a+="\n  // AudioRecorder ".concat(o," Button 1 (Record) - Bank ").concat(t,"\n  if (currentBank == ").concat(t,") {\n    float recLed = rec").concat(o,"_led1;\n    if (recLed > 0.9f) {\n      // Full brightness: Recording\n      neoPixels.setPixelColor(").concat(3,", neoPixels.Color(255, 0, 0));\n    } else if (recLed > 0.01f) {\n      // Pulsing: Armed\n      uint8_t brightness = (uint8_t)(recLed * 255.0f);\n      neoPixels.setPixelColor(").concat(3,", neoPixels.Color(brightness, 0, 0));\n    } else {\n      // Off\n      neoPixels.setPixelColor(").concat(3,", neoPixels.Color(0, 0, 0));\n    }\n  }\n"),a+="\n  // AudioRecorder ".concat(o," Button 2 (Play/Pause) - Bank ").concat(t,"\n  if (currentBank == ").concat(t,") {\n    float recLed = rec").concat(o,"_led2;\n    if (recLed > 0.9f) {\n      // Full brightness: Playing\n      neoPixels.setPixelColor(").concat(2,", neoPixels.Color(0, 255, 0));\n    } else if (recLed > 0.01f) {\n      // Pulsing: Paused\n      uint8_t brightness = (uint8_t)(recLed * 255.0f);\n      neoPixels.setPixelColor(").concat(2,", neoPixels.Color(0, brightness, 0));\n    } else {\n      // Off\n      neoPixels.setPixelColor(").concat(2,", neoPixels.Color(0, 0, 0));\n    }\n  }\n")}),this.modules.filter(function(e){return"StereoMixer4"===e.type}).forEach(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1",o=e.params.start_bank||2,c=o+1,r=[3,2,1,0];a+="\n  // StereoMixer4 ".concat(t," button LEDs (Banks ").concat(o," and ").concat(c,")\n\n  // Bank ").concat(o,": Mute status indicators\n  if (currentBank == ").concat(o,") {\n    // Button LEDs show mute status: Green = unmuted, Off = muted\n    for (int ch = 0; ch < 4; ch++) {\n      int ledIdx = ").concat(r[0],"; // Will be overwritten in loop\n      if (ch == 0) ledIdx = ").concat(r[0],"; // Button 1  LED 3\n      if (ch == 1) ledIdx = ").concat(r[1],"; // Button 2  LED 2\n      if (ch == 2) ledIdx = ").concat(r[2],"; // Button 3  LED 1\n      if (ch == 3) ledIdx = ").concat(r[3],"; // Button 4  LED 0\n\n      if (!stereoMixer4_").concat(t,"_mute[ch]) {\n        // Unmuted: Green (channel active)\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(0, 255, 0));\n      } else {\n        // Muted: Off\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(0, 0, 0));\n      }\n    }\n  }\n\n  // Bank ").concat(c,": Pan/Solo indicators\n  if (currentBank == ").concat(c,") {\n    // Button LEDs: Yellow when channel is soloed, Off otherwise\n    for (int ch = 0; ch < 4; ch++) {\n      int ledIdx = ").concat(r[0],"; // Will be overwritten in loop\n      if (ch == 0) ledIdx = ").concat(r[0],"; // Button 1  LED 3\n      if (ch == 1) ledIdx = ").concat(r[1],"; // Button 2  LED 2\n      if (ch == 2) ledIdx = ").concat(r[2],"; // Button 3  LED 1\n      if (ch == 3) ledIdx = ").concat(r[3],"; // Button 4  LED 0\n\n      if (stereoMixer4_").concat(t,"_solo_channel == (ch + 1)) {\n        // Channel soloed: Yellow\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(255, 180, 0));\n      } else {\n        // Normal: Off\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(0, 0, 0));\n      }\n    }\n  }\n")});var o=new Set;t.forEach(function(n){var t=n.params.index||1;if(!o.has(t)){o.add(t);var c=[7,6,5,4][t-1],r=e.connections.find(function(e){return e.from.id===n.id+":value"}),i="brightness",l=null;if(r){var s,u=r.to.id.split(":")[0],d=r.to.id.split(":")[1],p=e.modules.find(function(e){return e.id===u});if(p&&"GateGen"===p.type&&"self_clock_bpm"===d)i="gate_pulse",l=(null===(s=p.id.match(/\d+$/))||void 0===s?void 0:s[0])||"1";else if(p&&"Clock"===p.type&&"bpm_input"===d){var f;i="clock_pulse",l=(null===(f=p.id.match(/\d+$/))||void 0===f?void 0:f[0])||"1"}}var m=new Set;m.add(n.params.bank||1),e.connections.forEach(function(e){e.from&&e.from.id.startsWith(n.id+":")&&e.from.bank&&m.add(e.from.bank)});var _=Array.from(m).sort(function(e,n){return e-n}),g=1===_.length?"currentBank == ".concat(_[0]):_.map(function(e){return"currentBank == ".concat(e)}).join(" || ");a+="gate_pulse"===i?"\n  // Pot ".concat(t," NeoPixel (LED index ").concat(c,") - Flash in sync with Gate Generator pulses (banks: ").concat(_.join(", "),")\n  float pot").concat(t,"_brightness;\n  if (").concat(g,") {\n    pot").concat(t,"_brightness = gate").concat(l,"_led_output; // Flash with gate when in correct bank\n  } else {\n    pot").concat(t,"_brightness = 0.0f; // Off when not in pot's bank\n  }\n  neoPixels.setPixelColor(").concat(c,", neoPixels.Color(\n    (uint8_t)(color.r * pot").concat(t,"_brightness),\n    (uint8_t)(color.g * pot").concat(t,"_brightness),\n    (uint8_t)(color.b * pot").concat(t,"_brightness)\n  ));\n"):"clock_pulse"===i?"\n  // Pot ".concat(t," NeoPixel (LED index ").concat(c,") - Flash in sync with Clock pulses (banks: ").concat(_.join(", "),")\n  float pot").concat(t,"_brightness;\n  if (").concat(g,") {\n    pot").concat(t,"_brightness = clock").concat(l,"_led_output; // Flash with clock when in correct bank\n  } else {\n    pot").concat(t,"_brightness = 0.0f; // Off when not in pot's bank\n  }\n  neoPixels.setPixelColor(").concat(c,", neoPixels.Color(\n    (uint8_t)(color.r * pot").concat(t,"_brightness),\n    (uint8_t)(color.g * pot").concat(t,"_brightness),\n    (uint8_t)(color.b * pot").concat(t,"_brightness)\n  ));\n"):"\n  // Pot ".concat(t," NeoPixel (LED index ").concat(c,") - Brightness reflects pot value (banks: ").concat(_.join(", "),")\n  float pot").concat(t,"_brightness;\n  if (").concat(g,") {\n    pot").concat(t,"_brightness = pot").concat(t,"_value; // Show value when in correct bank\n  } else {\n    pot").concat(t,"_brightness = 0.0f; // Off when not in pot's bank\n  }\n  neoPixels.setPixelColor(").concat(c,", neoPixels.Color(\n    (uint8_t)(color.r * pot").concat(t,"_brightness),\n    (uint8_t)(color.g * pot").concat(t,"_brightness),\n    (uint8_t)(color.b * pot").concat(t,"_brightness)\n  ));\n")}}),this.modules.filter(function(e){return"StereoMixer4"===e.type}).forEach(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1",o=e.params.start_bank||2,c=[7,6,5,4];a+="\n  // StereoMixer4 ".concat(t," volume visualization (Bank ").concat(o,")\n  if (currentBank == ").concat(o,") {\n    // Show volume level on pot LEDs using bank color with brightness control\n    BankColor color = bankColors[(currentBank - 1) % 6];\n    for (int ch = 0; ch < 4; ch++) {\n      int ledIdx = ").concat(c[0],"; // Will be overwritten in loop\n      if (ch == 0) ledIdx = ").concat(c[0],"; // Pot 1  LED 7\n      if (ch == 1) ledIdx = ").concat(c[1],"; // Pot 2  LED 6\n      if (ch == 2) ledIdx = ").concat(c[2],"; // Pot 3  LED 5\n      if (ch == 3) ledIdx = ").concat(c[3],"; // Pot 4  LED 4\n\n      float brightness = stereoMixer4_").concat(t,"_smoothed_pot[ch]; // 0.0-1.0\n      neoPixels.setPixelColor(ledIdx, neoPixels.Color(\n        (uint8_t)(color.r * brightness),\n        (uint8_t)(color.g * brightness),\n        (uint8_t)(color.b * brightness)\n      ));\n    }\n  }\n")}),this.modules.filter(function(e){return"StereoMixer4"===e.type}).forEach(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1",o=(e.params.start_bank||2)+1,c=[7,6,5,4];a+="\n  // StereoMixer4 ".concat(t," pan visualization (Bank ").concat(o,")\n  if (currentBank == ").concat(o,") {\n    // Show pan position on pot LEDs: Purple (left)  Green (center)  Blue (right)\n    for (int ch = 0; ch < 4; ch++) {\n      int ledIdx = ").concat(c[0],"; // Will be overwritten in loop\n      if (ch == 0) ledIdx = ").concat(c[0],"; // Pot 1  LED 7\n      if (ch == 1) ledIdx = ").concat(c[1],"; // Pot 2  LED 6\n      if (ch == 2) ledIdx = ").concat(c[2],"; // Pot 3  LED 5\n      if (ch == 3) ledIdx = ").concat(c[3],"; // Pot 4  LED 4\n\n      float panPos = stereoMixer4_").concat(t,"_pan[ch]; // 0.0=left, 0.5=center, 1.0=right\n      uint8_t r, g, b;\n\n      if (panPos < 0.5) {\n        // Left half: Purple (128,0,255)  Green (0,255,0)\n        float t = panPos * 2.0; // 0.01.0 over left half\n        r = (uint8_t)(128 * (1.0 - t));           // 1280\n        g = (uint8_t)(255 * t);                   // 0255\n        b = (uint8_t)(255 * (1.0 - t));           // 2550\n      } else {\n        // Right half: Green (0,255,0)  Blue (0,0,255)\n        float t = (panPos - 0.5) * 2.0; // 0.01.0 over right half\n        r = 0;                                    // 00\n        g = (uint8_t)(255 * (1.0 - t));           // 2550\n        b = (uint8_t)(255 * t);                   // 0255\n      }\n\n      neoPixels.setPixelColor(ledIdx, neoPixels.Color(r, g, b));\n    }\n  }\n")}),this.modules.filter(function(e){return"Matrix2x2"===e.type}).forEach(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1",o=e.params.start_bank||1,c=[7,6,5,4];a+="\n  // Matrix2x2 ".concat(t," visualization (Bank ").concat(o,")\n  if (currentBank == ").concat(o,") {\n    // Show matrix coefficient values on pot LEDs using bipolar color coding\n    // Negative = Red, Zero = Off/Dim, Positive = Green\n    for (int i = 0; i < 4; i++) {\n      int ledIdx = ").concat(c[0],"; // Will be overwritten in loop\n      if (i == 0) ledIdx = ").concat(c[0],"; // Pot 1  LED 7 (aa)\n      if (i == 1) ledIdx = ").concat(c[1],"; // Pot 2  LED 6 (ab)\n      if (i == 2) ledIdx = ").concat(c[2],"; // Pot 3  LED 5 (ba)\n      if (i == 3) ledIdx = ").concat(c[3],"; // Pot 4  LED 4 (bb)\n\n      float value = matrix").concat(t,"_smoothed_pot[i]; // 0.0-1.0 (maps to -1.0 to +1.0 in audio code)\n      float bipolar = value * 2.0 - 1.0; // Convert to -1.0 to +1.0 for visualization\n      uint8_t r, g, b;\n\n      if (bipolar < -0.05) {\n        // Negative (red) - phase inverted routing\n        float intensity = min(fabsf(bipolar), 1.0f);\n        r = (uint8_t)(255 * intensity);\n        g = 0;\n        b = 0;\n      } else if (bipolar > 0.05) {\n        // Positive (green) - normal routing\n        float intensity = min(bipolar, 1.0f);\n        r = 0;\n        g = (uint8_t)(255 * intensity);\n        b = 0;\n      } else {\n        // Near zero (dim white) - minimal routing\n        r = 20;\n        g = 20;\n        b = 20;\n      }\n\n      neoPixels.setPixelColor(ledIdx, neoPixels.Color(r, g, b));\n    }\n  }\n")}),this.modules.filter(function(e){return"Clock"===e.type}).forEach(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1",o=e.params.bank||4,c=[7,6,5,4],r=[3,2,1,0];a+="\n  // Clock ".concat(t," NeoPixel visualization (Bank ").concat(o,")\n  if (currentBank == ").concat(o,") {\n    BankColor color = bankColors[(currentBank - 1) % 6];\n\n    // Pot LEDs: Show trigger pulses (flash when output fires)\n    // This visualizes the beat relationship between the 4 channels\n    for (int i = 0; i < 4; i++) {\n      int ledIdx = ").concat(c[0],"; // Will be overwritten in loop\n      if (i == 0) ledIdx = ").concat(c[0],"; // Pot 1  LED 7\n      if (i == 1) ledIdx = ").concat(c[1],"; // Pot 2  LED 6\n      if (i == 2) ledIdx = ").concat(c[2],"; // Pot 3  LED 5\n      if (i == 3) ledIdx = ").concat(c[3],"; // Pot 4  LED 4\n\n      bool outputState = false;\n      if (i == 0) outputState = clock").concat(t,"_out1;\n      if (i == 1) outputState = clock").concat(t,"_out2;\n      if (i == 2) outputState = clock").concat(t,"_out3;\n      if (i == 3) outputState = clock").concat(t,"_out4;\n\n      if (outputState) {\n        // Output HIGH: Full brightness pulse (shows trigger)\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(color.r, color.g, color.b));\n      } else {\n        // Output LOW: Dim baseline (10% brightness for visibility)\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(\n          (uint8_t)(color.r * 0.1f),\n          (uint8_t)(color.g * 0.1f),\n          (uint8_t)(color.b * 0.1f)\n        ));\n      }\n    }\n\n    // Button LEDs: Show fill button states (on when pressed, off when released)\n    for (int i = 0; i < 4; i++) {\n      int ledIdx = ").concat(r[0],"; // Will be overwritten in loop\n      if (i == 0) ledIdx = ").concat(r[0],"; // Btn 1  LED 3\n      if (i == 1) ledIdx = ").concat(r[1],"; // Btn 2  LED 2\n      if (i == 2) ledIdx = ").concat(r[2],"; // Btn 3  LED 1\n      if (i == 3) ledIdx = ").concat(r[3],"; // Btn 4  LED 0\n\n      bool fillState = false;\n      if (i == 0) fillState = clock").concat(t,"_fill1;\n      if (i == 1) fillState = clock").concat(t,"_fill2;\n      if (i == 2) fillState = clock").concat(t,"_fill3;\n      if (i == 3) fillState = clock").concat(t,"_fill4;\n\n      if (fillState) {\n        // Fill active: Full bank color\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(color.r, color.g, color.b));\n      } else {\n        // Fill inactive: Off\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(0, 0, 0));\n      }\n    }\n  }\n")}),this.modules.filter(function(e){return"BPMLooper"===e.type}).forEach(function(n){var t=e.modularInstances.get(n.id);if(t)for(var o=n.params.start_bank||1,c=o+1,r=0;r<4;r++){var i=[3,2,1,0][r];a+="\n  // BPM Looper slot ".concat(r+1," NeoPixel (LED index ").concat(i,") - Banks ").concat(o,"-").concat(c,"\n  if (currentBank == ").concat(o,") {\n    // Bank 1: Record/Mix mode (Red/Green)\n    float bpmLooperLed = ").concat(t.instanceName,".ledOutputs[").concat(r,"];\n    // Negative = red (empty/recording), Positive = green (playing), 0 = off (muted)\n    if (bpmLooperLed < 0.0f) {\n      // Red states (empty pulsing or recording solid)\n      uint8_t brightness = (uint8_t)(fabsf(bpmLooperLed) * 255.0f);\n      neoPixels.setPixelColor(").concat(i,", neoPixels.Color(brightness, 0, 0)); // Red\n    } else if (bpmLooperLed > 0.0f) {\n      // Green state (playing with beat pulse)\n      uint8_t brightness = (uint8_t)(bpmLooperLed * 255.0f);\n      neoPixels.setPixelColor(").concat(i,", neoPixels.Color(0, brightness, 0)); // Green\n    } else {\n      // Off (muted)\n      neoPixels.setPixelColor(").concat(i,", neoPixels.Color(0, 0, 0));\n    }\n  } else if (currentBank == ").concat(c,") {\n    // Bank 2: Randomization/Pitch mode (Blue/Cyan/Yellow)\n    float randomization = ").concat(t.instanceName,".slotRandomization[").concat(r,"];\n    float pitch = ").concat(t.instanceName,".slotPitch[").concat(r,"];\n    bool buttonPressed = ").concat(t.instanceName,".bank2ButtonPressed[").concat(r,"];\n\n    if (buttonPressed) {\n      // Button held: Pitch mode - color shift based on pitch (Blue=slow, Cyan=normal, Yellow=fast)\n      uint8_t r, g, b;\n      if (pitch < 0.75f) {\n        // Slow (0.5x-0.75x): Blue to Cyan\n        float t = (pitch - 0.5f) / 0.25f; // 0-1\n        r = 0;\n        g = (uint8_t)(t * 200.0f);\n        b = 200;\n      } else if (pitch < 1.25f) {\n        // Normal (0.75x-1.25x): Cyan\n        r = 0;\n        g = 200;\n        b = 200;\n      } else {\n        // Fast (1.25x-2.0x): Cyan to Yellow\n        float t = (pitch - 1.25f) / 0.75f; // 0-1\n        r = (uint8_t)(t * 200.0f);\n        g = 200;\n        b = (uint8_t)((1.0f - t) * 200.0f);\n      }\n      neoPixels.setPixelColor(").concat(i,", neoPixels.Color(r, g, b));\n    } else {\n      // Button released: Randomization mode - green intensity = randomization amount\n      uint8_t brightness = (uint8_t)(randomization * 200.0f);\n      neoPixels.setPixelColor(").concat(i,", neoPixels.Color(0, brightness, 0));\n    }\n  }\n")}}),this.modules.filter(function(e){return"MIDILooper"===e.type}).forEach(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1",o=e.params.bank||1;a+="\n  // MIDILooper ".concat(t," LED feedback (Bank ").concat(o,")\n  if (currentBank == ").concat(o,") {\n    // Check if we're at bar start (every 4 beats = 4 * 96 PPQ = 384 ticks)\n    bool atBarStart = (midiloop").concat(t,"_playhead % (4 * MIDILOOP").concat(t,"_PPQ)) < 8;  // ~8 tick window for flash\n    // Check if we're at beat (every 96 PPQ) - for armed state tempo indicator\n    bool atBeat = (midiloop").concat(t,"_playhead % MIDILOOP").concat(t,"_PPQ) < 8;\n\n    // LED3 (under Btn1): State indicator\n    switch (midiloop").concat(t,"_state) {\n      case 0: {  // Armed: flash red on beat to show internal clock is running\n        // Use internal clock timing to flash at 100 BPM (600ms per beat)\n        static unsigned long midiloop").concat(t,"_armed_flash_time = 0;\n        static bool midiloop").concat(t,"_armed_flash_on = false;\n        if (millis() - midiloop").concat(t,"_armed_flash_time >= 300) {  // 300ms = half beat at 100 BPM\n          midiloop").concat(t,"_armed_flash_time = millis();\n          midiloop").concat(t,"_armed_flash_on = !midiloop").concat(t,"_armed_flash_on;\n        }\n        uint8_t flash = midiloop").concat(t,"_armed_flash_on ? 150 : 20;  // Red pulse at tempo\n        neoPixels.setPixelColor(3, neoPixels.Color(flash, 0, 0));\n        break;\n      }\n      case 1: {  // Count-in: fast orange flash + white on bar\n        if (atBarStart) {\n          neoPixels.setPixelColor(3, neoPixels.Color(255, 255, 255));  // White flash on bar\n        } else {\n          uint8_t flash = (millis() % 300 < 150) ? 255 : 0;\n          neoPixels.setPixelColor(3, neoPixels.Color(flash, flash * 128 / 255, 0));  // Orange flash\n        }\n        break;\n      }\n      case 2: {  // Recording: red with white flash on bar start\n        if (atBarStart) {\n          neoPixels.setPixelColor(3, neoPixels.Color(255, 255, 255));  // White flash on bar\n        } else {\n          neoPixels.setPixelColor(3, neoPixels.Color(255, 0, 0));  // Solid red\n        }\n        break;\n      }\n      case 3: {  // Playing: green with white flash on bar start\n        if (atBarStart) {\n          neoPixels.setPixelColor(3, neoPixels.Color(255, 255, 255));  // White flash on bar\n        } else {\n          neoPixels.setPixelColor(3, neoPixels.Color(0, 255, 0));  // Solid green\n        }\n        break;\n      }\n      case 4: {  // Overdub: yellow with white flash on bar start\n        if (atBarStart) {\n          neoPixels.setPixelColor(3, neoPixels.Color(255, 255, 255));  // White flash on bar\n        } else {\n          neoPixels.setPixelColor(3, neoPixels.Color(255, 255, 0));  // Solid yellow\n        }\n        break;\n      }\n      case 5: neoPixels.setPixelColor(3, neoPixels.Color(0, 0, 255)); break;        // Stopped: blue\n    }\n    // LED2 (under Btn2): Scale-lock indicator\n    if (midiloop").concat(t,"_scale_lock) {\n      neoPixels.setPixelColor(2, neoPixels.Color(128, 0, 255));  // Purple when held\n    } else {\n      neoPixels.setPixelColor(2, neoPixels.Color(0, 0, 0));\n    }\n  }\n")}),a+="\n  neoPixels.show();\n}\n",this.globalFunctions.push(a),this.generateBLEMIDIHelpers()}},{key:"generateBLEMIDIHelpers",value:function(){var e=this,n=this.modules.filter(function(e){return"BLEMIDIIn"===e.type});0!==n.length&&(this.globalFunctions=this.globalFunctions||[],n.forEach(function(n){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1",o=e.hardwareModules.generateBLEMIDIHelpers(n,a);o&&e.globalFunctions.push(o)}))}},{key:"generateSetup",value:function(){var e=this,n=this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type})?921600:115200;this.setupCode.push("\nvoid setup() {\n    Serial.begin(".concat(n,');\n    delay(1000);\n    Serial.println("ESP32 Patcher starting...");\n    Serial.print("CPU Frequency: ");\n    Serial.print(getCpuFrequencyMhz());\n    Serial.println("MHz");\n\n').concat(this.modules.some(function(e){return"USBMIDIIn"===e.type||"USBMIDIOut"===e.type})?'    // Initialize USB MIDI (GPIO19/20)\n    // IMPORTANT: Arduino IDE  Tools  USB CDC On Boot: "Enabled"\n    // This ensures Serial/CDC remains available alongside USB MIDI\n    #if !ARDUINO_USB_CDC_ON_BOOT\n        #warning "USB CDC On Boot is DISABLED. Arduino IDE will not show device after upload!"\n        #warning "Go to Tools  USB CDC On Boot  Enabled to fix this."\n    #endif\n\n    USB.VID(0x239A);  // Adafruit VID (standard for TinyUSB)\n    USB.PID(0x4100);  // Generic MIDI device PID\n    USB.productName("SoniphormGen");  // Device name (no spaces for compatibility)\n    USB.manufacturerName("Soniphorm");\n    USB.serialNumber("0001");\n    USB.webUSB(false);\n    USB.begin();\n    usbMIDI.begin();\n    Serial.println("USB MIDI initialized (class-compliant, GPIO19/20)");\n    #if ARDUINO_USB_CDC_ON_BOOT\n        Serial.println("USB CDC enabled - Arduino IDE connectivity maintained");\n    #else\n        Serial.println("WARNING: USB CDC disabled - Device will not show in Arduino IDE!");\n    #endif\n\n':"",'    // Set a reasonable timestamp for file operations (no RTC)\n    // This prevents 1980 dates on SD card files\n    struct tm timeinfo;\n    timeinfo.tm_year = 2025 - 1900;  // Year since 1900\n    timeinfo.tm_mon = 0;              // January\n    timeinfo.tm_mday = 9;             // 9th\n    timeinfo.tm_hour = 12;\n    timeinfo.tm_min = 0;\n    timeinfo.tm_sec = 0;\n    time_t t = mktime(&timeinfo);\n    struct timeval now = { .tv_sec = t };\n    settimeofday(&now, NULL);\n    \n    // Comprehensive PSRAM detection and testing\n    Serial.println("=== PSRAM Detection ===");\n    \n    // Check if PSRAM is physically present\n    size_t psramSize = ESP.getPsramSize();\n    Serial.print("ESP.getPsramSize(): ");\n    Serial.print(psramSize);\n    Serial.println(" bytes");\n    \n    if (psramSize == 0) {\n        Serial.println("PSRAM: Not detected in hardware");\n    } else {\n        Serial.print("PSRAM: Detected ");\n        Serial.print(psramSize / 1024 / 1024);\n        Serial.println("MB chip");\n        \n        // Try to initialize PSRAM\n        if (psramInit()) {\n            Serial.println("PSRAM: Initialization successful");\n            \n            // Get available memory\n            size_t freePsram = ESP.getFreePsram();\n            Serial.print("Free PSRAM: ");\n            Serial.print(freePsram);\n            Serial.print(" bytes (");\n            Serial.print(freePsram / 1024 / 1024);\n            Serial.println("MB)");\n            \n            // Skip dangerous PSRAM test allocations that can cause crashes\n            Serial.println("PSRAM available - skipping test allocations for stability");\n        } else {\n            Serial.println("PSRAM: Initialization FAILED");\n        }\n    }\n    Serial.println("=== End PSRAM Detection ===");\n    Serial.println();\n\n    // Initialize I2C for MCP23017 (CRITICAL: I2C uses GPIO1/2, NOT GPIO17/18)\n    Wire.begin(').concat(Z.I2C_SDA,", ").concat(Z.I2C_SCL,');\n    Wire.setClock(400000); // 400kHz I2C Fast Mode (4 faster than default 100kHz)\n    Serial.println("I2C initialized on GPIO1/2 @ 400kHz");\n\n    // Initialize I2S FIRST (before MCP23017 to establish clean audio)\n    i2s_config_t i2s_config = {\n        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX').concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?" | I2S_MODE_RX":"","),\n        .sample_rate = SAMPLE_RATE,\n        .bits_per_sample = I2S_BITS_PER_SAMPLE_").concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"32BIT":"16BIT",",\n        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\n        .communication_format = I2S_COMM_FORMAT_STAND_I2S,\n        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n        .dma_buf_count = 8,\n        .dma_buf_len = 128, // Increased from 64 for more buffering headroom (prevents glitches at high CPU)\n        .use_apll = ").concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"true":"false",", // APLL required for PCM1802 MCLK\n        .tx_desc_auto_clear = true,\n        .fixed_mclk = 0\n    };\n\n    i2s_pin_config_t pin_config = {\n        ").concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?".mck_io_num = 16, // MCLK required for PCM1802\n        ":"",".bck_io_num = I2S_BCLK,\n        .ws_io_num = I2S_LRCK,\n        .data_out_num = I2S_DATA,\n        .data_in_num = ").concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"8 // GPIO8 - PCM1802 DOUT":"I2S_PIN_NO_CHANGE",'\n    };\n\n    i2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);\n    i2s_set_pin(I2S_NUM_0, &pin_config);\n    Serial.println("I2S initialized on GPIO15(BCK)/17(LRCK)/18(DATA)').concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"/16(MCLK)/8(DIN)":"",'");\n        ')),this.setupCode.push(this.generatePSRAMInitialization());var t=this.modules.filter(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type});t.length>0&&(this.setupCode.push('\n    // Initialize ring buffers for file transfer modules\n    Serial.println("Initializing file transfer ring buffers...");'),t.forEach(function(n){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";n.type,e.setupCode.push("\n    ringBuffer".concat(a," = (uint8_t*)ps_malloc(RING_BUFFER_SIZE);\n    if (ringBuffer").concat(a,') {\n        Serial.printf("Ring buffer ').concat(a,': 256KB allocated in PSRAM\\n");\n        ringWritePos').concat(a," = 0;\n        ringReadPos").concat(a," = 0;\n        ringBufferCount").concat(a,' = 0;\n    } else {\n        Serial.println("ERROR: Failed to allocate ring buffer ').concat(a,' in PSRAM!");\n    }'))}),this.setupCode.push('\n    Serial.println("Ring buffer initialization complete.");')),this.setupCode.push('\n    // Initialize MCP23017 AFTER I2S\n    if (!mcp.begin_I2C(0x20)) {\n        Serial.println("Error initializing MCP23017");\n        while(1);\n    }\n    Serial.println("MCP23017 initialized at address 0x20");\n        '),this.setupCode.push('\n    // Configure MCP23017 pins\n    // Port A: Buttons (0-3) as INPUT_PULLUP\n    for (int i = 0; i < 4; i++) {\n        mcp.pinMode(i, INPUT_PULLUP);\n    }\n    // Port A: MIDI LEDs (4-5) as OUTPUT (GPA4=MIDI_OUT_LED, GPA5=MIDI_IN_LED)\n    mcp.pinMode(4, OUTPUT);\n    mcp.pinMode(5, OUTPUT);\n    // Port A: Gate LEDs (6-7) as OUTPUT\n    for (int i = 6; i < 8; i++) {\n        mcp.pinMode(i, OUTPUT);\n    }\n    // Port B: Button LEDs (8-9) and Gate LEDs (10-13) as OUTPUT\n    for (int i = 8; i < 14; i++) {\n        mcp.pinMode(i, OUTPUT);\n    }\n\n    // CRITICAL: ALWAYS disable PAM8302 speaker amp at startup (GPB6, pin 14)\n    // This prevents amp staying on from previous patch uploads (MCP23017 doesn\'t reset with ESP32)\n    mcp.pinMode(14, OUTPUT);      // GPB6 - Amp shutdown control\n    mcp.digitalWrite(14, LOW);    // Amp disabled by default (HIGH = enabled)\n    Serial.println("PAM8302 speaker amp: DISABLED (safety default)");\n\n'.concat(this.modules.some(function(e){return["LineIn","Piezo","Coil","Exciter"].includes(e.type)})?"\n    // Audio input switches (GPB2/3 - Line In, GPB4 - Mono, GPB5 - PiP, GPB6 - Amp shutdown)\n    // GPB2/3 are active-LOW (LOW = line input enabled)\n    mcp.pinMode(10, OUTPUT); // GPB2 - LineR switch\n    mcp.pinMode(11, OUTPUT); // GPB3 - LineL switch\n    mcp.pinMode(12, OUTPUT); // GPB4 - Mono switch\n    mcp.pinMode(13, OUTPUT); // GPB5 - PiP switch\n    mcp.pinMode(14, OUTPUT); // GPB6 - Amp shutdown\n\n    // Enable line input (active-LOW: set to LOW)\n    mcp.digitalWrite(10, LOW);  // LineR enabled\n    mcp.digitalWrite(11, LOW);  // LineL enabled\n    mcp.digitalWrite(12, LOW);  // Mono off\n    mcp.digitalWrite(13, LOW);  // PiP off\n    mcp.digitalWrite(14, ".concat(this.modules.some(function(e){return"Exciter"===e.type})?"HIGH":"LOW","); // Amp ").concat(this.modules.some(function(e){return"Exciter"===e.type})?"enabled":"disabled",' (HIGH = on, ONLY for Exciter module)\n    Serial.println("Audio I/O: ').concat(this.modules.filter(function(e){return["LineIn","Piezo","Coil"].includes(e.type)}).map(function(e){return e.type}).join("/")," input enabled").concat(this.modules.some(function(e){return"Exciter"===e.type})?", Speaker amp enabled":", Speaker amp DISABLED",'");\n'):"",'\n    // Initialize all menu indicator LEDs to OFF by default\n    Serial.println("Initializing all menu indicator LEDs to OFF...");\n    mcp.digitalWrite(').concat(Q.MIDI_IN_LED,", LOW);   // Bank 3 indicator\n    mcp.digitalWrite(").concat(Q.MIDI_OUT_LED,', LOW);  // Bank 4 indicator\n    mcp.digitalWrite(GATE1_LED_PIN, LOW);             // Bank 1 indicator\n    mcp.digitalWrite(GATE2_LED_PIN, LOW);             // Bank 2 indicator\n    mcp.digitalWrite(GATE3_LED_PIN, LOW);             // Bank 5 indicator\n    mcp.digitalWrite(GATE4_LED_PIN, LOW);             // Bank 6 indicator\n\n    // Light up the initial bank indicator (currentBank = 1 by default)\n    Serial.print("Lighting initial bank indicator for bank: ");\n    Serial.println(currentBank);\n    mcp.digitalWrite(GATE1_LED_PIN, HIGH);            // Bank 1 starts active\n        ')),this.modules.filter(function(e){return["Pot","LEDButton","Encoder","GateOut","GateIn"].includes(e.type)}).forEach(function(n,t){if("Pot"===n.type){var a=n.params.index||1,o=Z.ANALOG_PINS[a-1]||Z.ANALOG_PINS[0];e.setupCode.push("    pinMode(".concat(o,", INPUT);"))}}),this.modules.forEach(function(n){if("MIDIIn"===n.type||"MIDIOut"===n.type){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1",o=e.hardwareModules.generateSetupCode(n,a);o&&e.setupCode.push(o)}}),this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type})&&this.setupCode.push('\n    // Initialize SD Card with high-speed setup for smooth sample playback\n    Serial.println("Initializing SD card...");\n    Serial.printf("SD SPI Pins: SCK=%d, MISO=%d, MOSI=%d, CS=%d\\n", '.concat(Z.SD_SCK,", ").concat(Z.SD_MISO,", ").concat(Z.SD_MOSI,", ").concat(Z.SD_CS,");\n    SPI.begin(").concat(Z.SD_SCK,", ").concat(Z.SD_MISO,", ").concat(Z.SD_MOSI,", ").concat(Z.SD_CS,');\n    delay(100);  // Give SD card time to stabilize after SPI.begin()\n\n    // Start at low speed for initialization\n    Serial.println("Attempting SD.begin() at 400kHz...");\n    if (!SD.begin(').concat(Z.SD_CS,', SPI, 400000)) {\n        Serial.println("SD Card initialization FAILED at 400kHz!");\n        Serial.println("Possible causes:");\n        Serial.println("  1) SD card not inserted or not seated properly");\n        Serial.println("  2) SD card not FAT32 formatted");\n        Serial.println("  3) SPI wiring issue (check SCK=12, MISO=11, MOSI=10, CS=9)");\n        Serial.println("  4) SD card damaged or incompatible");\n        Serial.println("  5) Power issue (SD card needs 3.3V)");\n        Serial.println("Try: Remove and reinsert SD card, then press RESET button");\n    } else {\n        Serial.println("SD Card initialized at 400kHz successfully!");\n        // Reinitialize at high speed for fast reads (eliminates audio stuttering)\n        SD.end();\n        const uint32_t SD_SPI_HZ = 40000000; // 40 MHz\n        if (!SD.begin(').concat(Z.SD_CS,', SPI, SD_SPI_HZ)) {\n            Serial.println("SD Card high-speed init failed, trying 25MHz");\n            SD.end();\n            if (!SD.begin(').concat(Z.SD_CS,', SPI, 25000000)) {\n                Serial.println("SD Card failed at all speeds!");\n                return;\n            }\n        }\n        Serial.println("SD Card initialized at high speed for smooth sample playback");\n        uint64_t cardSize = SD.cardSize() / (1024 * 1024);\n        Serial.printf("SD Card size: %lluMB\\n", cardSize);\n        \n        // Initialize SD card file transfer handler for modules with samples\n        // SD sample players initialized automatically\n        \n        // List WAV files in root directory\n        File root = SD.open("/");\n        if (root) {\n            Serial.println("WAV files on SD card:");\n            File file = root.openNextFile();\n            int fileCount = 0;\n            while (file) {\n                String fname = file.name();\n                if (!file.isDirectory() && (fname.endsWith(".wav") || fname.endsWith(".WAV"))) {\n                    fileCount++;\n                    Serial.printf("  %d: %s (%lu bytes)\\n", fileCount, file.name(), file.size());\n                }\n                file.close();\n                file = root.openNextFile();\n            }\n            root.close();\n            if (fileCount == 0) {\n                Serial.println("  No WAV files found. Copy sample1.wav, sample2.wav, etc. to SD card");\n            }\n            \n            // Count samples for each Sample Player module and set dynamic ranges\n            ').concat(this.modules.filter(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type}).map(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1";return"\n            // Count available samples for Sample Player ".concat(t,'\n            Serial.printf("Counting samples for Sample Player %d...\\n", ').concat(t,");\n            int sampleCount").concat(t,' = 0;\n            \n            // Check numbered samples (sample1.wav, sample2.wav, etc.)\n            for (int i = 1; i <= 99; i++) {\n                String testPaths[] = {\n                    "/sample" + String(i) + ".wav",\n                    "/samples/sample" + String(i) + ".wav"\n                };\n                \n                bool found = false;\n                for (String testPath : testPaths) {\n                    if (SD.exists(testPath)) {\n                        sampleCount').concat(t,'++;\n                        found = true;\n                        break;\n                    }\n                }\n                \n                // Also check session folders\n                File rootCount = SD.open("/");\n                if (rootCount && !found) {\n                    File entryCount = rootCount.openNextFile();\n                    while (entryCount && !found) {\n                        String entryName = String(entryCount.name());\n                        if (entryCount.isDirectory() && entryName.startsWith("session_")) {\n                            String sessionPath = "/" + entryName + "/sample" + String(i) + ".wav";\n                            if (SD.exists(sessionPath)) {\n                                sampleCount').concat(t,"++;\n                                found = true;\n                            }\n                        }\n                        entryCount.close();\n                        entryCount = rootCount.openNextFile();\n                    }\n                    rootCount.close();\n                }\n                \n                // Stop counting if we hit a gap (sample1.wav, sample2.wav exist, but sample3.wav missing)\n                if (!found) break;\n            }\n            \n            sdPlayer").concat(t,"_sampleCount = sampleCount").concat(t,';\n            Serial.printf("Sample Player %d: Found %d samples (pot will map across full range)\\n", ').concat(t,", sampleCount").concat(t,");")}).join(""),"\n        }\n    }\n            ")),this.setupCode.push("\n    // Initialize direct GPIO pins\n    pinMode(".concat(Z.ENCODER_A,", INPUT_PULLUP);\n    pinMode(").concat(Z.ENCODER_B,", INPUT_PULLUP);\n    pinMode(").concat(Z.ENCODER_BTN,", INPUT_PULLUP);\n    \n    // Calculate number of active banks based on hardware modules in patch\n    activeBanks = ").concat(this.calculateActiveBanks(),';\n    Serial.print("ESP32-S3 Patcher initialized with ");\n    Serial.print(activeBanks);\n    Serial.println(" active banks");\n    \n    // Initialize banking system state\n    currentBank = 1;\n    showingBankIndicator = false;\n    Serial.print("Starting in Bank ");\n    Serial.println(currentBank);\n    \n    // Allocate PSRAM for DrumDesigner delay lines and noise buffers\n    ').concat(this.modules.filter(function(e){return"DrumDesigner"===e.type}).map(function(e,n){var t,a=(null===(t=e.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";return"\n    // Allocate K-S delay line for DrumDesigner ".concat(a,' from PSRAM\n    Serial.println("Allocating DrumDesigner').concat(a,' delay line from PSRAM...");\n    ks').concat(a,"_delayLine = (float*)ps_malloc(KS_MAX_DELAY_").concat(a," * sizeof(float));\n    if (!ks").concat(a,'_delayLine) {\n        Serial.println("ERROR: Failed to allocate DrumDesigner').concat(a,' delay line from PSRAM!");\n        Serial.printf("Free PSRAM: %d bytes\\n", ESP.getFreePsram());\n        while(1); // Halt - cannot continue without delay line\n    }\n    memset(ks').concat(a,"_delayLine, 0, KS_MAX_DELAY_").concat(a,' * sizeof(float));\n    Serial.printf("DrumDesigner').concat(a,' delay line: 32KB allocated (8192 samples for sub-bass)\\n");\n\n    // Allocate and pre-generate noise buffer for fast excitation\n    Serial.println("Pre-generating noise buffer for DrumDesigner').concat(a,'...");\n    ks').concat(a,"_noiseBuffer = (float*)ps_malloc(KS_MAX_DELAY_").concat(a," * sizeof(float));\n    if (!ks").concat(a,'_noiseBuffer) {\n        Serial.println("ERROR: Failed to allocate DrumDesigner').concat(a,' noise buffer from PSRAM!");\n        Serial.printf("Free PSRAM: %d bytes\\n", ESP.getFreePsram());\n        while(1); // Halt - cannot continue without noise buffer\n    }\n    // Fill noise buffer with random values (done once at startup)\n    for (int i = 0; i < KS_MAX_DELAY_').concat(a,"; i++) {\n        ks").concat(a,'_noiseBuffer[i] = ((float)random(-32768, 32767) / 32768.0f);\n    }\n    Serial.printf("DrumDesigner').concat(a,' noise buffer: 32KB allocated and initialized\\n");\n    Serial.printf("Free PSRAM remaining: %d bytes (64KB total for DrumDesigner').concat(a,')\\n", ESP.getFreePsram());')}).join(""),"\n\n    // Allocate PSRAM for DrumDesigner4 (4-voice) delay lines and noise buffers\n    ").concat(this.modules.filter(function(e){return"DrumDesigner4"===e.type}).map(function(e,n){for(var t,a=(null===(t=e.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1",o="",c=1;c<=4;c++)!1!==e.params["voice".concat(c,"_enabled")]&&(o+="\n    // Allocate Voice ".concat(c," for DrumDesigner4 ").concat(a,'\n    Serial.println("Allocating DrumDesigner4_').concat(a," Voice ").concat(c,' delay line from PSRAM...");\n    dd4').concat(a,"_v").concat(c,"_delayLine = (float*)ps_malloc(KS_MAX_DELAY_DD4").concat(a,"_V").concat(c," * sizeof(float));\n    if (!dd4").concat(a,"_v").concat(c,'_delayLine) {\n        Serial.println("ERROR: Failed to allocate DrumDesigner4_').concat(a,"_v").concat(c,' delay line!");\n        while(1);\n    }\n    memset(dd4').concat(a,"_v").concat(c,"_delayLine, 0, KS_MAX_DELAY_DD4").concat(a,"_V").concat(c,' * sizeof(float));\n    Serial.printf("DrumDesigner4_').concat(a," Voice ").concat(c,' delay line: 8KB allocated\\n");\n\n    dd4').concat(a,"_v").concat(c,"_noiseBuffer = (float*)ps_malloc(KS_MAX_DELAY_DD4").concat(a,"_V").concat(c," * sizeof(float));\n    if (!dd4").concat(a,"_v").concat(c,'_noiseBuffer) {\n        Serial.println("ERROR: Failed to allocate DrumDesigner4_').concat(a,"_v").concat(c,' noise buffer!");\n        while(1);\n    }\n    for (int i = 0; i < KS_MAX_DELAY_DD4').concat(a,"_V").concat(c,"; i++) {\n        dd4").concat(a,"_v").concat(c,'_noiseBuffer[i] = ((float)random(-32768, 32767) / 32768.0f);\n    }\n    Serial.printf("DrumDesigner4_').concat(a," Voice ").concat(c,' initialized\\n");'));return o}).join(""),"\n\n    // Initialize wavetables for Wavetable oscillators\n    ").concat(this.modules.filter(function(e){return"Wavetable"===e.type}).map(function(e,n){var t,a=(null===(t=e.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";return"\n    // Initialize default wavetables for Wavetable ".concat(a,'\n    Serial.println("Initializing wavetables for Wavetable ').concat(a,'...");\n    for (int i = 0; i < WT').concat(a,"_TABLE_SIZE; i++) {\n        float phase = (2.0 * PI * i) / WT").concat(a,"_TABLE_SIZE;\n        wt").concat(a,"_table0[i] = sin(phase);                    // Sine wave\n        wt").concat(a,"_table1[i] = (i < WT").concat(a,"_TABLE_SIZE/2) ? 1.0 : -1.0; // Square wave\n        wt").concat(a,"_table2[i] = 2.0 * (float)i / WT").concat(a,"_TABLE_SIZE - 1.0; // Sawtooth wave\n        wt").concat(a,'_table3[i] = 1.0 - 4.0 * abs(phase - PI) / PI; // Triangle wave\n    }\n    Serial.println("Wavetables initialized for Wavetable ').concat(a,'");')}).join(""),"\n\n    // SAFE: Preload first sample for each Sample Player during setup (not during audio processing)\n    ").concat(this.modules.filter(function(e){return"SamplePlayer"===e.type}).map(function(e,n){var t,a=(null===(t=e.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";return"\n    // Preload sample1.wav for Sample Player ".concat(a,"\n    String preloadFile").concat(a,' = "/sample1.wav";\n    if (!SD.exists(preloadFile').concat(a,")) {\n        preloadFile").concat(a,' = "/samples/sample1.wav";\n    }\n    if (SD.exists(preloadFile').concat(a,") && sdPlayer").concat(a,"_player.loadFile(preloadFile").concat(a,".c_str())) {\n        sdPlayer").concat(a,'_lastLoadedFile = 1;\n        Serial.println("Preloaded: " + preloadFile').concat(a,');\n    } else {\n        Serial.println("Warning: Could not preload sample1.wav for Sample Player ').concat(a,'");\n    }')}).join(""),"\n\n    // Initialize AudioRecorder ring buffers and FreeRTOS tasks\n    ").concat(this.modules.filter(function(e){return"AudioRecorder"===e.type}).map(function(e,n){var t,a=(null===(t=e.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";return"\n    // AudioRecorder ".concat(a,' - Allocate PSRAM ring buffer and create SD writer task\n    Serial.println("Initializing AudioRecorder ').concat(a,' ring buffer...");\n    rec').concat(a,"_ringBuffer = (uint8_t*)ps_malloc(REC").concat(a,"_BLOCK_SIZE * REC").concat(a,"_BLOCK_COUNT);\n    if (rec").concat(a,'_ringBuffer == nullptr) {\n        Serial.println("ERROR: Failed to allocate PSRAM ring buffer for AudioRecorder ').concat(a,'!");\n    } else {\n        Serial.printf("AudioRecorder ').concat(a,' ring buffer allocated: %lu bytes\\n",\n                     REC').concat(a,"_BLOCK_SIZE * REC").concat(a,"_BLOCK_COUNT);\n\n        // Create mutex for thread-safe ring buffer access\n        rec").concat(a,"_bufferMutex = xSemaphoreCreateMutex();\n        if (rec").concat(a,'_bufferMutex == nullptr) {\n            Serial.println("ERROR: Failed to create buffer mutex for AudioRecorder ').concat(a,'!");\n        }\n\n        // Create SD writer task on Core 0 (non-audio core)\n        BaseType_t taskCreated = xTaskCreatePinnedToCore(\n            rec').concat(a,'_sdWriterTaskFunc,  // Task function\n            "Rec').concat(a,'Writer",           // Task name\n            8192,                                // Stack size (8KB)\n            nullptr,                             // Parameters\n            2,                                   // Priority (higher than reader for recording priority)\n            &rec').concat(a,'_sdWriterTask,     // Task handle\n            0                                    // Core 0 (not audio core)\n        );\n        if (taskCreated != pdPASS) {\n            Serial.println("ERROR: Failed to create SD writer task for AudioRecorder ').concat(a,'!");\n        } else {\n            Serial.println("AudioRecorder ').concat(a,' SD writer task created on Core 0");\n        }\n\n        // Allocate playback ring buffer for streaming playback\n        Serial.println("Initializing AudioRecorder ').concat(a,' playback ring buffer...");\n        play').concat(a,"_ringBuffer = (uint8_t*)ps_malloc(PLAY").concat(a,"_BLOCK_SIZE * PLAY").concat(a,"_BLOCK_COUNT);\n        if (play").concat(a,'_ringBuffer == nullptr) {\n            Serial.println("ERROR: Failed to allocate PSRAM playback ring buffer for AudioRecorder ').concat(a,'!");\n        } else {\n            Serial.printf("AudioRecorder ').concat(a,' playback ring buffer allocated: %lu bytes\\n",\n                         PLAY').concat(a,"_BLOCK_SIZE * PLAY").concat(a,"_BLOCK_COUNT);\n\n            // Create mutex for thread-safe playback ring buffer access\n            play").concat(a,"_bufferMutex = xSemaphoreCreateMutex();\n            if (play").concat(a,'_bufferMutex == nullptr) {\n                Serial.println("ERROR: Failed to create playback buffer mutex for AudioRecorder ').concat(a,'!");\n            }\n\n            // Create SD reader task on Core 0 (non-audio core)\n            BaseType_t playTaskCreated = xTaskCreatePinnedToCore(\n                play').concat(a,'_sdReaderTaskFunc,  // Task function\n                "Play').concat(a,'Reader",           // Task name\n                8192,                                 // Stack size (8KB)\n                nullptr,                              // Parameters\n                1,                                    // Priority (low)\n                &play').concat(a,'_sdReaderTask,     // Task handle\n                0                                     // Core 0 (not audio core)\n            );\n            if (playTaskCreated != pdPASS) {\n                Serial.println("ERROR: Failed to create SD reader task for AudioRecorder ').concat(a,'!");\n            } else {\n                Serial.println("AudioRecorder ').concat(a,' SD reader task created on Core 0");\n            }\n\n            // Scan SD card for existing recordings and set next file index\n            int highestIndex = rec').concat(a,"_findHighestFileIndex();\n            rec").concat(a,'_currentFileIndex = highestIndex + 1;\n            Serial.printf("AudioRecorder ').concat(a,' will record to: rec%03d.wav\\n", rec').concat(a,"_currentFileIndex);\n        }\n    }")}).join(""),'\n\n    // CRITICAL: Clear audio buffers and output silence before starting main loop\n    // This prevents startup glitches from uninitialized memory\n    Serial.println("Clearing audio buffers and outputting initial silence...");\n\n    // Clear all buffers\n    memset(leftBuffer, 0, sizeof(leftBuffer));\n    memset(rightBuffer, 0, sizeof(rightBuffer));\n    memset(i2sBuffer, 0, sizeof(i2sBuffer));\n\n    // Output 3 silent frames to let I2S stabilize\n    for (int frame = 0; frame < 3; frame++) {\n        size_t bytes_written;\n        i2s_write(I2S_NUM_0, i2sBuffer, sizeof(i2sBuffer), &bytes_written, portMAX_DELAY);\n    }\n\n    // Initialize NeoPixels\n    neoPixels.begin();\n    neoPixels.setBrightness(').concat(Z.NEOPIXEL_BRIGHTNESS,');\n    neoPixels.clear();\n    neoPixels.show();\n    Serial.println("NeoPixels initialized (8 LEDs, GPIO46)");\n\n    Serial.println("Audio system ready!");\n\n    // Launch control task on Core 0 (audio runs on Core 1 in loop())\n    Serial.println("Creating control task on Core 0...");\n    xTaskCreatePinnedToCore(\n        controlTask,           // Task function\n        "ControlTask",         // Task name\n        8192,                  // Stack size (bytes)\n        NULL,                  // Parameters\n        1,                     // Priority\n        NULL,                  // Task handle (not needed)\n        0                      // Core 0\n    );\n    Serial.println("Control task launched on Core 0 - dual-core operation active");\n}\n        '))}},{key:"generatePSRAMInitialization",value:function(){var e="";return this.modules.forEach(function(n,t){"Looper_OLD_DISABLED"===n.type&&(e+="\n    // OLD DISABLED: Initialize Looper module ".concat(t,"\n    // looper").concat(t,".init();\n                "))}),this.modularInstances.forEach(function(n,t){e+="\n    // Initialize modular ".concat(n.type," instance\n    ").concat(n.instanceName,".init();\n            ")}),this.modules.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||t+1;if("Delay"===n.type){var c=Math.round(44.1*(n.params.time_ms||380)*2);e+="\n    // Initialize PSRAM buffers for Delay module ".concat(o,'\n    Serial.println("Allocating PSRAM buffers for delay effect...");\n    delay').concat(o,"_bufferL = (float*)ps_malloc(").concat(c," * sizeof(float));\n    delay").concat(o,"_bufferR = (float*)ps_malloc(").concat(c," * sizeof(float));\n\n    if (!delay").concat(o,"_bufferL || !delay").concat(o,'_bufferR) {\n        Serial.println("PSRAM allocation failed for delay, falling back to DRAM with smaller buffers...");\n\n        // Fallback to DRAM - try progressively smaller buffers\n        const int maxDRAMSize = ').concat(Math.floor(4410),"; // 100ms max for DRAM\n        const int minDRAMSize = ").concat(Math.floor(441),"; // 10ms minimum\n        int fallbackSize = maxDRAMSize;\n\n        while (fallbackSize >= minDRAMSize) {\n            delay").concat(o,"_bufferL = (float*)malloc(fallbackSize * sizeof(float));\n            delay").concat(o,"_bufferR = (float*)malloc(fallbackSize * sizeof(float));\n\n            if (delay").concat(o,"_bufferL && delay").concat(o,'_bufferR) {\n                Serial.printf("Delay ').concat(o,': Allocated %d samples in DRAM (%.1fms)\\n", fallbackSize, fallbackSize / 44.1f);\n                break;\n            }\n\n            if (delay').concat(o,"_bufferL) free(delay").concat(o,"_bufferL);\n            if (delay").concat(o,"_bufferR) free(delay").concat(o,"_bufferR);\n\n            fallbackSize = (int)(fallbackSize * 0.75); // Reduce by 25%\n        }\n\n        if (!delay").concat(o,"_bufferL || !delay").concat(o,'_bufferR) {\n            Serial.println("ERROR: Even DRAM allocation failed for delay!");\n            while(1);\n        }\n    } else {\n        Serial.printf("Delay ').concat(o,': Allocated %d samples in PSRAM (%.1fms)\\n", ').concat(c,", ").concat(c," / 44.1f);\n\n        // Initialize buffers to silence\n        memset(delay").concat(o,"_bufferL, 0, ").concat(c," * sizeof(float));\n        memset(delay").concat(o,"_bufferR, 0, ").concat(c," * sizeof(float));\n    }\n                ")}else if("GranularSynth"===n.type){var r=Math.floor(.5*Z.SAMPLE_RATE);e+="\n    // Initialize PSRAM buffers for GranularSynth module ".concat(o,'\n    Serial.println("Allocating PSRAM buffers for granular synthesis...");\n    granular').concat(o,"_buffer_L = (float*)ps_malloc(").concat(r," * sizeof(float));\n    granular").concat(o,"_buffer_R = (float*)ps_malloc(").concat(r," * sizeof(float));\n\n    if (!granular").concat(o,"_buffer_L || !granular").concat(o,'_buffer_R) {\n        Serial.println("PSRAM allocation failed, falling back to DRAM with smaller buffers...");\n\n        // Fallback to DRAM - try progressively smaller buffers\n        const int maxDRAMSize = ').concat(Math.floor(.5*Z.SAMPLE_RATE),"; // 0.5s max\n        const int minDRAMSize = ").concat(Math.floor(.25*Z.SAMPLE_RATE),"; // Minimum 0.25s\n        int fallbackSize = maxDRAMSize;\n\n        while (fallbackSize >= minDRAMSize) {\n            granular").concat(o,"_buffer_L = (float*)malloc(fallbackSize * sizeof(float));\n            granular").concat(o,"_buffer_R = (float*)malloc(fallbackSize * sizeof(float));\n\n            if (granular").concat(o,"_buffer_L && granular").concat(o,"_buffer_R) {\n                break; // Success!\n            }\n\n            // Free any partial allocation\n            if (granular").concat(o,"_buffer_L) free(granular").concat(o,"_buffer_L);\n            if (granular").concat(o,"_buffer_R) free(granular").concat(o,'_buffer_R);\n\n            // Try smaller buffer\n            fallbackSize = (int)(fallbackSize * 0.75); // Reduce by 25%\n            Serial.print("Retrying with smaller buffer: ");\n            Serial.print(fallbackSize);\n            Serial.println(" samples");\n        }\n\n        if (!granular').concat(o,"_buffer_L || !granular").concat(o,'_buffer_R) {\n            Serial.println("ERROR: Even DRAM allocation failed!");\n            while(1);\n        }\n\n        granular').concat(o,'_buffer_size = fallbackSize;\n        Serial.printf("Using DRAM buffers: %d bytes (%.2fs buffer)\\n",\n            fallbackSize * sizeof(float) * 2, (float)fallbackSize / ').concat(Z.SAMPLE_RATE,");\n    } else {\n        granular").concat(o,"_buffer_size = ").concat(r,';\n        Serial.printf("PSRAM granular buffers allocated: %d bytes (%.2fs buffer)\\n",\n            ').concat(r," * sizeof(float) * 2, (float)").concat(r," / ").concat(Z.SAMPLE_RATE,");\n    }\n\n    // Initialize buffers to silence\n    for (int i = 0; i < granular").concat(o,"_buffer_size; i++) {\n        granular").concat(o,"_buffer_L[i] = 0.0f;\n        granular").concat(o,"_buffer_R[i] = 0.0f;\n    }\n\n    granular").concat(o,"_write_pos = 0;\n\n    // Initialize 4 grains to inactive\n    for (int i = 0; i < 4; i++) {\n        granular").concat(o,"_grains[i].active = false;\n        granular").concat(o,"_grains[i].position = 0.0f;\n        granular").concat(o,"_grains[i].pitch_ratio = 1.0f;\n        granular").concat(o,"_grains[i].amplitude = 0.0f;\n        granular").concat(o,"_grains[i].samples_remaining = 0;\n        granular").concat(o,"_grains[i].grain_size_samples = 0;\n    }\n")}else if("GranularDense"===n.type){var i=Math.floor(2*Z.SAMPLE_RATE);e+="\n    // Initialize PSRAM buffers for GranularDense module ".concat(o,'\n    Serial.println("Allocating PSRAM buffers for dense granular synthesis...");\n    granular').concat(o,"_buffer_L = (float*)ps_malloc(").concat(i," * sizeof(float));\n    granular").concat(o,"_buffer_R = (float*)ps_malloc(").concat(i," * sizeof(float));\n    \n    if (!granular").concat(o,"_buffer_L || !granular").concat(o,'_buffer_R) {\n        Serial.println("PSRAM allocation failed, falling back to DRAM with smaller buffers...");\n        \n        // Fallback to DRAM - smaller buffer sizes for dense processing\n        const int maxDRAMSize = ').concat(Math.floor(1*Z.SAMPLE_RATE),"; // 1s max for DRAM\n        const int minDRAMSize = ").concat(Math.floor(.5*Z.SAMPLE_RATE),"; // Minimum 0.5s\n        int fallbackSize = maxDRAMSize;\n        \n        while (fallbackSize >= minDRAMSize) {\n            granular").concat(o,"_buffer_L = (float*)malloc(fallbackSize * sizeof(float));\n            granular").concat(o,"_buffer_R = (float*)malloc(fallbackSize * sizeof(float));\n            \n            if (granular").concat(o,"_buffer_L && granular").concat(o,"_buffer_R) {\n                break; // Success!\n            }\n            \n            // Free any partial allocation\n            if (granular").concat(o,"_buffer_L) free(granular").concat(o,"_buffer_L);\n            if (granular").concat(o,"_buffer_R) free(granular").concat(o,'_buffer_R);\n            \n            // Try smaller buffer\n            fallbackSize = (int)(fallbackSize * 0.75); // Reduce by 25%\n            Serial.print("Retrying dense granular with smaller buffer: ");\n            Serial.print(fallbackSize);\n            Serial.println(" samples");\n        }\n        \n        if (!granular').concat(o,"_buffer_L || !granular").concat(o,'_buffer_R) {\n            Serial.println("ERROR: Even DRAM allocation failed for dense granular!");\n            while(1);\n        }\n        \n        granular').concat(o,'_buffer_size = fallbackSize;\n        Serial.print("Using DRAM buffers for dense granular: ");\n        Serial.print(fallbackSize * sizeof(float) * 2);\n        Serial.print(" bytes (");\n        Serial.print((float)fallbackSize / ').concat(Z.SAMPLE_RATE,');\n        Serial.println("s buffer)");\n    } else {\n        granular').concat(o,"_buffer_size = ").concat(i,';\n        Serial.print("PSRAM dense granular buffers allocated successfully: ");\n        Serial.print(').concat(i,' * sizeof(float) * 2);\n        Serial.print(" bytes (");\n        Serial.print((float)').concat(i," / ").concat(Z.SAMPLE_RATE,');\n        Serial.println("s buffer)");\n    }\n    \n    // Initialize dense granular buffers to silence\n    for (int i = 0; i < granular').concat(o,"_buffer_size; i++) {\n        granular").concat(o,"_buffer_L[i] = 0.0f;\n        granular").concat(o,"_buffer_R[i] = 0.0f;\n    }\n    \n    granular").concat(o,"_write_pos = 0;\n    \n    // Initialize all 20 dense grains to inactive\n    for (int i = 0; i < 20; i++) {\n        granular").concat(o,"_grains[i].active = false;\n        granular").concat(o,"_grains[i].position = 0.0f;\n        granular").concat(o,"_grains[i].pitch_ratio = 1.0f;\n        granular").concat(o,"_grains[i].envelope_pos = 0.0f;\n        granular").concat(o,"_grains[i].envelope_inc = 0.0f;\n        granular").concat(o,"_grains[i].samples_remaining = 0;\n    }\n")}else if("Automation"===n.type){var l=n.params.buffer_size||1e3,s=n.params.num_inputs||1;e+="\n    // Initialize PSRAM buffers for Automation module ".concat(o," (").concat(s,' channels)\n    Serial.println("Allocating PSRAM buffers for automation recording...");\n');for(var u=1;u<=s;u++)e+="    automation".concat(o,"_buffer_").concat(u," = (float*)ps_malloc(").concat(l," * sizeof(float));\n    if (!automation").concat(o,"_buffer_").concat(u,') {\n        Serial.println("ERROR: PSRAM allocation failed for automation channel ').concat(u,'");\n        while(1);\n    } else {\n        memset(automation').concat(o,"_buffer_").concat(u,", 0, ").concat(l,' * sizeof(float));\n        Serial.printf("Automation ').concat(o," channel ").concat(u,': Allocated %d samples in PSRAM (%.1fs @ 50Hz)\\n", ').concat(l,", ").concat(l," / 50.0f);\n    }\n")}else"CleanReverb"===n.type&&(e+="\n    // Initialize CleanReverb ".concat(o,' buffers to zero (critical to prevent glitching)\n    Serial.println("Initializing CleanReverb buffers...");\n    initCleanReverb').concat(o,"();\n"))}),e}},{key:"generateLoop",value:function(){var e=this,n=this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type});this.loopCode.push('\n// Core 0 Task: Control Processing\nvoid controlTask(void* parameter) {\n    Serial.println("  Control Task started on Core 0");\n\n    while(1) {\n        '.concat(n?"// Universal SD directory browser\n        handleSDCommands();":"// No SD modules - SD commands disabled","\n\n        ").concat(this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type})?"\n        // Handle SD card file transfers from web app (NOT AudioRecorder - it writes directly)\n        ".concat(this.modules.filter(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type}).map(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1";return"handleFileTransfer".concat(t,"();")}).join("\n        "),"\n        "):"","\n        // Fast encoder button polling (every 1ms for responsive button presses)\n        // This is direct GPIO read, not I2C, so it doesn't interfere with audio\n        updateEncoderButton();\n\n        // Timed I2C access to prevent I2S interference\n        // ").concat(this.modules.some(function(e){return"GateIn"===e.type})?"1ms polling (1kHz) for piezo trigger detection (brief pulses)":"100ms polling (10Hz) reduces audio glitches while maintaining responsive UI","\n        if (millis() - lastMcpRead > ").concat(this.modules.some(function(e){return"GateIn"===e.type})?"1":"100",") {\n            lastMcpRead = millis();\n            updateHardware();\n        }\n\n        // Update control signals at 100Hz\n        static unsigned long lastControlUpdate = 0;\n        if (millis() - lastControlUpdate > 10) {\n            lastControlUpdate = millis();\n            updateControl();\n        }\n\n        // Update NeoPixels every 100ms (10Hz) - reduced from 50Hz for lower CPU usage\n        // Visual feedback is still very responsive at 10Hz\n        static unsigned long lastNeoPixelUpdate = 0;\n        if (millis() - lastNeoPixelUpdate > 100) {\n            lastNeoPixelUpdate = millis();\n            updateNeoPixels();\n        }\n\n        // Yield to FreeRTOS scheduler (1ms delay)\n        vTaskDelay(1 / portTICK_PERIOD_MS);\n    }\n}\n\n// Core 1 Loop: Audio Processing ONLY\nvoid loop() {\n    // Generate and output audio buffer\n    // This runs as fast as possible on Core 1\n    processAudio();\n    outputAudio();\n}\n        "));var t=this.modules.some(function(e){return"GateGen"===e.type}),a=this.modules.some(function(e){return"Clock"===e.type});this.loopCode.push("\n// Fast encoder button polling (GPIO48 direct read, no I2C delay)\n// Called every 1ms from controlTask for instant button response\nvoid updateEncoderButton() {\n    // Read encoder button state (GPIO48 - direct GPIO, not I2C)\n    encoderBtn = !digitalRead(".concat(Z.ENCODER_BTN,"); // Active low (pullup)\n\n    // Encoder button: long-press detection for future automation recording\n    // Short press (<1s): Toggle Gate Generator or Clock start/stop\n    // Long press (>1s): Toggle automation recording (future feature)\n\n    // On button press, record timestamp\n    if (encoderBtn && !lastEncoderBtn) {\n        encoderBtnPressTime = millis();\n        encoderBtnLongPressHandled = false;\n        // Serial.println removed - causes audio glitches\n    }\n\n    // Check for long press while button is still held (>1000ms)\n    if (encoderBtn && (millis() - encoderBtnPressTime > 1000) && !encoderBtnLongPressHandled) {\n        encoderBtnLongPressHandled = true;\n        ").concat(this.modules.some(function(e){return"StereoMixer4"===e.type})?"\n        // Check if in mixer banks - encoder button reserved for solo mode in pan bank\n        bool inMixerBanks = false;\n        ".concat(this.modules.filter(function(e){return"StereoMixer4"===e.type}).map(function(e){var n=e.params.start_bank||2,t=n+1;return"if (currentBank == ".concat(n," || currentBank == ").concat(t,") inMixerBanks = true;")}).join("\n        "),"\n\n        if (!inMixerBanks) {\n            // LONG PRESS: Encoder button available for Automation mode selection (non-mixer banks)\n            enc1_buttonLongPressed = true;\n        }\n        // Note: In mixer banks, encoder hold is used for solo mode (not long-press toggle)\n        "):"\n        // LONG PRESS: Encoder button available for Automation mode selection\n        enc1_buttonLongPressed = true; // Expose to Automation modules\n        ","\n    }\n\n    // While button is held after long press, keep enc1_buttonLongPressed true (unless in mixer banks)\n    if (encoderBtn && encoderBtnLongPressHandled) {\n        ").concat(this.modules.some(function(e){return"StereoMixer4"===e.type})?"\n        // Check if in mixer banks - don't set enc1_buttonLongPressed in mixer banks\n        bool inMixerBanks = false;\n        ".concat(this.modules.filter(function(e){return"StereoMixer4"===e.type}).map(function(e){var n=e.params.start_bank||2,t=n+1;return"if (currentBank == ".concat(n," || currentBank == ").concat(t,") inMixerBanks = true;")}).join("\n        "),"\n        if (!inMixerBanks) {\n            enc1_buttonLongPressed = true;\n        }\n        "):"\n        enc1_buttonLongPressed = true;\n        ","\n    }\n\n    // Clear enc1_buttonLongPressed when button is released\n    if (!encoderBtn && enc1_buttonLongPressed) {\n        enc1_buttonLongPressed = false;\n        // Serial.println removed - causes audio glitches\n    }\n\n    // On button release, check if it was a short press\n    if (!encoderBtn && lastEncoderBtn && !encoderBtnLongPressHandled) {\n        ").concat(this.modules.some(function(e){return"StereoMixer4"===e.type})?"\n        // Check if in mixer banks - skip Gate Gen/Clock toggle in mixer banks\n        bool inMixerBanks = false;\n        ".concat(this.modules.filter(function(e){return"StereoMixer4"===e.type}).map(function(e){var n=e.params.start_bank||2,t=n+1;return"if (currentBank == ".concat(n," || currentBank == ").concat(t,") inMixerBanks = true;")}).join("\n        "),"\n\n        if (inMixerBanks) {\n            // SHORT PRESS IN MIXER BANKS: Just show bank indicator (no Gate Gen/Clock toggle)\n            showingBankIndicator = true;\n            bankIndicatorTime = millis();\n        } else {\n        "):"","\n        // SHORT PRESS: Toggle Gate Generator/Clock or show bank\n        ").concat(t?'\n        // Toggle Gate Generator run state\n        gate1_running = !gate1_running;\n        Serial.print("Gate Generator ");\n        Serial.println(gate1_running ? "STARTED" : "STOPPED");\n\n        // Show bank indicator when stopped\n        if (!gate1_running) {\n            showingBankIndicator = true;\n            bankIndicatorTime = millis();\n        }\n        ':a?"\n        // Toggle Clock run state (toggle all Clock modules)\n        ".concat(this.modules.filter(function(e){return"Clock"===e.type}).map(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1";return"clock".concat(t,"_running = !clock").concat(t,"_running;")}).join("\n        "),'\n        Serial.println("Clock(s) toggled");\n\n        // Show bank indicator\n        showingBankIndicator = true;\n        bankIndicatorTime = millis();\n        '):"\n        // No Gate Generator or Clock - just show bank indicator\n        showingBankIndicator = true;\n        bankIndicatorTime = millis();\n        ","\n        ").concat(this.modules.some(function(e){return"StereoMixer4"===e.type})?"\n        } // End mixer bank check\n        ":"",'\n    }\n\n    lastEncoderBtn = encoderBtn;\n}\n\nvoid updateHardware() {\n    // Batch read all MCP23017 inputs (single I2C transaction) into global variable\n    inputs = mcp.readGPIOAB();\n\n    // DEBUG: Print raw MCP23017 input values periodically\n    static unsigned long lastInputDebug = 0;\n    static uint16_t lastInputs = 0xFFFF;\n    if (inputs != lastInputs || millis() - lastInputDebug > 5000) {\n        lastInputDebug = millis();\n        lastInputs = inputs;\n        Serial.print("MCP23017 raw inputs: 0x");\n        Serial.println(inputs, HEX);\n    }\n\n    // DEDICATED ENCODER BANKING SYSTEM\n    // ================================\n    // Encoder controls bank switching for virtual pots/buttons\n    // LED Bank Indication (clockwise navigation):\n    //   Bank 1: Gate1 LED     Bank 2: Gate2 LED      Bank 3: MIDI-IN LED\n    //   Bank 4: MIDI-OUT LED  Bank 5: Gate3 LED      Bank 6: Gate4 LED  wraps to Bank 1\n    //\n    // Hardware: GPIO21(A), GPIO47(B) - encoder rotation only (button handled in updateEncoderButton())\n    // LEDs temporarily override normal operation during navigation\n\n\n    int encoderA = digitalRead(').concat(Z.ENCODER_A,");\n    int encoderB = digitalRead(").concat(Z.ENCODER_B,");\n    \n    // 20-detent encoder: One detent = one menu step (improved precision)\n    static unsigned long lastEncoderChange = 0;\n    static int encoderState = 0;\n    static const int encoderStates[4][2] = {{0,1},{1,1},{1,0},{0,0}}; // Quadrature sequence\n    \n    // Detect state changes for precise detent detection\n    int currentState = (encoderA << 1) | encoderB;\n    static int lastState = 0;\n    \n    if (currentState != lastState && millis() - lastEncoderChange > 25) { // 25ms debounce for 20-detent encoder\n        // Determine direction by comparing state transitions\n        int direction = 0;\n        if ((lastState == 0 && currentState == 1) || (lastState == 1 && currentState == 3) ||\n            (lastState == 3 && currentState == 2) || (lastState == 2 && currentState == 0)) {\n            direction = 1; // Clockwise\n        } else if ((lastState == 0 && currentState == 2) || (lastState == 2 && currentState == 3) ||\n                   (lastState == 3 && currentState == 1) || (lastState == 1 && currentState == 0)) {\n            direction = -1; // Counter-clockwise\n        }\n        \n        if (direction != 0) {\n            lastEncoderChange = millis();\n\n            // Additional safeguard: prevent rapid changes within 150ms (20-detent encoder)\n            static unsigned long lastBankChange = 0;\n            if (millis() - lastBankChange >= 150) {\n                lastBankChange = millis();\n\n            ").concat(this.modules.some(function(e){return"Clock"===e.type})?"\n            // ENCODER HOLD + ROTATE: Clock BPM adjustment\n            if (encoderBtn) {\n                // Encoder button held - adjust Clock BPM instead of navigating banks\n                const float BPM_STEP = 5.0; // 5 BPM per detent\n                const float BPM_MIN = 40.0;\n                const float BPM_MAX = 240.0;\n\n                ".concat(this.modules.filter(function(e){return"Clock"===e.type}).map(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1";return"\n                // Adjust Clock ".concat(t," BPM\n                if (direction > 0) {\n                    clock").concat(t,"_bpm = min(clock").concat(t,"_bpm + BPM_STEP, BPM_MAX);\n                } else {\n                    clock").concat(t,"_bpm = max(clock").concat(t,'_bpm - BPM_STEP, BPM_MIN);\n                }\n                Serial.print("Clock ').concat(t,' BPM: ");\n                Serial.println(clock').concat(t,"_bpm);")}).join(""),"\n            } else {\n            "):"",'\n                // Normal encoder rotation - bank navigation\n                Serial.print("DEBUG: Encoder direction = ");\n                Serial.print(direction);\n                Serial.print(", currentBank before = ");\n                Serial.print(currentBank);\n                Serial.print(", activeBanks = ");\n                Serial.println(activeBanks);\n\n                if (direction > 0) {\n                    currentBank++;\n                    Serial.print("DEBUG: After increment, currentBank = ");\n                    Serial.print(currentBank);\n                    if (currentBank > activeBanks) {\n                        Serial.print(" > activeBanks, resetting to 1");\n                        currentBank = 1;\n                    }\n                    Serial.println();\n                } else {\n                    currentBank--;\n                    Serial.print("DEBUG: After decrement, currentBank = ");\n                    Serial.print(currentBank);\n                    if (currentBank < 1) {\n                        Serial.print(" < 1, setting to activeBanks");\n                        currentBank = activeBanks;\n                    }\n                    Serial.println();\n                }\n\n                // Show bank indicator LED\n                showingBankIndicator = true;\n                bankIndicatorTime = millis();\n                Serial.print("Bank navigation (detent-precise): ");\n                Serial.println(currentBank);\n            ').concat(this.modules.some(function(e){return"Clock"===e.type})?"}":"",'\n            } else {\n                Serial.println("DEBUG: Ignoring rapid encoder change");\n            }\n        }\n        lastState = currentState;\n    }\n\n    // NOTE: Encoder button handling moved to updateEncoderButton() for faster polling (1ms vs 100ms)\n\n    // Bank indicator LED control (only controls indicator LEDs, not button LEDs)\n    if (showingBankIndicator) {\n        // Turn off only the bank indicator LEDs (not button LEDs!)\n        mcp.digitalWrite(').concat(Q.MIDI_IN_LED,", LOW);\n        mcp.digitalWrite(").concat(Q.MIDI_OUT_LED,', LOW);\n        // Gate LEDs controlled via MCP23017 (set to LOW)\n        mcp.digitalWrite(GATE1_LED_PIN, LOW);\n        mcp.digitalWrite(GATE2_LED_PIN, LOW);\n        mcp.digitalWrite(GATE3_LED_PIN, LOW);\n        mcp.digitalWrite(GATE4_LED_PIN, LOW);\n\n        // Light up the current bank indicator\n        Serial.print("Lighting bank indicator for bank: ");\n        Serial.println(currentBank);\n        switch(currentBank) {\n            case 1:\n                mcp.digitalWrite(GATE1_LED_PIN, HIGH);\n                Serial.println("Gate1 LED ON");\n                break;    // Bank 1: Gate1 LED\n            case 2:\n                mcp.digitalWrite(GATE2_LED_PIN, HIGH);\n                Serial.println("Gate2 LED ON");\n                break;    // Bank 2: Gate2 LED\n            case 3:\n                mcp.digitalWrite(').concat(Q.MIDI_IN_LED,', HIGH);\n                Serial.println("MIDI-IN LED ON");\n                break;  // Bank 3: MIDI-IN LED\n            case 4:\n                mcp.digitalWrite(').concat(Q.MIDI_OUT_LED,', HIGH);\n                Serial.println("MIDI-OUT LED ON");\n                break; // Bank 4: MIDI-OUT LED\n            case 5:\n                mcp.digitalWrite(GATE3_LED_PIN, HIGH);\n                Serial.println("Gate3 LED ON");\n                break;    // Bank 5: Gate3 LED\n            case 6:\n                mcp.digitalWrite(GATE4_LED_PIN, HIGH);\n                Serial.println("Gate4 LED ON");\n                break;    // Bank 6: Gate4 LED\n            case 7: /* Reserved for future expansion */ break;\n            case 8: /* Reserved for future expansion */ break;\n        }\n\n        // Auto-fade back to functional LED display after 1 second\n        if (millis() - bankIndicatorTime > 1000) {\n            showingBankIndicator = false;\n            Serial.println("Bank indicator faded - returning to functional LED display");\n        }\n    } else {\n        // Functional LED feedback (Gate/MIDI activity) when NOT showing bank indicator\n\n        // Gate In LEDs (GPA4Gate1 LED, GPA5Gate2 LED)\n        mcp.digitalWrite(GATE1_LED_PIN, led_gatein1_active ? HIGH : LOW);\n        mcp.digitalWrite(GATE2_LED_PIN, led_gatein2_active ? HIGH : LOW);\n\n        // Gate Out LEDs (Gate3 LED, Gate4 LED)\n        mcp.digitalWrite(GATE3_LED_PIN, led_gateout1_active ? HIGH : LOW);\n        mcp.digitalWrite(GATE4_LED_PIN, led_gateout2_active ? HIGH : LOW);\n\n        // MIDI In LED (50ms flash on activity)\n        if (led_midiin_active && (millis() - led_midiin_time < 50)) {\n            mcp.digitalWrite(').concat(Q.MIDI_IN_LED,", HIGH);\n        } else {\n            mcp.digitalWrite(").concat(Q.MIDI_IN_LED,", LOW);\n            led_midiin_active = false;\n        }\n\n        // MIDI Out LED (50ms flash on activity)\n        if (led_midiout_active && (millis() - led_midiout_time < 50)) {\n            mcp.digitalWrite(").concat(Q.MIDI_OUT_LED,", HIGH);\n        } else {\n            mcp.digitalWrite(").concat(Q.MIDI_OUT_LED,", LOW);\n            led_midiout_active = false;\n        }\n    }\n\n    lastEncoderA = encoderA;\n    // NOTE: lastEncoderBtn updated in updateEncoderButton() for fast polling\n        ")),this.modules.filter(function(e){return["Pot","LEDButton","Encoder","GateOut","GateIn"].includes(e.type)}).forEach(function(n,t){var a=e.modules.findIndex(function(e){return e.id===n.id});switch(n.type){case"LEDButton":var o=n.params.index||1,c=n.params.bank||1,r=n.params.locked||!1,i=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"sampleIn"===e.to.port}),l=i,s="0.0";if(i){var u=i.from.id.split(":")[0],d=e.modules.find(function(e){return e.id===u});if(d){var p,f=(null===(p=u.match(/\d+$/))||void 0===p?void 0:p[0])||"1";switch(d.type){case"Pot":var m=d.params.index||1;s="pot".concat(m,"_value");break;case"ADSR":s="adsr".concat(f,"_output");break;case"LFO":s="lfo".concat(f,"_output");break;case"Scale":s="scale".concat(f,"_output");break;default:s="0.0"}}}e.loopCode.push("\n    // Button ".concat(a," (Bank ").concat(c,", Physical ").concat(o).concat(r?" - LOCKED":"",")").concat(l?" - SAMPLE & HOLD MODE":"","\n    btn").concat(o,"_lastState = btn").concat(o,"_state;\n    if (").concat(r?"true":"currentBank == ".concat(c),") {\n        // Physical buttons use actual hardware pin mapping (Button 1=GPA2, 2=GPA1, 3=GPA0, 4=GPA3)\n        bool rawBit = (inputs & (1 << BTN_PIN_").concat(o,")) != 0; // Use actual MCP23017 pin from ESP32Config\n        btn").concat(o,"_state = !rawBit; // Inverted due to pullup\n        btn").concat(o,"_pressed = btn").concat(o,"_state && !btn").concat(o,"_lastState;\n        btn").concat(o,"_gate = btn").concat(o,"_state;  // Raw gate signal always follows button state\n        btn").concat(o,"_output = btn").concat(o,"_state ? 1.0 : 0.0;\n\n        ").concat(l?"\n        // Sample & Hold: Read sampleIn and capture on button press\n        btn".concat(o,"_sampleIn = ").concat(s,";\n        if (btn").concat(o,"_pressed) {\n            btn").concat(o,"_sampleOut = btn").concat(o,'_sampleIn; // Sample and hold\n            Serial.print("Button ').concat(o,' S&H: Sampled value = ");\n            Serial.println(btn').concat(o,"_sampleOut);\n        }\n        // Note: sampleOut holds its value until next press"):"","\n        \n        // DEBUG: Print button state changes\n        if (btn").concat(o,"_state != btn").concat(o,'_lastState) {\n            Serial.print("Button ').concat(a," (Physical ").concat(o,'): ");\n            Serial.print(btn').concat(o,'_state ? "PRESSED" : "RELEASED");\n            Serial.print(" (raw bit: ");\n            Serial.print(rawBit);\n            Serial.print(", inputs: 0x");\n            Serial.print(inputs, HEX);\n            Serial.println(")");\n        }\n        \n        // DEBUG: Print button press detection\n        if (btn').concat(o,'_pressed) {\n            Serial.println("BUTTON EDGE DETECTED!");\n        }\n\n        // Note: Button LED feedback is handled by NeoPixels in updateNeoPixels() on Core 0\n        // MCP23017 pins 6-9 are Gate LEDs and MIDI LEDs, NOT button LEDs\n    } else {\n        // Button not in current bank - set to inactive\n        btn').concat(o,"_state = false;\n        btn").concat(o,"_pressed = false;\n        btn").concat(o,"_gate = false;  // CRITICAL: Clear gate signal for proper bank isolation\n        btn").concat(o,"_output = 0.0;\n    }\n                    "));break;case"GateIn":var _=n.params.index||1,g=e.hardwareModules.generateControlCode(n,_,e.connections);g&&e.loopCode.push(g)}}),this.loopCode.push("\n}\n        "),this.loopCode.push("\nvoid updateControl() {\n        "),this.loopCode.push("\n        unsigned long currentTime = millis(); // Shared time for all control modules\n        "),this.modules.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";if("ADSR"!==n.type)switch(n.type){case"GateGen":e.loopCode.push("\n        // Gate Generator ".concat(o," - Clock-triggered gate with S&H\n        bool clockTrigger = false;\n        \n        // Update BPM from pot connection if available\n        float currentBPM = gate").concat(o,"_self_clock_bpm;\n        // Update probability from pot connection if available\n        float currentProbability = gate").concat(o,"_probability;\n                    "));var c=e.connections.find(function(e){return e.to.id==="".concat(n.id,":self_clock_bpm")});if(c){var r,i=c.from.id.split(":")[0],l=e.modules.find(function(e){return e.id===i});if(null===(r=i.match(/\d+$/))||void 0===r||r[0],l&&"Pot"===l.type){var s=e.getPotReference(l.id);s&&e.loopCode.push("        currentBPM = 60.0 + ".concat(s,"_value * 240.0; // BPM from pot (60-300 BPM)"))}}var u=e.connections.find(function(e){return e.to.id==="".concat(n.id,":probability")});if(u){var d,p=u.from.id.split(":")[0],f=e.modules.find(function(e){return e.id===p});if(null===(d=p.match(/\d+$/))||void 0===d||d[0],f&&"Pot"===f.type){var m=e.getPotReference(f.id);m&&e.loopCode.push("        currentProbability = ".concat(m,"_value; // Probability from pot"))}}var _=e.connections.find(function(e){return e.to.id==="".concat(n.id,":gate_input")});if(_){var g,h=_.from.id.split(":")[0],v=e.modules.find(function(e){return e.id===h}),b=(null===(g=h.match(/\d+$/))||void 0===g?void 0:g[0])||"1";if(v&&b>=0){if("LEDButton"===v.type){var y=v.params.index||1;e.loopCode.push("        gate".concat(o,"_gate_input = btn").concat(y,"_state; // Gate input from button ").concat(y)),e.loopCode.push("        gate".concat(o,"_use_self_clock = true; // Button connected - run sequence when button held"))}else"ADSR"===v.type?e.loopCode.push("        gate".concat(o,"_gate_input = adsr").concat(b,"_output; // Gate input from ADSR")):"LFO"===v.type?e.loopCode.push("        gate".concat(o,"_gate_input = lfo").concat(b,"_output; // Gate input from LFO")):"Clock"===v.type?e.loopCode.push("        gate".concat(o,"_gate_input = clock").concat(b,"_out1; // Gate input from clock")):e.loopCode.push("        gate".concat(o,"_gate_input = ").concat(v.type.toLowerCase()).concat(b,"_output; // Gate input"));e.loopCode.push("        gate".concat(o,"_gate_enabled = (gate").concat(o,"_gate_input > 0.5); // Gate active when > 0.5"))}else e.loopCode.push("        gate".concat(o,"_gate_enabled = true; // Invalid gate input connection - always enabled"))}else e.loopCode.push("        gate".concat(o,"_gate_enabled = true; // No gate input - always enabled"));var k=e.connections.find(function(e){return e.to.id==="".concat(n.id,":sh_input")});if(k){var x,S=k.from.id.split(":")[0],E=e.modules.find(function(e){return e.id===S}),P=(null===(x=S.match(/\d+$/))||void 0===x?void 0:x[0])||"1";if(E)if("LFO"===E.type)e.loopCode.push("        gate".concat(o,"_sh_input = lfo").concat(P,"_output; // S&H input from LFO"));else if("Pot"===E.type){var w=e.getPotReference(E.id);e.loopCode.push("        gate".concat(o,"_sh_input = ").concat(w,"_value; // S&H input from Pot"))}else"ADSR"===E.type?e.loopCode.push("        gate".concat(o,"_sh_input = adsr").concat(P,"_output; // S&H input from ADSR")):e.loopCode.push("        gate".concat(o,"_sh_input = ").concat(E.type.toLowerCase()).concat(P,"_output; // S&H input"))}e.loopCode.push("\n        // Check for clock input or use self-clock (only when running)\n        if (gate".concat(o,"_use_self_clock && gate").concat(o,"_running) {\n            // Self-clock mode - generate internal clock\n            float clockPeriod = 60000.0 / currentBPM; // Period in ms using current BPM\n            if (currentTime - gate").concat(o,"_last_self_clock >= clockPeriod) {\n                clockTrigger = true;\n                gate").concat(o,"_last_self_clock = currentTime;\n            }\n        } else {\n            // External clock mode - would need external clock source\n            // This mode is for connecting to other clock generators\n        }\n        \n        // Process gate logic (only when gate is enabled)\n        // Gate input acts as an on/off toggle - when enabled, generator runs normally\n        if (clockTrigger && !gate").concat(o,"_last_clock && gate").concat(o,"_gate_enabled) {\n            // Rising edge of clock - check probability\n            float random_val = (float)random(0, 1000) / 1000.0; // 0.0 to 1.0\n            if (random_val <= currentProbability) {\n                gate").concat(o,"_state = true;\n                gate").concat(o,'_start_time = currentTime;\n                \n                // Debug: Gate triggered\n                Serial.println("Gate Generator triggered");\n                \n                // Sample & Hold: capture input value on gate trigger\n                if (gate').concat(o,"_sh_enabled) {\n                    gate").concat(o,"_sh_output = gate").concat(o,'_sh_input;\n                }\n            }\n            // Debug: Print probability info occasionally\n            static unsigned long lastProbDebug = 0;\n            if (millis() - lastProbDebug > 2000) { // Every 2 seconds\n                lastProbDebug = millis();\n                Serial.print("Gate Gen Prob: ");\n                Serial.print(currentProbability);\n                Serial.print(", Random: ");\n                Serial.print(random_val);\n                Serial.print(", Triggered: ");\n                Serial.println(random_val <= currentProbability ? "YES" : "NO");\n            }\n        }\n        \n        // Gate input controls whether the generator is enabled to run\n        // When gate_enabled is false, generator doesn\'t trigger new gates\n        \n        gate').concat(o,"_last_clock = clockTrigger;\n        \n        // Check gate length (in self-clock mode)\n        if (gate").concat(o,"_state) {\n            float gatePeriod = 60000.0 / currentBPM; // Period in ms using current BPM\n            float gateDuration = gatePeriod * gate").concat(o,"_length; // Gate duration in ms\n            \n            if (currentTime - gate").concat(o,"_start_time >= gateDuration) {\n                gate").concat(o,"_state = false;\n            }\n        }\n        \n        // Gate input behavior: when gate_enabled is false, generator stops triggering new gates\n        // but existing gate states continue their natural length for musical timing\n\n        gate").concat(o,"_output = gate").concat(o,"_state ? 1.0 : 0.0;\n\n        // Update LED output (metronome flash mode if led_flash_ms > 0)\n        if (gate").concat(o,"_led_flash_ms > 0) {\n            // Metronome mode: Fixed-duration flash on gate trigger\n            if (gate").concat(o,"_state && gate").concat(o,"_led_output == 0.0f) {\n                // Gate just went high - start LED flash\n                gate").concat(o,"_led_output = 1.0f;\n                gate").concat(o,"_led_start_time = currentTime;\n            } else if (gate").concat(o,"_led_output > 0.0f) {\n                // LED is on - check if flash duration expired\n                if (currentTime - gate").concat(o,"_led_start_time >= gate").concat(o,"_led_flash_ms) {\n                    gate").concat(o,"_led_output = 0.0f; // Turn off LED after flash\n                }\n            }\n        } else {\n            // Normal mode: LED follows gate state\n            gate").concat(o,"_led_output = gate").concat(o,"_output;\n        }\n                    "));break;case"Oscillator":var C=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"gate"===e.to.port});if(C){var I=C.from.id.split(":")[0],R=e.modules.find(function(e){return e.id===I});if(R&&"LEDButton"===R.type){var L=R.params.index||1;e.loopCode.push("    // Oscillator ".concat(o," gate from Button ").concat(L)),e.loopCode.push(e.generateBankAwareButtonAssignment(R.id,"osc".concat(o,"_gate = btn").concat(L,"_gate ? 1.0 : 0.0;")))}else if(R&&"ADSR"===R.type){var M,D=(null===(M=I.match(/\d+$/))||void 0===M?void 0:M[0])||"1";e.loopCode.push("    // Oscillator ".concat(o," gate from ADSR ").concat(D)),e.loopCode.push("    osc".concat(o,"_gate = adsr").concat(D,"_output;"))}else if(R&&"GateGen"===R.type){var A,O=(null===(A=I.match(/\d+$/))||void 0===A?void 0:A[0])||"1";e.loopCode.push("    // Oscillator ".concat(o," gate from GateGen ").concat(O)),e.loopCode.push("    osc".concat(o,"_gate = gate").concat(O,"_output;"))}else if(R&&"MIDIIn"===R.type){var B,T=(null===(B=I.match(/\d+$/))||void 0===B?void 0:B[0])||"1";e.loopCode.push("    // Oscillator ".concat(o," gate from MIDI In ").concat(T)),e.loopCode.push("    osc".concat(o,"_gate = midiin").concat(T,"_gate ? 1.0 : 0.0;"))}else if(R&&"GateIn"===R.type){var F,N=(null===(F=I.match(/\d+$/))||void 0===F?void 0:F[0])||"1";e.loopCode.push("    // Oscillator ".concat(o," gate from Gate In ").concat(N)),e.loopCode.push("    osc".concat(o,"_gate = gatein").concat(N,"_gate ? 1.0 : 0.0;"))}else if(R&&"Clock"===R.type){var z,G=(null===(z=I.match(/\d+$/))||void 0===z?void 0:z[0])||"1";e.loopCode.push("    // Oscillator ".concat(o," gate from Clock ").concat(G)),e.loopCode.push("    osc".concat(o,"_gate = clock").concat(G,"_out1;"))}}var q=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"freq"===e.to.port});if(q){var U,W=q.from.id.split(":")[0],V=e.modules.find(function(e){return e.id===W}),H=(null===(U=W.match(/\d+$/))||void 0===U?void 0:U[0])||"1";V&&"Scale"===V.type?(e.controlConnectionCode.push("    // Oscillator ".concat(o," frequency from Scale ").concat(H)),e.controlConnectionCode.push("    osc".concat(o,"_freq = scale").concat(H,"_output;"))):V&&"MIDIIn"===V.type?(e.loopCode.push("    // Oscillator ".concat(o," freq from MIDI In ").concat(H," (note  Hz)")),e.loopCode.push("    osc".concat(o,"_freq = 440.0 * pow(2.0, (midiin").concat(H,"_note * 48.0 + 48.0 - 69.0) / 12.0);")),C||e.loopCode.push("    osc".concat(o,"_gate = midiin").concat(H,"_gate ? 1.0 : 0.0; // Auto gate from MIDI"))):V&&"USBMIDIIn"===V.type?(e.loopCode.push("    // Oscillator ".concat(o," freq from USB MIDI ").concat(H," (note  Hz)")),e.loopCode.push("    osc".concat(o,"_freq = 440.0 * pow(2.0, (usbmidiin").concat(H,"_note * 48.0 + 48.0 - 69.0) / 12.0);")),C||e.loopCode.push("    osc".concat(o,"_gate = usbmidiin").concat(H,"_gate ? 1.0 : 0.0; // Auto gate from USB MIDI"))):V&&"BLEMIDIIn"===V.type&&(e.loopCode.push("    // Oscillator ".concat(o," freq from BLE MIDI ").concat(H," (note  Hz)")),e.loopCode.push("    osc".concat(o,"_freq = 440.0 * pow(2.0, (blemidi").concat(H,"_note * 48.0 + 48.0 - 69.0) / 12.0);")),C||e.loopCode.push("    osc".concat(o,"_gate = blemidi").concat(H,"_gate ? 1.0 : 0.0; // Auto gate from BLE MIDI")))}var j=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"gain"===e.to.port});if(j){var K=j.from.id.split(":")[0],Y=e.modules.find(function(e){return e.id===K});if(Y&&"Pot"===Y.type){var $=e.getPotReference(Y.id);e.loopCode.push("    // Oscillator ".concat(o," gain from ").concat(Y.id)),e.loopCode.push("    osc".concat(o,"_amplitude = ").concat($,"_value; // 0-1 amplitude control"))}else if(Y&&"ADSR"===Y.type){var X,Z=(null===(X=K.match(/\d+$/))||void 0===X?void 0:X[0])||"1";e.loopCode.push("    // Oscillator ".concat(o," gain from ADSR ").concat(Z)),e.loopCode.push("    osc".concat(o,"_amplitude = adsr").concat(Z,"_output;"))}}var Q=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"wave"===e.to.port});if(Q){var J=Q.from.id.split(":")[0],ee=e.modules.find(function(e){return e.id===J});if(ee&&"Pot"===ee.type){var ne=e.getPotReference(ee.id);e.loopCode.push("    // Oscillator ".concat(o," waveform from ").concat(ee.id)),e.loopCode.push(e.generateBankAwareAssignment(ee.id,"osc".concat(o,"_waveform = (int)(").concat(ne,"_value * 3.99);")))}}var te=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"morph"===e.to.port});if(te){var ae=te.from.id.split(":")[0],oe=e.modules.find(function(e){return e.id===ae});if(oe&&"Pot"===oe.type){var ce=e.getPotReference(oe.id);e.loopCode.push("    // Oscillator ".concat(o," morph from ").concat(oe.id)),e.loopCode.push("    osc".concat(o,"_morph = ").concat(ce,"_value; // 0-1 wave morphing"))}}break;case"NoiseGenerator":case"Noise":var re=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"gate"===e.to.port});if(re){var ie=re.from.id.split(":")[0],le=e.modules.find(function(e){return e.id===ie});if(le&&"LEDButton"===le.type){var se=le.params.index||1;e.loopCode.push("    // NoiseGenerator ".concat(o," gate from Button ").concat(se)),e.loopCode.push(e.generateBankAwareButtonAssignment(le.id,"noise".concat(o,"_gate = btn").concat(se,"_gate ? 1.0 : 0.0;")))}else if(le&&"ADSR"===le.type){var ue,de=(null===(ue=ie.match(/\d+$/))||void 0===ue?void 0:ue[0])||"1";e.loopCode.push("    // NoiseGenerator ".concat(o," gate from ADSR ").concat(de)),e.loopCode.push("    noise".concat(o,"_gate = adsr").concat(de,"_output;"))}else if(le&&"GateGen"===le.type){var pe,fe=(null===(pe=ie.match(/\d+$/))||void 0===pe?void 0:pe[0])||"1";e.loopCode.push("    // NoiseGenerator ".concat(o," gate from GateGen ").concat(fe)),e.loopCode.push("    noise".concat(o,"_gate = gate").concat(fe,"_output;"))}else if(le&&"MIDIIn"===le.type){var me,_e=(null===(me=ie.match(/\d+$/))||void 0===me?void 0:me[0])||"1";e.loopCode.push("    // NoiseGenerator ".concat(o," gate from MIDI In ").concat(_e)),e.loopCode.push("    noise".concat(o,"_gate = midiin").concat(_e,"_gate ? 1.0 : 0.0;"))}else if(le&&"GateIn"===le.type){var ge,he=(null===(ge=ie.match(/\d+$/))||void 0===ge?void 0:ge[0])||"1";e.loopCode.push("    // NoiseGenerator ".concat(o," gate from Gate In ").concat(he)),e.loopCode.push("    noise".concat(o,"_gate = gatein").concat(he,"_gate ? 1.0 : 0.0;"))}else if(le&&"Clock"===le.type){var ve,be=(null===(ve=ie.match(/\d+$/))||void 0===ve?void 0:ve[0])||"1";e.loopCode.push("    // NoiseGenerator ".concat(o," gate from Clock ").concat(be)),e.loopCode.push("    noise".concat(o,"_gate = clock").concat(be,"_out1;"))}}var ye=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"gain"===e.to.port});if(ye){var ke=ye.from.id.split(":")[0],xe=e.modules.find(function(e){return e.id===ke});if(xe&&"Pot"===xe.type){var Se=e.getPotReference(xe.id);e.loopCode.push("    // NoiseGenerator ".concat(o," gain from ").concat(xe.id)),e.loopCode.push(e.generateBankAwareAssignment(xe.id,"noise".concat(o,"_gain = ").concat(Se,"_value;")))}}var Ee=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"type"===e.to.port});if(Ee){var Pe=Ee.from.id.split(":")[0],we=e.modules.find(function(e){return e.id===Pe});if(we&&"Pot"===we.type){var Ce=e.getPotReference(we.id);e.loopCode.push("    // NoiseGenerator ".concat(o," type from ").concat(we.id)),e.loopCode.push(e.generateBankAwareAssignment(we.id,"noise".concat(o,"_type = (int)(").concat(Ce,"_value * 3.99);")))}}var Ie=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"morph"===e.to.port});if(Ie){var Re=Ie.from.id.split(":")[0],Le=e.modules.find(function(e){return e.id===Re});if(Le&&"Pot"===Le.type){var Me=e.getPotReference(Le.id);e.loopCode.push("    // NoiseGenerator ".concat(o," morph from ").concat(Le.id)),e.loopCode.push(e.generateBankAwareAssignment(Le.id,"noise".concat(o,"_morph = ").concat(Me,"_value;")))}}break;case"StereoMixer4":var De=n.params.start_bank||2,Ae=De+1;e.loopCode.push("\n    // StereoMixer4 ".concat(o," banking controls (Banks ").concat(De," and ").concat(Ae,")\n\n    // BANK ").concat(De,": Volume/Mute controls\n    if (currentBank == ").concat(De,") {\n        // Detect bank change for soft takeover\n        if (stereoMixer4_").concat(o,"_last_bank == -1) {\n            // First time entering ANY bank - initialize to physical position immediately (like manual pots)\n            for (int i = 0; i < 4; i++) {\n                stereoMixer4_").concat(o,"_vol_physical[i] = analogRead(4 + i) / 4095.0;\n                stereoMixer4_").concat(o,"_smoothed_pot[i] = stereoMixer4_").concat(o,"_vol_physical[i];\n                stereoMixer4_").concat(o,"_vol_target[i] = stereoMixer4_").concat(o,"_vol_physical[i];\n                stereoMixer4_").concat(o,"_vol_saved[i] = stereoMixer4_").concat(o,"_vol_physical[i];\n                stereoMixer4_").concat(o,"_vol_taken_over[i] = true; // Taken over immediately on first entry\n            }\n            stereoMixer4_").concat(o,"_last_bank = 0;\n        } else if (stereoMixer4_").concat(o,"_last_bank != 0) {\n            // Switching FROM pan bank TO volume bank - load saved volume values as targets\n            for (int i = 0; i < 4; i++) {\n                stereoMixer4_").concat(o,"_vol_target[i] = stereoMixer4_").concat(o,"_vol_saved[i]; // Load saved value as target\n                stereoMixer4_").concat(o,"_vol_taken_over[i] = false; // Require soft takeover\n            }\n            stereoMixer4_").concat(o,"_last_bank = 0;\n        }\n\n        // Read and smooth hardware pots to reduce noise\n        float pot_raw[4];\n        pot_raw[0] = analogRead(4) / 4095.0; // GPIO4 - POT1\n        pot_raw[1] = analogRead(5) / 4095.0; // GPIO5 - POT2\n        pot_raw[2] = analogRead(6) / 4095.0; // GPIO6 - POT3\n        pot_raw[3] = analogRead(7) / 4095.0; // GPIO7 - POT4\n\n        // Apply exponential smoothing and soft takeover\n        for (int i = 0; i < 4; i++) {\n            // Smooth physical pot reading\n            stereoMixer4_").concat(o,"_vol_physical[i] = stereoMixer4_").concat(o,"_vol_physical[i] * stereoMixer4_").concat(o,"_pot_smooth_factor +\n                                                           pot_raw[i] * (1.0 - stereoMixer4_").concat(o,"_pot_smooth_factor);\n\n            // Soft takeover logic\n            if (!stereoMixer4_").concat(o,"_vol_taken_over[i]) {\n                // Check if physical pot has crossed within threshold of target\n                float diff = fabsf(stereoMixer4_").concat(o,"_vol_physical[i] - stereoMixer4_").concat(o,"_vol_target[i]);\n                if (diff < 0.05 ||\n                    (stereoMixer4_").concat(o,"_vol_physical[i] < stereoMixer4_").concat(o,"_vol_target[i] && stereoMixer4_").concat(o,"_vol_physical[i] > pot_raw[i]) ||\n                    (stereoMixer4_").concat(o,"_vol_physical[i] > stereoMixer4_").concat(o,"_vol_target[i] && stereoMixer4_").concat(o,"_vol_physical[i] < pot_raw[i])) {\n                    // Pot has crossed the target value - TAKEOVER\n                    stereoMixer4_").concat(o,"_vol_taken_over[i] = true;\n                } else {\n                    // Not taken over - maintain target value\n                    stereoMixer4_").concat(o,"_smoothed_pot[i] = stereoMixer4_").concat(o,"_vol_target[i];\n                    continue; // Skip to next channel\n                }\n            }\n\n            // Taken over - follow physical pot\n            stereoMixer4_").concat(o,"_smoothed_pot[i] = stereoMixer4_").concat(o,"_vol_physical[i];\n        }\n\n        // Apply pot values to gains (pots control channel volumes)\n        stereoMixer4_").concat(o,"_gain1 = stereoMixer4_").concat(o,"_smoothed_pot[0];\n        stereoMixer4_").concat(o,"_gain2 = stereoMixer4_").concat(o,"_smoothed_pot[1];\n        stereoMixer4_").concat(o,"_gain3 = stereoMixer4_").concat(o,"_smoothed_pot[2];\n        stereoMixer4_").concat(o,"_gain4 = stereoMixer4_").concat(o,"_smoothed_pot[3];\n\n        // Save current gain values for this bank (for recall when switching back)\n        for (int i = 0; i < 4; i++) {\n            stereoMixer4_").concat(o,"_vol_saved[i] = stereoMixer4_").concat(o,"_smoothed_pot[i];\n        }\n\n        // Rate-limited MCP23017 I2C read to prevent audio interference\n        static unsigned long lastMcpRead_mixer").concat(o," = 0;\n        static bool btn_current_mixer").concat(o,"[4] = {false, false, false, false};\n        if (currentTime - lastMcpRead_mixer").concat(o," > 20) { // Read every 20ms to avoid I2S interference\n            lastMcpRead_mixer").concat(o," = currentTime;\n            uint16_t mcpInputs = mcp.readGPIOAB();\n            btn_current_mixer").concat(o,"[0] = !(mcpInputs & (1 << 2)); // GPA2 - Btn1 - active low\n            btn_current_mixer").concat(o,"[1] = !(mcpInputs & (1 << 1)); // GPA1 - Btn2 - active low\n            btn_current_mixer").concat(o,"[2] = !(mcpInputs & (1 << 0)); // GPA0 - Btn3 - active low\n            btn_current_mixer").concat(o,"[3] = !(mcpInputs & (1 << 3)); // GPA3 - Btn4 - active low\n        }\n\n        // Button mute toggles (debounced)\n        for (int i = 0; i < 4; i++) {\n            if (btn_current_mixer").concat(o,"[i] && !stereoMixer4_").concat(o,"_btn_last[i]) {\n                // BANK 1: Button press toggles mute\n                stereoMixer4_").concat(o,"_mute[i] = !stereoMixer4_").concat(o,"_mute[i];\n            }\n            stereoMixer4_").concat(o,"_btn_last[i] = btn_current_mixer").concat(o,"[i];\n        }\n    } // End Bank ").concat(De,"\n\n    // BANK ").concat(Ae,": Pan/Solo controls\n    if (currentBank == ").concat(Ae,") {\n        // Detect bank change for soft takeover\n        if (stereoMixer4_").concat(o,"_last_bank == -1) {\n            // First time entering ANY bank - initialize to physical position immediately (like manual pots)\n            for (int i = 0; i < 4; i++) {\n                stereoMixer4_").concat(o,"_pan_physical[i] = analogRead(4 + i) / 4095.0;\n                stereoMixer4_").concat(o,"_smoothed_pan[i] = stereoMixer4_").concat(o,"_pan_physical[i];\n                stereoMixer4_").concat(o,"_pan_target[i] = stereoMixer4_").concat(o,"_pan_physical[i];\n                stereoMixer4_").concat(o,"_pan_saved[i] = stereoMixer4_").concat(o,"_pan_physical[i];\n                stereoMixer4_").concat(o,"_pan_taken_over[i] = true; // Taken over immediately on first entry\n            }\n            stereoMixer4_").concat(o,"_last_bank = 1;\n        } else if (stereoMixer4_").concat(o,"_last_bank != 1) {\n            // Switching FROM volume bank TO pan bank - load saved pan values as targets\n            for (int i = 0; i < 4; i++) {\n                stereoMixer4_").concat(o,"_pan_target[i] = stereoMixer4_").concat(o,"_pan_saved[i]; // Load saved value as target\n                stereoMixer4_").concat(o,"_pan_taken_over[i] = false; // Require soft takeover\n            }\n            stereoMixer4_").concat(o,"_last_bank = 1;\n        }\n\n        // Read and smooth hardware pots for pan control\n        float pot_raw[4];\n        pot_raw[0] = analogRead(4) / 4095.0; // GPIO4 - POT1\n        pot_raw[1] = analogRead(5) / 4095.0; // GPIO5 - POT2\n        pot_raw[2] = analogRead(6) / 4095.0; // GPIO6 - POT3\n        pot_raw[3] = analogRead(7) / 4095.0; // GPIO7 - POT4\n\n        // Apply exponential smoothing and soft takeover\n        for (int i = 0; i < 4; i++) {\n            // Smooth physical pot reading\n            stereoMixer4_").concat(o,"_pan_physical[i] = stereoMixer4_").concat(o,"_pan_physical[i] * stereoMixer4_").concat(o,"_pot_smooth_factor +\n                                                          pot_raw[i] * (1.0 - stereoMixer4_").concat(o,"_pot_smooth_factor);\n\n            // Soft takeover logic\n            if (!stereoMixer4_").concat(o,"_pan_taken_over[i]) {\n                // Check if physical pot has crossed within threshold of target\n                float diff = fabsf(stereoMixer4_").concat(o,"_pan_physical[i] - stereoMixer4_").concat(o,"_pan_target[i]);\n                if (diff < 0.05 ||\n                    (stereoMixer4_").concat(o,"_pan_physical[i] < stereoMixer4_").concat(o,"_pan_target[i] && stereoMixer4_").concat(o,"_pan_physical[i] > pot_raw[i]) ||\n                    (stereoMixer4_").concat(o,"_pan_physical[i] > stereoMixer4_").concat(o,"_pan_target[i] && stereoMixer4_").concat(o,"_pan_physical[i] < pot_raw[i])) {\n                    // Pot has crossed the target value - TAKEOVER\n                    stereoMixer4_").concat(o,"_pan_taken_over[i] = true;\n                } else {\n                    // Not taken over - maintain target value\n                    stereoMixer4_").concat(o,"_smoothed_pan[i] = stereoMixer4_").concat(o,"_pan_target[i];\n                    continue; // Skip to next channel\n                }\n            }\n\n            // Taken over - follow physical pot\n            stereoMixer4_").concat(o,"_smoothed_pan[i] = stereoMixer4_").concat(o,"_pan_physical[i];\n        }\n\n        // Apply pot values to pan controls\n        stereoMixer4_").concat(o,"_pan[0] = stereoMixer4_").concat(o,"_smoothed_pan[0];\n        stereoMixer4_").concat(o,"_pan[1] = stereoMixer4_").concat(o,"_smoothed_pan[1];\n        stereoMixer4_").concat(o,"_pan[2] = stereoMixer4_").concat(o,"_smoothed_pan[2];\n        stereoMixer4_").concat(o,"_pan[3] = stereoMixer4_").concat(o,"_smoothed_pan[3];\n\n        // Save current pan values for this bank (for recall when switching back)\n        for (int i = 0; i < 4; i++) {\n            stereoMixer4_").concat(o,"_pan_saved[i] = stereoMixer4_").concat(o,"_smoothed_pan[i];\n        }\n\n        // Pre-calculate pan coefficients (equal-power panning law)\n        // Calculate at control rate (100Hz) to avoid expensive cos/sin in audio loop (44.1kHz)\n        for (int ch = 0; ch < 4; ch++) {\n            float panPos = stereoMixer4_").concat(o,"_pan[ch];\n            stereoMixer4_").concat(o,"_panL[ch] = cos(panPos * 1.5708); // 0.0=1.0, 0.5=0.707, 1.0=0.0\n            stereoMixer4_").concat(o,"_panR[ch] = sin(panPos * 1.5708); // 0.0=0.0, 0.5=0.707, 1.0=1.0\n        }\n\n        // Rate-limited MCP23017 I2C read to prevent audio interference\n        static unsigned long lastMcpRead_panmixer").concat(o," = 0;\n        static bool btn_current_panmixer").concat(o,"[4] = {false, false, false, false};\n        if (currentTime - lastMcpRead_panmixer").concat(o," > 20) { // Read every 20ms to avoid I2S interference\n            lastMcpRead_panmixer").concat(o," = currentTime;\n            uint16_t mcpInputs = mcp.readGPIOAB();\n            btn_current_panmixer").concat(o,"[0] = !(mcpInputs & (1 << 2)); // GPA2 - Btn1 - active low\n            btn_current_panmixer").concat(o,"[1] = !(mcpInputs & (1 << 1)); // GPA1 - Btn2 - active low\n            btn_current_panmixer").concat(o,"[2] = !(mcpInputs & (1 << 0)); // GPA0 - Btn3 - active low\n            btn_current_panmixer").concat(o,"[3] = !(mcpInputs & (1 << 3)); // GPA3 - Btn4 - active low\n        }\n\n        // SOLO MODE: Button press toggles solo on that channel\n        for (int i = 0; i < 4; i++) {\n            if (btn_current_panmixer").concat(o,"[i] && !stereoMixer4_").concat(o,"_btn_last[i]) {\n                // Toggle solo: if already soloed, turn off; otherwise solo this channel\n                if (stereoMixer4_").concat(o,"_solo_channel == (i + 1)) {\n                    stereoMixer4_").concat(o,"_solo_channel = 0; // Turn off solo\n                } else {\n                    stereoMixer4_").concat(o,"_solo_channel = i + 1; // Solo this channel (1-4)\n                }\n            }\n            stereoMixer4_").concat(o,"_btn_last[i] = btn_current_panmixer").concat(o,"[i];\n        }\n    } // End Bank ").concat(Ae,"\n                    ")),["g1","g2","g3","g4"].forEach(function(t,a){var c=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&e.to.port===t});if(c){var r=c.from.id.split(":")[0],i=e.modules.find(function(e){return e.id===r});if(i&&"Pot"===i.type){var l=e.getPotReference(i.id);e.loopCode.push("    // StereoMixer4 ".concat(o," ").concat(t," from ").concat(i.id)),e.loopCode.push(e.generateBankAwareAssignment(i.id,"stereoMixer4_".concat(o,"_gain").concat(a+1," = ").concat(l,"_value;")))}}});break;case"Matrix2x2":var Oe=n.params.start_bank||1;e.loopCode.push("\n    // Matrix2x2 ".concat(o," banking controls (Bank ").concat(Oe,")\n    // Pots 1-4 control aa, ab, ba, bb matrix coefficients (0.0-1.0 mapped to -1.0 to +1.0)\n\n    if (currentBank == ").concat(Oe,") {\n        // Detect bank change for soft takeover\n        if (matrix").concat(o,"_last_bank == -1) {\n            // First time entering this bank - initialize to physical position immediately\n            for (int i = 0; i < 4; i++) {\n                matrix").concat(o,"_physical[i] = analogRead(4 + i) / 4095.0;\n                matrix").concat(o,"_smoothed_pot[i] = matrix").concat(o,"_physical[i];\n                matrix").concat(o,"_target[i] = matrix").concat(o,"_physical[i];\n                matrix").concat(o,"_saved[i] = matrix").concat(o,"_physical[i];\n                matrix").concat(o,"_taken_over[i] = true; // Taken over immediately on first entry\n            }\n            matrix").concat(o,"_last_bank = 0;\n        } else if (matrix").concat(o,"_last_bank != 0) {\n            // Switching back to this bank - load saved values as targets\n            for (int i = 0; i < 4; i++) {\n                matrix").concat(o,"_target[i] = matrix").concat(o,"_saved[i]; // Load saved value as target\n                matrix").concat(o,"_taken_over[i] = false; // Require soft takeover\n            }\n            matrix").concat(o,"_last_bank = 0;\n        }\n\n        // Read and smooth hardware pots to reduce noise\n        float pot_raw[4];\n        pot_raw[0] = analogRead(4) / 4095.0; // GPIO4 - POT1\n        pot_raw[1] = analogRead(5) / 4095.0; // GPIO5 - POT2\n        pot_raw[2] = analogRead(6) / 4095.0; // GPIO6 - POT3\n        pot_raw[3] = analogRead(7) / 4095.0; // GPIO7 - POT4\n\n        // Apply exponential smoothing and soft takeover\n        for (int i = 0; i < 4; i++) {\n            // Smooth physical pot reading\n            matrix").concat(o,"_physical[i] = matrix").concat(o,"_physical[i] * matrix").concat(o,"_pot_smooth_factor +\n                                                pot_raw[i] * (1.0 - matrix").concat(o,"_pot_smooth_factor);\n\n            // Soft takeover logic\n            if (!matrix").concat(o,"_taken_over[i]) {\n                // Check if physical pot has crossed within threshold of target\n                float diff = fabsf(matrix").concat(o,"_physical[i] - matrix").concat(o,"_target[i]);\n                if (diff < 0.05 ||\n                    (matrix").concat(o,"_physical[i] < matrix").concat(o,"_target[i] && matrix").concat(o,"_physical[i] > pot_raw[i]) ||\n                    (matrix").concat(o,"_physical[i] > matrix").concat(o,"_target[i] && matrix").concat(o,"_physical[i] < pot_raw[i])) {\n                    // Pot has crossed the target value - TAKEOVER\n                    matrix").concat(o,"_taken_over[i] = true;\n                } else {\n                    // Not taken over - maintain target value\n                    matrix").concat(o,"_smoothed_pot[i] = matrix").concat(o,"_target[i];\n                    continue; // Skip to next pot\n                }\n            }\n\n            // Taken over - follow physical pot\n            matrix").concat(o,"_smoothed_pot[i] = matrix").concat(o,"_physical[i];\n        }\n\n        // Map pot values (0.0-1.0) to matrix coefficients (-1.0 to +1.0)\n        // This allows bidirectional routing (negative = phase inversion)\n        matrix").concat(o,"_aa = matrix").concat(o,"_smoothed_pot[0] * 2.0 - 1.0; // Pot1  aa\n        matrix").concat(o,"_ab = matrix").concat(o,"_smoothed_pot[1] * 2.0 - 1.0; // Pot2  ab\n        matrix").concat(o,"_ba = matrix").concat(o,"_smoothed_pot[2] * 2.0 - 1.0; // Pot3  ba\n        matrix").concat(o,"_bb = matrix").concat(o,"_smoothed_pot[3] * 2.0 - 1.0; // Pot4  bb\n\n        // Save current values for this bank (for recall when switching back)\n        for (int i = 0; i < 4; i++) {\n            matrix").concat(o,"_saved[i] = matrix").concat(o,"_smoothed_pot[i];\n        }\n    } // End Bank ").concat(Oe,"\n                    "));break;case"Clock":var Be=n.params.bank||0,Te=n.params.use_outputs_5_8||!1,Fe=Be+1;e.loopCode.push("\n    // Clock ".concat(o," banking controls (Bank ").concat(Be).concat(Te?" and ".concat(Fe):"",")\n\n    // Discrete musical rate values (16, 12, 8, 6, 4, 3, 2, 1, 2, 3, 4, 6, 8, 12, 16)\n    static const float clock").concat(o,"_rate_values[15] = {\n        0.0625, 0.08333, 0.125, 0.16667, 0.25, 0.33333, 0.5, // Divisions (16 to 2)\n        1.0,                                                    // Center (1)\n        2.0, 3.0, 4.0, 6.0, 8.0, 12.0, 16.0                   // Multiplications (2 to 16)\n    };\n\n    // BANK ").concat(Be,": Outputs 1-4 (pot=rate, button=fill) with SOFT TAKEOVER\n    if (currentBank == ").concat(Be,") {\n        // Detect bank change for soft takeover\n        if (clock").concat(o,"_last_bank == -1) {\n            // First time entering Clock bank - initialize to physical position immediately\n            for (int i = 0; i < 4; i++) {\n                float pot_raw = analogRead(4 + i) / 4095.0;\n                clock").concat(o,"_rate_physical[i] = pot_raw;\n\n                // Map to discrete rate\n                int rateIndex = (int)(pot_raw * 14.999);\n                if (rateIndex < 0) rateIndex = 0;\n                if (rateIndex > 14) rateIndex = 14;\n                float rate = clock").concat(o,"_rate_values[rateIndex];\n\n                clock").concat(o,"_rate_target[i] = rate;\n                clock").concat(o,"_rate_saved[i] = rate;\n                clock").concat(o,"_rate_taken_over[i] = true; // Taken over immediately on first entry\n            }\n            clock").concat(o,"_last_bank = ").concat(Be,";\n        } else if (clock").concat(o,"_last_bank != ").concat(Be,") {\n            // Switching FROM different bank TO Clock bank - load saved rates as targets\n            for (int i = 0; i < 4; i++) {\n                clock").concat(o,"_rate_target[i] = clock").concat(o,"_rate_saved[i]; // Load saved value as target\n                clock").concat(o,"_rate_taken_over[i] = false; // Require soft takeover\n            }\n            clock").concat(o,"_last_bank = ").concat(Be,";\n        }\n\n        // Read and smooth hardware pots to reduce noise\n        float pot_raw[4];\n        pot_raw[0] = analogRead(4) / 4095.0; // GPIO4 - POT1\n        pot_raw[1] = analogRead(5) / 4095.0; // GPIO5 - POT2\n        pot_raw[2] = analogRead(6) / 4095.0; // GPIO6 - POT3\n        pot_raw[3] = analogRead(7) / 4095.0; // GPIO7 - POT4\n\n        // Apply exponential smoothing and soft takeover\n        const float pot_smooth_factor = 0.8; // Smoothing factor (0.8 = smooth, 0.0 = instant)\n        const float takeover_threshold = 0.05; // 5% threshold for soft takeover\n\n        for (int i = 0; i < 4; i++) {\n            // Smooth physical pot reading\n            clock").concat(o,"_rate_physical[i] = clock").concat(o,"_rate_physical[i] * pot_smooth_factor +\n                                                           pot_raw[i] * (1.0 - pot_smooth_factor);\n\n            // Map to discrete rate\n            int rateIndex = (int)(clock").concat(o,"_rate_physical[i] * 14.999);\n            if (rateIndex < 0) rateIndex = 0;\n            if (rateIndex > 14) rateIndex = 14;\n            float physical_rate = clock").concat(o,"_rate_values[rateIndex];\n\n            // Soft takeover check - has pot crossed within threshold of target?\n            if (!clock").concat(o,"_rate_taken_over[i]) {\n                // Check if physical rate is within threshold of target rate\n                float rate_diff = fabsf(physical_rate - clock").concat(o,"_rate_target[i]);\n                if (rate_diff <= takeover_threshold ||\n                    (physical_rate < clock").concat(o,"_rate_target[i] && clock").concat(o,"_rate_physical[i] > pot_raw[i]) ||\n                    (physical_rate > clock").concat(o,"_rate_target[i] && clock").concat(o,"_rate_physical[i] < pot_raw[i])) {\n                    // Pot has crossed the target value - TAKEOVER\n                    clock").concat(o,"_rate_taken_over[i] = true;\n                }\n            }\n\n            // Apply rate based on takeover state\n            float final_rate;\n            if (clock").concat(o,"_rate_taken_over[i]) {\n                // Pot has control - use physical position\n                final_rate = physical_rate;\n            } else {\n                // Waiting for takeover - maintain target value\n                final_rate = clock").concat(o,"_rate_target[i];\n            }\n\n            // Apply rate and store pot value (for probability attenuation during fill)\n            switch(i) {\n                case 0:\n                    clock").concat(o,"_rate1 = final_rate;\n                    clock").concat(o,"_pot_value1 = clock").concat(o,"_rate_physical[i];\n                    clock").concat(o,"_rate_saved[0] = final_rate; // Save for recall\n                    break;\n                case 1:\n                    clock").concat(o,"_rate2 = final_rate;\n                    clock").concat(o,"_pot_value2 = clock").concat(o,"_rate_physical[i];\n                    clock").concat(o,"_rate_saved[1] = final_rate;\n                    break;\n                case 2:\n                    clock").concat(o,"_rate3 = final_rate;\n                    clock").concat(o,"_pot_value3 = clock").concat(o,"_rate_physical[i];\n                    clock").concat(o,"_rate_saved[2] = final_rate;\n                    break;\n                case 3:\n                    clock").concat(o,"_rate4 = final_rate;\n                    clock").concat(o,"_pot_value4 = clock").concat(o,"_rate_physical[i];\n                    clock").concat(o,"_rate_saved[3] = final_rate;\n                    break;\n            }\n        }\n\n        // Read buttons for fill (momentary)\n        static unsigned long lastBtnRead_clock").concat(o,"_bank1 = 0;\n        static bool btn_current_clock").concat(o,"_bank1[4] = {false, false, false, false};\n        if (millis() - lastBtnRead_clock").concat(o,"_bank1 > 20) { // Rate-limited\n            lastBtnRead_clock").concat(o,"_bank1 = millis();\n            uint16_t mcpInputs = mcp.readGPIOAB();\n            btn_current_clock").concat(o,"_bank1[0] = !(mcpInputs & (1 << 2)); // GPA2 - Btn1\n            btn_current_clock").concat(o,"_bank1[1] = !(mcpInputs & (1 << 1)); // GPA1 - Btn2\n            btn_current_clock").concat(o,"_bank1[2] = !(mcpInputs & (1 << 0)); // GPA0 - Btn3\n            btn_current_clock").concat(o,"_bank1[3] = !(mcpInputs & (1 << 3)); // GPA3 - Btn4\n        }\n\n        // Update fill states (momentary - active while held)\n        clock").concat(o,"_fill1 = btn_current_clock").concat(o,"_bank1[0];\n        clock").concat(o,"_fill2 = btn_current_clock").concat(o,"_bank1[1];\n        clock").concat(o,"_fill3 = btn_current_clock").concat(o,"_bank1[2];\n        clock").concat(o,"_fill4 = btn_current_clock").concat(o,'_bank1[3];\n\n        // While fill button held, pot value also attenuates probability (expressive control)\n        // This allows "thinning out" the fill rhythmically\n        // Note: pot value is 0.0-1.0, directly usable as probability multiplier\n    }\n    ').concat(Te?"\n    // BANK ".concat(Fe,": Outputs 5-8 (pot=rate, button=fill)\n    if (currentBank == ").concat(Fe,") {\n        // Read hardware pots (GPIO4-7)\n        float clock").concat(o,"_pot_raw[4];\n        clock").concat(o,"_pot_raw[0] = analogRead(4) / 4095.0; // POT1\n        clock").concat(o,"_pot_raw[1] = analogRead(5) / 4095.0; // POT2\n        clock").concat(o,"_pot_raw[2] = analogRead(6) / 4095.0; // POT3\n        clock").concat(o,"_pot_raw[3] = analogRead(7) / 4095.0; // POT4\n\n        // Map pot values to discrete musical rate values\n        for (int i = 0; i < 4; i++) {\n            float sliderValue = clock").concat(o,"_pot_raw[i];\n\n            // Map slider (0.0-1.0) to discrete rate index (0-14)\n            int rateIndex = (int)(sliderValue * 14.999); // 0-14 range\n            if (rateIndex < 0) rateIndex = 0;\n            if (rateIndex > 14) rateIndex = 14;\n            float rate = clock").concat(o,"_rate_values[rateIndex];\n\n            // Apply rate and store raw pot value for outputs 5-8\n            switch(i) {\n                case 0:\n                    clock").concat(o,"_rate5 = rate;\n                    clock").concat(o,"_pot_value5 = sliderValue;\n                    break;\n                case 1:\n                    clock").concat(o,"_rate6 = rate;\n                    clock").concat(o,"_pot_value6 = sliderValue;\n                    break;\n                case 2:\n                    clock").concat(o,"_rate7 = rate;\n                    clock").concat(o,"_pot_value7 = sliderValue;\n                    break;\n                case 3:\n                    clock").concat(o,"_rate8 = rate;\n                    clock").concat(o,"_pot_value8 = sliderValue;\n                    break;\n            }\n        }\n\n        // Read buttons for fill\n        static unsigned long lastBtnRead_clock").concat(o,"_bank2 = 0;\n        static bool btn_current_clock").concat(o,"_bank2[4] = {false, false, false, false};\n        if (millis() - lastBtnRead_clock").concat(o,"_bank2 > 20) {\n            lastBtnRead_clock").concat(o,"_bank2 = millis();\n            uint16_t mcpInputs = mcp.readGPIOAB();\n            btn_current_clock").concat(o,"_bank2[0] = !(mcpInputs & (1 << 2));\n            btn_current_clock").concat(o,"_bank2[1] = !(mcpInputs & (1 << 1));\n            btn_current_clock").concat(o,"_bank2[2] = !(mcpInputs & (1 << 0));\n            btn_current_clock").concat(o,"_bank2[3] = !(mcpInputs & (1 << 3));\n        }\n\n        // Update fill states for outputs 5-8\n        clock").concat(o,"_fill5 = btn_current_clock").concat(o,"_bank2[0];\n        clock").concat(o,"_fill6 = btn_current_clock").concat(o,"_bank2[1];\n        clock").concat(o,"_fill7 = btn_current_clock").concat(o,"_bank2[2];\n        clock").concat(o,"_fill8 = btn_current_clock").concat(o,"_bank2[3];\n    }\n    "):"","\n                    "))}}),this.modules.forEach(function(n,t){if("KickDrum"===n.type){var a=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"gate"===e.to.port});if(a){var o,c=a.from.id.split(":")[0],r=e.modules.find(function(e){return e.id===c}),i=(null===(o=c.match(/\d+$/))||void 0===o?void 0:o[0])||"1";r&&"LEDButton"===r.type?e.loopCode.push("\n    // Kick Drum ".concat(t," trigger detection from LEDButton\n    if (btn").concat(i,"_pressed) {\n        // Start all envelopes for kick").concat(t,"\n        kick").concat(t,"_osc_amp_stage = 1;\n        kick").concat(t,"_osc_amp_time = 0.0;\n        kick").concat(t,"_osc_pitch_stage = 1;\n        kick").concat(t,"_osc_pitch_time = 0.0;\n        kick").concat(t,"_noise_amp_stage = 1;\n        kick").concat(t,'_noise_amp_time = 0.0;\n        Serial.println("KICK ').concat(t,' TRIGGERED!");\n        Serial.print("  Osc muted: ");\n        Serial.println(kick').concat(t,'_osc_mute ? "YES" : "NO");\n        Serial.print("  Noise muted: ");\n        Serial.println(kick').concat(t,'_noise_mute ? "YES" : "NO");\n        Serial.print("  Osc level: ");\n        Serial.println(kick').concat(t,'_osc_level);\n        Serial.print("  Noise level: ");\n        Serial.println(kick').concat(t,"_noise_level);\n    }\n                        ")):r&&"GateGen"===r.type&&e.loopCode.push("\n    // Kick Drum ".concat(t," trigger detection from Gate Generator\n    static bool kick").concat(t,"_lastGateState = false;\n    if (gate").concat(i,"_output > 0.5 && !kick").concat(t,"_lastGateState) {\n        // Rising edge trigger from Gate Generator\n        kick").concat(t,"_osc_amp_stage = 1;\n        kick").concat(t,"_osc_amp_time = 0.0;\n        kick").concat(t,"_osc_pitch_stage = 1;\n        kick").concat(t,"_osc_pitch_time = 0.0;\n        kick").concat(t,"_noise_amp_stage = 1;\n        kick").concat(t,'_noise_amp_time = 0.0;\n        Serial.println("KICK ').concat(t,' TRIGGERED BY GATE GENERATOR!");\n        Serial.print("  Gate signal: ");\n        Serial.println(gate').concat(i,'_output);\n        Serial.print("  Osc muted: ");\n        Serial.println(kick').concat(t,'_osc_mute ? "YES" : "NO");\n        Serial.print("  Noise muted: ");\n        Serial.println(kick').concat(t,'_noise_mute ? "YES" : "NO");\n    }\n    kick').concat(t,"_lastGateState = (gate").concat(i,"_output > 0.5);\n                        "))}}});var o=new Map;this.modules.forEach(function(e){if("Pot"===e.type){var n=e.params.index||1,t=e.params.bank||1,a=e.params.locked||!1;o.has(n)||o.set(n,[]),o.get(n).push({bank:t,locked:a})}}),this.modules.forEach(function(e){if("BPMLooper"===e.type)for(var n=e.params.start_bank||1,t=n+1,a=1;a<=4;a++)o.has(a)||o.set(a,[]),o.get(a).push({bank:n,locked:!1}),o.get(a).push({bank:t,locked:!1})}),this.connections.forEach(function(n){if(n.from&&n.from.bank){var t=n.from.id.split(":")[0],a=e.modules.find(function(e){return e.id===t});if(a&&"Pot"===a.type){var c=a.params.index||1,r=n.from.bank;o.has(c)||o.set(c,[]),o.get(c).map(function(e){return e.bank}).includes(r)||(o.get(c).push({bank:r,locked:!1}),console.log("Added bank ".concat(r," to Pot").concat(c," from connection")))}}}),o.forEach(function(n,t){var a,o=Z.ANALOG_PINS[t-1]||Z.ANALOG_PINS[0],c=n.map(function(e){return e.bank}).filter(function(e,n,t){return t.indexOf(e)===n}),r=n.some(function(e){return e.locked});a=r?"true":1===c.length?"currentBank == ".concat(c[0]):c.map(function(e){return"currentBank == ".concat(e)}).join(" || "),e.loopCode.push("\n    // Pot ".concat(t," (Physical ").concat(t,", Banks: ").concat(c.join(", ")).concat(r?" - LOCKED":"",") - SOFT TAKEOVER\n    static int pot").concat(t,"_last_bank = -1;\n    static float pot").concat(t,"_bank_values[6] = {0}; // Store value per bank (MAX_BANKS)\n    static float pot").concat(t,"_smoothed = 0.0; // Smoothed ADC reading to reduce jitter\n    int pot").concat(t,"_raw = analogRead(").concat(o,");\n    float pot").concat(t,"_raw_normalized = pot").concat(t,"_raw / 4095.0;\n\n    // Exponential smoothing filter (alpha=0.2) to reduce ESP32 ADC noise\n    pot").concat(t,"_smoothed = pot").concat(t,"_smoothed * 0.8 + pot").concat(t,"_raw_normalized * 0.2;\n    pot").concat(t,"_physical = pot").concat(t,"_smoothed; // Use smoothed value\n\n    if (").concat(a,") {\n        // Pot is active in current bank\n\n        // Check for first-time initialization or bank change\n        if (pot").concat(t,"_last_bank == -1) {\n            // First time entering any bank - initialize to physical position immediately\n            pot").concat(t,"_value = pot").concat(t,"_physical;\n            pot").concat(t,"_target = pot").concat(t,"_physical;\n            pot").concat(t,"_taken_over = true;\n            pot").concat(t,"_bank_values[currentBank - 1] = pot").concat(t,'_physical;\n            Serial.print("Pot').concat(t,' INITIAL in Bank ");\n            Serial.print(currentBank);\n            Serial.print(", Value: ");\n            Serial.println(pot').concat(t,"_physical);\n        } else if (pot").concat(t,"_last_bank != currentBank) {\n            // Bank just changed - save old bank's value, load new bank's target\n            pot").concat(t,"_bank_values[pot").concat(t,"_last_bank - 1] = pot").concat(t,"_value; // Save old bank value\n            pot").concat(t,"_target = pot").concat(t,"_bank_values[currentBank - 1]; // Load new bank's last value as target\n            pot").concat(t,"_taken_over = false;\n            pot").concat(t,'_last_bank_change = millis();\n            Serial.print("Pot').concat(t,' Bank Change: ");\n            Serial.print(pot').concat(t,'_last_bank);\n            Serial.print(" -> ");\n            Serial.print(currentBank);\n            Serial.print(", Target: ");\n            Serial.print(pot').concat(t,'_target);\n            Serial.print(", Physical: ");\n            Serial.println(pot').concat(t,"_physical);\n        }\n\n        // Soft takeover logic (only if not already taken over)\n        if (!pot").concat(t,"_taken_over) {\n            // Check if physical pot is close enough to target (within 5%)\n            float takeover_threshold = 0.05;\n            if (abs(pot").concat(t,"_physical - pot").concat(t,"_target) < takeover_threshold) {\n                pot").concat(t,'_taken_over = true;\n                Serial.print("Pot').concat(t,' TAKEOVER at physical=");\n                Serial.print(pot').concat(t,'_physical);\n                Serial.print(", target=");\n                Serial.println(pot').concat(t,"_target);\n            } else {\n                // Not taken over yet - maintain target value\n                pot").concat(t,"_value = pot").concat(t,"_target;\n            }\n        }\n\n        if (pot").concat(t,"_taken_over) {\n            // Pot has taken over - follow physical position\n            pot").concat(t,"_value = pot").concat(t,"_physical;\n        }\n\n        // Save current value to this bank's storage\n        pot").concat(t,"_bank_values[currentBank - 1] = pot").concat(t,"_value;\n        pot").concat(t,"_last_bank = currentBank;\n\n        // Debug: Print pot value periodically (disabled for cleaner serial output)\n        // static unsigned long pot").concat(t,"_lastDebug = 0;\n        // if (millis() - pot").concat(t,"_lastDebug > 1000) {\n        //     pot").concat(t,'_lastDebug = millis();\n        //     Serial.print("Pot').concat(t," (Banks: ").concat(c.join(","),') - Physical: ");\n        //     Serial.print(pot').concat(t,'_physical);\n        //     Serial.print(", Value: ");\n        //     Serial.print(pot').concat(t,'_value);\n        //     Serial.print(", TakenOver: ");\n        //     Serial.print(pot').concat(t,'_taken_over ? "YES" : "NO");\n        //     Serial.print(", CurrentBank: ");\n        //     Serial.println(currentBank);\n        // }\n    } else {\n        // Pot not in current bank - maintain last value\n        // DO NOT update last_bank here - it should only track banks where pot IS active\n        // pot').concat(t,"_value remains unchanged\n    }\n                    "))}),this.connections.forEach(function(n){var t=n.from.id.split(":")[0],a=n.to.id.split(":")[0],o=e.modules.find(function(e){return e.id===t}),c=e.modules.find(function(e){return e.id===a});if(o&&c&&("HarmonicSequencer"!==o.type||!n.from.port.includes("step"))){if(n.from&&n.to&&("value"===n.from.port||"pitch_hz"===n.from.port))if(o&&c&&"Pot"===o.type){var r,i=o.params.index||1,l=o.params.bank||1,s=o.params.locked||!1,u=(null===(r=a.match(/\d+$/))||void 0===r?void 0:r[0])||"1";if("Oscillator"===c.type&&"freq"===n.to.port)e.potConnectionCode.push("\n    // Oscillator ".concat(u," frequency from Pot").concat(i,"\n        if (").concat(s?"true":"currentBank == ".concat(l),") { osc").concat(u,"_freq = (pot").concat(i,"_value * 2000.0 + 20.0); } // Pot").concat(i," Bank ").concat(l,"\n                        "));else if("Filter"===c.type&&"cutoff_hz"===n.to.port)e.potConnectionCode.push("\n    // Filter ".concat(u," cutoff from Pot").concat(i," (logarithmic response)\n        if (").concat(s?"true":"currentBank == ".concat(l),") {\n            // Logarithmic frequency mapping: 20Hz to 20kHz (3 decades)\n            filter").concat(u,"_cutoff = 20.0 * pow(1000.0, pot").concat(i,"_value);\n        } // Pot").concat(i," Bank ").concat(l," (logarithmic 20Hz-20kHz)\n                        "));else if("Filter"===c.type&&"resonance"===n.to.port)e.potConnectionCode.push("\n    // Filter ".concat(u," resonance from Pot").concat(i,"\n        if (").concat(s?"true":"currentBank == ".concat(l),") {\n            filter").concat(u,"_resonance = pot").concat(i,"_value;\n        } // Pot").concat(i," Bank ").concat(l,"\n                        "));else if("LFO"===c.type&&"rate_hz"===n.to.port){var d,p,f=(null===(d=c.params)||void 0===d?void 0:d.rate_min_hz)||.01,m=(null===(p=c.params)||void 0===p?void 0:p.rate_max_hz)||40,_=m-f;e.potConnectionCode.push("\n    // LFO ".concat(u," rate from Pot").concat(i," (configurable range: ").concat(f,"-").concat(m," Hz)\n        if (").concat(s?"true":"currentBank == ".concat(l),") { lfo").concat(u,"_rate_hz = ").concat(f," + pot").concat(i,"_value * ").concat(_,"; } // Pot").concat(i," Bank ").concat(l,"\n                        "))}}else if(o&&c&&"HarmonicSequencer"===o.type&&"pitch_hz"===n.from.port){var g,h,v=(null===(g=t.match(/\d+$/))||void 0===g?void 0:g[0])||"1",b=(null===(h=a.match(/\d+$/))||void 0===h?void 0:h[0])||"1";"Oscillator"===c.type&&"freq"===n.to.port&&e.loopCode.push("\n    // Oscillator ".concat(b," frequency from HarmonicSequencer").concat(v," Hz output\n        osc").concat(b,"_freq = seq").concat(v,"_pitch_hz; // Direct Hz from HarmonicSequencer\n                        "))}if(n.from&&n.to&&"env"===n.from.port&&"pitch_cv"===n.to.port&&o&&c&&"ADSR"===o.type&&"Oscillator"===c.type){var y,k,x=(null===(y=t.match(/\d+$/))||void 0===y?void 0:y[0])||"1",S=(null===(k=a.match(/\d+$/))||void 0===k?void 0:k[0])||"1";e.controlConnectionCode.push("\n    // Oscillator ".concat(S," pitch modulation from ADSR ").concat(x,"\n        osc").concat(S,"_freq *= pow(2.0, (adsr").concat(x,"_output - 0.5) * (osc").concat(S,"_pitch_amount / 12.0)); // ADSR pitch CV (pitch_amount semitones, use negative for kick drop)\n                    "))}if(n.from&&n.to&&"press"===n.from.port&&"bypass"===n.to.port&&o&&c&&"LEDButton"===o.type&&"Distortion"===c.type){var E,P,w=(null===(E=t.match(/\d+$/))||void 0===E?void 0:E[0])||"1",C=(null===(P=a.match(/\d+$/))||void 0===P?void 0:P[0])||"1";e.controlConnectionCode.push("\n    // Distortion ".concat(C," bypass from Button ").concat(w,"\n        dist").concat(C,"_bypass = btn").concat(w,"_pressed ? 1.0 : 0.0;\n                    "))}if(n.from&&n.to&&"gate"===n.from.port&&"record_trigger"===n.to.port&&o&&c&&"LEDButton"===o.type&&"Automation"===c.type){var I,R=o.params.index||1,L=(null===(I=a.match(/\d+$/))||void 0===I?void 0:I[0])||"1";e.controlConnectionCode.push("\n    // Automation ".concat(L," record trigger from Button ").concat(R,"\n        automation").concat(L,"_record_trigger = btn").concat(R,"_gate;\n                    "))}if(n.from&&n.to&&("press"===n.from.port||"gate"===n.from.port)&&"mode_select"===n.to.port&&o&&c&&"Automation"===c.type){var M,D,A=(null===(M=t.match(/\d+$/))||void 0===M?void 0:M[0])||"1",O=(null===(D=a.match(/\d+$/))||void 0===D?void 0:D[0])||"1";if("Encoder"===o.type)e.controlConnectionCode.push("\n    // Automation ".concat(O," mode select from Encoder ").concat(A," button\n    automation").concat(O,"_mode_select = enc").concat(A,"_buttonPressed;\n                        "));else if("LEDButton"===o.type){var B=o.params.index||1;e.controlConnectionCode.push("\n    // Automation ".concat(O," mode select from Button ").concat(B,"\n    automation").concat(O,"_mode_select = btn").concat(B,"_gate;\n                        "))}}if(n.from&&n.to&&n.from.port&&"clock"===n.to.port&&o&&c&&"Clock"===o.type&&"Automation"===c.type){var T,F,N=(null===(T=t.match(/\d+$/))||void 0===T?void 0:T[0])||"1",z=(null===(F=a.match(/\d+$/))||void 0===F?void 0:F[0])||"1";e.controlConnectionCode.push("\n    // Automation ".concat(z," clock sync from Clock ").concat(N,"\n        automation").concat(z,"_clock_input = clock").concat(N,"_output").concat(n.from.port.replace("out","")," > 0.5 ? 1.0 : 0.0;\n                    "))}if(n.from&&n.to&&"preset_cv"===n.to.port&&c&&"Distortion"===c.type){var G,q,U=(null===(G=t.match(/\d+$/))||void 0===G?void 0:G[0])||"1",W=(null===(q=a.match(/\d+$/))||void 0===q?void 0:q[0])||"1";if("Pot"===o.type&&"value"===n.from.port)e.controlConnectionCode.push("\n    // Distortion ".concat(W," preset CV from Pot ").concat(U,"\n        dist").concat(W,"_preset_cv = pot").concat(U,"_value; // 0-1 maps to presets 0-5\n                        "));else if("ADSR"===o.type&&"env"===n.from.port)e.controlConnectionCode.push("\n    // Distortion ".concat(W," preset CV from ADSR ").concat(U,"\n        dist").concat(W,"_preset_cv = adsr").concat(U,"_output; // 0-1 maps to presets 0-5\n                        "));else if("Modulation"===o.type&&["lfo1","lfo2","lfo3","lfo4"].includes(n.from.port)){var V=n.from.port.replace("lfo","");e.controlConnectionCode.push("\n    // Distortion ".concat(W," preset CV from Modulation ").concat(U," LFO").concat(V,"\n        dist").concat(W,"_preset_cv = mod").concat(U,"_lfo").concat(V,"_output; // 0-1 maps to presets 0-5\n                        "))}else"HarmonicSequencer"===o.type&&"cv1"===n.from.port?e.controlConnectionCode.push("\n    // Distortion ".concat(W," preset CV from HarmonicSequencer ").concat(U,"\n        dist").concat(W,"_preset_cv = seq").concat(U,"_cv1; // 0-1 maps to presets 0-5\n                        ")):"LFO"===o.type&&"out"===n.from.port&&e.controlConnectionCode.push("\n    // Distortion ".concat(W," preset CV from LFO ").concat(U,"\n        dist").concat(W,"_preset_cv = lfo").concat(U,"_output; // 0-1 maps to presets 0-5\n                        "))}}});var c=this.modules.filter(function(e){return"Automation"===e.type});c.length>0&&c.forEach(function(n){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";e.controlConnectionCode.push("\n    // Automation ".concat(a," mode select from encoder button (built-in auto-wiring)\n    // Hold encoder button (>1s) + move pot to select playback mode (0=normal, 1=reverse, 2=2x, 3=0.5x, 4=pingpong)\n    automation").concat(a,"_mode_select = enc1_buttonLongPressed;\n                "))}),this.modularInstances.forEach(function(n,t){var a=e.modules.find(function(e){return e.id===n.moduleId});if(a&&"BPMLooper"===a.type)for(var o=a.params.start_bank||1,c=o+1,r=0;r<4;r++){var i=r+1;e.potConnectionCode.push("\n    // BPM Looper pot control - Bank ".concat(o," (volume/offset) and Bank ").concat(c," (randomization/pitch)\n    if (currentBank == ").concat(o,") {\n        // Bank 1: Volume or loop start offset (when encoder held)\n        ").concat(n.instanceName,".setPotValue(").concat(r,", pot").concat(i,"_value);\n    } else if (currentBank == ").concat(c,") {\n        // Bank 2: Randomization or pitch (when button held)\n        ").concat(n.instanceName,".setBank2PotValue(").concat(r,", pot").concat(i,"_value);\n    }"))}}),this.potConnectionCode.forEach(function(n){e.loopCode.push(n)}),this.controlConnectionCode.forEach(function(n){e.loopCode.push(n)}),this.modules.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";switch(n.type){case"Pot":case"Scale":break;case"ADSR":var c=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&("gate"===e.to.port||"trigger"===e.to.port)});e.loopCode.push("\n    // ADSR ".concat(o,"\n    float adsr").concat(o,"_currentTimescale = adsr").concat(o,"_timescale; // Default timescale\n    "));var r=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"attack_ms"===e.to.port}),i=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"decay_ms"===e.to.port}),l=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"sustain"===e.to.port}),s=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"release_ms"===e.to.port});if(r){var u=r.from.id.split(":")[0],d=e.modules.find(function(e){return e.id===u});if(d&&"Pot"===d.type){var p=e.getPotReference(d.id);e.loopCode.push("    adsr".concat(o,"_attack = 0.001 + ").concat(p,"_value * 1.999; // Attack 1ms to 2000ms (2s)"))}}if(i){var f=i.from.id.split(":")[0],m=e.modules.find(function(e){return e.id===f});if(m&&"Pot"===m.type){var _=e.getPotReference(m.id);e.loopCode.push("    adsr".concat(o,"_decay = 0.001 + ").concat(_,"_value * 2.999; // Decay 1ms to 3000ms (3s)"))}}if(l){var g=l.from.id.split(":")[0],h=e.modules.find(function(e){return e.id===g});if(h&&"Pot"===h.type){var v=e.getPotReference(h.id);e.loopCode.push("    adsr".concat(o,"_sustain = ").concat(v,"_value; // Sustain 0.0 to 1.0"))}}if(s){var b=s.from.id.split(":")[0],y=e.modules.find(function(e){return e.id===b});if(y&&"Pot"===y.type){var k=e.getPotReference(y.id);e.loopCode.push("    adsr".concat(o,"_release = 0.001 + ").concat(k,"_value * 4.999; // Release 1ms to 5000ms (5s)"))}}var x=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"timescale"===e.to.port});if(x){var S,E=x.from.id.split(":")[0],P=e.modules.find(function(e){return e.id===E});if(null===(S=E.match(/\d+$/))||void 0===S||S[0],P&&"Pot"===P.type){var w=e.getPotReference(P.id);e.loopCode.push("    adsr".concat(o,"_currentTimescale = 0.1 + ").concat(w,"_value * 9.9; // Timescale from pot (0.1x to 10x)"))}}if(c){var C,I=c.from.id.split(":")[0],R=e.modules.find(function(e){return e.id===I}),L=(null===(C=I.match(/\d+$/))||void 0===C?void 0:C[0])||"1";if(R&&"LEDButton"===R.type){var M=R.params.index||1;e.loopCode.push("    adsr".concat(o,"_gate = btn").concat(M,"_state;"))}else R&&"GateGen"===R.type?e.loopCode.push("    adsr".concat(o,"_gate = gate").concat(L,"_output > 0.5; // Gate from GateGen")):R&&"GateIn"===R.type?e.loopCode.push("    adsr".concat(o,"_gate = gatein").concat(L,"_trigger; // Trigger from Gate In")):R&&"MIDIIn"===R.type?e.loopCode.push("    adsr".concat(o,"_gate = midiin").concat(L,"_gate; // Gate from MIDI In")):R&&"Clock"===R.type?e.loopCode.push("    adsr".concat(o,"_gate = clock").concat(L,"_out1; // Gate from Clock")):R&&"LFO"===R.type&&e.loopCode.push("    adsr".concat(o,"_gate = lfo").concat(L,"_output > 0.0; // Gate from LFO (positive half)"))}}}),this.modules.forEach(function(n,t){if("MIDIIn"===n.type){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1",c=e.hardwareModules.generateControlCode(n,o,e.connections);c&&e.loopCode.push(c)}}),this.modules.forEach(function(n,t){if("USBMIDIIn"===n.type){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1",c=e.hardwareModules.generateControlCode(n,o,e.connections);c&&e.loopCode.push(c)}}),this.modules.forEach(function(n,t){if("BLEMIDIIn"===n.type){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1",c=e.hardwareModules.generateControlCode(n,o,e.connections);c&&e.loopCode.push(c)}}),this.loopCode.push("\n\n    // Control module processing (HarmonicSequencer, Scale, LFO, MIDILooper) - runs on Core 0\n        "),this.controlChain.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";if("ADSR"!==n.type){if("HarmonicSequencer"===n.type){e.globalFunctions=e.globalFunctions||[];var c=e.controlModules.generateQuantizationFunction(n,o);c&&!e.globalFunctions.some(function(e){return e.includes("quantizePitch".concat(o))})&&e.globalFunctions.push(c);var r=e.controlModules.generateGlissandoFunction(n,o);r&&!e.globalFunctions.some(function(e){return e.includes("glissandoInterpolate".concat(o))})&&e.globalFunctions.push(r)}var i=e.controlModules.generateProcessingCode(n,o,e.connections);i&&(e.loopCode.push(i),"HarmonicSequencer"===n.type&&e.connections.forEach(function(n){var t=n.from.id.split(":")[0],a=n.to.id.split(":")[0],o=e.modules.find(function(e){return e.id===t}),c=e.modules.find(function(e){return e.id===a});if(o&&c&&"HarmonicSequencer"===o.type&&n.from.port.includes("step")){var r,i,l=(null===(r=t.match(/\d+$/))||void 0===r?void 0:r[0])||"1",s=(null===(i=a.match(/\d+$/))||void 0===i?void 0:i[0])||"1",u=n.from.port;u.includes("pitch")&&u.includes("_hz")&&"Oscillator"===c.type&&"freq"===n.to.port?e.loopCode.push("\n    // Oscillator ".concat(s," frequency from HarmonicSequencer").concat(l," ").concat(u,"\n        osc").concat(s,"_freq = seq").concat(l,"_").concat(u,"; // Direct Hz from HarmonicSequencer step\n                                ")):u.includes("gate")&&"ADSR"===c.type&&"gate"===n.to.port&&e.loopCode.push("\n    // ADSR ".concat(s," gate from HarmonicSequencer").concat(l," ").concat(u,"\n        adsr").concat(s,"_gate = (seq").concat(l,"_").concat(u," > 0.5); // Gate from HarmonicSequencer step\n                                "))}}))}}),this.modules.forEach(function(n,t){if("MIDIOut"===n.type){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1",c=e.hardwareModules.generateControlCode(n,o,e.connections);c&&e.loopCode.push(c)}}),this.modules.forEach(function(n,t){if("USBMIDIOut"===n.type){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1",c=e.hardwareModules.generateControlCode(n,o,e.connections);c&&e.loopCode.push(c)}}),this.loopCode.push("\n}\n        "),this.loopCode.push("\nvoid processAudio() {\n    // CPU load monitoring\n    static unsigned long processingStartMicros = 0;\n    static unsigned long lastCpuReportTime = 0;\n    static float maxCpuLoad = 0.0;\n    static float avgCpuLoad = 0.0;\n    static int cpuSampleCount = 0;\n\n    processingStartMicros = micros();\n    unsigned long currentTime = millis(); // Shared time for processAudio function\n\n    // Set control inputs for modular instances ONCE per buffer (not per sample)\n    "),this.modularInstances.forEach(function(n,t){var a=e.modules.find(function(n){return(n.id||"".concat(n.type).concat(e.modules.indexOf(n)))===t});if(a)if(console.log("Looking for connections to module: ".concat(a.id)),"Looper"===n.type)Object.entries({record:0,decay:1,reverse:2,speed:3}).forEach(function(t){var o=Ue(t,2),c=o[0],r=o[1],i=e.connections.find(function(e){return e.to.id==="".concat(a.id,":").concat(c)});if(i){var l=e.modules.find(function(e){return e.id===i.from.id.split(":")[0]});if(l){var s,u=(null===(s=l.params)||void 0===s?void 0:s.index)||1;"LEDButton"===l.type?(e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(r,", btn").concat(u,"_state ? 1.0f : 0.0f);  // ").concat(c," button")),console.log("Generated setControl(".concat(r,") for ").concat(n.instanceName,".").concat(c," from btn").concat(u,"_state"))):"Pot"===l.type?(e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(r,", pot").concat(u,"_value);  // ").concat(c," pot")),console.log("Generated setControl(".concat(r,") for ").concat(n.instanceName,".").concat(c," from pot").concat(u,"_value"))):"LFO"===l.type&&(e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(r,", lfo").concat(u,"_output);  // ").concat(c," LFO")),console.log("Generated setControl(".concat(r,") for ").concat(n.instanceName,".").concat(c," from lfo").concat(u,"_output")))}}});else if("BPMLooper"===n.type){Object.entries({clock:0,slot1_trig:1,slot2_trig:2,slot3_trig:3,slot4_trig:4,slot1_pitch:5,slot2_pitch:6,slot3_pitch:7,slot4_pitch:8}).forEach(function(t){var o=Ue(t,2),c=o[0],r=o[1],i=e.connections.find(function(e){return e.to.id==="".concat(a.id,":").concat(c)});if(i){var l=e.modules.find(function(e){return e.id===i.from.id.split(":")[0]});if(l){var s,u=(null===(s=l.params)||void 0===s?void 0:s.index)||1;if("LEDButton"===l.type)e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(r,", btn").concat(u,"_state ? 1.0f : 0.0f);  // ").concat(c," button"));else if("Pot"===l.type)e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(r,", pot").concat(u,"_value);  // ").concat(c," pot"));else if("LFO"===l.type)e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(r,", lfo").concat(u,"_output);  // ").concat(c," LFO"));else if("Clock"===l.type)e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(r,", clock").concat(u,"_output);  // ").concat(c," clock"));else if("MIDIIn"===l.type&&c.includes("pitch")&&"chromatic"===a.params.midi_mode){var d=a.params.root_note||60;e.loopCode.push("    // MIDI chromatic mode: ".concat(c)),e.loopCode.push("    {"),e.loopCode.push("        float midiPitch = powf(2.0f, (midiin".concat(u,"_note - ").concat(d,".0f) / 12.0f);  // Chromatic pitch multiplier")),e.loopCode.push("        float pitchCV = (midiPitch - 0.5f) / 1.5f;  // Map 0.5x-2.0x pitch to 0.0-1.0 CV"),e.loopCode.push("        ".concat(n.instanceName,".setControl(").concat(r,", constrain(pitchCV, 0.0f, 1.0f));  // ").concat(c," MIDI chromatic")),e.loopCode.push("    }")}else"MIDIIn"===l.type&&c.includes("trig")&&e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(r,", midiin").concat(u,"_gate);  // ").concat(c," MIDI gate"))}}});for(var o=1;o<=4;o++)e.declaredButtons.has(o)||(e.declaredButtons.add(o),e.globalVariables.push("\n// Button ".concat(o," state (auto-declared for BPM Looper)\nbool btn").concat(o,"_state = false;\nbool btn").concat(o,"_lastState = false;\nbool btn").concat(o,"_pressed = false;\n                        ")));var c=a.params.start_bank||1,r=c+1;e.loopCode.push("\n    // BPMLooper ".concat(n.instanceName," - 2-Bank system (Banks ").concat(c,"-").concat(r,")\n    // Read button states from MCP23017 (rate-limited to avoid I2S interference)\n    {\n        static unsigned long lastBtnRead = 0;\n        if (millis() - lastBtnRead > 20) { // Read every 20ms\n            lastBtnRead = millis();\n            uint16_t mcpInputs = mcp.readGPIOAB();\n            btn1_state = !(mcpInputs & (1 << 2)); // GPA2 - active low (v1.0 mapping)\n            btn2_state = !(mcpInputs & (1 << 1)); // GPA1 - active low\n            btn3_state = !(mcpInputs & (1 << 0)); // GPA0 - active low\n            btn4_state = !(mcpInputs & (1 << 3)); // GPA3 - active low\n        }\n    }"));for(var i=0;i<4;i++){var l=i+1;e.loopCode.push("\n    // Button ".concat(l," routing\n    if (currentBank == ").concat(c,") {\n        // Bank 1: Record/play control\n        ").concat(n.instanceName,".setButtonState(").concat(i,", btn").concat(l,"_state ? 1.0f : 0.0f, encoderBtn);\n    } else if (currentBank == ").concat(r,") {\n        // Bank 2: Momentary pitch control toggle\n        ").concat(n.instanceName,".setBank2ButtonState(").concat(i,", btn").concat(l,"_state);\n    }"))}for(var s=1;s<=4;s++)if(!e.declaredPots.has(s)){e.declaredPots.add(s);var u=[4,5,6,7][s-1];e.globalVariables.push("\n// Pot ".concat(s," (auto-declared for BPM Looper)\nconst int pot").concat(s,"_pin = ").concat(u,";\nfloat pot").concat(s,"_value = 0.0;\nfloat pot").concat(s,"_physical = 0.0;\nfloat pot").concat(s,"_target = 0.0;\nbool pot").concat(s,"_taken_over = false;\nfloat pot").concat(s,"_last_bank_change = 0.0;\n                        "))}}else e.connections.forEach(function(t){if(console.log("Checking connection: ".concat(t.from.id,"  ").concat(t.to.id)),t.to.id.startsWith("".concat(a.id,":"))){var o=e.modules.find(function(e){return e.id===t.from.id.split(":")[0]});if(o&&"LEDButton"===o.type){var c=o.params.index||1,r="btn".concat(c,"_state");e.loopCode.push("    ".concat(n.instanceName,".setControl(0, ").concat(r," ? 1.0f : 0.0f);")),console.log("Generated setControl for ".concat(n.instanceName," with ").concat(r))}}})}),this.loopCode.push("\n    // Set control inputs for modular instances ONCE per buffer (not per sample)\n    "),this.audioChain.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";"SamplePlayer"===n.type&&(console.log("Processing Sample Player ".concat(n.id," connections (preprocessing)...")),e.generateSamplePlayerPreProcessing(n,o)),"DrumDesigner"===n.type&&(console.log("Processing DrumDesigner ".concat(n.id," body filter coefficients (preprocessing)...")),e.generateDrumDesignerPreProcessing(n,o))}),this.loopCode.push("\n        // ADSR envelope processing (buffer-rate timing on Core 1)\n        "),this.controlChain.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";if("ADSR"===n.type){var c=e.controlModules.generateProcessingCode(n,o,e.connections);c&&e.loopCode.push(c)}}),this.loopCode.push("\n".concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"\n    // Read I2S input buffer from PCM1802 ADC\n    size_t bytes_read = 0;\n    esp_err_t read_result = i2s_read(I2S_NUM_0, i2sInputBuffer, sizeof(i2sInputBuffer), &bytes_read, portMAX_DELAY);\n    if (read_result != ESP_OK || bytes_read == 0) {\n        // Clear input buffer on read failure\n        memset(i2sInputBuffer, 0, sizeof(i2sInputBuffer));\n    }\n":"","\n    for (int i = 0; i < BUFFER_SIZE; i++) {\n        // Clear buffers for this sample\n        leftBuffer[i] = 0.0;\n        rightBuffer[i] = 0.0;\n\n        // Interpolate ADSR envelopes within buffer to prevent zipper noise\n        float interpFactor = (float)i / (float)BUFFER_SIZE;")),this.modules.forEach(function(n){if("ADSR"===n.type){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";e.loopCode.push("\n        adsr".concat(a,"_output = adsr").concat(a,"_prevOutput + (adsr").concat(a,"_targetOutput - adsr").concat(a,"_prevOutput) * interpFactor;"))}}),this.loopCode.push("\n\n        // Audio processing chain\n        "),this.audioChain.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";if(!["Scale","ADSR","LFO","Clock"].includes(n.type)&&!["CleanReverb","Delay","Filter","VCA","Distortion","AudioRecorder","I2SOut","StereoMixer4","Matrix2x2","Panner"].includes(n.type)){"Oscillator"===n.type&&console.log("Processing Oscillator ".concat(n.id," (").concat(o,") in audio loop"));var c=null;(c=e.audioModules.generateProcessingCode(n,o,e.connections))||(c=e.sampleModules.generateProcessingCode(n,o,e.connections))||(c=e.hardwareModules.generateProcessingCode(n,o,e.connections))?e.loopCode.push(c):(console.warn("No modular processor found for audio module: ".concat(n.type)),e.loopCode.push("        // TODO: Implement ".concat(n.type," in modular system")))}}),this.audioChain.forEach(function(n){if(["CleanReverb","Delay","Filter","VCA","Distortion","AudioRecorder"].includes(n.type)){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";"CleanReverb"===n.type?e.loopCode.push("        cleanreverb".concat(a,"_inputL = 0.0; cleanreverb").concat(a,"_inputR = 0.0; // Clear inputs")):"Delay"===n.type?e.loopCode.push("        delay".concat(a,"_inputL = 0.0; delay").concat(a,"_inputR = 0.0; // Clear inputs")):"VCA"===n.type?e.loopCode.push("        vca".concat(a,"_inputL = 0.0; vca").concat(a,"_inputR = 0.0; // Clear inputs")):"Filter"===n.type?e.loopCode.push("        filter".concat(a,"_inputL = 0.0; filter").concat(a,"_inputR = 0.0; // Clear inputs")):"Distortion"===n.type?e.loopCode.push("        dist".concat(a,"_inputL = 0.0; dist").concat(a,"_inputR = 0.0; // Clear inputs")):"AudioRecorder"===n.type&&e.loopCode.push("        // AudioRecorder".concat(a," - No input clearing needed (handled internally)"));var o=e.generateConnectionsToModule(n.id);o&&e.loopCode.push(o);var c=e.audioModules.generateProcessingCode(n,a,e.connections);c&&e.loopCode.push(c)}}),this.audioChain.forEach(function(n){if(["StereoMixer4","Matrix2x2","Panner"].includes(n.type)){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";"StereoMixer4"===n.type&&(e.loopCode.push("        stereoMixer4_".concat(a,"_input1L = 0.0; stereoMixer4_").concat(a,"_input1R = 0.0; // Clear inputs")),e.loopCode.push("        stereoMixer4_".concat(a,"_input2L = 0.0; stereoMixer4_").concat(a,"_input2R = 0.0;")),e.loopCode.push("        stereoMixer4_".concat(a,"_input3L = 0.0; stereoMixer4_").concat(a,"_input3R = 0.0;")),e.loopCode.push("        stereoMixer4_".concat(a,"_input4L = 0.0; stereoMixer4_").concat(a,"_input4R = 0.0;")));var o=e.generateConnectionsToModule(n.id);o&&e.loopCode.push(o);var c=e.audioModules.generateProcessingCode(n,a,e.connections);c&&e.loopCode.push(c)}}),this.audioChain.forEach(function(n){if("I2SOut"===n.type||"PCM5102A Out"===n.type){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1",o=e.generateConnectionsToModule(n.id);o&&e.loopCode.push(o);var c=e.audioModules.generateProcessingCode(n,a,e.connections);c&&e.loopCode.push(c)}}),this.loopCode.push("\n        // Initialize buffers (only if no I2S module has written to them)\n        // Note: I2S modules write directly to buffers, other modules add to them\n        ");var r=this.modules.some(function(e){return"I2SOut"===e.type}),i=this.modules.find(function(e){return"I2SOut"===e.type});if(i&&!r){var l=this.connections.filter(function(e){return e.to.id==="".concat(i.id,":L")}),s=this.connections.filter(function(e){return e.to.id==="".concat(i.id,":R")});l.length>0&&l.forEach(function(n){var t=n.from.id.split(":")[0],a=e.modules.find(function(e){return e.id===t});if(a){var o,c=(null===(o=t.match(/\d+$/))||void 0===o?void 0:o[0])||"1";"KickDrum"===a.type?e.loopCode.push("        leftBuffer[i] += kick".concat(c,"_output;")):"Oscillator"===a.type?e.loopCode.push("        leftBuffer[i] += osc".concat(c,"_outputL;")):"Wavetable"===a.type?e.loopCode.push("        leftBuffer[i] += wavetable".concat(c,"_outputL;")):"VCA"===a.type?e.loopCode.push("        leftBuffer[i] += vca".concat(c,"_outputL;")):"GranularSynth"===a.type||"GranularPSRAM"===a.type||"GranularDense"===a.type?e.loopCode.push("        leftBuffer[i] += granular".concat(c,"_outputL;")):"SDPlayer"===a.type||"SamplePlayer"===a.type?e.loopCode.push("        leftBuffer[i] += sdPlayer".concat(c,"_outputL;")):"StereoMixer4"===a.type?e.loopCode.push("        leftBuffer[i] += stereoMixer4_".concat(c,"_outputL;")):"Filter"===a.type?e.loopCode.push("        leftBuffer[i] += filter".concat(c,"_outputL;")):"Delay"===a.type?e.loopCode.push("        leftBuffer[i] += delay".concat(c,"_outputL;")):"AudioMath"===a.type?e.loopCode.push("        leftBuffer[i] += audioMath".concat(c,"_output;")):"Panner"===a.type?e.loopCode.push("        leftBuffer[i] += panner".concat(c,"_outputL;")):"AdvancedLooper"===a.type?e.loopCode.push("        leftBuffer[i] += advancedLooper".concat(c,"_outputL;")):"SnareDrum"===a.type?e.loopCode.push("        leftBuffer[i] += snareDrum".concat(c,"_output;")):a.type}}),s.length>0&&s.forEach(function(n){var t=n.from.id.split(":")[0],a=e.modules.find(function(e){return e.id===t});if(a){var o,c=(null===(o=t.match(/\d+$/))||void 0===o?void 0:o[0])||"1";"KickDrum"===a.type?e.loopCode.push("        rightBuffer[i] += kick".concat(c,"_output;")):"Oscillator"===a.type?e.loopCode.push("        rightBuffer[i] += osc".concat(c,"_outputR;")):"Wavetable"===a.type?e.loopCode.push("        rightBuffer[i] += wavetable".concat(c,"_outputR;")):"VCA"===a.type?e.loopCode.push("        rightBuffer[i] += vca".concat(c,"_outputR;")):"GranularSynth"===a.type||"GranularPSRAM"===a.type||"GranularDense"===a.type?e.loopCode.push("        rightBuffer[i] += granular".concat(c,"_outputR;")):"SDPlayer"===a.type||"SamplePlayer"===a.type?e.loopCode.push("        rightBuffer[i] += sdPlayer".concat(c,"_outputR;")):"StereoMixer4"===a.type?e.loopCode.push("        rightBuffer[i] += stereoMixer4_".concat(c,"_outputR;")):"Filter"===a.type?e.loopCode.push("        rightBuffer[i] += filter".concat(c,"_outputR;")):"Delay"===a.type?e.loopCode.push("        rightBuffer[i] += delay".concat(c,"_outputR;")):"AudioMath"===a.type?e.loopCode.push("        rightBuffer[i] += audioMath".concat(c,"_output;")):"Panner"===a.type?e.loopCode.push("        rightBuffer[i] += panner".concat(c,"_outputR;")):"AdvancedLooper"===a.type?e.loopCode.push("        rightBuffer[i] += advancedLooper".concat(c,"_outputR;")):"SnareDrum"===a.type?e.loopCode.push("        rightBuffer[i] += snareDrum".concat(c,"_output;")):a.type}}),0===l.length&&0===s.length&&this.loopCode.push("\n        // DEBUG FALLBACK: No I2S connections found, but modules should be explicitly connected\n        // Fallback disabled to prevent double-adding signals\n        ")}else this.loopCode.push("\n        // DEBUG FALLBACK: No I2S module found - modules should be explicitly connected\n        // Fallback disabled to prevent double-adding signals\n        ");this.modularInstances.forEach(function(n,t){var a=e.modules.find(function(n){return(n.id||"".concat(n.type).concat(e.modules.indexOf(n)))===t});a&&(e.loopCode.push("\n        \n        // Process modular ".concat(n.type," instance ").concat(n.instanceName,"\n        ").concat(n.instanceName,"_inputL = 0.0f;\n        ").concat(n.instanceName,"_inputR = 0.0f;")),e.connections.forEach(function(t){if(t.to.id.startsWith("".concat(a.id,":"))){var o=e.modules.find(function(e){return e.id===t.from.id.split(":")[0]});if(o){var c,r=(null===(c=o.id.match(/\d+$/))||void 0===c?void 0:c[0])||"1";o.type.toLowerCase(),t.to.id.includes("inL")&&("Oscillator"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputL = osc").concat(r,"_outputL;")):"LineIn"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputL = linein").concat(r,"_outputL;")):"Piezo"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputL = piezo").concat(r,"_outputL;")):"Coil"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputL = coil").concat(r,"_outputL;")):"CleanReverb"!==o.type&&"Reverb"!==o.type||e.loopCode.push("        ".concat(n.instanceName,"_inputL = cleanreverb").concat(r,"_outputL;"))),t.to.id.includes("inR")&&("Oscillator"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputR = osc").concat(r,"_outputR;")):"LineIn"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputR = linein").concat(r,"_outputR;")):"Piezo"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputR = piezo").concat(r,"_outputR;")):"Coil"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputR = coil").concat(r,"_outputR;")):"CleanReverb"!==o.type&&"Reverb"!==o.type||e.loopCode.push("        ".concat(n.instanceName,"_inputR = cleanreverb").concat(r,"_outputR;")))}}}),e.loopCode.push("        ".concat(n.instanceName,".process(").concat(n.instanceName,"_inputL, ").concat(n.instanceName,"_inputR);")),e.connections.forEach(function(t){if(t.from.id.startsWith("".concat(a.id,":"))){var o=e.modules.find(function(e){return e.id===t.to.id.split(":")[0]});o&&"I2SOut"===o.type&&(t.from.id.includes("outL")&&t.to.id.includes("L")&&e.loopCode.push("        leftBuffer[i] += ".concat(n.instanceName,".outL;")),t.from.id.includes("outR")&&t.to.id.includes("R")&&e.loopCode.push("        rightBuffer[i] += ".concat(n.instanceName,".outR;")))}}))}),this.loopCode.push('\n    }\n\n    // CPU load monitoring - calculate processing time\n    unsigned long processingTimeMicros = micros() - processingStartMicros;\n    float availableTimeMicros = (BUFFER_SIZE * 1000000.0) / SAMPLE_RATE; // Time available for this buffer\n    float cpuLoad = (processingTimeMicros / availableTimeMicros) * 100.0;\n\n    // Track statistics\n    if (cpuLoad > maxCpuLoad) maxCpuLoad = cpuLoad;\n    avgCpuLoad = (avgCpuLoad * cpuSampleCount + cpuLoad) / (cpuSampleCount + 1);\n    cpuSampleCount++;\n\n    // Print CPU load report every second\n    if (millis() - lastCpuReportTime > 1000) {\n        lastCpuReportTime = millis();\n\n        Serial.print("CPU Load - Current: ");\n        Serial.print(cpuLoad, 1);\n        Serial.print("%, Avg: ");\n        Serial.print(avgCpuLoad, 1);\n        Serial.print("%, Max: ");\n        Serial.print(maxCpuLoad, 1);\n        Serial.print("% (");\n        Serial.print(processingTimeMicros);\n        Serial.print("us / ");\n        Serial.print((int)availableTimeMicros);\n        Serial.print("us) @ ");\n        Serial.print(getCpuFrequencyMhz());\n        Serial.print("MHz");\n\n        if (cpuLoad > 90.0) {\n            Serial.print("  WARNING: CPU OVERLOAD!");\n        }\n        Serial.println();\n\n        // Debug: Print buffer contents periodically\n        float maxLeft = 0.0, maxRight = 0.0;\n        for (int i = 0; i < BUFFER_SIZE; i++) {\n            if (abs(leftBuffer[i]) > maxLeft) maxLeft = abs(leftBuffer[i]);\n            if (abs(rightBuffer[i]) > maxRight) maxRight = abs(rightBuffer[i]);\n        }\n        if (maxLeft > 0.0 || maxRight > 0.0) {\n            Serial.print("Audio buffer peaks - L: ");\n            Serial.print(maxLeft);\n            Serial.print(", R: ");\n            Serial.println(maxRight);\n        }\n\n        // Reset max for next period\n        maxCpuLoad = 0.0;\n        avgCpuLoad = 0.0;\n        cpuSampleCount = 0;\n    }\n}\n        ');var u=this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)});this.loopCode.push("\nvoid outputAudio() {\n    // Convert float samples to ".concat(u?"32":"16","-bit integers and interleave with clipping protection\n    for (int i = 0; i < BUFFER_SIZE; i++) {\n        // Clamp float values to [-1.0, 1.0] range to prevent harsh clipping\n        float leftSample = leftBuffer[i];\n        float rightSample = rightBuffer[i];\n        if (leftSample > 1.0) leftSample = 1.0;\n        if (leftSample < -1.0) leftSample = -1.0;\n        if (rightSample > 1.0) rightSample = 1.0;\n        if (rightSample < -1.0) rightSample = -1.0;\n\n").concat(u?"        // 32-bit output (24-bit in 32-bit slot for PCM5102A compatibility)\n        i2sBuffer[i * 2] = ((int32_t)(leftSample * 8388608.0f)) << 8;      // Left channel\n        i2sBuffer[i * 2 + 1] = ((int32_t)(rightSample * 8388608.0f)) << 8;  // Right channel":"        i2sBuffer[i * 2] = (int16_t)(leftSample * 16000.0);     // Left channel\n        i2sBuffer[i * 2 + 1] = (int16_t)(rightSample * 16000.0); // Right channel","\n    }\n\n    // Write to I2S\n    size_t bytesWritten;\n    i2s_write(I2S_NUM_0, i2sBuffer, BUFFER_SIZE * ").concat(u?"8":"4",", &bytesWritten, portMAX_DELAY);\n}\n        "))}},{key:"generateSamplePlayerPreProcessing",value:function(e,n){var t=this.connections.find(function(n){return n.to.id==="".concat(e.id,":trig")||n.to.id==="".concat(e.id,":gate")}),a=this.connections.find(function(n){return n.to.id==="".concat(e.id,":gain")}),o=this.connections.find(function(n){return n.to.id==="".concat(e.id,":file_index")||n.to.id==="".concat(e.id,":sample_select")}),c=this.connections.find(function(n){return n.to.id==="".concat(e.id,":pitch")}),r=this.connections.find(function(n){return n.to.id==="".concat(e.id,":pitch_env")}),i=this.connections.find(function(n){return n.to.id==="".concat(e.id,":start_pos")}),l=this.connections.find(function(n){return n.to.id==="".concat(e.id,":end_pos")});if(console.log("Sample Player ".concat(n," connection debug:")),console.log("- trigConnection: ".concat(t?"FOUND":"NOT FOUND")),console.log("- fileIndexConnection: ".concat(o?"FOUND":"NOT FOUND")),console.log("- samplePitchConnection: ".concat(c?"FOUND":"NOT FOUND")),console.log("- startPosConnection: ".concat(i?"FOUND":"NOT FOUND")),console.log("- endPosConnection: ".concat(l?"FOUND":"NOT FOUND")),console.log("Module ID: ".concat(e.id)),console.log("All connections to this module:"),this.connections.filter(function(n){return n.to.id.startsWith(e.id)}).forEach(function(e){console.log("  ".concat(e.from.id,"  ").concat(e.to.id))}),this.loopCode.push("\n    // Sample Player ".concat(n," - Pre-processing (trigger detection)\n    float sdPlayer").concat(n,"_trigger = 0.0;\n    float sdPlayer").concat(n,"_currentGain = sdPlayer").concat(n,"_gain;\n    float sdPlayer").concat(n,"_currentPitch = sdPlayer").concat(n,"_pitch;\n    int sdPlayer").concat(n,"_targetFile = sdPlayer").concat(n,"_currentFile;\n    float sdPlayer").concat(n,"_startPos = ").concat(e.params.start_pos||0,";\n    float sdPlayer").concat(n,"_endPos = ").concat(e.params.end_pos||1,";\n    \n    // Track loaded sample to avoid unnecessary reloads (declared globally)\n        ")),t){var s=t.from.id.split(":")[0],u=this.modules.find(function(e){return e.id===s});if(u&&"LEDButton"===u.type){var d=this.getButtonReference(u.id);this.loopCode.push("    sdPlayer".concat(n,"_trigger = ").concat(d,"_output;"))}else if(u&&"GateGen"===u.type){var p,f=(null===(p=s.match(/\d+$/))||void 0===p?void 0:p[0])||"1";this.loopCode.push("    sdPlayer".concat(n,"_trigger = gate").concat(f,"_output;"))}else if(u){var m,_=(null===(m=s.match(/\d+$/))||void 0===m?void 0:m[0])||"1";this.loopCode.push("    sdPlayer".concat(n,"_trigger = ").concat(u.type.toLowerCase()).concat(_,"_output;"))}}if(a){var g=a.from.id.split(":")[0],h=this.modules.find(function(e){return e.id===g});if(h&&"Pot"===h.type){var v=this.getPotReference(h.id);this.loopCode.push("    sdPlayer".concat(n,"_currentGain = ").concat(v,"_value;"))}else if(h&&"ADSR"===h.type){var b,y=(null===(b=g.match(/\d+$/))||void 0===b?void 0:b[0])||"1";this.loopCode.push("    sdPlayer".concat(n,"_currentGain = adsr").concat(y,"_output; // Gain from ADSR envelope"))}}if(o){var k=o.from.id.split(":")[0],x=this.modules.find(function(e){return e.id===k});if(x&&"Pot"===x.type){var S=this.getPotReference(x.id);this.loopCode.push("    // Dynamic sample selection: pot maps to actual sample count\n    if (sdPlayer".concat(n,"_sampleCount > 0) {\n        int oldTargetFile = sdPlayer").concat(n,"_targetFile;\n        sdPlayer").concat(n,"_targetFile = 1 + (int)(").concat(S,"_value * sdPlayer").concat(n,"_sampleCount);\n        if (sdPlayer").concat(n,"_targetFile > sdPlayer").concat(n,"_sampleCount) {\n            sdPlayer").concat(n,"_targetFile = sdPlayer").concat(n,"_sampleCount;\n        }\n        \n        // Debug sample selection changes\n        if (sdPlayer").concat(n,'_targetFile != oldTargetFile) {\n            Serial.printf("Sample selection changed: pot=%.3f, sampleCount=%d, targetFile=%d\\n", \n                         ').concat(S,"_value, sdPlayer").concat(n,"_sampleCount, sdPlayer").concat(n,"_targetFile);\n        }\n    } else {\n        sdPlayer").concat(n,'_targetFile = 1; // Default if no samples found\n        Serial.println("Warning: No samples found for selection!");\n    }'))}}else this.loopCode.push("    sdPlayer".concat(n,"_targetFile = 1; // Default to sample1.wav"));if(c){var E=c.from.id.split(":")[0],P=this.modules.find(function(e){return e.id===E});if(P&&"Pot"===P.type){var w=this.getPotReference(P.id);this.loopCode.push("    sdPlayer".concat(n,"_currentPitch = 0.5 + (").concat(w,"_value * 1.5); // Coarse pitch: 0.5x to 2.0x speed"))}else if(P&&"ADSR"===P.type){var C,I=(null===(C=E.match(/\d+$/))||void 0===C?void 0:C[0])||"1";this.loopCode.push("    sdPlayer".concat(n,"_currentPitch = adsr").concat(I,"_output; // Pitch from ADSR envelope"))}else if(P&&"Scale"===P.type){var R,L=(null===(R=E.match(/\d+$/))||void 0===R?void 0:R[0])||"1";this.loopCode.push("    // Convert Scale output (frequency Hz) to pitch ratio\n    float scaleFreq = scale".concat(L,"_output;\n    float scalePitchRatio = scaleFreq / 440.0; // Convert frequency to pitch ratio (440Hz = 1.0x)\n    scalePitchRatio = constrain(scalePitchRatio, 0.25, 4.0); // Limit to reasonable range\n    sdPlayer").concat(n,"_currentPitch = scalePitchRatio; // Musical pitch from Scale quantizer"))}else if(P){var M,D=(null===(M=E.match(/\d+$/))||void 0===M?void 0:M[0])||"1";this.loopCode.push("    sdPlayer".concat(n,"_currentPitch = 0.5 + (").concat(P.type.toLowerCase()).concat(D,"_output * 1.5); // Coarse pitch from ").concat(P.type))}}if(r){var A=r.from.id.split(":")[0],O=this.modules.find(function(e){return e.id===A});if(O&&"ADSR"===O.type){var B,T=(null===(B=A.match(/\d+$/))||void 0===B?void 0:B[0])||"1";this.loopCode.push("    // Pitch envelope modulation: 2 semitones, center offset: 0\n    float pitchEnvMod = adsr".concat(T,"_output; // 0.0 to 1.0\n    float envSemitoneOffset = 0 + ((pitchEnvMod - 0.5) * 2.0 * 2); // range around center\n    float pitchEnvRatio = pow(2.0, envSemitoneOffset / 12.0); // Convert semitones to pitch ratio\n    sdPlayer").concat(n,"_currentPitch *= pitchEnvRatio; // Apply envelope modulation"))}}if(this.loopCode.push("    sdPlayer".concat(n,"_currentPitch = constrain(sdPlayer").concat(n,"_currentPitch, 0.1, 8.0); // Final safety limit")),i){var F=i.from.id.split(":")[0],N=this.modules.find(function(e){return e.id===F});if(N&&"Pot"===N.type){var z=this.getPotReference(N.id);this.loopCode.push("    sdPlayer".concat(n,"_startPos = ").concat(z,"_value; // 0.0 to 1.0"))}}if(l){var G=l.from.id.split(":")[0],q=this.modules.find(function(e){return e.id===G});if(q&&"Pot"===q.type){var U=this.getPotReference(q.id);this.loopCode.push("    sdPlayer".concat(n,"_endPos = ").concat(U,"_value; // 0.0 to 1.0"))}}this.loopCode.push("\n    // Single-voice MinimalWAVPlayer trigger detection (rising edge)\n    if (sdPlayer".concat(n,"_trigger > sdPlayer").concat(n,"_triggerThreshold && !sdPlayer").concat(n,'_lastTrigger) {\n        Serial.printf("Single-voice trigger: sample %d, pitch %.2f\\n", \n                     sdPlayer').concat(n,"_targetFile, sdPlayer").concat(n,"_currentPitch);\n        \n        // CRITICAL: No SD I/O during audio processing!\n        // Just flag that we need a different sample - let setup() or background task handle loading\n        if (sdPlayer").concat(n,"_targetFile != sdPlayer").concat(n,'_lastLoadedFile) {\n            Serial.println("Sample change requested - SD loading handled elsewhere");\n            // For now, keep using the currently loaded sample to avoid crashes\n        }\n        \n        // Apply position controls to current sample (safe during audio processing)\n        if (sdPlayer').concat(n,"_lastLoadedFile != -1) {\n            sdPlayer").concat(n,"_player.setStartPosition(sdPlayer").concat(n,"_startPos);\n            sdPlayer").concat(n,"_player.setEndPosition(sdPlayer").concat(n,"_endPos);\n            \n            // Always restart playback from beginning\n            sdPlayer").concat(n,"_player.play();\n            sdPlayer").concat(n,"_playing = true;\n        }\n    }\n    \n    // Stop playback on falling edge (button release)\n    if (sdPlayer").concat(n,"_trigger <= sdPlayer").concat(n,"_triggerThreshold && sdPlayer").concat(n,"_lastTrigger) {\n        if (sdPlayer").concat(n,'_playing) {\n            Serial.println("Single-voice release: stopping playback");\n            sdPlayer').concat(n,"_player.stop();\n            sdPlayer").concat(n,"_playing = false;\n        }\n    }\n    \n    sdPlayer").concat(n,"_lastTrigger = sdPlayer").concat(n,"_trigger > sdPlayer").concat(n,"_triggerThreshold;\n            "))}},{key:"generateDrumDesignerPreProcessing",value:function(e,n){}},{key:"generateAudioConnections",value:function(){var e=this;if(!this.connections||0===this.connections.length)return"// No audio connections to resolve";var n=[];return this.connections.forEach(function(t,a){var o,c,r,i,l,s;if(t.from&&"string"==typeof t.from)r=t.from,i=t.fromPort;else{if(!t.from||!t.from.id)return;r=t.from.id.split(":")[0],i=t.from.port||t.from.id.split(":")[1]}if(t.to&&"string"==typeof t.to)l=t.to,s=t.toPort;else{if(!t.to||!t.to.id)return;l=t.to.id.split(":")[0],s=t.to.port||t.to.id.split(":")[1]}var u=e.modules.find(function(e){return e.id===r}),d=e.modules.find(function(e){return e.id===l});if(u&&d){var p=(null===(o=r.match(/\d+$/))||void 0===o?void 0:o[0])||"1",f=(null===(c=l.match(/\d+$/))||void 0===c?void 0:c[0])||"1";if(e.isAudioPort(u.type,i)&&e.isAudioPort(d.type,s)){var m=e.getAudioOutputVariable(u.type,p,i),_=e.getAudioInputVariable(d.type,f,s);m&&_&&n.push("        ".concat(_," = ").concat(m,"; // ").concat(u.type).concat(p,":").concat(i," -> ").concat(d.type).concat(f,":").concat(s))}}}),n.join("\n")}},{key:"generateConnectionsToModule",value:function(e){var n=this;if(!this.connections||0===this.connections.length)return"";var t=[];return this.connections.forEach(function(a){var o,c,r,i,l,s;if(a.from&&"string"==typeof a.from)r=a.from,i=a.fromPort;else{if(!a.from||!a.from.id)return;r=a.from.id.split(":")[0],i=a.from.port||a.from.id.split(":")[1]}if(a.to&&"string"==typeof a.to)l=a.to,s=a.toPort;else{if(!a.to||!a.to.id)return;l=a.to.id.split(":")[0],s=a.to.port||a.to.id.split(":")[1]}if(l===e){var u=n.modules.find(function(e){return e.id===r}),d=n.modules.find(function(e){return e.id===l});if(u&&d){var p=(null===(o=r.match(/\d+$/))||void 0===o?void 0:o[0])||"1",f=(null===(c=l.match(/\d+$/))||void 0===c?void 0:c[0])||"1";if(n.isAudioPort(u.type,i)&&n.isAudioPort(d.type,s)){var m=n.getAudioOutputVariable(u.type,p,i),_=n.getAudioInputVariable(d.type,f,s);m&&_&&t.push("        ".concat(_," = ").concat(m,"; // ").concat(u.type).concat(p,":").concat(i," -> ").concat(d.type).concat(f,":").concat(s))}}}}),t.join("\n")}},{key:"isAudioPort",value:function(e,n){var t;return(null===(t={Oscillator:["outL","outR","L","R"],PolyOscillator:["outL","outR","L","R"],Wavetable:["outL","outR","L","R"],Noise:["out"],NoiseGenerator:["out"],LineIn:["L","R","outL","outR"],Filter:["in","out","inL","inR","outL","outR"],VCA:["inL","inR","outL","outR"],Distortion:["inL","inR","outL","outR"],Delay:["inL","inR","outL","outR"],Reverb:["inL","inR","outL","outR"],CleanReverb:["inL","inR","outL","outR"],Looper:["inL","inR","outL","outR","L","R"],BPMLooper:["inL","inR","outL","outR","L","R"],StereoMixer4:["in1L","in1R","in2L","in2R","in3L","in3R","in4L","in4R","outL","outR","1L","1R","2L","2R","3L","3R","4L","4R"],Matrix2x2:["inAL","inAR","inBL","inBR","outAL","outAR","outBL","outBR"],DrumDesigner:["outL","outR"],KickDrum:["outL","outR"],SnareDrum:["outL","outR"],AudioRecorder:["outL","outR"],I2SOut:["inL","inR","L","R"],"PCM5102A Out":["inL","inR","L","R"]}[e])||void 0===t?void 0:t.includes(n))||!1}},{key:"getAudioOutputVariable",value:function(e,n,t){switch(e){case"Oscillator":if("outL"===t||"L"===t)return"osc".concat(n,"_outputL");if("outR"===t||"R"===t)return"osc".concat(n,"_outputR");break;case"PolyOscillator":if("outL"===t||"L"===t)return"polyosc".concat(n,"_outputL");if("outR"===t||"R"===t)return"polyosc".concat(n,"_outputR");break;case"Wavetable":if("outL"===t||"L"===t)return"wt".concat(n,"_outputL");if("outR"===t||"R"===t)return"wt".concat(n,"_outputR");break;case"Noise":case"NoiseGenerator":if("out"===t)return"noise".concat(n,"_output");break;case"LineIn":if("L"===t||"outL"===t)return"linein".concat(n,"_outputL");if("R"===t||"outR"===t)return"linein".concat(n,"_outputR");break;case"Piezo":if("L"===t||"outL"===t)return"piezo".concat(n,"_outputL");if("R"===t||"outR"===t)return"piezo".concat(n,"_outputR");break;case"Coil":if("L"===t||"outL"===t)return"coil".concat(n,"_outputL");if("R"===t||"outR"===t)return"coil".concat(n,"_outputR");break;case"Filter":if("out"===t)return"filter".concat(n,"_output");if("outL"===t)return"filter".concat(n,"_outputL");if("outR"===t)return"filter".concat(n,"_outputR");break;case"VCA":if("outL"===t)return"vca".concat(n,"_outputL");if("outR"===t)return"vca".concat(n,"_outputR");break;case"Distortion":if("outL"===t)return"dist".concat(n,"_outputL");if("outR"===t)return"dist".concat(n,"_outputR");break;case"Delay":if("outL"===t)return"delay".concat(n,"_outputL");if("outR"===t)return"delay".concat(n,"_outputR");break;case"Reverb":if("outL"===t)return"reverb".concat(n,"_outputL");if("outR"===t)return"reverb".concat(n,"_outputR");break;case"CleanReverb":if("outL"===t)return"cleanreverb".concat(n,"_outputL");if("outR"===t)return"cleanreverb".concat(n,"_outputR");break;case"Looper":if("outL"===t||"L"===t)return"looper".concat(n,".outL");if("outR"===t||"R"===t)return"looper".concat(n,".outR");break;case"BPMLooper":if("outL"===t||"L"===t)return"bpmlooper".concat(n,".outL");if("outR"===t||"R"===t)return"bpmlooper".concat(n,".outR");break;case"AudioRecorder":if("outL"===t)return"rec".concat(n,"_outputL");if("outR"===t)return"rec".concat(n,"_outputR");break;case"DrumDesigner":if("outL"===t)return"ks".concat(n,"_outputL");if("outR"===t)return"ks".concat(n,"_outputR");break;case"DrumDesigner4":if("mixL"===t)return"dd4".concat(n,"_outputMixL");if("mixR"===t)return"dd4".concat(n,"_outputMixR");if("voice1_outL"===t)return"dd4".concat(n,"_v1_outL");if("voice1_outR"===t)return"dd4".concat(n,"_v1_outR");if("voice2_outL"===t)return"dd4".concat(n,"_v2_outL");if("voice2_outR"===t)return"dd4".concat(n,"_v2_outR");if("voice3_outL"===t)return"dd4".concat(n,"_v3_outL");if("voice3_outR"===t)return"dd4".concat(n,"_v3_outR");if("voice4_outL"===t)return"dd4".concat(n,"_v4_outL");if("voice4_outR"===t)return"dd4".concat(n,"_v4_outR");break;case"KickDrum":if("outL"===t)return"kick".concat(n,"_outputL");if("outR"===t)return"kick".concat(n,"_outputR");break;case"SnareDrum":if("outL"===t)return"snare".concat(n,"_outputL");if("outR"===t)return"snare".concat(n,"_outputR");break;case"StereoMixer4":if("outL"===t)return"stereoMixer4_".concat(n,"_outputL");if("outR"===t)return"stereoMixer4_".concat(n,"_outputR");break;case"Matrix2x2":if("outAL"===t)return"matrix".concat(n,"_outputAL");if("outAR"===t)return"matrix".concat(n,"_outputAR");if("outBL"===t)return"matrix".concat(n,"_outputBL");if("outBR"===t)return"matrix".concat(n,"_outputBR")}return null}},{key:"getAudioInputVariable",value:function(e,n,t){switch(e){case"Filter":if("in"===t)return"filter".concat(n,"_input");if("inL"===t)return"filter".concat(n,"_inputL");if("inR"===t)return"filter".concat(n,"_inputR");break;case"VCA":if("inL"===t)return"vca".concat(n,"_inputL");if("inR"===t)return"vca".concat(n,"_inputR");break;case"Distortion":if("inL"===t)return"dist".concat(n,"_inputL");if("inR"===t)return"dist".concat(n,"_inputR");break;case"Delay":if("inL"===t)return"delay".concat(n,"_inputL");if("inR"===t)return"delay".concat(n,"_inputR");break;case"Reverb":if("inL"===t)return"reverb".concat(n,"_inputL");if("inR"===t)return"reverb".concat(n,"_inputR");break;case"CleanReverb":if("inL"===t)return"cleanreverb".concat(n,"_inputL");if("inR"===t)return"cleanreverb".concat(n,"_inputR");break;case"StereoMixer4":if("in1L"===t||"1L"===t)return"stereoMixer4_".concat(n,"_input1L");if("in1R"===t||"1R"===t)return"stereoMixer4_".concat(n,"_input1R");if("in2L"===t||"2L"===t)return"stereoMixer4_".concat(n,"_input2L");if("in2R"===t||"2R"===t)return"stereoMixer4_".concat(n,"_input2R");if("in3L"===t||"3L"===t)return"stereoMixer4_".concat(n,"_input3L");if("in3R"===t||"3R"===t)return"stereoMixer4_".concat(n,"_input3R");if("in4L"===t||"4L"===t)return"stereoMixer4_".concat(n,"_input4L");if("in4R"===t||"4R"===t)return"stereoMixer4_".concat(n,"_input4R");break;case"Matrix2x2":if("inAL"===t)return"matrix".concat(n,"_inputAL");if("inAR"===t)return"matrix".concat(n,"_inputAR");if("inBL"===t)return"matrix".concat(n,"_inputBL");if("inBR"===t)return"matrix".concat(n,"_inputBR");break;case"AudioRecorder":if("inL"===t)return"rec".concat(n,"_inputL");if("inR"===t)return"rec".concat(n,"_inputR");break;case"I2SOut":case"PCM5102A Out":if("inL"===t||"L"===t)return"i2sout".concat(n,"_inputL");if("inR"===t||"R"===t)return"i2sout".concat(n,"_inputR")}return null}},{key:"generateNetlist",value:function(){var e=["/*"," * PATCH NETLIST"," * ============"],n=this.connections.filter(function(e){return"audio"===e.from.kind}),t=this.connections.filter(function(e){return"ctrl"===e.from.kind||"control"===e.from.kind});return n.length>0&&(e.push(" *"," * AUDIO CONNECTIONS:"),n.forEach(function(n){var t=n.from.id.split(":"),a=n.to.id.split(":");e.push(" * [audio] ".concat(t[0],":").concat(n.from.port,"  ").concat(a[0],":").concat(n.to.port))})),t.length>0&&(e.push(" *"," * CONTROL CONNECTIONS:"),t.forEach(function(n){var t=n.from.id.split(":"),a=n.to.id.split(":");e.push(" * [ctrl] ".concat(t[0],":").concat(n.from.port,"  ").concat(a[0],":").concat(n.to.port))})),e.push(" */"),e.join("\n")}},{key:"assembleCode",value:function(){return["// Generated ESP32-S3 Patcher Code","// Target: ESP32-S3 with PCM5102A DAC and MCP23017 I/O Expander","// Generated on: "+(new Date).toISOString(),this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type})?"// File transfer functionality is built-in - no external libraries required":"","",this.generateNetlist(),""].concat(We(Array.from(this.includes)),[""],We(this.moduleClasses),[""],We(this.globalVariables),[""],We(this.globalFunctions||[]),[""],We(this.setupCode),[""],We(this.loopCode)).join("\n")}},{key:"estimateCPU",value:function(){var e=new Set(["HarmonicSequencer","BankSequencer","Scale","Modulation","Clock","GateGen","Pot","LEDButton","Encoder","MIDIIn","MIDIOut","GateOut"]),n={Oscillator:10,Wavetable:10,Noise:2,NoiseGenerator:2,ADSR:3,VCA:2,Filter:15,Delay:10,Reverb:40,CleanReverb:30,StereoMixer4:2,Matrix2x2:4,Panner:2,SamplePlayer:12,GranularDense:50,Looper:22,KickDrum:18,SnareDrum:18,SDPlay:10,I2SOut:2,"PCM5102A Out":2,HarmonicSequencer:0,BankSequencer:0,Scale:0,Modulation:0,Clock:0,GateGen:0,Pot:0,LEDButton:0,Encoder:0,MIDIIn:0,MIDIOut:0,GateOut:0},t=0,a=0,o=[];this.modules.forEach(function(c){var r=void 0!==n[c.type]?n[c.type]:5;e.has(c.type)?a++:t+=r,o.push({id:c.id,type:c.type,cost:r,core:e.has(c.type)?0:1})});var c=55*(t+=10),r=c/5442*100;return{percentage:Math.round(10*r)/10,breakdown:o,total:t,core0ModuleCount:a,estimatedCycles:c,availableCycles:5442,dualCore:!0}}},{key:"checkAudioRecorderButton",value:function(e,n){var t,a=qe(this.modules.filter(function(e){return"AudioRecorder"===e.type}));try{for(a.s();!(t=a.n()).done;){var o=t.value.params.bank||1,c=e.params.bank||1,r=e.params.index||1;if(o===c&&(1===r||2===r))return!0}}catch(e){a.e(e)}finally{a.f()}return!1}},{key:"getAudioRecorderForButton",value:function(e,n){var t,a=qe(this.modules.filter(function(e){return"AudioRecorder"===e.type}));try{for(a.s();!(t=a.n()).done;){var o=t.value,c=o.params.bank||1,r=e.params.bank||1,i=e.params.index||1;if(c===r){var l,s=(null===(l=o.id.match(/\d+$/))||void 0===l?void 0:l[0])||"1";if(1===i)return{instanceIndex:s,buttonRole:"record"};if(2===i)return{instanceIndex:s,buttonRole:"play"}}}}catch(e){a.e(e)}finally{a.f()}return null}}])&&Ye(n.prototype,t),Object.defineProperty(n,"prototype",{writable:!1}),n;var n,t}();$e(Ze,"PANEL_PORT_MAP",{panel_lineInL:{type:"LineIn",virtualId:"panel_LineIn_1",port:"outL",side:"right",kind:"audio"},panel_lineInR:{type:"LineIn",virtualId:"panel_LineIn_1",port:"outR",side:"right",kind:"audio"},panel_lineOutL:{type:"I2SOut",virtualId:"panel_I2SOut_1",port:"inL",side:"left",kind:"audio"},panel_lineOutR:{type:"I2SOut",virtualId:"panel_I2SOut_1",port:"inR",side:"left",kind:"audio"},panel_speakerOut:{type:"I2SOut",virtualId:"panel_I2SOut_1",port:"inL",side:"left",kind:"audio"},panel_pot1:{type:"Pot",virtualId:"panel_Pot_1",port:"out",side:"right",kind:"ctrl",index:1},panel_pot2:{type:"Pot",virtualId:"panel_Pot_2",port:"out",side:"right",kind:"ctrl",index:2},panel_pot3:{type:"Pot",virtualId:"panel_Pot_3",port:"out",side:"right",kind:"ctrl",index:3},panel_pot4:{type:"Pot",virtualId:"panel_Pot_4",port:"out",side:"right",kind:"ctrl",index:4},panel_btn1:{type:"LEDButton",virtualId:"panel_LEDButton_1",port:"gate",side:"right",kind:"ctrl",index:1},panel_btn2:{type:"LEDButton",virtualId:"panel_LEDButton_2",port:"gate",side:"right",kind:"ctrl",index:2},panel_btn3:{type:"LEDButton",virtualId:"panel_LEDButton_3",port:"gate",side:"right",kind:"ctrl",index:3},panel_btn4:{type:"LEDButton",virtualId:"panel_LEDButton_4",port:"gate",side:"right",kind:"ctrl",index:4},panel_encoderBtn:{type:"Encoder",virtualId:"panel_Encoder_1",port:"gate",side:"right",kind:"ctrl"},panel_gateIn1:{type:"GateIn",virtualId:"panel_GateIn_1",port:"out",side:"right",kind:"ctrl",index:1},panel_gateIn2:{type:"GateIn",virtualId:"panel_GateIn_2",port:"out",side:"right",kind:"ctrl",index:2},panel_gateOut1:{type:"GateOut",virtualId:"panel_GateOut_1",port:"in",side:"left",kind:"ctrl",index:1},panel_gateOut2:{type:"GateOut",virtualId:"panel_GateOut_2",port:"in",side:"left",kind:"ctrl",index:2},panel_midiIn:{type:"MIDIIn",virtualId:"panel_MIDIIn_1",port:"note",side:"right",kind:"ctrl"},panel_midiOut:{type:"MIDIOut",virtualId:"panel_MIDIOut_1",port:"note",side:"left",kind:"ctrl"}});const Qe=t.p+"assets/soniphormLogo.png";function Je(){var e,n,t="function"==typeof Symbol?Symbol:{},a=t.iterator||"@@iterator",o=t.toStringTag||"@@toStringTag";function c(t,a,o,c){var l=a&&a.prototype instanceof i?a:i,s=Object.create(l.prototype);return en(s,"_invoke",function(t,a,o){var c,i,l,s=0,u=o||[],d=!1,p={p:0,n:0,v:e,a:f,f:f.bind(e,4),d:function(n,t){return c=n,i=0,l=e,p.n=t,r}};function f(t,a){for(i=t,l=a,n=0;!d&&s&&!o&&n<u.length;n++){var o,c=u[n],f=p.p,m=c[2];t>3?(o=m===a)&&(l=c[(i=c[4])?5:(i=3,3)],c[4]=c[5]=e):c[0]<=f&&((o=t<2&&f<c[1])?(i=0,p.v=a,p.n=c[1]):f<m&&(o=t<3||c[0]>a||a>m)&&(c[4]=t,c[5]=a,p.n=m,i=0))}if(o||t>1)return r;throw d=!0,a}return function(o,u,m){if(s>1)throw TypeError("Generator is already running");for(d&&1===u&&f(u,m),i=u,l=m;(n=i<2?e:l)||!d;){c||(i?i<3?(i>1&&(p.n=-1),f(i,l)):p.n=l:p.v=l);try{if(s=2,c){if(i||(o="next"),n=c[o]){if(!(n=n.call(c,l)))throw TypeError("iterator result is not an object");if(!n.done)return n;l=n.value,i<2&&(i=0)}else 1===i&&(n=c.return)&&n.call(c),i<2&&(l=TypeError("The iterator does not provide a '"+o+"' method"),i=1);c=e}else if((n=(d=p.n<0)?l:t.call(a,p))!==r)break}catch(n){c=e,i=1,l=n}finally{s=1}}return{value:n,done:d}}}(t,o,c),!0),s}var r={};function i(){}function l(){}function s(){}n=Object.getPrototypeOf;var u=[][a]?n(n([][a]())):(en(n={},a,function(){return this}),n),d=s.prototype=i.prototype=Object.create(u);function p(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,s):(e.__proto__=s,en(e,o,"GeneratorFunction")),e.prototype=Object.create(d),e}return l.prototype=s,en(d,"constructor",s),en(s,"constructor",l),l.displayName="GeneratorFunction",en(s,o,"GeneratorFunction"),en(d),en(d,o,"Generator"),en(d,a,function(){return this}),en(d,"toString",function(){return"[object Generator]"}),(Je=function(){return{w:c,m:p}})()}function en(e,n,t,a){var o=Object.defineProperty;try{o({},"",{})}catch(e){o=0}en=function(e,n,t,a){function c(n,t){en(e,n,function(e){return this._invoke(n,t,e)})}n?o?o(e,n,{value:t,enumerable:!a,configurable:!a,writable:!a}):e[n]=t:(c("next",0),c("throw",1),c("return",2))},en(e,n,t,a)}function nn(e,n,t,a,o,c,r){try{var i=e[c](r),l=i.value}catch(e){return void t(e)}i.done?n(l):Promise.resolve(l).then(a,o)}function tn(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,c,r,i=[],l=!0,s=!1;try{if(c=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=c.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(r=t.return(),Object(r)!==r))return}finally{if(s)throw o}}return i}}(e,n)||function(e,n){if(e){if("string"==typeof e)return an(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?an(e,n):void 0}}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function an(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}const on=function(e){var n=e.module,t=e.onUpdateParam,o=e.onClose,c=e.embedded,r=void 0!==c&&c,i=e.activeLayer,l=void 0===i?"oscillator":i,s=e.setActiveLayer,u=e.onAudioLoaded,d=e.preloadedAudio,p=e.fixedEnvelopeType,f=void 0===p?null:p;console.log(" EnvelopeWaveformEditor rendered with embedded =",r);var m=(0,a.useRef)(),_=(0,a.useRef)(),g=tn((0,a.useState)(null),2),h=g[0],v=g[1],b=tn((0,a.useState)({x:0,y:0}),2),y=(b[0],b[1]),k=tn((0,a.useState)(null),2),x=k[0],S=k[1],E=tn((0,a.useState)(null),2),P=E[0],w=E[1],C=tn((0,a.useState)(!1),2),I=C[0],R=C[1],L=tn((0,a.useState)(f||"amplitude"),2),M=L[0],D=L[1];(0,a.useEffect)(function(){if(d){var e=d.originalBuffer||d.audioBuffer;e&&(console.log(" Using preloaded trimmed audio in EnvelopeWaveformEditor:",e),S(e),setTimeout(function(){Y()},100))}},[d]);var A,O,B,T,F=function(e){var n=440*Math.pow(2,-4.75);if(e<=0)return"---";var t=Math.round(12*Math.log2(e/n)),a=Math.floor(t/12);return"".concat(["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][t%12]).concat(a)},N=200,z=40,G=720,q=320,U=function(){var e,a=(e=Je().m(function e(a){var o,c,r,i,l,s;return Je().w(function(e){for(;;)switch(e.p=e.n){case 0:if(a){e.n=1;break}return e.a(2);case 1:if(R(!0),e.p=2,(o=P)&&"closed"!==o.state||(o=new(window.AudioContext||window.webkitAudioContext),w(o)),"suspended"!==o.state){e.n=3;break}return e.n=3,o.resume();case 3:return e.n=4,a.arrayBuffer();case 4:return c=e.v,e.n=5,o.decodeAudioData(c);case 5:r=e.v,console.log("Loaded audio file:",{name:a.name,duration:r.duration,sampleRate:r.sampleRate,channels:r.numberOfChannels}),S(r),u&&(console.log(" Calling onAudioLoaded with decodedBuffer"),i=r.getChannelData(0),l=new Float32Array(i),u(l,r)),n.params.sample_name&&""!==n.params.sample_name||t("sample_name",a.name.replace(/\.[^/.]+$/,"")),e.n=7;break;case 6:e.p=6,s=e.v,console.error("Failed to load audio file:",s),alert("Failed to load audio file: ".concat(a.name,"\n\nError: ").concat(s.message,"\n\nPlease try a different audio format (WAV, MP3, or OGG)."));case 7:return e.p=7,R(!1),e.f(7);case 8:return e.a(2)}},e,null,[[2,6,7,8]])}),function(){var n=this,t=arguments;return new Promise(function(a,o){var c=e.apply(n,t);function r(e){nn(c,a,o,r,i,"next",e)}function i(e){nn(c,a,o,r,i,"throw",e)}r(void 0)})});return function(e){return a.apply(this,arguments)}}(),W=function(e){var n=e.target.files[0];n&&U(n)},V=function(e){e.preventDefault();var n=Array.from(e.dataTransfer.files).find(function(e){return e.type.startsWith("audio/")||e.name.toLowerCase().match(/\.(wav|mp3|ogg|flac|aac)$/)});n&&U(n)},H=function(e){e.preventDefault()},j=function(e,n){var t=n.attack_ms,a=n.decay_ms,o=n.sustain,c=n.release_ms,r=n.attack_curve,i=n.decay_curve,l=n.release_curve,s=e*(t+a+200+c),u=0;if(s<=t){var d=s/t,p=d;switch(r){case"exp":p=(1-Math.exp(-5*d))/(1-Math.exp(-5));break;case"log":p=Math.log(1+9*d)/Math.log(10);break;case"sine":p=Math.sin(d*Math.PI/2);break;case"quad":p=d*d}u=p}else if(s<=t+a){var f=(s-t)/a,m=f;switch(i){case"exp":m=1-(1-Math.exp(-5*(1-f)))/(1-Math.exp(-5));break;case"log":m=1-Math.log(1+9*(1-f))/Math.log(10);break;case"sine":m=1-Math.sin((1-f)*Math.PI/2);break;case"quad":m=1-(1-f)*(1-f)}u=1-(1-o)*m}else if(s<=t+a+200)u=o;else{var _=(s-t-a-200)/c;if(_>=1)u=0;else{var g=_;switch(l){case"exp":g=1-(1-Math.exp(-5*(1-_)))/(1-Math.exp(-5));break;case"log":g=1-Math.log(1+9*(1-_))/Math.log(10);break;case"sine":g=1-Math.sin((1-_)*Math.PI/2);break;case"quad":g=1-(1-_)*(1-_)}u=o*(1-g)}}return Math.max(0,Math.min(1,u))},K=function(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"amplitude";e="sample"===l?"sample_".concat("filter"===t?"filter":"pitch"===t?"pitch":"amp"):"noise"===l?"noise_".concat("filter"===t?"filter":"amp"):"osc_".concat("pitch"===t?"pitch":"amp");var a={attack_ms:n.params["".concat(e,"_attack_ms")]||10,decay_ms:n.params["".concat(e,"_decay_ms")]||120,sustain:n.params["".concat(e,"_sustain")]||.6,release_ms:n.params["".concat(e,"_release_ms")]||200,attack_curve:n.params["".concat(e,"_attack_curve")]||"linear",decay_curve:n.params["".concat(e,"_decay_curve")]||"exp",release_curve:n.params["".concat(e,"_release_curve")]||"exp"};return console.log(" getCurrentLayerParams: envelopeTab=".concat(t,", prefix=").concat(e,", result:"),a),a},Y=function(){var e=m.current;if(e){var t,a,o=e.getContext("2d"),c=K(M);console.log(" Drawing with params:",c,"activeEnvelopeTab:",M),o.fillStyle="#0f172a",o.fillRect(0,0,800,400),o.strokeStyle="#374151",o.lineWidth=1,o.setLineDash([2,2]);for(var r=0;r<=4;r++){var i=z+r*q/4;o.beginPath(),o.moveTo(z,i),o.lineTo(760,i),o.stroke();var s=z+r*G/4;o.beginPath(),o.moveTo(s,z),o.lineTo(s,360),o.stroke()}switch(o.setLineDash([]),l){case"oscillator":t=function(e,n,t){for(var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:44100,o=[],c=Math.floor(t*a),r=0;r<c;r++){var i=r/a,l=2*Math.PI*n*i;switch(e){case"sine":default:o[r]=Math.sin(l);break;case"saw":o[r]=l%(2*Math.PI)/(2*Math.PI)*2-1;break;case"square":o[r]=Math.sign(Math.sin(l));break;case"triangle":o[r]=2/Math.PI*Math.asin(Math.sin(l))}}return o}("sine",n.params.osc_freq||60,1);break;case"noise":t=function(e,n){for(var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:44100,a=[],o=Math.floor(n*t),c=0,r=0;r<o;r++){var i=void 0;switch(e){case"white":default:i=2*Math.random()-1;break;case"brown":i=c+.1*(2*Math.random()-1),c=i=Math.max(-1,Math.min(1,i));break;case"pink":i=(2*Math.random()-1)*Math.pow(Math.random(),.5)}a[r]=i}return a}(n.params.noise_type||"white",1);break;case"sample":t=function(){if(console.log("getRealSampleWaveform called, audioBuffer:",x),x&&x.getChannelData){var e=x.getChannelData(0),n=e.length,t=4e3;if(n-0>t){for(var a=(n-0)/t,o=[],c=0;c<t;c++){var r=Math.floor(0+c*a);o[c]=e[r]}return o}return Array.from(e.slice(0,n))}if(x&&x.length){console.log("Using Float32Array audioBuffer:",x.length,"samples");var i=4e3;if(x.length>i){for(var l=x.length/i,s=[],u=0;u<i;u++){var d=Math.floor(u*l);s[u]=x[d]}return s}return Array.from(x)}for(var p=[],f=Math.floor(44100),m=0;m<f;m++){var _=m/44100,g=Math.exp(8*-_),h=1+2*Math.exp(15*-_),v=2*Math.PI*60*h*_;p[m]=Math.sin(v)*g}return p}()}a="pitch"===M?function(e,t,a){for(var o="sample"===l?n.params.sample_pitch_amount||12:n.params.osc_pitch_amount||.5,c=[],r=0,i=0;i<e.length;i++){var s=i/(e.length-1),u=j(s,t),d=void 0;if("sample"===l){var p=u*o;d=a*Math.pow(2,p/12)}else d=a*Math.pow(2,u*o);e.length,(r+=2*Math.PI*d/44100)>=2*Math.PI&&(r-=2*Math.PI),c[i]=Math.sin(r)}return c}(t,c,n.params.osc_frequency||60):function(e,n){return e&&e.map?e.map(function(t,a){var o=a/(e.length-1);return t*j(o,n)}):(console.warn("applyEnvelopeToWaveform: waveform is undefined or not array-like"),[])}(t,c),o.strokeStyle="#4b5563",o.lineWidth=1,o.globalAlpha=.3,o.beginPath();for(var u=0;u<t.length;u+=Math.ceil(t.length/G)){var d=z+u/t.length*G,p=200+t[u]*q/4;0===u?o.moveTo(d,p):o.lineTo(d,p)}o.stroke(),o.globalAlpha=1;var f={oscillator:"#10b981",noise:"#f59e0b",sample:"#8b5cf6"};o.strokeStyle=f[l],o.lineWidth=2,o.beginPath();for(var _=0;_<a.length;_+=Math.ceil(a.length/G)){var g=z+_/a.length*G,v=200+a[_]*q/4;0===_?o.moveTo(g,v):o.lineTo(g,v)}o.stroke(),o.strokeStyle="#ef4444",o.lineWidth=3,o.globalAlpha=.8,o.beginPath();for(var b=0;b<=G;b+=2){var y=j(b/G,c),k=z+b,S=z+(1-y)*q;0===b?o.moveTo(k,S):o.lineTo(k,S)}o.stroke(),o.globalAlpha=1;var E=c.attack_ms+c.decay_ms+200+c.release_ms,P=z+c.attack_ms/E*G,w=z+(c.attack_ms+c.decay_ms)/E*G,C=z+(c.attack_ms+c.decay_ms+200)/E*G,I=z+(1-c.sustain)*q,R=I,L=function(e,n,t,a){o.fillStyle=t?"#fbbf24":"#ef4444",o.strokeStyle="#000",o.lineWidth=2,o.beginPath(),o.arc(e,n,8,0,2*Math.PI),o.fill(),o.stroke(),o.fillStyle="#fff",o.font="bold 12px sans-serif",o.textAlign="center",o.fillText(a,e,n-12)};L(P,40,"attack"===h,"A"),L(w,I,"decay"===h,"D"),L(C,R,"sustain"===h,"S"),L(760,360,"release"===h,"R"),o.fillStyle=f[l],o.font="bold 16px sans-serif",o.textAlign="left",o.fillText("".concat(l.toUpperCase()," LAYER"),45,60),"sample"!==l||x||(o.fillStyle="#8b5cf6",o.font="bold 14px sans-serif",o.textAlign="center",o.fillText("Drag & drop audio file here or use Load button",400,200),o.font="12px sans-serif",o.fillStyle="#a855f7",o.fillText("Supports: WAV, MP3, OGG, FLAC, AAC",400,220))}},$=function(e){console.log(" EnvelopeWaveformEditor handleMouseDown fired!",e);var n=m.current;if(n){var t=n.getBoundingClientRect(),a=n.width/t.width,o=n.height/t.height,c=(e.clientX-t.left)*a,r=(e.clientY-t.top)*o,i=K(M);console.log(" activeLayer:",l,"activeEnvelopeTab:",M),console.log(" params:",i);var s=i.attack_ms+i.decay_ms+200+i.release_ms,u=z+i.attack_ms/s*G,d=z+(i.attack_ms+i.decay_ms)/s*G,p=z+(i.attack_ms+i.decay_ms+200)/s*G,f=z+(1-i.sustain)*q,_=f;Math.sqrt(Math.pow(c-u,2)+Math.pow(r-40,2))<15?(v("attack"),e.preventDefault(),e.stopPropagation()):Math.sqrt(Math.pow(c-d,2)+Math.pow(r-f,2))<15?(v("decay"),e.preventDefault(),e.stopPropagation()):Math.sqrt(Math.pow(c-p,2)+Math.pow(r-_,2))<15?(v("sustain"),e.preventDefault(),e.stopPropagation()):Math.sqrt(Math.pow(c-760,2)+Math.pow(r-360,2))<15&&(v("release"),e.preventDefault(),e.stopPropagation()),y({x:c,y:r})}else console.log(" No canvas ref!")},X=function(e){if(h){var n=m.current;if(n){var a,o=n.getBoundingClientRect(),c=n.width/o.width,r=n.height/o.height,i=(e.clientX-o.left)*c,s=(e.clientY-o.top)*r;if(K(M),a="sample"===l?"sample_".concat("filter"===M?"filter":"pitch"===M?"pitch":"amp"):"noise"===l?"noise_".concat("filter"===M?"filter":"amp"):"osc_".concat("pitch"===M?"pitch":"amp"),"attack"===h){var u=Math.max(0,Math.min(1,(i-z)/G)),d=Math.max(1,Math.min(1e3,500*u));t("".concat(a,"_attack_ms"),Math.round(d))}else if("decay"===h){var p=Math.max(0,Math.min(1,(i-z)/G)),f=Math.max(1,Math.min(2e3,800*p));t("".concat(a,"_decay_ms"),Math.round(f))}else if("sustain"===h){var _=Math.max(0,Math.min(1,1-(s-z)/q));t("".concat(a,"_sustain"),_)}else if("release"===h){var g=Math.max(0,Math.min(1,(i-z)/G)),v=Math.max(10,Math.min(3e3,1500*g));t("".concat(a,"_release_ms"),Math.round(v))}y({x:i,y:s}),e.preventDefault()}}},Z=function(){v(null)};return(0,a.useEffect)(function(){Y()},[l,M,n.params,h,x]),r?(console.log(" EMBEDDED MODE ACTIVATED - No left panel, knobs handled by parent"),console.log(" activeLayer:",l,"activeEnvelopeTab:",M),console.log(" module.params:",n.params),a.createElement("div",{style:{width:"100%",height:"100%",display:"flex",flexDirection:"column",backgroundColor:"#0c1428"}},("oscillator"===l||"noise"===l||"sample"===l)&&!f&&a.createElement("div",{style:{padding:"8px 16px",borderBottom:"1px solid #334155",display:"flex",alignItems:"center",gap:"8px"}},a.createElement("div",{style:{display:"flex",gap:"2px",border:"1px solid #374151",borderRadius:"4px",overflow:"hidden"}},a.createElement("button",{onClick:function(){return D("amplitude")},style:{padding:"4px 12px",background:"amplitude"===M?"#ef4444":"#374151",color:"amplitude"===M?"#000":"#cbd5e1",border:"none",fontSize:"11px",fontWeight:"600",cursor:"pointer"}},"Amplitude"),("oscillator"===l||"sample"===l)&&a.createElement("button",{onClick:function(){return D("pitch")},style:{padding:"4px 12px",background:"pitch"===M?"#3b82f6":"#374151",color:"pitch"===M?"#000":"#cbd5e1",border:"none",fontSize:"11px",fontWeight:"600",cursor:"pointer"}},"Pitch"),("noise"===l||"sample"===l)&&a.createElement("button",{onClick:function(){return D("filter")},style:{padding:"4px 12px",background:"filter"===M?"#10b981":"#374151",color:"filter"===M?"#000":"#cbd5e1",border:"none",fontSize:"11px",fontWeight:"600",cursor:"pointer"}},"Filter"))),a.createElement("div",{style:{flex:1,display:"flex",alignItems:"center",justifyContent:"flex-start",padding:"16px"}},"sample"!==l||x?a.createElement("canvas",{ref:m,width:800,height:400,onMouseDown:$,onMouseMove:X,onMouseUp:Z,onMouseLeave:Z,style:{border:"2px solid #374151",borderRadius:"8px",backgroundColor:"#0f172a",maxWidth:"100%",maxHeight:"100%",cursor:h?"grabbing":"grab"}}):a.createElement("div",{style:{width:"100%",height:"100%",border:"2px dashed #8b5cf6",borderRadius:"8px",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",backgroundColor:"#0f172a"},onClick:function(){var e;return null===(e=_.current)||void 0===e?void 0:e.click()},onDragOver:H,onDrop:V},a.createElement("div",{style:{textAlign:"center",color:"#8b5cf6"}},a.createElement("div",{style:{fontSize:"48px",marginBottom:"12px"}},""),a.createElement("div",{style:{fontSize:"16px",fontWeight:"600"}},"Drop audio file here"),a.createElement("div",{style:{fontSize:"13px",marginTop:"6px"}},"or click to browse")),a.createElement("input",{ref:_,type:"file",accept:".wav,.mp3,.ogg,.flac,.aac",onChange:W,style:{display:"none"}}))),a.createElement("div",{style:{backgroundColor:"#0f172a",padding:"16px",borderTop:"1px solid #334155",display:"flex",alignItems:"flex-start",gap:"20px",flexWrap:"wrap",minHeight:"120px"}},a.createElement("div",{style:{color:{oscillator:"#10b981",noise:"#f59e0b",sample:"#8b5cf6"}[l],fontSize:"12px",fontWeight:"600",textTransform:"uppercase",letterSpacing:"0.5px",minWidth:"80px"}},l),"oscillator"===l&&a.createElement("div",{style:{display:"flex",flexWrap:"wrap",gap:"16px",alignItems:"center",border:"1px solid #334155",borderRadius:"6px",padding:"12px",backgroundColor:"#0c1428"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#10b981",fontSize:"12px",fontWeight:"600",minWidth:"70px"}},"Waveform:"),a.createElement("select",{value:n.params.osc_waveform||"sine",onChange:function(e){return t("osc_waveform",e.target.value)},style:{padding:"6px 8px",borderRadius:"4px",border:"1px solid #10b981",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px",minWidth:"100px"}},a.createElement("option",{value:"sine"},"Sine"),a.createElement("option",{value:"square"},"Square"),a.createElement("option",{value:"saw"},"Sawtooth"),a.createElement("option",{value:"triangle"},"Triangle"))),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px",flexWrap:"wrap"}},a.createElement("label",{style:{color:"#10b981",fontSize:"12px",fontWeight:"600",minWidth:"70px"}},"pitch"===M?"Start Freq:":"Frequency:"),a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"4px",cursor:"pointer"}},a.createElement("input",{type:"checkbox",checked:n.params.osc_snap_to_note||!1,onChange:function(e){return t("osc_snap_to_note",e.target.checked)},style:{accentColor:"#10b981"}}),a.createElement("span",{style:{color:"#10b981",fontSize:"10px",fontWeight:"500"}},"Snap to Note")),a.createElement("input",{type:"range",min:"0",max:"100",step:n.params.osc_snap_to_note?"1":"0.1",value:(A=n.params.osc_freq||60,O=Math.max(30,Math.min(N,A)),B=Math.log(30),T=Math.log(N),(Math.log(O)-B)/(T-B)*100),onChange:function(e){var a=function(e){var n=e/100,t=Math.log(30),a=Math.log(N);return Math.exp(t+n*(a-t))}(parseFloat(e.target.value));n.params.osc_snap_to_note&&(a=function(e){var n=440*Math.pow(2,-4.75),t=Math.round(12*Math.log2(e/n)),a=n*Math.pow(2,t/12);return Math.max(30,Math.min(N,a))}(a)),t("osc_freq",Math.round(10*a)/10)},style:{width:"120px",accentColor:"#10b981"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px",fontWeight:"500",minWidth:"120px"}},(n.params.osc_freq||60).toFixed(1),"Hz (",F(n.params.osc_freq||60),")")),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#10b981",fontSize:"12px",fontWeight:"600",minWidth:"70px"}},"Distortion:"),a.createElement("input",{type:"range",min:"0",max:"10",step:"0.1",value:n.params.osc_distortion||0,onChange:function(e){return t("osc_distortion",parseFloat(e.target.value))},style:{width:"120px",accentColor:"#10b981"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px",fontWeight:"500",minWidth:"40px"}},(n.params.osc_distortion||0).toFixed(1))),"pitch"===M&&a.createElement(a.Fragment,null,"oscillator"===l&&a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px",padding:"4px",backgroundColor:"rgba(59, 130, 246, 0.1)",borderRadius:"4px",position:"relative",zIndex:10}},a.createElement("label",{style:{color:"#3b82f6",fontSize:"12px",fontWeight:"600",minWidth:"80px"}},"Pitch Range:"),a.createElement("input",{type:"range",min:"1",max:"24",step:"1",value:n.params.osc_pitch_amount||12,onChange:function(e){console.log("OSC PITCH AMOUNT CHANGE:",e.target.value),t("osc_pitch_amount",parseInt(e.target.value))},style:{width:"120px",accentColor:"#3b82f6",cursor:"pointer",height:"20px",pointerEvents:"auto"}}),a.createElement("span",{style:{color:"#3b82f6",fontSize:"11px",fontWeight:"500",minWidth:"120px"}},"",n.params.osc_pitch_amount||12," semitones")),"sample"===l&&a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#3b82f6",fontSize:"12px",fontWeight:"600",minWidth:"80px"}},"Pitch Range:"),a.createElement("input",{type:"range",min:"1",max:"24",step:"1",value:n.params.sample_pitch_amount||12,onChange:function(e){return t("sample_pitch_amount",parseInt(e.target.value))},style:{width:"120px",accentColor:"#3b82f6"}}),a.createElement("span",{style:{color:"#3b82f6",fontSize:"11px",fontWeight:"500",minWidth:"120px"}},"",n.params.sample_pitch_amount||12," semitones")),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px",width:"100%"}},a.createElement("label",{style:{color:"#3b82f6",fontSize:"12px",fontWeight:"600",minWidth:"70px"}},"End Freq:"),a.createElement("span",{style:{color:"#3b82f6",fontSize:"11px",minWidth:"120px",fontWeight:"500"}},Math.round((n.params.osc_freq||60)*Math.pow(2,0*(n.params.osc_pitch_amount||12)/12)),"Hz (",F(Math.round((n.params.osc_freq||60)*Math.pow(2,0*(n.params.osc_pitch_amount||12)/12))),")"),a.createElement("span",{style:{color:"#94a3b8",fontSize:"10px"}}," Max: ",Math.round((n.params.osc_freq||60)*Math.pow(2,1*(n.params.osc_pitch_amount||12)/12)),"Hz (",F(Math.round((n.params.osc_freq||60)*Math.pow(2,1*(n.params.osc_pitch_amount||12)/12))),")")))),"noise"===l&&a.createElement("div",{style:{display:"flex",flexWrap:"wrap",gap:"16px",alignItems:"center",border:"1px solid #334155",borderRadius:"6px",padding:"12px",backgroundColor:"#0c1428"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#f59e0b",fontSize:"12px",fontWeight:"600",minWidth:"50px"}},"Type:"),a.createElement("select",{value:n.params.noise_type||"white",onChange:function(e){return t("noise_type",e.target.value)},style:{padding:"6px 8px",borderRadius:"4px",border:"1px solid #f59e0b",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px",minWidth:"100px"}},a.createElement("option",{value:"white"},"White"),a.createElement("option",{value:"pink"},"Pink"),a.createElement("option",{value:"brown"},"Brown"))),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#f59e0b",fontSize:"12px",fontWeight:"600",minWidth:"50px"}},"Filter:"),a.createElement("input",{type:"range",min:"100",max:"8000",step:"100",value:n.params.noise_filter||2e3,onChange:function(e){return t("noise_filter",parseInt(e.target.value))},style:{width:"120px",accentColor:"#f59e0b"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px",fontWeight:"500",minWidth:"80px"}},n.params.noise_filter||2e3,"Hz"))),"sample"===l&&a.createElement("div",{style:{display:"flex",flexWrap:"wrap",gap:"16px",alignItems:"center",border:"1px solid #334155",borderRadius:"6px",padding:"12px",backgroundColor:"#0c1428"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#8b5cf6",fontSize:"12px",fontWeight:"600"}},"File:"),a.createElement("input",{ref:_,type:"file",accept:".wav,.mp3,.ogg,.flac,.aac",onChange:W,style:{fontSize:"12px",color:"#cbd5e1",backgroundColor:"#0f172a",border:"1px solid #8b5cf6",borderRadius:"4px",padding:"6px 8px"}})),x&&a.createElement("div",{style:{color:"#8b5cf6",fontSize:"11px",fontWeight:"500"}},"Loaded: ",(x.duration||0).toFixed(2),"s @ ",x.sampleRate,"Hz"),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"4px",cursor:"pointer"}},a.createElement("input",{type:"checkbox",checked:n.params.sample_pitch_enabled||!1,onChange:function(e){return t("sample_pitch_enabled",e.target.checked)},style:{accentColor:"#8b5cf6"}}),a.createElement("span",{style:{color:"#8b5cf6",fontSize:"12px",fontWeight:"500"}},"Enable Pitch Envelope")))),a.createElement("div",{style:{display:"flex",flexWrap:"wrap",gap:"16px",alignItems:"center",border:"1px solid #334155",borderRadius:"6px",padding:"12px",backgroundColor:"#0c1428",width:"100%"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:{oscillator:"#10b981",noise:"#f59e0b",sample:"#8b5cf6"}[l],fontSize:"12px",fontWeight:"600",minWidth:"80px"}},"Duration:"),"oscillator"===l&&a.createElement(a.Fragment,null,a.createElement("input",{type:"range",min:"0.1",max:"2.0",step:"0.01",value:n.params.osc_time||.8,onChange:function(e){return t("osc_time",parseFloat(e.target.value))},style:{width:"120px",accentColor:"#10b981"}}),a.createElement("span",{style:{color:"#10b981",fontSize:"11px",fontWeight:"500",minWidth:"60px"}},(n.params.osc_time||.8).toFixed(2),"s")),"noise"===l&&a.createElement(a.Fragment,null,a.createElement("input",{type:"range",min:"0.05",max:"0.5",step:"0.005",value:n.params.noise_time||.15,onChange:function(e){return t("noise_time",parseFloat(e.target.value))},style:{width:"120px",accentColor:"#f59e0b"}}),a.createElement("span",{style:{color:"#f59e0b",fontSize:"11px",fontWeight:"500",minWidth:"60px"}},Math.round(1e3*(n.params.noise_time||.15)),"ms")),"sample"===l&&a.createElement(a.Fragment,null,a.createElement("input",{type:"range",min:"0.2",max:"3.0",step:"0.01",value:n.params.sample_time||1.2,onChange:function(e){return t("sample_time",parseFloat(e.target.value))},style:{width:"120px",accentColor:"#8b5cf6"}}),a.createElement("span",{style:{color:"#8b5cf6",fontSize:"11px",fontWeight:"500",minWidth:"60px"}},(n.params.sample_time||1.2).toFixed(2),"s"))),a.createElement("div",{style:{color:"#6b7280",fontSize:"10px",fontStyle:"italic"}},"Controls the overall duration of the ",l," layer"))))):a.createElement("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(0, 0, 0, 0.9)",zIndex:2e3,display:"flex",alignItems:"center",justifyContent:"center"}},a.createElement("div",{style:{backgroundColor:"#0c1428",border:"1px solid #1f2937",borderRadius:"12px",width:"95vw",height:"90vh",padding:"20px",display:"flex",flexDirection:"column",overflow:"auto"}},a.createElement("div",{style:{display:"flex",alignItems:"center",justifyContent:"space-between",marginBottom:"20px",paddingBottom:"12px",borderBottom:"1px solid #334155"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"20px"}},a.createElement("h2",{style:{color:"#22c55e",fontWeight:"bold",fontSize:"24px",margin:0}}," Waveform + Envelope Editor"),a.createElement("div",{style:{display:"flex",gap:"2px",border:"1px solid #374151",borderRadius:"6px",overflow:"hidden"}},["oscillator","noise","sample"].map(function(e){return a.createElement("button",{key:e,onClick:function(){return s(e)},style:{padding:"8px 16px",background:l===e?{oscillator:"#10b981",noise:"#f59e0b",sample:"#8b5cf6"}[e]:"#374151",color:l===e?"#000":"#cbd5e1",border:"none",fontSize:"14px",fontWeight:"700",cursor:"pointer",textTransform:"capitalize"}},e)})),"sample"===l&&a.createElement("div",{style:{display:"flex",gap:"8px",alignItems:"center"}},a.createElement("input",{ref:_,type:"file",accept:".wav,.mp3,.ogg,.flac,.aac",onChange:W,style:{display:"none"}}),a.createElement("button",{onClick:function(){var e;return null===(e=_.current)||void 0===e?void 0:e.click()},disabled:I,style:{padding:"6px 12px",background:I?"#6b7280":"#8b5cf6",color:"#fff",border:"none",borderRadius:"4px",fontSize:"12px",fontWeight:"600",cursor:I?"not-allowed":"pointer"}},I?" Loading...":" Load Audio File"),x&&a.createElement("span",{style:{color:"#8b5cf6",fontSize:"12px"}}," ",x.duration.toFixed(1),"s @ ",x.sampleRate,"Hz"))),a.createElement("button",{onClick:o,style:{background:"#dc2626",color:"#fff",border:"none",borderRadius:"6px",padding:"8px 16px",cursor:"pointer",fontSize:"14px",fontWeight:"700"}},"Close Editor")),a.createElement("div",{style:{flex:1,display:"flex",justifyContent:"center",alignItems:"center"}},a.createElement("canvas",{ref:m,width:800,height:400,onMouseDown:$,onMouseMove:X,onMouseUp:Z,onMouseLeave:Z,onDragOver:H,onDrop:V,style:{border:"sample"!==l||x?"2px solid #374151":"2px dashed #8b5cf6",borderRadius:"8px",backgroundColor:"#0f172a",maxWidth:"100%",maxHeight:"100%",cursor:h?"grabbing":"grab"}})),a.createElement("div",{style:{marginTop:"20px",padding:"16px",background:"#111827",borderRadius:"8px",fontSize:"12px",color:"#94a3b8"}},a.createElement("strong",null,"Legend:"),a.createElement("span",{style:{color:"#4b5563",marginLeft:"12px"}}," Original Waveform"),a.createElement("span",{style:{color:{oscillator:"#10b981",noise:"#f59e0b",sample:"#8b5cf6"}[l],marginLeft:"12px"}}," Enveloped Waveform"),a.createElement("span",{style:{color:"#ef4444",marginLeft:"12px"}}," Envelope Shape"))))};function cn(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,c,r,i=[],l=!0,s=!1;try{if(c=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=c.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(r=t.return(),Object(r)!==r))return}finally{if(s)throw o}}return i}}(e,n)||function(e,n){if(e){if("string"==typeof e)return rn(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?rn(e,n):void 0}}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function rn(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}var ln=(0,a.createContext)(),sn=function(){var e=(0,a.useContext)(ln);if(!e)throw new Error("useTransfer must be used within a TransferProvider");return e},un=function(e){var n=e.children,t=cn((0,a.useState)([]),2),o=t[0],c=t[1],r=cn((0,a.useState)(null),2),i=r[0],l=r[1],s={transferQueue:o,setTransferQueue:c,currentTransfer:i,setCurrentTransfer:l,getOverallProgress:function(){if(0===o.length)return{current:0,total:0,percentage:0};var e=o.filter(function(e){return"completed"===e.status}).length,n=o.length,t=0,a=o.find(function(e){return"transferring"===e.status});a&&(t=a.progress/100);var c=(e+t)/n*100;return{current:e+(a?1:0),total:n,percentage:Math.min(100,Math.max(0,c)),currentFile:a?a.filename:null,currentFileProgress:a?a.progress:0}},hasActiveTransfers:function(){return o.some(function(e){return"transferring"===e.status||"queued"===e.status})}};return a.createElement(ln.Provider,{value:s},n)};function dn(e){return dn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},dn(e)}function pn(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function fn(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?pn(Object(t),!0).forEach(function(n){mn(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):pn(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function mn(e,n,t){return(n=function(e){var n=function(e){if("object"!=dn(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=dn(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==dn(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function _n(){var e,n,t="function"==typeof Symbol?Symbol:{},a=t.iterator||"@@iterator",o=t.toStringTag||"@@toStringTag";function c(t,a,o,c){var l=a&&a.prototype instanceof i?a:i,s=Object.create(l.prototype);return gn(s,"_invoke",function(t,a,o){var c,i,l,s=0,u=o||[],d=!1,p={p:0,n:0,v:e,a:f,f:f.bind(e,4),d:function(n,t){return c=n,i=0,l=e,p.n=t,r}};function f(t,a){for(i=t,l=a,n=0;!d&&s&&!o&&n<u.length;n++){var o,c=u[n],f=p.p,m=c[2];t>3?(o=m===a)&&(l=c[(i=c[4])?5:(i=3,3)],c[4]=c[5]=e):c[0]<=f&&((o=t<2&&f<c[1])?(i=0,p.v=a,p.n=c[1]):f<m&&(o=t<3||c[0]>a||a>m)&&(c[4]=t,c[5]=a,p.n=m,i=0))}if(o||t>1)return r;throw d=!0,a}return function(o,u,m){if(s>1)throw TypeError("Generator is already running");for(d&&1===u&&f(u,m),i=u,l=m;(n=i<2?e:l)||!d;){c||(i?i<3?(i>1&&(p.n=-1),f(i,l)):p.n=l:p.v=l);try{if(s=2,c){if(i||(o="next"),n=c[o]){if(!(n=n.call(c,l)))throw TypeError("iterator result is not an object");if(!n.done)return n;l=n.value,i<2&&(i=0)}else 1===i&&(n=c.return)&&n.call(c),i<2&&(l=TypeError("The iterator does not provide a '"+o+"' method"),i=1);c=e}else if((n=(d=p.n<0)?l:t.call(a,p))!==r)break}catch(n){c=e,i=1,l=n}finally{s=1}}return{value:n,done:d}}}(t,o,c),!0),s}var r={};function i(){}function l(){}function s(){}n=Object.getPrototypeOf;var u=[][a]?n(n([][a]())):(gn(n={},a,function(){return this}),n),d=s.prototype=i.prototype=Object.create(u);function p(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,s):(e.__proto__=s,gn(e,o,"GeneratorFunction")),e.prototype=Object.create(d),e}return l.prototype=s,gn(d,"constructor",s),gn(s,"constructor",l),l.displayName="GeneratorFunction",gn(s,o,"GeneratorFunction"),gn(d),gn(d,o,"Generator"),gn(d,a,function(){return this}),gn(d,"toString",function(){return"[object Generator]"}),(_n=function(){return{w:c,m:p}})()}function gn(e,n,t,a){var o=Object.defineProperty;try{o({},"",{})}catch(e){o=0}gn=function(e,n,t,a){function c(n,t){gn(e,n,function(e){return this._invoke(n,t,e)})}n?o?o(e,n,{value:t,enumerable:!a,configurable:!a,writable:!a}):e[n]=t:(c("next",0),c("throw",1),c("return",2))},gn(e,n,t,a)}function hn(e,n,t,a,o,c,r){try{var i=e[c](r),l=i.value}catch(e){return void t(e)}i.done?n(l):Promise.resolve(l).then(a,o)}function vn(e){return function(){var n=this,t=arguments;return new Promise(function(a,o){var c=e.apply(n,t);function r(e){hn(c,a,o,r,i,"next",e)}function i(e){hn(c,a,o,r,i,"throw",e)}r(void 0)})}}function bn(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,c,r,i=[],l=!0,s=!1;try{if(c=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=c.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(r=t.return(),Object(r)!==r))return}finally{if(s)throw o}}return i}}(e,n)||function(e,n){if(e){if("string"==typeof e)return yn(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?yn(e,n):void 0}}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function yn(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}function kn(e){var n,t,a,o=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,a=Symbol.iterator);o--;){if(t&&null!=(n=e[t]))return n.call(e);if(a&&null!=(n=e[a]))return new xn(n.call(e));t="@@asyncIterator",a="@@iterator"}throw new TypeError("Object is not async iterable")}function xn(e){function n(e){if(Object(e)!==e)return Promise.reject(new TypeError(e+" is not an object."));var n=e.done;return Promise.resolve(e.value).then(function(e){return{value:e,done:n}})}return xn=function(e){this.s=e,this.n=e.next},xn.prototype={s:null,n:null,next:function(){return n(this.n.apply(this.s,arguments))},return:function(e){var t=this.s.return;return void 0===t?Promise.resolve({value:e,done:!0}):n(t.apply(this.s,arguments))},throw:function(e){var t=this.s.return;return void 0===t?Promise.reject(e):n(t.apply(this.s,arguments))}},new xn(e)}const Sn=function(e){var n=e.module,t=e.onUpdateParam,o=e.onClose,c=(e.modules,(0,a.useRef)()),r=(0,a.useRef)(),i=bn((0,a.useState)(null),2),l=i[0],s=i[1],u=bn((0,a.useState)(null),2),d=u[0],p=u[1],f=bn((0,a.useState)(!1),2),m=(f[0],f[1],bn((0,a.useState)(0),2)),_=m[0],g=m[1],h=bn((0,a.useState)(!1),2),v=h[0],b=h[1],y=bn((0,a.useState)(.2),2),k=y[0],x=y[1],S=bn((0,a.useState)(.8),2),E=S[0],P=S[1],w=bn((0,a.useState)(0),2),C=w[0],I=w[1],R=bn((0,a.useState)(0),2),L=R[0],M=R[1],D=bn((0,a.useState)(1),2),A=D[0],O=D[1],B=bn((0,a.useState)(44100),2),T=B[0],F=B[1],N=bn((0,a.useState)(null),2),z=N[0],G=N[1],q=bn((0,a.useState)(0),2),U=(q[0],q[1]),W=bn((0,a.useState)(0),2),V=W[0],H=W[1],j=bn((0,a.useState)(0),2),K=j[0],Y=j[1],$=bn((0,a.useState)(60),2),X=$[0],Z=$[1],Q=bn((0,a.useState)(1),2),J=Q[0],ee=(Q[1],bn((0,a.useState)(1),2)),ne=ee[0],te=ee[1],ae=bn((0,a.useState)(0),2),oe=ae[0],ce=ae[1],re=bn((0,a.useState)(.8),1)[0],ie=bn((0,a.useState)("normal"),2),le=ie[0],se=ie[1],ue=bn((0,a.useState)("manual"),2),de=ue[0],pe=ue[1],fe=bn((0,a.useState)("stopped"),2),me=fe[0],_e=fe[1],ge=bn((0,a.useState)(null),2),he=ge[0],ve=ge[1],be=bn((0,a.useState)("disconnected"),2),ye=be[0],ke=be[1],xe=bn((0,a.useState)(null),2),Se=xe[0],Ee=xe[1],Pe=sn(),we=Pe.transferQueue,Ce=Pe.setTransferQueue,Ie=bn((0,a.useState)([]),2),Re=Ie[0],Le=Ie[1],Me=bn((0,a.useState)(null),2),De=Me[0],Ae=Me[1],Oe=(0,a.useRef)(null),Be=bn((0,a.useState)(0),2),Te=Be[0],Fe=(Be[1],bn((0,a.useState)(""),2));Fe[0],Fe[1],(0,a.useEffect)(function(){console.log("useEffect triggered - localTransferQueue.length:",Re.length,"localCurrentTransfer:",De),Re.length>0&&!De?(console.log("useEffect: Local queue has items and no current transfer, processing queue..."),Wn()):console.log("useEffect: Not processing local queue - length:",Re.length,"localCurrentTransfer:",!!De)},[Re,De]),(0,a.useEffect)(function(){console.log("localCurrentTransfer changed to:",De)},[De]);var Ne=bn((0,a.useState)(null),2),ze=Ne[0],Ge=Ne[1],qe=bn((0,a.useState)("not_connected"),2),Ue=qe[0],We=qe[1],Ve=bn((0,a.useState)(1),2),He=Ve[0],je=Ve[1],Ke=bn((0,a.useState)(!1),2),Ye=(Ke[0],Ke[1],bn((0,a.useState)("oscillator"),2)),$e=Ye[0],Xe=Ye[1],Ze=bn((0,a.useState)(null),2),Qe=(Ze[0],Ze[1],bn((0,a.useState)(0),2)),Je=(Qe[0],Qe[1],bn((0,a.useState)(0),2)),en=(Je[0],Je[1],bn((0,a.useState)({osc_level:n.params.osc_level||.7,noise_level:n.params.noise_level||.3,sample_level:n.params.sample_level||0,osc_mute:n.params.osc_mute||!1,noise_mute:n.params.noise_mute||!1,sample_mute:n.params.sample_mute||!1}),2)),nn=en[0],tn=en[1],an=bn((0,a.useState)(!1),2),cn=an[0],rn=an[1],ln=bn((0,a.useState)(0),2),un=ln[0],dn=ln[1],pn=bn((0,a.useState)(0),2),gn=pn[0],hn=pn[1],yn=(0,a.useRef)(null),xn=(0,a.useRef)([]),Sn=(0,a.useRef)(null),En=(0,a.useRef)(null),Pn=(0,a.useRef)(null);(0,a.useEffect)(function(){tn({osc_level:n.params.osc_level||.7,noise_level:n.params.noise_level||.3,sample_level:n.params.sample_level||0,osc_mute:n.params.osc_mute||!1,noise_mute:n.params.noise_mute||!1,sample_mute:n.params.sample_mute||!1})},[n.params.osc_level,n.params.noise_level,n.params.sample_level,n.params.osc_mute,n.params.noise_mute,n.params.sample_mute]);var wn=(0,a.useCallback)(function(e,a){try{t.length>=3&&void 0!==(null==n?void 0:n.id)?(console.log(" Sending param with 3-arg signature:",n.id,e,a),t(n.id,e,a)):(console.log(" Sending param with 2-arg signature:",e,a),t(e,a))}catch(n){console.warn(" Error sending param, falling back to 2-arg:",n),t(e,a)}},[t,null==n?void 0:n.id]),Cn=bn((0,a.useState)(null),2),In=Cn[0],Rn=Cn[1],Ln=bn((0,a.useState)(null),2),Mn=Ln[0],Dn=Ln[1],An=bn((0,a.useState)(null),2),On=An[0],Bn=An[1];(0,a.useEffect)(function(){l&&Tn(l)},[ne,oe,l,k,E,C,L,_,me,z]);var Tn=function(e){var n=c.current;if(n&&e){var t=n.getContext("2d"),a=n.width,o=n.height;t.clearRect(0,0,a,o),t.fillStyle="#0b1220",t.fillRect(0,0,a,o);var r=e.getChannelData?e.getChannelData(0):e,i=r.length,l=Math.floor(i/ne),s=Math.floor(oe*(i-l)),u=Math.max(0,s),d=Math.min(i,u+l),p=d-u,f=Math.max(1,Math.floor(p/a));if(t.strokeStyle="#10b981",t.lineWidth=1,f>1){t.fillStyle="#10b981";for(var m=0;m<a;m++){for(var g=u+Math.floor(m*f),h=Math.min(d,u+Math.floor((m+1)*f)),v=0,b=0,y=g;y<h;y++)y<r.length&&(v=Math.min(v,r[y]),b=Math.max(b,r[y]));var x=o/2-v*o*re*.45,S=o/2-b*o*re*.45;t.fillRect(m,Math.min(x,S),1,Math.abs(S-x)||1)}}else{t.beginPath();for(var P=0;P<a;P++){var w=u+Math.floor(P*f);if(w<r.length){var I=o/2-r[w]*o*re*.45;0===P?t.moveTo(P,I):t.lineTo(P,I)}}t.stroke()}var R=u/i,M=d/i,D=M-R,A=(k-R)/D*a,O=(E-R)/D*a;if(A<a&&O>0&&A<O){var B=Math.max(0,A),T=Math.min(a,O);t.fillStyle="rgba(34, 197, 94, 0.1)",t.fillRect(B,0,T-B,o)}if(A>=-20&&A<=a+20){t.strokeStyle="loopStart"===z?"#34d399":"#22c55e",t.lineWidth="loopStart"===z?4:2,t.beginPath(),t.moveTo(A,0),t.lineTo(A,o),t.stroke();t.fillStyle="loopStart"===z?"#34d399":"#22c55e",t.fillRect(A-8,0,16,18),t.strokeStyle="#000000",t.lineWidth=2,t.strokeRect(A-8,0,16,18),t.strokeStyle="#ffffff",t.lineWidth=1,t.strokeRect(A-8+1,1,14,16),t.fillStyle="#000000",t.font="bold 12px monospace",t.textAlign="center",t.fillText("S",A,13)}if(O>=-20&&O<=a+20){t.strokeStyle="loopEnd"===z?"#f87171":"#dc2626",t.lineWidth="loopEnd"===z?4:2,t.beginPath(),t.moveTo(O,0),t.lineTo(O,o),t.stroke();t.fillStyle="loopEnd"===z?"#f87171":"#dc2626",t.fillRect(O-8,0,16,18),t.strokeStyle="#000000",t.lineWidth=2,t.strokeRect(O-8,0,16,18),t.strokeStyle="#ffffff",t.lineWidth=1,t.strokeRect(O-8+1,1,14,16),t.fillStyle="#000000",t.font="bold 12px monospace",t.textAlign="center",t.fillText("E",O,13)}var F=E-k,N=k+C*F,G=E-L*F;if(C>0&&N>=R&&k<=M){var q=Math.max(0,(k-R)/D*a),U=Math.min(a,(N-R)/D*a);U>q&&(t.fillStyle="rgba(34, 197, 94, 0.2)",t.fillRect(q,0,U-q,o))}if(L>0&&G<=M&&E>=R){var W=Math.max(0,(G-R)/D*a),V=Math.min(a,(E-R)/D*a);V>W&&(t.fillStyle="rgba(239, 68, 68, 0.2)",t.fillRect(W,0,V-W,o))}if("playing"===me&&_>=R&&_<=M){var H=(_-R)/D*a;t.strokeStyle="#f59e0b",t.lineWidth=3,t.beginPath(),t.moveTo(H,0),t.lineTo(H,o),t.stroke()}}},Fn=function(e){console.log("Processing file:",e.name,"Type:",e.type,"Size:",e.size);var n=new FileReader;n.onload=function(){var n=vn(_n().m(function n(t){var a,o,c,r,i,l,u;return _n().w(function(n){for(;;)switch(n.p=n.n){case 0:if(n.p=0,(a=In)&&"closed"!==a.state||(a=new(window.AudioContext||window.webkitAudioContext),Rn(a)),"suspended"!==a.state){n.n=1;break}return n.n=1,a.resume();case 1:return o=t.target.result,console.log("ArrayBuffer size:",o.byteLength),n.n=2,a.decodeAudioData(o);case 2:c=n.v,console.log("Decoded buffer:",{duration:c.duration,sampleRate:c.sampleRate,numberOfChannels:c.numberOfChannels,length:c.length}),p(c),r=c.getChannelData(0),i=new Float32Array(r),s(i),x(.2),P(.8),g(.2),(l=a.createGain()).connect(a.destination),Bn(l),F(c.sampleRate),wn("sample_name",e.name.replace(/\.[^/.]+$/,"")),console.log("File processed successfully"),n.n=4;break;case 3:n.p=3,u=n.v,console.error("Failed to decode audio file:",u),alert("Failed to load audio file: ".concat(e.name,"\n\nError: ").concat(u.message,"\n\nPlease try a different file format (WAV, MP3, or OGG)."));case 4:return n.a(2)}},n,null,[[0,3]])}));return function(e){return n.apply(this,arguments)}}(),n.readAsArrayBuffer(e)},Nn=function(){var e=vn(_n().m(function e(){var n,t,a,o,c,r,i,l,s;return _n().w(function(e){for(;;)switch(e.p=e.n){case 0:return e.p=0,e.n=1,navigator.mediaDevices.getUserMedia({audio:{sampleRate:44100,channelCount:1,echoCancellation:!1,noiseSuppression:!1,autoGainControl:!1}});case 1:n=e.v,Pn.current=n,t=new(window.AudioContext||window.webkitAudioContext),a=t.createAnalyser(),o=t.createMediaStreamSource(n),a.fftSize=256,o.connect(a),En.current={analyser:a,audioCtx:t},c=function(){if(cn){var e=new Uint8Array(a.frequencyBinCount);a.getByteTimeDomainData(e);for(var n=0,t=0;t<e.length;t++){var o=Math.abs((e[t]-128)/128);o>n&&(n=o)}hn(n),requestAnimationFrame(c)}},r=MediaRecorder.isTypeSupported("audio/webm;codecs=opus")?"audio/webm;codecs=opus":"audio/webm",i=new MediaRecorder(n,{mimeType:r}),xn.current=[],i.ondataavailable=function(e){e.data.size>0&&xn.current.push(e.data)},i.onstop=vn(_n().m(function e(){var t,a;return _n().w(function(e){for(;;)switch(e.p=e.n){case 0:return n.getTracks().forEach(function(e){return e.stop()}),t=new Blob(xn.current,{type:r}),e.p=1,e.n=2,zn(t);case 2:e.n=4;break;case 3:e.p=3,a=e.v,console.error("Failed to convert recording:",a),alert("Failed to process recording. Please try again.");case 4:En.current&&(En.current.audioCtx.close(),En.current=null),Pn.current=null,hn(0),dn(0),Sn.current&&(clearInterval(Sn.current),Sn.current=null);case 5:return e.a(2)}},e,null,[[1,3]])})),yn.current=i,i.start(),rn(!0),l=Date.now(),Sn.current=setInterval(function(){dn((Date.now()-l)/1e3)},100),c(),e.n=3;break;case 2:e.p=2,s=e.v,console.error("Failed to start recording:",s),alert("Failed to access microphone.\n\nError: ".concat(s.message,"\n\nPlease grant microphone permissions."));case 3:return e.a(2)}},e,null,[[0,2]])}));return function(){return e.apply(this,arguments)}}(),zn=function(){var e=vn(_n().m(function e(n){var a,o,c,r,i,l,u,d,f,m,_,g,h,v,b,y,k,x;return _n().w(function(e){for(;;)switch(e.n){case 0:return e.n=1,n.arrayBuffer();case 1:return a=e.v,e.n=2,In.decodeAudioData(a);case 2:if(o=e.v,c=44100,r=Math.floor(o.duration*c),i=In.createBuffer(1,r,c),l=i.getChannelData(0),1===o.numberOfChannels)for(u=o.getChannelData(0),d=o.sampleRate/c,f=0;f<r;f++)m=Math.floor(f*d),l[f]=u[Math.min(m,u.length-1)];else for(_=o.getChannelData(0),g=o.getChannelData(1),h=o.sampleRate/c,v=0;v<r;v++)b=Math.floor(v*h),y=Math.min(b,_.length-1),l[v]=(_[y]+g[y])/2;s(i),p(i),k=(new Date).toISOString().slice(11,19).replace(/:/g,"-"),x="recorded_".concat(k,".wav"),t("sample_name",x),console.log("Recording converted: ".concat(r," samples, ").concat(c,"Hz, mono")),alert("Recording captured!\n\nDuration: ".concat(o.duration.toFixed(1),"s\nName: ").concat(x,"\n\nYou can now edit and save to SD card."));case 3:return e.a(2)}},e)}));return function(n){return e.apply(this,arguments)}}(),Gn=function(){var e=vn(_n().m(function e(){var n,t,a,o,c,r,i,l,s,u,p,f;return _n().w(function(e){for(;;)switch(e.p=e.n){case 0:if(d&&In){e.n=1;break}return console.warn("No audio buffer or context available"),d||alert("Please load an audio file first."),e.a(2);case 1:if("playing"!==me){e.n=2;break}if(Mn){try{Mn.stop()}catch(e){console.warn("Error stopping audio source:",e)}Dn(null)}return he&&(clearInterval(he),ve(null)),_e("stopped"),e.a(2);case 2:if(e.p=2,"suspended"!==In.state){e.n=4;break}return e.n=3,In.resume();case 3:console.log("Audio context resumed");case 4:n=d,t=100*V+K,a=Math.pow(2,t/1200)*J,console.log("Starting playback with:",{pitchRatio:a,loopStart:k,loopEnd:E,playbackMode:le,volume:A,bufferDuration:n.duration}),(o=In.createBufferSource()).buffer=n,o.playbackRate.value=a,(c=In.createGain()).gain.value=.5*A,Bn(c),o.connect(c),c.connect(In.destination),r=k*n.duration,i=E*n.duration,l=i-r,"loop"!==le&&"sustain"!==le||(o.loop=!0,o.loopStart=r,o.loopEnd=i,console.log("Loop enabled:",{startTime:r,endTime:i})),"loop"===le||"sustain"===le?o.start(0,r):o.start(0,r,l),Dn(o),_e("playing"),g("reverse"===le?E:k),s=Date.now(),u=E-k,p=setInterval(function(){var e=(Date.now()-s)/1e3;g(function(n){var t;if("reverse"===le){if((t=E-e*a/(i-r)*u)<=k)return"loop"===le||"sustain"===le?E:k}else if((t=k+e*a/(i-r)*u)>=E)return"loop"===le||"sustain"===le?k+(t-k)%u:E;return t})},50),ve(p),o.onended=function(){console.log("Playback ended"),_e("stopped"),g(k),p&&(clearInterval(p),ve(null)),Dn(null),Bn(null)},console.log("Playback started successfully"),e.n=6;break;case 5:e.p=5,f=e.v,console.error("Error playing audio:",f),alert("Could not play audio: ".concat(f.message,"\n\nPlease check that your browser supports Web Audio API and audio is not muted."));case 6:return e.a(2)}},e,null,[[2,5]])}));return function(){return e.apply(this,arguments)}}();(0,a.useEffect)(function(){"auto"===de&&(I(.1),M(.1))},[de,k,E]),(0,a.useEffect)(function(){if("playing"===me&&Mn&&In){var e=100*V+K,n=Math.pow(2,e/1200)*J;Mn.playbackRate.value=n,On&&(On.gain.value=.5*A),console.log("Updated real-time params:",{pitchRatio:n,volume:.5*A})}},[V,K,J,A,me,Mn,On,In]),(0,a.useEffect)(function(){if("playing"===me&&Mn&&d&&("loop"===le||"sustain"===le)){var e=k*d.duration,n=E*d.duration;Mn.loopStart=e,Mn.loopEnd=n,console.log("Updated loop points in real-time:",{loopStart:e,loopEnd:n})}},[k,E,me,Mn,d,le]),(0,a.useEffect)(function(){return function(){he&&clearInterval(he)}},[he]);var qn=function(){if(!l)return null;var e=l;if(0!==V||0!==K||1!==J){var n=100*V+K,t=Math.pow(2,n/1200)*J,a=Math.floor(l.length/t);e=new Float32Array(a);for(var o=0;o<a;o++){var c=o*t,r=Math.floor(c),i=Math.min(r+1,l.length-1),s=c-r;e[o]=l[r]*(1-s)+l[i]*s}}1!==A&&(e=e.map(function(e){return e*A}));for(var u=0;u<e.length;u++){var d=u/e.length,p=1;C>0&&d<C&&(p*=d/C),L>0&&d>1-L&&(p*=(1-d)/L),e[u]*=p}var f=e.length,m=1*T*2,_=2*f,g=44+_,h=new ArrayBuffer(g),v=new DataView(h),b=function(e,n){for(var t=0;t<n.length;t++)v.setUint8(e+t,n.charCodeAt(t))};b(0,"RIFF"),v.setUint32(4,g-8,!0),b(8,"WAVE"),b(12,"fmt "),v.setUint32(16,16,!0),v.setUint16(20,1,!0),v.setUint16(22,1,!0),v.setUint32(24,T,!0),v.setUint32(28,m,!0),v.setUint16(32,2,!0),v.setUint16(34,16,!0),b(36,"data"),v.setUint32(40,_,!0);for(var y=44,k=0;k<f;k++){var x=e[k];x=Math.max(-1,Math.min(1,x)),x*=32767,v.setInt16(y,x,!0),y+=2}return h},Un=function(){var e=vn(_n().m(function e(){var n;return _n().w(function(e){for(;;)switch(e.p=e.n){case 0:if(!Se){e.n=5;break}return e.p=1,e.n=2,Se.close();case 2:e.n=4;break;case 3:e.p=3,n=e.v,console.error("Error closing serial port:",n);case 4:Ee(null);case 5:ke("disconnected");case 6:return e.a(2)}},e,null,[[1,3]])}));return function(){return e.apply(this,arguments)}}(),Wn=function(){var e=vn(_n().m(function e(){var n,t,a,o;return _n().w(function(e){for(;;)switch(e.p=e.n){case 0:if(console.log("processLocalTransferQueue called - queue length:",Re.length,"localCurrentTransfer:",De),0!==Re.length&&!De){e.n=1;break}return console.log("Local queue empty or transfer in progress, returning"),e.a(2);case 1:return n=Re[0],console.log("Processing local transfer:",n),console.log("Setting localCurrentTransfer and ref to:",n),Ae(n),Oe.current=n,e.p=2,ke("transferring"),t=Se.writable.getWriter(),a="SD:FILE:".concat(n.filename,":").concat(n.size,"\n"),console.log("Sending to ESP32:",a.trim()),e.n=3,t.write((new TextEncoder).encode(a));case 3:t.releaseLock(),e.n=5;break;case 4:e.p=4,o=e.v,console.error("Failed to start local transfer:",o),Ae(null),ke("synth");case 5:return e.a(2)}},e,null,[[2,4]])}));return function(){return e.apply(this,arguments)}}(),Vn=function(){var e=vn(_n().m(function e(){var n,t;return _n().w(function(e){for(;;)switch(e.p=e.n){case 0:if(!("showDirectoryPicker"in window)){e.n=6;break}return e.p=1,e.n=2,window.showDirectoryPicker({mode:"readwrite"});case 2:return n=e.v,Ge(n),We("connected"),console.log("SD card connected:",n.name),e.n=3,Hn(n);case 3:e.n=5;break;case 4:e.p=4,t=e.v,console.error("Failed to connect to SD card:",t),"AbortError"!==t.name&&alert("Failed to connect to SD card. Make sure you select the SD card root folder.");case 5:e.n=7;break;case 6:alert("Direct SD card access not supported in this browser. Please use Chrome/Edge with File System Access API.");case 7:return e.a(2)}},e,null,[[1,4]])}));return function(){return e.apply(this,arguments)}}(),Hn=function(){var e=vn(_n().m(function e(n){var t,a,o,c,r,i,l,s,u,d;return _n().w(function(e){for(;;)switch(e.p=e.n){case 0:e.p=0,t=!1,a=!1,e.p=1,c=kn(n.entries());case 2:return e.n=3,c.next();case 3:if(!(t=!(r=e.v).done)){e.n=5;break}i=bn(r.value,2),l=i[0],s=i[1],console.log("Found:",l,s.kind);case 4:t=!1,e.n=2;break;case 5:e.n=7;break;case 6:e.p=6,u=e.v,a=!0,o=u;case 7:if(e.p=7,e.p=8,!t||null==c.return){e.n=9;break}return e.n=9,c.return();case 9:if(e.p=9,!a){e.n=10;break}throw o;case 10:return e.f(9);case 11:return e.f(7);case 12:alert("SD card connected successfully!\nDirectory: ".concat(n.name,"\n\nYou can now save samples directly to the SD card.")),e.n=14;break;case 13:e.p=13,d=e.v,console.warn("Could not verify SD card structure:",d);case 14:return e.a(2)}},e,null,[[8,,9,11],[1,6,7,12],[0,13]])}));return function(n){return e.apply(this,arguments)}}(),jn=function(){var e=vn(_n().m(function e(){var t,a,o,c,r,i,s,u;return _n().w(function(e){for(;;)switch(e.p=e.n){case 0:if(l&&ze){e.n=3;break}if(ze){e.n=2;break}return e.n=1,Vn();case 1:return e.a(2);case 2:return alert("No audio loaded to save"),e.a(2);case 3:if(e.p=3,We("writing"),t=qn()){e.n=4;break}return alert("No audio data to save"),We("connected"),e.a(2);case 4:return a=n.params.sample_name||"sample",o=a.replace(/[^a-zA-Z0-9-_]/g,"_"),"SDPlayer"===n.type||"SamplePlayer"===n.type?(r=n.params.sample_number||1,c="sample".concat(r,".wav")):c="".concat(o,".wav"),e.n=5,ze.getFileHandle(c,{create:!0});case 5:return i=e.v,e.n=6,i.createWritable();case 6:return s=e.v,e.n=7,s.write(t);case 7:return e.n=8,s.close();case 8:We("connected"),alert(" Sample saved to SD card successfully!\n\nFile: ".concat(c,"\nSize: ").concat((t.byteLength/1024).toFixed(1)," KB\nFormat: 16-bit WAV at ").concat(T," Hz\n\nThe file is now ready to use with your ESP32 Sample Player module!")),e.n=10;break;case 9:e.p=9,u=e.v,console.error("Failed to save to SD card:",u),We("connected"),"NotAllowedError"===u.name?alert("Permission denied. Please grant write access to the SD card directory."):alert("Failed to save to SD card: ".concat(u.message));case 10:return e.a(2)}},e,null,[[3,9]])}));return function(){return e.apply(this,arguments)}}(),Kn=function(){var e=vn(_n().m(function e(){var t,a,o,c,r,i,l,s,u;return _n().w(function(e){for(;;)switch(e.p=e.n){case 0:if(t=qn()){e.n=1;break}return alert("No audio data to export"),e.a(2);case 1:if(a=(n.params.sample_name||"sample").replace(/[^a-zA-Z0-9-_]/g,"_"),o="".concat(a).concat(He,".wav"),!ze){e.n=9;break}return e.p=2,We("writing"),e.n=3,ze.getFileHandle(o,{create:!0});case 3:return c=e.v,e.n=4,c.createWritable();case 4:return r=e.v,e.n=5,r.write(t);case 5:return e.n=6,r.close();case 6:We("connected"),je(He+1),alert(" Exported to SD card!\n\nFile: ".concat(o,"\nSize: ").concat((t.byteLength/1024).toFixed(1)," KB\nNext export will be: ").concat(a).concat(He+1,".wav")),e.n=8;break;case 7:e.p=7,u=e.v,console.error("Failed to save to SD card:",u),We("connected"),"NotAllowedError"===u.name?alert("Permission denied. Please grant write access to the SD card folder."):alert("Failed to save to SD card: ".concat(u.message));case 8:e.n=10;break;case 9:i=new Blob([t],{type:"audio/wav"}),l=URL.createObjectURL(i),(s=document.createElement("a")).href=l,s.download=o,s.click(),URL.revokeObjectURL(l),je(He+1),console.log("Exported ".concat(o,". Next export will be: ").concat(a).concat(He+1,".wav"));case 10:return e.a(2)}},e,null,[[2,7]])}));return function(){return e.apply(this,arguments)}}();(0,a.useEffect)(function(){return function(){Un()}},[]);var Yn=function(){z&&$n(k,E),G(null),U(0)},$n=function(e,n){if(l){var t=Math.abs(n-e);if(t<.02&&t<1/ne*.1){var a=Math.min(20,1/(10*t));te(a);var o=(e+n)/2,c=1/a,r=Math.max(0,Math.min(1-c,o-c/2));ce(r)}}},Xn=["KickDrum","SnareDrum","Percussion"].includes(n.type),Zn=(0,a.useRef)({isDragging:!1,param:null,startY:0,startValue:0}),Qn=function(e,n,t,a){console.log(" SIMPLE Knob MouseDown:",n,t),e.preventDefault(),e.stopPropagation(),Zn.current={isDragging:!0,param:n,startY:e.clientY,startValue:t},console.log(" Set drag state:",Zn.current),a&&(Xe(a),console.log(" Set active layer to:",a)),console.log(" Adding global mouse listeners IMMEDIATELY"),document.addEventListener("mousemove",Jn),document.addEventListener("mouseup",et)},Jn=function(e){if(console.log(" SIMPLE MouseMove, isDragging:",Zn.current.isDragging),Zn.current.isDragging){var n=Zn.current.startY-e.clientY,t=.005*n,a=Math.max(0,Math.min(1,Zn.current.startValue+t));if(console.log(" SIMPLE MouseMove:",Zn.current.param,"deltaY:",n,"newValue:",a),"volume"===Zn.current.param)O(a),console.log(" Updated volume to:",a);else{var o=Zn.current.param;tn(function(e){return fn(fn({},e),{},mn({},o,a))}),wn(o,a),console.log(" Updated param",o,"to:",a)}}else console.log(" Not dragging, ignoring")},et=function(){console.log(" SIMPLE MouseUp, was dragging:",Zn.current.param),Zn.current={isDragging:!1,param:null,startY:0,startValue:0},console.log(" Removing global mouse listeners"),document.removeEventListener("mousemove",Jn),document.removeEventListener("mouseup",et)};return a.createElement("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(0, 0, 0, 1)",zIndex:2e3,display:"flex",alignItems:"center",justifyContent:"center"}},a.createElement("div",{style:{backgroundColor:"#0c1428",border:"1px solid #1f2937",borderRadius:"12px",width:"90vw",height:"85vh",maxWidth:"1200px",maxHeight:"800px",display:"flex",flexDirection:"column",overflow:"hidden"}},a.createElement("div",{style:{padding:"16px 24px",borderBottom:"1px solid #1f2937",display:"flex",justifyContent:"space-between",alignItems:"center"}},a.createElement("h2",{style:{margin:0,color:"#22c55e",fontSize:"18px"}},n.type," Sample Editor"),a.createElement("button",{className:"btn btn-ghost",onClick:o,style:{fontSize:"18px",padding:"4px 8px"}},"")),a.createElement("div",{style:{flex:1,display:"grid",gridTemplateColumns:Xn?"120px 1fr":"120px 1fr 250px",gap:"1px",backgroundColor:"#1f2937",minHeight:0}},a.createElement("div",{style:{backgroundColor:"#0c1428",padding:"16px",display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",gap:"20px",borderRight:"1px solid #334155"}},a.createElement("h3",{style:{color:"#e2e8f0",fontSize:"14px",marginBottom:"8px",textAlign:"center"}},"Layer Volumes"),Xn?a.createElement(a.Fragment,null,("KickDrum"===n.type||"SnareDrum"===n.type)&&a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("div",{style:{textAlign:"center"}},a.createElement("div",{style:{width:"60px",height:"60px",borderRadius:"50%",background:"conic-gradient(from 0deg, #334155 0deg, #22c55e "+270*nn.osc_level+"deg, #334155 "+270*nn.osc_level+"deg)",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",border:"oscillator"===$e?"3px solid #22c55e":"2px solid #1f2937",marginBottom:"8px",opacity:nn.osc_mute?.5:1},onMouseDown:function(e){return Qn(e,"osc_level",nn.osc_level,"oscillator")},onMouseEnter:function(){return console.log(" Mouse ENTERED oscillator knob")},onMouseLeave:function(){return console.log(" Mouse LEFT oscillator knob")},onClick:function(e){console.log(" Oscillator knob CLICKED",e);var n=nn.osc_level,t=Math.min(1,n+.1);console.log(" TEST: Updating osc_level from",n,"to",t),tn(function(e){return fn(fn({},e),{},{osc_level:t})}),wn("osc_level",t)}},a.createElement("div",{style:{width:"46px",height:"46px",borderRadius:"50%",backgroundColor:"#0f172a",display:"flex",alignItems:"center",justifyContent:"center",color:"#e2e8f0",fontSize:"10px",fontWeight:"bold"}},Math.round(100*nn.osc_level))),a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block"}},"KickDrum"===n.type?"Sub Osc":"Tone")),a.createElement("button",{style:{width:"24px",height:"24px",borderRadius:"4px",border:"none",backgroundColor:nn.osc_mute?"#dc2626":"#374151",color:nn.osc_mute?"#fff":"#9ca3af",fontSize:"10px",fontWeight:"bold",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center"},onClick:function(){var e=!nn.osc_mute;tn(function(n){return fn(fn({},n),{},{osc_mute:e})}),wn("osc_mute",e)},title:"Mute Oscillator Layer"},"M")),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("div",{style:{textAlign:"center"}},a.createElement("div",{style:{width:"60px",height:"60px",borderRadius:"50%",background:"conic-gradient(from 0deg, #334155 0deg, #f59e0b "+270*nn.noise_level+"deg, #334155 "+270*nn.noise_level+"deg)",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",border:"noise"===$e?"3px solid #f59e0b":"2px solid #1f2937",marginBottom:"8px",opacity:nn.noise_mute?.5:1},onMouseDown:function(e){return Qn(e,"noise_level",nn.noise_level,"noise")}},a.createElement("div",{style:{width:"46px",height:"46px",borderRadius:"50%",backgroundColor:"#0f172a",display:"flex",alignItems:"center",justifyContent:"center",color:"#e2e8f0",fontSize:"10px",fontWeight:"bold"}},Math.round(100*nn.noise_level))),a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block"}},"Noise")),a.createElement("button",{style:{width:"24px",height:"24px",borderRadius:"4px",border:"none",backgroundColor:nn.noise_mute?"#dc2626":"#374151",color:nn.noise_mute?"#fff":"#9ca3af",fontSize:"10px",fontWeight:"bold",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center"},onClick:function(){var e=!nn.noise_mute;tn(function(n){return fn(fn({},n),{},{noise_mute:e})}),wn("noise_mute",e)},title:"Mute Noise Layer"},"M")),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("div",{style:{textAlign:"center"}},a.createElement("div",{style:{width:"60px",height:"60px",borderRadius:"50%",background:"conic-gradient(from 0deg, #334155 0deg, #8b5cf6 "+270*nn.sample_level+"deg, #334155 "+270*nn.sample_level+"deg)",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",border:"sample"===$e?"3px solid #8b5cf6":"2px solid #1f2937",marginBottom:"8px",opacity:nn.sample_mute?.5:1},onMouseDown:function(e){return Qn(e,"sample_level",nn.sample_level,"sample")}},a.createElement("div",{style:{width:"46px",height:"46px",borderRadius:"50%",backgroundColor:"#0f172a",display:"flex",alignItems:"center",justifyContent:"center",color:"#e2e8f0",fontSize:"10px",fontWeight:"bold"}},Math.round(100*nn.sample_level))),a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block"}},"Sample")),a.createElement("button",{style:{width:"24px",height:"24px",borderRadius:"4px",border:"none",backgroundColor:nn.sample_mute?"#dc2626":"#374151",color:nn.sample_mute?"#fff":"#9ca3af",fontSize:"10px",fontWeight:"bold",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center"},onClick:function(){var e=!nn.sample_mute;tn(function(n){return fn(fn({},n),{},{sample_mute:e})}),wn("sample_mute",e)},title:"Mute Sample Layer"},"M"))):a.createElement("div",{style:{textAlign:"center"}},a.createElement("div",{style:{width:"60px",height:"60px",borderRadius:"50%",background:"conic-gradient(from 0deg, #334155 0deg, #22c55e "+270*A+"deg, #334155 "+270*A+"deg)",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",border:"2px solid #1f2937",marginBottom:"8px"},onMouseDown:function(e){return Qn(e,"volume",A)}},a.createElement("div",{style:{width:"46px",height:"46px",borderRadius:"50%",backgroundColor:"#0f172a",display:"flex",alignItems:"center",justifyContent:"center",color:"#e2e8f0",fontSize:"10px",fontWeight:"bold"}},Math.round(100*A))),a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block"}},"Volume"))),a.createElement("div",{style:{backgroundColor:"#0c1428",display:"flex",flexDirection:"column"}},a.createElement("div",{style:{padding:"12px",borderBottom:"1px solid #1f2937",display:"flex",justifyContent:"space-between",alignItems:"center"}},a.createElement("div",{style:{display:"flex",gap:"8px",alignItems:"center"}},!Xn&&a.createElement(a.Fragment,null,a.createElement("div",{style:{display:"flex",gap:"4px",alignItems:"center",marginRight:"12px"}},a.createElement("button",{className:"btn ".concat("playing"===me?"btn-amber":"btn-green"),onClick:Gn,disabled:!l,style:{fontSize:"11px",padding:"6px 12px",minWidth:"70px",fontWeight:"600"}},"playing"===me?" Pause":" Play")),a.createElement("div",{style:{display:"flex",gap:"4px",alignItems:"center",marginRight:"12px"}},a.createElement("span",{style:{color:"#cbd5e1",fontSize:"11px"}},"Mode:"),a.createElement("select",{value:le,onChange:function(e){return se(e.target.value)},style:{padding:"2px 4px",borderRadius:"4px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"11px"}},a.createElement("option",{value:"normal"},"Forward"),a.createElement("option",{value:"reverse"},"Reverse"),a.createElement("option",{value:"loop"},"Loop"),a.createElement("option",{value:"sustain"},"Sustain"))))),a.createElement("div",{style:{display:"flex",gap:"12px",alignItems:"center"}},!Xn&&a.createElement("div",{style:{display:"flex",gap:"8px",alignItems:"center"}},a.createElement("span",{style:{color:"#cbd5e1",fontSize:"12px"}},"Zoom:"),a.createElement("button",{className:"btn btn-ghost",onClick:function(){return te(function(e){return Math.max(.1,.5*e)})},style:{fontSize:"11px",padding:"2px 6px"}},"-"),a.createElement("span",{style:{color:"#e2e8f0",fontSize:"11px",minWidth:"40px",textAlign:"center"}},ne.toFixed(1),"x"),a.createElement("button",{className:"btn btn-ghost",onClick:function(){return te(function(e){return Math.min(10,2*e)})},style:{fontSize:"11px",padding:"2px 6px"}},"+")))),Xn?a.createElement("div",{style:{flex:1,padding:"12px"}},a.createElement(on,{module:n,onUpdateParam:wn,embedded:!0,activeLayer:$e,setActiveLayer:Xe})):a.createElement("div",{style:{flex:1,padding:"12px"},onDragOver:function(e){e.preventDefault(),e.stopPropagation(),b(!0)},onDragLeave:function(e){e.preventDefault(),e.stopPropagation(),b(!1)},onDrop:function(e){e.preventDefault(),e.stopPropagation(),b(!1);var n=Array.from(e.dataTransfer.files).find(function(e){return e.type.startsWith("audio/")||e.name.toLowerCase().endsWith(".wav")||e.name.toLowerCase().endsWith(".mp3")||e.name.toLowerCase().endsWith(".ogg")});n&&Fn(n)}},a.createElement("div",{style:{position:"relative",width:"100%",height:"100%",backgroundColor:v?"#1e293b":"#0b1220",border:"2px dashed ".concat(v?"#22c55e":"#334155"),borderRadius:"8px",display:"flex",alignItems:"center",justifyContent:"center",cursor:l?"crosshair":"pointer",transition:"all 0.2s ease"}},l?null:a.createElement("div",{style:{textAlign:"center",color:"#94a3b8",fontSize:"14px",userSelect:"none",pointerEvents:"none"}},v?a.createElement("div",null,a.createElement("div",{style:{fontSize:"24px",marginBottom:"8px"}},""),a.createElement("div",{style:{fontWeight:"600",color:"#22c55e"}},"Drop audio file here"),a.createElement("div",{style:{fontSize:"12px",marginTop:"4px"}},"Supports .wav, .mp3, .ogg")):a.createElement("div",null,a.createElement("div",{style:{fontSize:"32px",marginBottom:"12px",opacity:.5}},""),a.createElement("div",{style:{fontWeight:"600",marginBottom:"4px"}},"No sample loaded"),a.createElement("div",{style:{fontSize:"12px"}},"Click here to browse files"),a.createElement("div",{style:{fontSize:"12px",marginTop:"2px"}},"or drag & drop audio files"))),a.createElement("canvas",{ref:c,width:800,height:300,onMouseDown:function(e){if(console.log(" MOUSE DOWN EVENT:",{type:e.type,button:e.button,buttons:e.buttons,target:e.target.tagName,defaultPrevented:e.defaultPrevented}),l){var n=c.current,t=n.getBoundingClientRect(),a=n.width/t.width,o=(e.clientX-t.left)*a,i=o/n.width,s=l?l.getChannelData?l.getChannelData(0).length:l.length:0,u=Math.floor(s/ne),d=Math.floor(oe*(s-u)),p=d/s,f=(d+u)/s-p,m=(k-p)/f*n.width,_=(E-p)/f*n.width;if(console.log(" MARKER POSITIONS:"),console.log("  mouseX:",o),console.log("  loopStart:",k," loopStartX:",m,"(distance:",Math.abs(o-m),")"),console.log("  loopEnd:",E," loopEndX:",_,"(distance:",Math.abs(o-_),")"),console.log("  clickTolerance:",50),console.log("  startInRange:",Math.abs(o-m)<50),console.log("  endInRange:",Math.abs(o-_)<50),Math.abs(o-_)<50)return console.log(" END MARKER HIT! Setting drag state to loopEnd"),console.log(" Current isDragging state before:",z),G("loopEnd"),U(o),e.preventDefault(),e.stopPropagation(),console.log(" Event prevented and propagation stopped"),void setTimeout(function(){console.log(" isDragging state after timeout:",z)},0);if(Math.abs(o-m)<50)return console.log(" START MARKER HIT! Setting drag state to loopStart"),console.log(" Current isDragging state before:",z),G("loopStart"),U(o),e.preventDefault(),e.stopPropagation(),console.log(" Event prevented and propagation stopped"),void setTimeout(function(){console.log(" isDragging state after timeout:",z)},0);console.log(" No marker hit, normal click behavior");var h=p+i*f;if(e.shiftKey){var v=Math.max(h,k+.01);P(v),$n(k,v)}else if(e.ctrlKey){var b=Math.min(h,E-.01);x(b),$n(b,E)}else g(h)}else!l&&r.current&&r.current.click()},onMouseMove:function(e){if(z&&l){console.log(" Mouse move: isDragging =",z);var n=c.current,t=n.getBoundingClientRect(),a=n.width/t.width,o=(e.clientX-t.left)*a/n.width,r=l.getChannelData?l.getChannelData(0).length:l.length,i=Math.floor(r/ne),s=Math.floor(oe*(r-i)),u=s/r,d=(s+i)/r-u,p=Math.max(0,Math.min(1,u+o*d));if("loopStart"===z){var f=Math.min(p,E-.01);x(f)}else if("loopEnd"===z){var m=Math.max(p,k+.01);P(m)}e.preventDefault()}else z&&console.log(" Mouse move called but no audio buffer")},onMouseUp:Yn,onMouseLeave:Yn,onWheel:function(e){if(e.preventDefault(),e.ctrlKey){var n=e.deltaY>0?.5:2;te(function(e){return Math.max(.1,Math.min(50,e*n))})}else{var t=e.deltaY>0?.05:-.05;ce(function(e){return Math.max(0,Math.min(1,e+t))})}},style:{position:"absolute",width:"100%",height:"100%",cursor:l?z?"grabbing":"crosshair":"pointer",opacity:l?1:0}})))),a.createElement("div",{style:{backgroundColor:"#0c1428",padding:"16px",overflowY:"auto"}},!Xn&&a.createElement(a.Fragment,null,a.createElement("h3",{style:{color:"#e2e8f0",fontSize:"14px",marginBottom:"16px"}},"Sample Controls"),a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Load Sample"),a.createElement("div",{style:{display:"flex",gap:"8px"}},a.createElement("input",{ref:r,type:"file",accept:".wav,.mp3,.ogg",onChange:function(e){var n=e.target.files[0];n&&Fn(n)},style:{flex:1,padding:"6px",borderRadius:"8px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px"}}),a.createElement("button",{onClick:cn?function(){yn.current&&cn&&(yn.current.stop(),rn(!1))}:Nn,style:{padding:"6px 12px",borderRadius:"8px",border:"none",backgroundColor:cn?"#dc2626":"#22c55e",color:"white",fontSize:"12px",fontWeight:"500",cursor:"pointer",whiteSpace:"nowrap",transition:"all 0.2s"},onMouseEnter:function(e){e.target.style.opacity="0.8"},onMouseLeave:function(e){e.target.style.opacity="1"}},cn?" Stop":" Record")),cn&&a.createElement("div",{style:{marginTop:"8px",padding:"8px",borderRadius:"6px",backgroundColor:"#1e293b",border:"1px solid #dc2626"}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"6px"}},a.createElement("span",{style:{color:"#ef4444",fontSize:"11px",fontWeight:"600"}}," RECORDING"),a.createElement("span",{style:{color:"#cbd5e1",fontSize:"11px",fontFamily:"monospace"}},Math.floor(un/60),":",String(Math.floor(un%60)).padStart(2,"0"))),a.createElement("div",{style:{width:"100%",height:"4px",backgroundColor:"#0f172a",borderRadius:"2px",overflow:"hidden"}},a.createElement("div",{style:{width:"".concat(100*gn,"%"),height:"100%",backgroundColor:gn>.9?"#ef4444":gn>.7?"#f59e0b":"#22c55e",transition:"width 0.05s"}})))),a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Sample Name"),a.createElement("input",{type:"text",value:n.params.sample_name||"",onChange:function(e){return wn("sample_name",e.target.value)},placeholder:"Custom sample name",style:{width:"100%",padding:"6px",borderRadius:"8px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px"}})),("SDPlayer"===n.type||"SamplePlayer"===n.type)&&a.createElement(a.Fragment,null,a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Sample Number (for SDPlayer)"),a.createElement("input",{type:"number",min:"1",max:"32",value:n.params.sample_number||1,onChange:function(e){return wn("sample_number",parseInt(e.target.value)||1)},style:{width:"100%",padding:"6px",borderRadius:"8px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"Will save as: sample",n.params.sample_number||1,".wav")),a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Custom Suffix (optional)"),a.createElement("input",{type:"text",placeholder:"e.g. kick, snare, lead",value:n.params.custom_suffix||"",onChange:function(e){return wn("custom_suffix",e.target.value)},style:{width:"100%",padding:"6px",borderRadius:"8px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px"}}),a.createElement("div",{style:{color:"#64748b",fontSize:"10px",marginTop:"2px"}},"Preview: sample_",n.params.sample_number||1,"_",n.params.custom_suffix||"name",".wav"),a.createElement("div",{style:{color:"#64748b",fontSize:"10px",marginTop:"1px"}},Te>=1?" Next file will use session folder: session_[timestamp]":" Will save to root /samples/"))),a.createElement("h4",{style:{color:"#22c55e",fontSize:"12px",marginBottom:"8px",borderTop:"1px solid #334155",paddingTop:"8px"}}," Pitch Controls"),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Root Note (MIDI)"),a.createElement("select",{value:X,onChange:function(e){return Z(parseInt(e.target.value))},style:{width:"100%",padding:"6px",borderRadius:"8px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px"}},Array.from({length:128},function(e,n){var t=Math.floor(n/12)-1,o=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][n%12];return a.createElement("option",{key:n,value:n},o,t," (",n,")")}))),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Pitch Shift (Semitones)"),a.createElement("input",{type:"range",min:"-24",max:"24",step:"1",value:V,onChange:function(e){return H(parseInt(e.target.value))},style:{width:"100%"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px"}},V>0?"+":"",V," semitones")),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Fine Tune (Cents)"),a.createElement("input",{type:"range",min:"-100",max:"100",step:"1",value:K,onChange:function(e){return Y(parseInt(e.target.value))},style:{width:"100%"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px"}},K>0?"+":"",K," cents")),a.createElement("h4",{style:{color:"#22c55e",fontSize:"12px",marginBottom:"8px",borderTop:"1px solid #334155",paddingTop:"8px"}}," Loop & Fade Controls"),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Loop Start"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.001",value:k,onChange:function(e){return x(parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px"}},(100*k).toFixed(1),"%")),a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Loop End"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.001",value:E,onChange:function(e){return P(parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px"}},(100*E).toFixed(1),"%")),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"flex",alignItems:"center",gap:"8px"}},a.createElement("span",null,"Fade Mode:"),a.createElement("button",{className:"btn ".concat("auto"===de?"btn-green":"btn-ghost"),onClick:function(){return pe("auto"===de?"manual":"auto")},style:{fontSize:"11px",padding:"2px 6px"}},"auto"===de?" Auto":" Manual"))),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Fade In ","auto"===de?"(Auto)":""),a.createElement("input",{type:"range",min:"0",max:"0.5",step:"0.001",value:C,onChange:function(e){return I(parseFloat(e.target.value))},disabled:"auto"===de,style:{width:"100%",opacity:"auto"===de?.5:1}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px"}},(100*C).toFixed(1),"% of selection ","auto"===de?"(Auto)":"")),a.createElement("div",{style:{marginBottom:"16px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Fade Out"),a.createElement("input",{type:"range",min:"0",max:"0.5",step:"0.001",value:L,onChange:function(e){return M(parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px"}},(100*L).toFixed(1),"% of selection")),a.createElement("h3",{style:{color:"#e2e8f0",fontSize:"14px",marginBottom:"16px",borderTop:"1px solid #334155",paddingTop:"16px"}},"Export Settings"),a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Sample Rate"),a.createElement("select",{value:T,onChange:function(e){return F(parseInt(e.target.value))},style:{width:"100%",padding:"6px",borderRadius:"8px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px"}},a.createElement("option",{value:44100},"44.1 kHz"),a.createElement("option",{value:22050},"22.05 kHz"),a.createElement("option",{value:16e3},"16 kHz"),a.createElement("option",{value:8e3},"8 kHz"))),a.createElement("button",{className:"btn btn-green",onClick:Kn,disabled:!l,style:{width:"100%",marginBottom:"8px"}},ze?" Export to SD (".concat((n.params.sample_name||"sample").replace(/[^a-zA-Z0-9-_]/g,"_")).concat(He,".wav)"):" Export WAV (".concat((n.params.sample_name||"sample").replace(/[^a-zA-Z0-9-_]/g,"_")).concat(He,".wav)")),a.createElement("button",{className:"btn ".concat("connected"===Ue?"btn-purple":"writing"===Ue?"btn-amber":"btn-ghost"),onClick:"not_connected"===Ue?Vn:jn,disabled:!l||"writing"===Ue,style:{width:"100%",marginBottom:"8px"}},"not_connected"===Ue&&" Connect SD Card","connected"===Ue&&" Save to SD Card","writing"===Ue&&" Writing to SD..."),"not_connected"!==Ue&&a.createElement("button",{className:"btn btn-ghost",onClick:function(){Ge(null),We("not_connected")},style:{width:"100%",marginBottom:"8px",fontSize:"11px"}},"Disconnect SD Card"),(De||we.length>0)&&a.createElement("div",{style:{backgroundColor:"#fbbf24",color:"#92400e",padding:"8px",borderRadius:"4px",marginBottom:"8px",fontSize:"11px",border:"1px solid #f59e0b"}},a.createElement("div",{style:{fontWeight:"bold",marginBottom:"4px"}}," File Transfer Active"),a.createElement("div",null,"Do NOT upload Arduino sketches while transferring files! This will interrupt the transfer and may corrupt files."),we.length>1&&a.createElement("div",{style:{marginTop:"4px",fontSize:"10px"}},"Queue: ",we.length," files waiting")),we.length>0&&a.createElement("div",{style:{marginBottom:"16px"}},a.createElement("div",{style:{color:"#cbd5e1",fontSize:"12px",marginBottom:"8px",display:"flex",justifyContent:"space-between",alignItems:"center"}},a.createElement("span",null,"Transfer Queue (",we.length,")"),we.some(function(e){return"queued"===e.status})&&a.createElement("button",{className:"btn btn-ghost",onClick:function(){Le([]),Ae(null),Ce([])},style:{fontSize:"10px",padding:"2px 6px"}},"Clear")),a.createElement("div",{style:{maxHeight:"120px",overflowY:"auto"}},we.map(function(e){return a.createElement("div",{key:e.id,style:{backgroundColor:"#374151",padding:"6px",marginBottom:"4px",borderRadius:"4px",fontSize:"11px"}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"2px"}},a.createElement("span",{style:{color:"#cbd5e1"}}," ",e.filename),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"6px"}},a.createElement("span",{style:{color:"transferring"===e.status?"#fbbf24":"completed"===e.status?"#10b981":"error"===e.status?"#ef4444":"#94a3b8"}},"transferring"===e.status&&"","queued"===e.status&&"","completed"===e.status&&"","error"===e.status&&""),"queued"===e.status&&a.createElement("button",{onClick:function(){return n=e.id,Le(function(e){return e.filter(function(e){return e.id!==n})}),void Ce(function(e){return e.filter(function(e){return e.id!==n})});var n},style:{background:"none",border:"none",color:"#ef4444",cursor:"pointer",fontSize:"10px",padding:"0 2px"}},""))),a.createElement("div",{style:{display:"flex",justifyContent:"space-between",color:"#94a3b8",fontSize:"10px"}},a.createElement("span",null,(e.size/1024).toFixed(1)," KB"),"transferring"===e.status&&a.createElement("span",null,e.progress.toFixed(1),"%")),"transferring"===e.status&&a.createElement("div",{style:{width:"100%",height:"2px",backgroundColor:"#4b5563",borderRadius:"1px",marginTop:"4px",overflow:"hidden"}},a.createElement("div",{style:{width:"".concat(e.progress,"%"),height:"100%",backgroundColor:"#fbbf24",transition:"width 0.3s ease"}})))})))),a.createElement("div",{style:{backgroundColor:"#111827",padding:"8px",borderRadius:"6px",border:"1px solid #334155",marginBottom:"12px"}},a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginBottom:"4px"}},"Total Pitch: ",(12*Math.log2(J)+V+K/100).toFixed(1)," semitones"),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginBottom:"4px"}},"Final Speed: ",(J*Math.pow(2,(100*V+K)/1200)).toFixed(3),"x (",(J*Math.pow(2,(100*V+K)/1200)*100).toFixed(1),"%)"),a.createElement("div",{style:{fontSize:"10px",color:"synth"===ye?"#22c55e":"#94a3b8"}},"Hardware: ","disconnected"===ye?"Not connected":"synth"===ye?"Connected (Synth mode)":"usb"===ye?"USB Storage mode":"Switching..."),a.createElement("div",{style:{fontSize:"10px",color:"connected"===Ue?"#8b5cf6":"#94a3b8"}},"SD Card: ","not_connected"===Ue?"Not connected":"connected"===Ue?"Connected (Direct access)":"Writing...")),!Xn&&a.createElement("div",{style:{backgroundColor:"#111827",padding:"12px",borderRadius:"8px",border:"1px solid #334155"}},a.createElement("h4",{style:{color:"#22c55e",fontSize:"12px",margin:"0 0 8px 0"}},"Legend"),a.createElement("div",{style:{fontSize:"11px",color:"#cbd5e1"}},a.createElement("div",{style:{marginBottom:"4px"}},a.createElement("span",{style:{color:"#22c55e"}},"")," Loop Start"),a.createElement("div",{style:{marginBottom:"4px"}},a.createElement("span",{style:{color:"#dc2626"}},"")," Loop End"),a.createElement("div",{style:{marginBottom:"4px"}},a.createElement("span",{style:{color:"#f59e0b"}},"")," Play Position"),a.createElement("div",{style:{marginBottom:"4px"}},a.createElement("span",{style:{color:"#22c55e",opacity:.3}},"")," Loop Region"),a.createElement("div",null,a.createElement("span",{style:{color:"#f59e0b",opacity:.3}},"")," Fade Regions")))))))};function En(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,c,r,i=[],l=!0,s=!1;try{if(c=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=c.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(r=t.return(),Object(r)!==r))return}finally{if(s)throw o}}return i}}(e,n)||function(e,n){if(e){if("string"==typeof e)return Pn(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Pn(e,n):void 0}}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Pn(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}const wn=function(e){e.module;var n,t,o,c,r=e.onUpdateParam,i=e.onClose,l=En((0,a.useState)(null),2),s=l[0],u=l[1],d=En((0,a.useState)(null),2),p=d[0],f=d[1],m=(0,a.useRef)();(0,a.useEffect)(function(){var e=function(e){var n;if(e.source===(null===(n=m.current)||void 0===n?void 0:n.contentWindow)){var t=e.data,a=t.type,o=t.data;switch(a){case"ANALYSIS_COMPLETE":u(o),console.log("Received analysis:",o);break;case"PRESET_EXPORT":_(o)}}};return window.addEventListener("message",e),function(){return window.removeEventListener("message",e)}},[]);var _=function(e){var n=function(e){for(var n=e.harmonics,t=(e.meta,[]),a=0;a<257;a++){var o=a/256*2-1,c=o;if(n&&n.length>1){for(var r=0,i=n[0],l=1;l<Math.min(n.length,16);l++){var s=n[l];s&&(r+=Math.pow(10,(s.db-i.db)/20)*Math.sin((l+1)*Math.PI*o))}c=.5*o+.5*r}c=Math.max(-1,Math.min(1,c)),t.push(c.toFixed(6))}return t}(e);f(n),r("preset","custom"),r("customTable",n),alert("Custom preset generated from analysis!\nFundamental: ".concat(e.meta.f0.toFixed(1)," Hz\nTHD: ").concat((100*e.meta.thd).toFixed(1),"%\nHarmonics: ").concat(e.harmonics.length))};return a.createElement("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,background:"rgba(0,0,0,0.9)",zIndex:9999,display:"flex",alignItems:"center",justifyContent:"center"}},a.createElement("div",{style:{width:"95%",height:"95%",background:"#0b0d10",borderRadius:"16px",display:"flex",flexDirection:"column",boxShadow:"0 20px 50px rgba(0,0,0,0.5)"}},a.createElement("div",{style:{padding:"16px 24px",borderBottom:"1px solid #1f2a38",display:"flex",justifyContent:"space-between",alignItems:"center"}},a.createElement("div",null,a.createElement("h2",{style:{margin:0,fontSize:"18px",color:"#e9f1f7"}},"Distortion Editor - Spectral Analyzer"),a.createElement("p",{style:{margin:"4px 0 0",fontSize:"13px",color:"#8aa"}},"Load reference & effected audio  Analyze harmonics  Generate custom waveshaping preset")),a.createElement("div",{style:{display:"flex",gap:"8px"}},p&&a.createElement("button",{onClick:function(){p&&(r("preset","custom"),r("customTable",p))},style:{background:"#1c2a42",border:"1px solid #2f5b9e",color:"#e9f1f7",padding:"8px 16px",borderRadius:"8px",cursor:"pointer",fontSize:"13px"}},"Apply Custom Preset"),a.createElement("button",{onClick:i,style:{background:"#4d1f1f",border:"1px solid #8b1d1d",color:"#e9f1f7",padding:"8px 16px",borderRadius:"8px",cursor:"pointer",fontSize:"13px"}},"Close"))),a.createElement("iframe",{ref:m,src:"/spectral_analyzer_ir_helper.html",style:{flex:1,border:"none",borderRadius:"0 0 16px 16px"},title:"Spectral Analyzer"}),s&&a.createElement("div",{style:{position:"absolute",bottom:"24px",left:"24px",background:"#12161b",border:"1px solid #2a3a4d",borderRadius:"12px",padding:"12px 16px",fontSize:"13px",color:"#8aa",maxWidth:"400px"}},a.createElement("div",{style:{color:"#60a5fa",fontWeight:"bold",marginBottom:"4px"}},"Analysis Complete"),a.createElement("div",null,"f: ",null===(n=s.meta)||void 0===n||null===(n=n.f0)||void 0===n?void 0:n.toFixed(1)," Hz"),a.createElement("div",null,"THD: ",null===(t=100*(null===(o=s.meta)||void 0===o?void 0:o.thd))||void 0===t?void 0:t.toFixed(1),"%"),a.createElement("div",null,"Harmonics detected: ",null===(c=s.harmonics)||void 0===c?void 0:c.length))))};function Cn(e){return Cn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Cn(e)}function In(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,Rn(a.key),a)}}function Rn(e){var n=function(e){if("object"!=Cn(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=Cn(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==Cn(n)?n:n+""}function Ln(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(e){}return(Ln=function(){return!!e})()}function Mn(e){return Mn=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},Mn(e)}function Dn(e,n){return Dn=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,n){return e.__proto__=n,e},Dn(e,n)}const An=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=function(e,n,t){return n=Mn(n),function(e,n){if(n&&("object"==Cn(n)||"function"==typeof n))return n;if(void 0!==n)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}(e,Ln()?Reflect.construct(n,t||[],Mn(e).constructor):n.apply(e,t))}(this,n,[e])).state={hasError:!1,error:null},t}return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),n&&Dn(e,n)}(n,e),t=n,c=[{key:"getDerivedStateFromError",value:function(e){return{hasError:!0,error:e}}}],(o=[{key:"componentDidCatch",value:function(e,n){console.error("ErrorBoundary caught an error:",e,n)}},{key:"render",value:function(){var e,n=this;return this.state.hasError?a.createElement("div",{style:{padding:"20px",backgroundColor:"#fee2e2",border:"1px solid #fecaca",borderRadius:"8px",color:"#991b1b"}},a.createElement("h3",{style:{margin:"0 0 12px 0",color:"#991b1b"}},this.props.componentName||"Component"," Error"),a.createElement("p",{style:{margin:"0 0 12px 0",fontSize:"14px"}},"This component has been temporarily disabled due to an error. The rest of the application should continue to work normally."),a.createElement("details",{style:{fontSize:"12px",color:"#7f1d1d"}},a.createElement("summary",null,"Error details"),a.createElement("pre",{style:{whiteSpace:"pre-wrap",marginTop:"8px"}},null===(e=this.state.error)||void 0===e?void 0:e.toString())),this.props.onRetry&&a.createElement("button",{onClick:function(){n.setState({hasError:!1,error:null}),n.props.onRetry()},style:{marginTop:"12px",padding:"6px 12px",backgroundColor:"#991b1b",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"}},"Retry")):this.props.children}}])&&In(t.prototype,o),c&&In(t,c),Object.defineProperty(t,"prototype",{writable:!1}),t;var t,o,c}(a.Component);function On(e){return On="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},On(e)}function Bn(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function Tn(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?Bn(Object(t),!0).forEach(function(n){Fn(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):Bn(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function Fn(e,n,t){return(n=function(e){var n=function(e){if("object"!=On(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=On(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==On(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function Nn(e){return function(e){if(Array.isArray(e))return qn(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||Gn(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function zn(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,c,r,i=[],l=!0,s=!1;try{if(c=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=c.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(r=t.return(),Object(r)!==r))return}finally{if(s)throw o}}return i}}(e,n)||Gn(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Gn(e,n){if(e){if("string"==typeof e)return qn(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?qn(e,n):void 0}}function qn(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}var Un=function(e){var n=e.label,t=e.value,o=e.min,c=e.max,r=e.step,i=void 0===r?1:r,l=e.onChange,s=e.color,u=void 0===s?"#22c55e":s,d=e.unit,p=void 0===d?"":d,f=zn((0,a.useState)(!1),2),m=f[0],_=f[1],g=zn((0,a.useState)({x:0,y:0,value:0}),2),h=g[0],v=g[1],b=(0,a.useRef)(null),y=(t-o)/(c-o),k=270*y-135;return(0,a.useEffect)(function(){var e=function(e){if(m){var n=h.y-e.clientY,t=(c-o)/100,a=Math.max(o,Math.min(c,h.value+n*t)),r=Math.round(a/i)*i;l(r)}},n=function(){_(!1)};return m&&(document.addEventListener("mousemove",e),document.addEventListener("mouseup",n)),function(){document.removeEventListener("mousemove",e),document.removeEventListener("mouseup",n)}},[m,h,o,c,i,l]),a.createElement("div",{style:{display:"flex",flexDirection:"column",alignItems:"center",gap:"6px"}},a.createElement("div",{ref:b,onMouseDown:function(e){e.preventDefault(),_(!0),v({x:e.clientX,y:e.clientY,value:t})},style:{width:"40px",height:"40px",borderRadius:"50%",background:"conic-gradient(from 45deg, ".concat(u," ").concat(100*y,"%, #374151 ").concat(100*y,"%)"),border:"2px solid #475569",position:"relative",cursor:m?"grabbing":"grab",transform:"rotate(".concat(k,"deg)"),transition:m?"none":"transform 0.1s ease"}},a.createElement("div",{style:{position:"absolute",width:"2px",height:"12px",backgroundColor:"#ffffff",top:"2px",left:"50%",transform:"translateX(-50%)",borderRadius:"1px"}})),a.createElement("div",{style:{fontSize:"11px",fontWeight:"600",color:u,textAlign:"center",minWidth:"50px"}},n),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",textAlign:"center",fontFamily:"monospace"}},t,p))};const Wn=function(e){var n=e.params,t=e.onUpdateParam,o=e.moduleId,c=e.module,r=e.onClose,i=e.fullscreen,l=void 0!==i&&i,s=n||(null==c?void 0:c.params)||{},u=o||(null==c?void 0:c.id),d=(0,a.useRef)(null),p=zn((0,a.useState)(null),2),f=p[0],m=p[1],_=zn((0,a.useState)({x:0,y:0}),2),g=(_[0],_[1]),h=zn((0,a.useState)(!1),2),v=h[0],b=h[1],y=zn((0,a.useState)("ADSR"),2),k=y[0],x=y[1],S=zn((0,a.useState)(!1),2),E=S[0],P=S[1],w=s.attack_ms||10,C=s.decay_ms||120,I=s.sustain||.6,R=s.release_ms||200,L=s.loop_mode||"oneshot",M=s.timescale||1,D=s.trigger_mode||"gate",A=s.attack_curve||"linear",O=s.decay_curve||"exp",B=s.release_curve||"exp",T=s.sustain_mod_enabled||!1,F=s.sustain_lfo_rate||1,N=s.sustain_lfo_depth||.2,z=s.sustain_lfo_wave||"sine",G=s.sustain_mod_source||"internal",q=s.breakpoints||[{time:0,level:0,curve:.5},{time:.1,level:1,curve:.3},{time:.3,level:.6,curve:.7},{time:.8,level:.6,curve:.5},{time:1,level:0,curve:.8}],U=l?800:280,W=l?320:100,V=20,H=200,j=w+C+H,K=Math.max(1e3,j+R);(0,a.useEffect)(function(){Y()},[w,C,I,R,f,k,q,L,M,A,O,B]);var Y=function(){var e=d.current;if(e){var n=e.getContext("2d"),t=e.getBoundingClientRect(),a=window.devicePixelRatio||1;e.width=t.width*a,e.height=t.height*a,e.style.width=t.width+"px",e.style.height=t.height+"px",n.scale(a,a);var o=t.width,c=t.height,r=o-40,i=c-40,l=V+w/K*r,s=V+(w+C)/K*r,u=V+(w+C+H+R/2e3*200)/K*r,p=V+(w+C+H+R)/K*r,f=V+(1-I)*i,m=c-V;n.textRenderingOptimization="optimizeLegibility",n.imageSmoothingEnabled=!1,n.fillStyle="#0f172a",n.fillRect(0,0,o,c),n.strokeStyle="#374151",n.lineWidth=1,n.setLineDash([2,2]);for(var _=0;_<=4;_++){var g=V+_*i/4;n.beginPath(),n.moveTo(V,g),n.lineTo(o-V,g),n.stroke()}for(var h=0;h<=4;h++){var v=V+h*r/4;n.beginPath(),n.moveTo(v,V),n.lineTo(v,c-V),n.stroke()}n.setLineDash([]),"ADSR"===k?X(n,o,c,r,i,l,s,u,p,20,f,m):Z(n,o,c,r,i),"oneshot"!==L&&(n.strokeStyle="#f59e0b",n.lineWidth=2,n.setLineDash([5,5]),n.strokeRect(V,V,r,i),n.setLineDash([]),n.fillStyle="#f59e0b",n.font="bold 10px monospace",n.textAlign="left",n.fillText("".concat(L.toUpperCase()),25,35));var b=M<.01?"".concat((1e3*M).toFixed(1),"s"):M<1?"".concat((1e3*M).toFixed(0),"ms"):M<60?"".concat(M.toFixed(1),"s"):"".concat((M/60).toFixed(1),"m");n.fillStyle="#94a3b8",n.font="10px monospace",n.textAlign="right",n.fillText("".concat(b),U-V-5,W-V-5)}},$=function(e,n,t,a,o,c,r){for(var i=0;i<=20;i++){var l=i/20,s=void 0;switch(c){case"linear":default:s=l;break;case"exp":s=r?(1-Math.exp(-5*l))/(1-Math.exp(-5)):1-(1-Math.exp(-5*(1-l)))/(1-Math.exp(-5));break;case"log":s=r?Math.log(1+9*l)/Math.log(10):1-Math.log(1+9*(1-l))/Math.log(10);break;case"sine":s=r?Math.sin(l*Math.PI/2):1-Math.sin((1-l)*Math.PI/2);break;case"quad":s=r?l*l:1-(1-l)*(1-l)}var u=n+(a-n)*l,d=t+(o-t)*s;0===i?e.moveTo(u,d):e.lineTo(u,d)}},X=function(e,n,t,a,o,c,r,i,l,s,u,d){e.strokeStyle="#22c55e",e.lineWidth=3,e.beginPath(),e.moveTo(V,W-V),$(e,V,W-V,c,s,A,!0),$(e,c,s,r,u,O,!1),e.lineTo(i,u),$(e,i,u,l,d,B,!1),e.stroke(),J(e,c,s,0,"#22c55e","A"),J(e,r,s,1,"#f59e0b","D"),J(e,i,u,2,"#3b82f6","S"),J(e,l,d,3,"#ef4444","R"),e.fillStyle="#cbd5e1",e.font='bold 11px "SF Mono", "Monaco", "Inconsolata", "Fira Code", "Droid Sans Mono", "Source Code Pro", monospace',e.textAlign="center",e.textBaseline="alphabetic";var p=w*M,f=C*M,m=R*M;e.fillText("A: ".concat(Q(p)),Math.round(c),Math.round(t-5)),e.fillText("D: ".concat(Q(f)),Math.round((c+r)/2),Math.round(t-5)),e.fillText("S: ".concat(Math.round(100*I),"%"),Math.round((r+i)/2),Math.round(t-5)),e.fillText("R: ".concat(Q(m)),Math.round((i+l)/2),Math.round(t-5))},Z=function(e,n,t,a,o){if(!(q.length<2)){e.strokeStyle="#22c55e",e.lineWidth=3,e.beginPath();for(var c=0;c<q.length;c++){var r=q[c],i=V+r.time*a,l=V+(1-r.level)*o;if(0===c)e.moveTo(i,l);else{var s=q[c-1],u=V+s.time*a,d=V+(1-s.level)*o,p=s.curve,m=u+(i-u)*p,_=d+(l-d)*(1-p);e.quadraticCurveTo(m,_,i,l)}}if(e.stroke(),q.forEach(function(n,t){var c=V+n.time*a,r=V+(1-n.level)*o;J(e,c,r,t,["#22c55e","#f59e0b","#3b82f6","#ef4444","#8b5cf6"][t%5],"".concat(t+1))}),null!==f&&f<q.length-1){var g=q[f],h=q[f+1],v=V+g.time*a,b=V+(1-g.level)*o,y=V+h.time*a,k=V+(1-h.level)*o,x=v+(y-v)*g.curve,S=b+(k-b)*(1-g.curve);e.strokeStyle="#94a3b8",e.lineWidth=1,e.setLineDash([2,2]),e.beginPath(),e.moveTo(v,b),e.lineTo(x,S),e.lineTo(y,k),e.stroke(),e.setLineDash([]),e.fillStyle="#94a3b8",e.strokeStyle="#ffffff",e.lineWidth=1,e.beginPath(),e.arc(x,S,4,0,2*Math.PI),e.fill(),e.stroke()}}},Q=function(e){return e<1?"".concat((1e3*e).toFixed(0),"s"):e<1e3?"".concat(e.toFixed(0),"ms"):e<6e4?"".concat((e/1e3).toFixed(1),"s"):"".concat((e/6e4).toFixed(1),"m")},J=function(e,n,t,a,o,c){var r=f===a?8:6;e.fillStyle=o,e.strokeStyle="#ffffff",e.lineWidth=2,e.beginPath(),e.arc(n,t,r,0,2*Math.PI),e.fill(),e.stroke(),e.fillStyle="#000000",e.font="bold 10px monospace",e.textAlign="center",e.fillText(c,n,t+3)},ee=function(e){console.log(" MOUSE DOWN EVENT FIRED!",{type:e.type,button:e.button,clientX:e.clientX,clientY:e.clientY});var n=d.current;if(n){var a=n.getBoundingClientRect(),o=e.clientX-a.left,c=e.clientY-a.top;console.log(" Mouse coordinates:",{mouseX:o,mouseY:c,editMode:k});var r=a.width-40,i=a.height-40,l=15;if("ADSR"===k){var s=V+w/K*r,p=V+(w+C)/K*r,_=V+(w+C+H+R/2e3*200)/K*r,h=V+(w+C+H+R)/K*r,v=V,b=V+(1-I)*i,y=a.height-V;console.log(" ADSR Click Detection:",{mouseX:o,mouseY:c,tolerance:l,editMode:k,attack_ms:w,decay_ms:C,sustain:I,release_ms:R,timescale:M,totalTime:K,margin:V,plotWidth:r,plotHeight:i,attackX:s,attackY:v,decayX:p,sustainY:b,sustainX:_,releaseX:h,releaseY:y,attackDist:Math.abs(o-s)+Math.abs(c-v),decayDist:Math.abs(o-p)+Math.abs(c-v),sustainDist:Math.abs(o-_)+Math.abs(c-b),releaseDist:Math.abs(o-h)+Math.abs(c-y)}),Math.abs(o-s)<l&&Math.abs(c-v)<l?(console.log(" ATTACK point clicked"),m(0)):Math.abs(o-p)<l&&Math.abs(c-v)<l?(console.log(" DECAY point clicked"),m(1)):Math.abs(o-_)<l&&Math.abs(c-b)<l?(console.log(" SUSTAIN point clicked"),m(2)):Math.abs(o-h)<l&&Math.abs(c-y)<l?(console.log(" RELEASE point clicked"),m(3)):console.log(" No control point hit")}else{for(var x=0;x<q.length;x++){var S=q[x],E=V+S.time*r,P=V+(1-S.level)*i;if(Math.abs(o-E)<l&&Math.abs(c-P)<l){m(x),g({x:o-E,y:c-P});break}}if(null===f&&2===e.detail){var L=(o-V)/r,D=1-(c-V)/i;if(L>=0&&L<=1&&D>=0&&D<=1){var A=[].concat(Nn(q),[{time:L,level:D,curve:.5}]).sort(function(e,n){return e.time-n.time});t(u,"breakpoints",A)}}}e.preventDefault()}else console.log(" No canvas ref!")};return(0,a.useEffect)(function(){if(null!==f){var e=function(e){d.current&&function(e){if(null!==f&&console.log(" MOUSE MOVE while dragging:",{isDragging:f,editMode:k}),null!==f){var n=d.current.getBoundingClientRect(),a=e.clientX-n.left,o=e.clientY-n.top,c=n.width-40,r=n.height-40,i=Math.max(0,Math.min(1,(a-V)/c)),l=Math.max(0,Math.min(1,1-(o-V)/r));if("ADSR"===k){console.log(" ADSR drag detected:",{isDragging:f,timeRatio:i,levelRatio:l});var s=2e3;switch(f){case 0:var p=4e3*M,m=Math.max(1,Math.min(p,i*p));console.log(" Attack update:",{newAttack:m,timeRatio:i,maxAttackTime:p,actualModuleId:u}),t(u,"attack_ms",Math.round(m));break;case 1:var _=4e3*M,g=Math.max(1,Math.min(_,i*_));console.log(" Decay update:",{newDecay:g,timeRatio:i,maxDecayTime:_,actualModuleId:u}),t(u,"decay_ms",Math.round(g));break;case 2:console.log(" Sustain update:",{levelRatio:l,timeRatio:i,actualModuleId:u}),t(u,"sustain",l);var h=V+(w+C)/K*c,v=.8*c,b=Math.max(0,Math.min(1,(a-h)/v));b=Math.pow(b,.5);var y=Math.max(50,Math.min(s,50+1950*b));t(u,"release_ms",Math.round(y));break;case 3:var x=V+(w+C+H)/K*c,S=Math.max(0,Math.min(1,(a-x)/(.3*c))),E=Math.max(10,Math.min(s,S*s));console.log(" Release update:",{mouseX:a,sustainX:x,releaseTimeRatio:S,newReleaseTime:E,actualModuleId:u}),t(u,"release_ms",Math.round(E))}}else if(f<q.length){var P=Nn(q),I=0,R=1;f>0&&(I=q[f-1].time+.01),f<q.length-1&&(R=q[f+1].time-.01),P[f]=Tn(Tn({},P[f]),{},{time:Math.max(I,Math.min(R,i)),level:l}),t(u,"breakpoints",P)}e.preventDefault()}}(Tn(Tn({},e),{},{clientX:e.clientX,clientY:e.clientY,preventDefault:function(){}}))},n=function(e){console.log(" GLOBAL MOUSE UP - ending drag"),null!==f&&console.log(" MOUSE UP - ending drag for:",f),m(null)};return document.addEventListener("mousemove",e),document.addEventListener("mouseup",n),function(){document.removeEventListener("mousemove",e),document.removeEventListener("mouseup",n)}}},[f,k,q,w,C,I,R,M,u]),(0,a.useEffect)(function(){var e=function(e){"Escape"===e.key&&r()};return document.addEventListener("keydown",e),function(){return document.removeEventListener("keydown",e)}},[r]),l?a.createElement("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(0, 0, 0, 1)",zIndex:2e3,display:"flex",alignItems:"center",justifyContent:"center"}},a.createElement("div",{style:{backgroundColor:"#0c1428",border:"1px solid #1f2937",borderRadius:"12px",width:"95vw",height:"90vh",padding:"20px",display:"flex",flexDirection:"column",overflow:"auto"}},a.createElement("div",{style:{display:"flex",alignItems:"center",justifyContent:"space-between",marginBottom:"20px",paddingBottom:"12px",borderBottom:"1px solid #334155"}},a.createElement("div",{style:{display:"flex",alignItems:"center",justifyContent:"space-between",width:"100%"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("h2",{style:{color:"#22c55e",fontWeight:"bold",fontSize:"24px",margin:0}}," Advanced Envelope Generator"),a.createElement("div",{style:{color:"#94a3b8",fontSize:"16px"}},null==c?void 0:c.type," - ",null==c?void 0:c.id))),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"16px"}},a.createElement("div",{style:{display:"flex",border:"1px solid #374151",borderRadius:"6px",overflow:"hidden"}},a.createElement("button",{onClick:function(){return x("ADSR")},style:{padding:"8px 16px",background:"ADSR"===k?"#22c55e":"#374151",color:"ADSR"===k?"#000":"#cbd5e1",border:"none",fontSize:"14px",fontWeight:"700",cursor:"pointer"}},"ADSR MODE"),a.createElement("button",{onClick:function(){return x("Freeform")},style:{padding:"8px 16px",background:"Freeform"===k?"#22c55e":"#374151",color:"Freeform"===k?"#000":"#cbd5e1",border:"none",fontSize:"14px",fontWeight:"700",cursor:"pointer"}},"FREEFORM MODE")),a.createElement("button",{onClick:r,style:{width:"32px",height:"32px",borderRadius:"4px",border:"none",background:"#dc2626",color:"#fff",fontSize:"18px",fontWeight:"bold",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",boxShadow:"0 2px 4px rgba(0, 0, 0, 0.3)"},title:"Close Editor (ESC)"},""))),a.createElement("div",{style:{flex:1,display:"flex",gap:"20px",overflow:"auto",minHeight:0}},a.createElement("div",{style:{flex:1,display:"flex",flexDirection:"column",justifyContent:"center"}},a.createElement("canvas",{ref:d,width:U,height:W,onMouseDown:ee,style:{border:"2px solid #374151",borderRadius:"8px",cursor:null!==f?"grabbing":"crosshair",backgroundColor:"#0f172a",display:"block",width:l?"800px":"280px",height:l?"320px":"100px"}}),a.createElement("div",{style:{fontSize:"14px",color:"#94a3b8",textAlign:"center",marginTop:"12px",lineHeight:"1.4"}},"ADSR"===k?" Drag control points to adjust envelope  Sustain:  level,  release time  Switch to FREEFORM mode for unlimited breakpoints":" Drag breakpoints to shape envelope  Double-click to add points  Right-click to delete points"),"ADSR"===k&&a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",width:l?"800px":"280px",marginTop:"20px",padding:"16px 20px",backgroundColor:"#0f172a",border:"1px solid #334155",borderRadius:"8px",boxSizing:"border-box"}},a.createElement(Un,{label:"Attack",value:w,min:1,max:2e3,step:1,onChange:function(e){return t(u,"attack_ms",e)},color:"#22c55e",unit:"ms"}),a.createElement(Un,{label:"Decay",value:C,min:1,max:2e3,step:1,onChange:function(e){return t(u,"decay_ms",e)},color:"#f59e0b",unit:"ms"}),a.createElement(Un,{label:"Sustain",value:Math.round(100*I),min:0,max:100,step:1,onChange:function(e){return t(u,"sustain",e/100)},color:"#3b82f6",unit:"%"}),a.createElement(Un,{label:"Release",value:R,min:10,max:3e3,step:1,onChange:function(e){return t(u,"release_ms",e)},color:"#ef4444",unit:"ms"}))),a.createElement("div",{style:{width:"300px",display:"flex",flexDirection:"column",gap:"20px",overflowY:"auto",paddingRight:"10px"}},a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"16px",fontSize:"14px"}},a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"8px"}},a.createElement("label",{style:{color:"#22c55e",fontWeight:"700",fontSize:"16px"}},"Loop Mode"),a.createElement("select",{value:L,onChange:function(e){return t(u,"loop_mode",e.target.value)},style:{padding:"8px 12px",background:"#0f172a",border:"2px solid #374151",borderRadius:"6px",color:"#cbd5e1",fontSize:"14px"}},a.createElement("option",{value:"oneshot"}," One-Shot"),a.createElement("option",{value:"loop"}," Loop"),a.createElement("option",{value:"pingpong"}," Ping-Pong"))),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"8px"}},a.createElement("label",{style:{color:"#22c55e",fontWeight:"700",fontSize:"16px"}},"Trigger Mode"),a.createElement("select",{value:D,onChange:function(e){return t(u,"trigger_mode",e.target.value)},style:{padding:"8px 12px",background:"#0f172a",border:"2px solid #374151",borderRadius:"6px",color:"#cbd5e1",fontSize:"14px"}},a.createElement("option",{value:"gate"}," Gate"),a.createElement("option",{value:"trigger"}," Trigger"),a.createElement("option",{value:"lfo"}," LFO"))),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"8px"}},a.createElement("label",{style:{color:"#22c55e",fontWeight:"700",fontSize:"16px"}}," Timescale: ",M<.01?"".concat((1e3*M).toFixed(1),"s"):M<1?"".concat((1e3*M).toFixed(0),"ms"):M<60?"".concat(M.toFixed(1),"s"):"".concat((M/60).toFixed(1),"m")),a.createElement("input",{type:"range",min:"-3",max:"2",step:"0.1",value:Math.log10(M),onChange:function(e){return t(u,"timescale",Math.pow(10,parseFloat(e.target.value)))},style:{width:"100%",height:"8px",background:"#374151",outline:"none",borderRadius:"4px"}}),a.createElement("div",{style:{display:"flex",justifyContent:"space-between",fontSize:"12px",color:"#6b7280"}},a.createElement("span",null,"1ms"),a.createElement("span",null,"1s"),a.createElement("span",null,"100s"))),"ADSR"===k&&a.createElement("div",{style:{backgroundColor:"#111827",border:"1px solid #374151",borderRadius:"8px",padding:"16px"}},a.createElement("h3",{style:{color:"#3b82f6",marginBottom:"12px",fontSize:"16px"}}," Response Curves"),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"12px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#22c55e",fontSize:"12px",width:"60px"}},"Attack:"),a.createElement("select",{value:A,onChange:function(e){return t(u,"attack_curve",e.target.value)},style:{flex:1,padding:"4px 8px",background:"#0f172a",border:"1px solid #374151",borderRadius:"4px",color:"#cbd5e1",fontSize:"12px"}},a.createElement("option",{value:"linear"},"Linear"),a.createElement("option",{value:"exp"},"Exponential"),a.createElement("option",{value:"log"},"Logarithmic"),a.createElement("option",{value:"sine"},"Sine"),a.createElement("option",{value:"quad"},"Quadratic"))),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#f59e0b",fontSize:"12px",width:"60px"}},"Decay:"),a.createElement("select",{value:O,onChange:function(e){return t(u,"decay_curve",e.target.value)},style:{flex:1,padding:"4px 8px",background:"#0f172a",border:"1px solid #374151",borderRadius:"4px",color:"#cbd5e1",fontSize:"12px"}},a.createElement("option",{value:"linear"},"Linear"),a.createElement("option",{value:"exp"},"Exponential"),a.createElement("option",{value:"log"},"Logarithmic"),a.createElement("option",{value:"sine"},"Sine"),a.createElement("option",{value:"quad"},"Quadratic"))),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#ef4444",fontSize:"12px",width:"60px"}},"Release:"),a.createElement("select",{value:B,onChange:function(e){return t(u,"release_curve",e.target.value)},style:{flex:1,padding:"4px 8px",background:"#0f172a",border:"1px solid #374151",borderRadius:"4px",color:"#cbd5e1",fontSize:"12px"}},a.createElement("option",{value:"linear"},"Linear"),a.createElement("option",{value:"exp"},"Exponential"),a.createElement("option",{value:"log"},"Logarithmic"),a.createElement("option",{value:"sine"},"Sine"),a.createElement("option",{value:"quad"},"Quadratic"))))),"ADSR"===k&&a.createElement("div",{style:{backgroundColor:"#111827",border:"1px solid #374151",borderRadius:"8px",overflow:"hidden"}},a.createElement("button",{onClick:function(){return P(!E)},style:{width:"100%",padding:"12px 16px",background:"#1e293b",border:"none",color:"#94a3b8",fontSize:"14px",fontWeight:"600",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"space-between"}},a.createElement("span",{style:{color:"#a78bfa"}}," Sustain Modulation"),a.createElement("span",{style:{transform:E?"rotate(180deg)":"rotate(0deg)",transition:"transform 0.2s"}},"")),E&&a.createElement("div",{style:{padding:"16px"}},a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px",marginBottom:"12px"}},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px",cursor:"pointer"}},a.createElement("input",{type:"checkbox",checked:T,onChange:function(e){return t(u,"sustain_mod_enabled",e.target.checked)},style:{width:"16px",height:"16px"}}),a.createElement("span",{style:{color:"#cbd5e1",fontSize:"12px"}},"Enable Modulation")),a.createElement("select",{value:G,onChange:function(e){return t(u,"sustain_mod_source",e.target.value)},disabled:!T,style:{marginLeft:"auto",padding:"4px 8px",background:T?"#0f172a":"#1e293b",border:"1px solid #374151",borderRadius:"4px",color:T?"#cbd5e1":"#64748b",fontSize:"12px"}},a.createElement("option",{value:"internal"},"Internal LFO"),a.createElement("option",{value:"external"},"External CV")))),"internal"===G&&T&&a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"12px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#a78bfa",fontSize:"12px",width:"60px"}},"Wave:"),a.createElement("select",{value:z,onChange:function(e){return t(u,"sustain_lfo_wave",e.target.value)},style:{flex:1,padding:"4px 8px",background:"#0f172a",border:"1px solid #374151",borderRadius:"4px",color:"#cbd5e1",fontSize:"12px"}},a.createElement("option",{value:"sine"}," Sine"),a.createElement("option",{value:"triangle"}," Triangle"),a.createElement("option",{value:"square"}," Square"),a.createElement("option",{value:"saw"}," Sawtooth"),a.createElement("option",{value:"random"},"? Random"))),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#a78bfa",fontSize:"12px",width:"60px"}},"Rate:"),a.createElement("input",{type:"range",min:"0.1",max:"20",step:"0.1",value:F,onChange:function(e){return t(u,"sustain_lfo_rate",parseFloat(e.target.value))},style:{flex:1,height:"6px",background:"#374151",outline:"none",borderRadius:"3px"}}),a.createElement("span",{style:{color:"#cbd5e1",fontSize:"11px",width:"50px",textAlign:"right"}},F.toFixed(1)," Hz")),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#a78bfa",fontSize:"12px",width:"60px"}},"Depth:"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:N,onChange:function(e){return t(u,"sustain_lfo_depth",parseFloat(e.target.value))},style:{flex:1,height:"6px",background:"#374151",outline:"none",borderRadius:"3px"}}),a.createElement("span",{style:{color:"#cbd5e1",fontSize:"11px",width:"50px",textAlign:"right"}},Math.round(100*N),"%"))),"external"===G&&T&&a.createElement("div",{style:{padding:"12px",background:"#0f172a",borderRadius:"6px",fontSize:"12px",color:"#94a3b8"}},"Connect a control signal to the Sustain CV input to modulate the sustain level. The incoming CV (0-1) will be multiplied by the sustain level."))),a.createElement("div",{style:{backgroundColor:"#111827",border:"1px solid #374151",borderRadius:"8px",padding:"16px"}},a.createElement("h3",{style:{color:"#f59e0b",marginBottom:"12px",fontSize:"16px"}}," Current Values"),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr",gap:"8px",fontSize:"12px"}},a.createElement("div",null,a.createElement("span",{style:{color:"#22c55e"}},"Attack:")," ",Q(w*M)),a.createElement("div",null,a.createElement("span",{style:{color:"#f59e0b"}},"Decay:")," ",Q(C*M)),a.createElement("div",null,a.createElement("span",{style:{color:"#3b82f6"}},"Sustain:")," ",Math.round(100*I),"%"),a.createElement("div",null,a.createElement("span",{style:{color:"#ef4444"}},"Release:")," ",Q(R*M))))))))):v?a.createElement("div",{style:{marginBottom:"16px"}},a.createElement("div",{style:{border:"1px solid #334155",borderRadius:"8px",background:"#111827",padding:"12px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",justifyContent:"space-between",marginBottom:"12px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("div",{style:{color:"#22c55e",fontWeight:"bold",fontSize:"14px"}},"Envelope Generator"),a.createElement("div",{style:{display:"flex",border:"1px solid #374151",borderRadius:"4px",overflow:"hidden"}},a.createElement("button",{onClick:function(){return x("ADSR")},style:{padding:"4px 8px",background:"ADSR"===k?"#22c55e":"#374151",color:"ADSR"===k?"#000":"#cbd5e1",border:"none",fontSize:"10px",fontWeight:"600",cursor:"pointer"}},"ADSR"),a.createElement("button",{onClick:function(){return x("Freeform")},style:{padding:"4px 8px",background:"Freeform"===k?"#22c55e":"#374151",color:"Freeform"===k?"#000":"#cbd5e1",border:"none",fontSize:"10px",fontWeight:"600",cursor:"pointer"}},"FREE"))),a.createElement("button",{onClick:function(){return b(!1)},style:{background:"none",border:"none",color:"#94a3b8",cursor:"pointer",fontSize:"16px"}},"")),a.createElement("div",{style:{display:"flex",gap:"12px",marginBottom:"12px",fontSize:"11px",flexWrap:"wrap"}},a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"4px"}},a.createElement("label",{style:{color:"#cbd5e1",fontWeight:"600"}},"Loop Mode"),a.createElement("select",{value:L,onChange:function(e){return t(u,"loop_mode",e.target.value)},style:{padding:"4px 6px",background:"#0f172a",border:"1px solid #374151",borderRadius:"4px",color:"#cbd5e1",fontSize:"10px"}},a.createElement("option",{value:"oneshot"},"One-Shot"),a.createElement("option",{value:"loop"},"Loop"),a.createElement("option",{value:"pingpong"},"Ping-Pong"))),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"4px"}},a.createElement("label",{style:{color:"#cbd5e1",fontWeight:"600"}},"Trigger"),a.createElement("select",{value:D,onChange:function(e){return t(u,"trigger_mode",e.target.value)},style:{padding:"4px 6px",background:"#0f172a",border:"1px solid #374151",borderRadius:"4px",color:"#cbd5e1",fontSize:"10px"}},a.createElement("option",{value:"gate"},"Gate"),a.createElement("option",{value:"trigger"},"Trigger"),a.createElement("option",{value:"lfo"},"LFO"))),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"4px",flex:"1",minWidth:"120px"}},a.createElement("label",{style:{color:"#cbd5e1",fontWeight:"600"}},"Timescale: ",M<.01?"".concat((1e3*M).toFixed(1),"s"):M<1?"".concat((1e3*M).toFixed(0),"ms"):M<60?"".concat(M.toFixed(1),"s"):"".concat((M/60).toFixed(1),"m")),a.createElement("input",{type:"range",min:"-3",max:"2",step:"0.1",value:Math.log10(M),onChange:function(e){return t(u,"timescale",Math.pow(10,parseFloat(e.target.value)))},style:{width:"100%",height:"4px",background:"#374151",outline:"none",borderRadius:"2px"}}),a.createElement("div",{style:{display:"flex",justifyContent:"space-between",fontSize:"9px",color:"#6b7280"}},a.createElement("span",null,"1ms"),a.createElement("span",null,"1s"),a.createElement("span",null,"100s")))),a.createElement("div",{style:{border:"1px solid #374151",borderRadius:"6px",overflow:"hidden",marginBottom:"8px"}},a.createElement("canvas",{ref:d,width:U,height:W,onMouseDown:ee,style:{display:"block",cursor:null!==f?"grabbing":"crosshair"}})),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",textAlign:"center"}},"ADSR"===k?"Drag control points  Sustain:  level,  release time  Switch to FREE mode for custom breakpoints":"Drag breakpoints to shape envelope  Double-click to add points  Right-click to delete"),"ADSR"===k&&a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",width:"280px",marginTop:"8px",padding:"8px 20px",backgroundColor:"#0f172a",border:"1px solid #334155",borderRadius:"4px",boxSizing:"border-box"}},a.createElement("div",{style:{transform:"scale(0.8)"}}," ",a.createElement(Un,{label:"Attack",value:w,min:1,max:2e3,step:1,onChange:function(e){return t(u,"attack_ms",e)},color:"#22c55e",unit:"ms"})),a.createElement("div",{style:{transform:"scale(0.8)"}},a.createElement(Un,{label:"Decay",value:C,min:1,max:2e3,step:1,onChange:function(e){return t(u,"decay_ms",e)},color:"#f59e0b",unit:"ms"})),a.createElement("div",{style:{transform:"scale(0.8)"}},a.createElement(Un,{label:"Sustain",value:Math.round(100*I),min:0,max:100,step:1,onChange:function(e){return t(u,"sustain",e/100)},color:"#3b82f6",unit:"%"})),a.createElement("div",{style:{transform:"scale(0.8)"}},a.createElement(Un,{label:"Release",value:R,min:10,max:3e3,step:1,onChange:function(e){return t(u,"release_ms",e)},color:"#ef4444",unit:"ms"}))))):a.createElement("div",{style:{marginBottom:"16px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px",cursor:"pointer",padding:"8px",borderRadius:"8px",border:"1px solid #334155",background:"#111827"},onClick:function(){return b(!0)}},a.createElement("div",{style:{color:"#22c55e",fontWeight:"bold"}},"ADSR"===k?"ADSR":"ENV","oneshot"!==L&&a.createElement("span",{style:{color:"#f59e0b"}}," ")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8"}},"ADSR"===k?"A:".concat(Q(w*M)," D:").concat(Q(C*M)," S:").concat(Math.round(100*I),"% R:").concat(Q(R*M)):"".concat(q.length," points, ").concat(Q(1e3*M)," scale")),a.createElement("div",{style:{marginLeft:"auto",color:"#94a3b8"}},"")))};function Vn(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}const Hn=function(e){var n,t,o,c,r,i,l,s=e.module,u=e.onUpdateParam,d=e.onClose,p=e.fullscreen,f=void 0!==p&&p,m=(i=(0,a.useState)(1),l=2,function(e){if(Array.isArray(e))return e}(i)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,c,r,i=[],l=!0,s=!1;try{if(c=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=c.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(r=t.return(),Object(r)!==r))return}finally{if(s)throw o}}return i}}(i,l)||function(e,n){if(e){if("string"==typeof e)return Vn(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Vn(e,n):void 0}}(i,l)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),_=m[0],g=m[1],h=(null==s?void 0:s.params)||{},v=[.0625,.08333,.125,.16667,.25,.33333,.5,1,2,3,4,6,8,12,16],b=function(e){return h["gate_mode".concat(e)]||!1},y=function(e){return h["rate".concat(e)]||1},k=function(e){return h["prob".concat(e)]||1},x=function(e){if(e<1){var n=1/e;return Math.abs(n-Math.round(n))<.01?"".concat(Math.round(n)):"".concat(n.toFixed(1))}return 1===e?"1":Math.abs(e-Math.round(e))<.01?"".concat(Math.round(e)):"".concat(e.toFixed(1))},S=function(e,n){u&&u(s.id,e,n)},E=function(e){var n=y(e),t=k(e),o=b(e),c=_===e;return a.createElement("div",{key:e,style:{display:"flex",flexDirection:"column",alignItems:"center",gap:"8px"}},a.createElement("div",{onClick:function(){return g(e)},style:{width:"80px",height:"80px",borderRadius:"50%",border:"3px solid ".concat(c?"#22c55e":"#374151"),background:c?"#064e3b":"#111827",display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",cursor:"pointer",position:"relative",transition:"all 0.2s ease"}},a.createElement("div",{style:{color:"#22c55e",fontSize:"20px",fontWeight:"bold",lineHeight:"1"}},x(n)),t<1&&a.createElement("div",{style:{color:"#f59e0b",fontSize:"12px",fontWeight:"600",lineHeight:"1",marginTop:"2px"}},(100*t).toFixed(0),"%"),a.createElement("div",{style:{position:"absolute",top:"4px",right:"4px",width:"12px",height:"12px",borderRadius:"50%",backgroundColor:o?"#ef4444":"#3b82f6",fontSize:"8px",color:"white",display:"flex",alignItems:"center",justifyContent:"center",fontWeight:"bold"}},o?"G":"C")),a.createElement("div",{style:{color:"#94a3b8",fontSize:"12px",fontWeight:"600"}},"OUT",e))};return a.createElement("div",{style:{position:f?"fixed":"absolute",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(0, 0, 0, 0.9)",zIndex:1e3,display:"flex",alignItems:"flex-start",justifyContent:"center",padding:"20px",overflow:"auto"}},a.createElement("div",{style:{width:"100%",maxWidth:"800px",maxHeight:"calc(100vh - 40px)",backgroundColor:"#1f2937",borderRadius:"12px",padding:"24px",border:"1px solid #374151",overflow:"auto"}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"24px"}},a.createElement("h2",{style:{color:"#8b5cf6",margin:0,fontSize:"24px",fontWeight:"bold"}},"Clock Sequencer"),a.createElement("button",{onClick:d,style:{background:"none",border:"none",color:"#94a3b8",fontSize:"24px",cursor:"pointer",padding:"4px",borderRadius:"4px"}},"X")),(r=h.use_outputs_5_8||!1,a.createElement("div",{style:{marginBottom:"20px",padding:"16px",backgroundColor:"#0f172a",borderRadius:"8px",border:"1px solid #374151"}},a.createElement("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr 1fr",gap:"16px",alignItems:"center"}},a.createElement("div",null,a.createElement("label",{style:{display:"block",color:"#e2e8f0",fontSize:"14px",fontWeight:"600",marginBottom:"8px"}},"BPM: ",h.bpm||120),a.createElement("input",{type:"range",min:"30",max:"300",value:h.bpm||120,onChange:function(e){return S("bpm",parseInt(e.target.value))},style:{width:"100%",accentColor:"#8b5cf6"}})),a.createElement("div",null,a.createElement("label",{style:{display:"block",color:"#e2e8f0",fontSize:"14px",fontWeight:"600",marginBottom:"8px"}},"Swing: ",(100*(h.swing||0)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"0.3",step:"0.01",value:h.swing||0,onChange:function(e){return S("swing",parseFloat(e.target.value))},style:{width:"100%",accentColor:"#f59e0b"}})),a.createElement("div",null,a.createElement("button",{onClick:function(){return S("running",!(!1!==h.running))},style:{width:"100%",padding:"12px",borderRadius:"6px",border:"none",backgroundColor:!1!==h.running?"#22c55e":"#ef4444",color:"white",fontSize:"14px",fontWeight:"600",cursor:"pointer"}},!1!==h.running?"RUNNING":"STOPPED"))),a.createElement("div",{style:{marginTop:"16px",display:"flex",alignItems:"center",gap:"12px",padding:"12px",backgroundColor:"#1f2937",borderRadius:"6px",border:"1px solid #374151"}},a.createElement("input",{type:"checkbox",id:"use_outputs_5_8",checked:r,onChange:function(e){return S("use_outputs_5_8",e.target.checked)},style:{width:"20px",height:"20px",cursor:"pointer",accentColor:"#8b5cf6"}}),a.createElement("label",{htmlFor:"use_outputs_5_8",style:{color:"#e2e8f0",fontSize:"14px",fontWeight:"600",cursor:"pointer",flex:1}},"Enable Outputs 5-8 (uses second bank)"),a.createElement("div",{style:{color:"#94a3b8",fontSize:"12px",padding:"4px 8px",backgroundColor:"#0f172a",borderRadius:"4px"}},"Bank ",h.bank||"Auto",r?" + ".concat((h.bank||1)+1):"")))),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"repeat(4, 1fr)",gap:"20px",justifyItems:"center",marginBottom:"20px",padding:"20px",backgroundColor:"#0f172a",borderRadius:"8px",border:"1px solid #374151"}},[1,2,3,4].map(E),!!h.use_outputs_5_8&&[5,6,7,8].map(E)),(n=y(_),t=k(_),o=h["euclid".concat(_)]||1,c=b(_),a.createElement("div",{style:{marginTop:"20px",padding:"16px",backgroundColor:"#0f172a",borderRadius:"8px",border:"1px solid #374151"}},a.createElement("h3",{style:{color:"#22c55e",margin:"0 0 16px 0",fontSize:"16px",fontWeight:"bold"}},"Output ",_," Controls"),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr",gap:"16px",alignItems:"center"}},a.createElement("div",null,a.createElement("label",{style:{display:"block",color:"#e2e8f0",fontSize:"14px",fontWeight:"600",marginBottom:"8px"}},"Rate: ",x(n)),a.createElement("input",{type:"range",min:"0",max:v.length-1,step:"1",value:function(e){for(var n=0,t=Math.abs(e-v[0]),a=1;a<v.length;a++){var o=Math.abs(e-v[a]);o<t&&(t=o,n=a)}return n}(n),onChange:function(e){var n,t=(n=parseInt(e.target.value),v[n]);S("rate".concat(_),t)},style:{width:"100%",accentColor:"#22c55e"}}),a.createElement("div",{style:{color:"#94a3b8",fontSize:"12px",marginTop:"4px"}},n<1?"Division: 1 trigger every ".concat(Math.round(1/n)," beat").concat(Math.round(1/n)>1?"s":""):1===n?"Clock rate: 1 trigger per beat":"Multiplication: ".concat(Math.round(n)," trigger").concat(Math.round(n)>1?"s":""," per beat"))),a.createElement("div",null,a.createElement("label",{style:{display:"block",color:"#e2e8f0",fontSize:"14px",fontWeight:"600",marginBottom:"8px"}},"Probability: ",(100*t).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:t,onChange:function(e){return S("prob".concat(_),parseFloat(e.target.value))},style:{width:"100%",accentColor:"#f59e0b"}}),a.createElement("div",{style:{color:"#94a3b8",fontSize:"12px",marginTop:"4px"}},1===t?"Always triggers":0===t?"Never triggers":"".concat((100*t).toFixed(0),"% chance to trigger"))),a.createElement("div",null,a.createElement("label",{style:{display:"block",color:"#e2e8f0",fontSize:"14px",fontWeight:"600",marginBottom:"8px"}},"Euclidean Fill: ",o,""),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("button",{onClick:function(){var e=Math.max(1,o-1);S("euclid".concat(_),e)},style:{width:"36px",height:"36px",borderRadius:"6px",border:"none",backgroundColor:"#374151",color:"#e2e8f0",fontSize:"18px",fontWeight:"bold",cursor:"pointer",transition:"all 0.2s ease"}},"-"),a.createElement("input",{type:"number",min:"1",max:"8",value:o,onChange:function(e){var n=parseInt(e.target.value);n>=1&&n<=8&&S("euclid".concat(_),n)},style:{flex:1,padding:"8px",borderRadius:"6px",border:"1px solid #374151",backgroundColor:"#1f2937",color:"#22c55e",fontSize:"16px",fontWeight:"bold",textAlign:"center"}}),a.createElement("button",{onClick:function(){var e=Math.min(8,o+1);S("euclid".concat(_),e)},style:{width:"36px",height:"36px",borderRadius:"6px",border:"none",backgroundColor:"#374151",color:"#e2e8f0",fontSize:"18px",fontWeight:"bold",cursor:"pointer",transition:"all 0.2s ease"}},"+")),a.createElement("div",{style:{color:"#94a3b8",fontSize:"12px",marginTop:"4px"}},1===o?"No subdivision (normal rate)":"Fill button multiplies rate by ".concat(o,""))),a.createElement("div",{style:{gridColumn:"1 / -1",marginTop:"8px"}},a.createElement("button",{onClick:function(){return S("gate_mode".concat(_),!c)},style:{width:"100%",padding:"12px",borderRadius:"6px",border:"none",backgroundColor:c?"#ef4444":"#3b82f6",color:"white",fontSize:"14px",fontWeight:"600",cursor:"pointer",transition:"all 0.2s ease"}},c?"GATE Mode":"CLOCK Mode"),a.createElement("div",{style:{color:"#94a3b8",fontSize:"12px",textAlign:"center",marginTop:"4px"}},c?"Outputs gate pulses":"Outputs clock/toggle signals"))))),a.createElement("div",{style:{marginTop:"20px",padding:"16px",backgroundColor:"#0f172a",borderRadius:"8px",border:"1px solid #374151",color:"#94a3b8",fontSize:"12px",lineHeight:"1.5"}},a.createElement("div",null,a.createElement("strong",{style:{color:"#22c55e"}},"Instructions:")),a.createElement("div",{style:{marginTop:"8px"}}," Click circles to select outputs",a.createElement("br",null)," ",a.createElement("strong",null,"Rate slider:")," Discrete musical intervals - divisions (16, 12, 8, 6, 4, 3, 2), center (1), multiplications (2, 3, 4, 6, 8, 12, 16)",a.createElement("br",null)," ",a.createElement("strong",null,"Triplets:")," 12, 6, 3, 3, 6, 12 for polyrhythmic patterns",a.createElement("br",null)," ",a.createElement("strong",null,"Euclidean fill:")," Set subdivision (1-8), then hold hardware button to multiply rate by this value",a.createElement("br",null)," ",a.createElement("strong",null,"During fill:"),' Hardware pot attenuates probability for expressive "thinning"',a.createElement("br",null)," ",a.createElement("strong",null,"Probability:")," Controls output trigger chance (100% = always, 0% = never)",a.createElement("br",null)," ",a.createElement("strong",null,"Gate mode:")," Outputs pulses (for drums), ",a.createElement("strong",null,"Clock mode:")," Outputs toggles (for sequencers)",a.createElement("br",null)," ",a.createElement("strong",null,"Outputs 5-8:")," Enable checkbox to use second hardware bank (8 channels total)"))))};function jn(e){return function(e){if(Array.isArray(e))return $n(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||Yn(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Kn(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,c,r,i=[],l=!0,s=!1;try{if(c=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=c.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(r=t.return(),Object(r)!==r))return}finally{if(s)throw o}}return i}}(e,n)||Yn(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Yn(e,n){if(e){if("string"==typeof e)return $n(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?$n(e,n):void 0}}function $n(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}var Xn=function(e){var n=e.module,t=e.onUpdateParam,o=e.onClose,c=(0,a.useRef)(null),r=Kn((0,a.useState)(0),2),i=r[0],l=r[1],s=Kn((0,a.useState)("custom"),2),u=s[0],d=s[1],p=Kn((0,a.useState)(!1),2),f=p[0],m=p[1],_=Kn((0,a.useState)(!1),2),g=_[0],h=_[1],v=Kn((0,a.useState)(256),1)[0],b=Kn((0,a.useState)(function(){var e=n.params.wavetables||[];if(0===e.length){for(var t=[],a=0;a<4;a++){var o=new Float32Array(v);if(0===a)for(var c=0;c<v;c++)o[c]=Math.sin(c/v*2*Math.PI);t.push(o)}return t}return e.map(function(e){return e instanceof Float32Array?e:new Float32Array(e)})}),2),y=b[0],k=b[1],x=(0,a.useCallback)(function(e){for(var n=new Float32Array(v),t=0;t<v;t++){var a=t/v*2*Math.PI;switch(e){case"sine":n[t]=Math.sin(a);break;case"saw":n[t]=t/v*2-1;break;case"square":n[t]=t<v/2?1:-1;break;case"triangle":n[t]=t<v/4?t/v*4:t<3*v/4?2-t/v*4:t/v*4-4;break;case"noise":n[t]=2*Math.random()-1;break;case"pulse25":n[t]=t<v/4?1:-1;break;case"pulse12":n[t]=t<v/8?1:-1;break;default:n[t]=0}}return n},[v]),S=(0,a.useCallback)(function(){var e=c.current;if(e){var n=e.getContext("2d"),t=e.width,a=e.height;n.fillStyle="#1e293b",n.fillRect(0,0,t,a),n.strokeStyle="#334155",n.lineWidth=1,n.beginPath(),n.moveTo(0,a/2),n.lineTo(t,a/2),n.stroke();for(var o=0;o<=8;o++)n.beginPath(),n.moveTo(t/8*o,0),n.lineTo(t/8*o,a),n.stroke();var r=y[i];if(r&&0!==r.length){n.strokeStyle="#22c55e",n.lineWidth=2,n.beginPath();for(var l=0;l<v;l++){var s=l/v*t,u=a/2-r[l]*a*.4;0===l?n.moveTo(s,u):n.lineTo(s,u)}if(n.stroke(),g)for(var d=0;d<y.length;d++)if(d!==i){var p=y[d];if(p&&0!==p.length){n.strokeStyle="rgba(148, 163, 184, 0.3)",n.lineWidth=1,n.beginPath();for(var f=0;f<v;f++){var m=f/v*t,_=a/2-p[f]*a*.4;0===f?n.moveTo(m,_):n.lineTo(m,_)}n.stroke()}}for(var h=0;h<4;h++)n.fillStyle=h===i?"#22c55e":"#475569",n.fillRect(10+25*h,10,20,20),n.fillStyle="#fff",n.font="12px monospace",n.textAlign="center",n.fillText((h+1).toString(),20+25*h,24)}}},[y,i,v,g]),E=(0,a.useCallback)(function(e){if("custom"===u){m(!0);var n=c.current,t=n.getBoundingClientRect(),a=n.width/t.width,o=n.height/t.height,r=(e.clientX-t.left)*a,l=(e.clientY-t.top)*o,s=Math.floor(r/n.width*v),d=1-l/n.height*2;if(s>=0&&s<v){var p=jn(y),f=new Float32Array(p[i]);f[s]=Math.max(-1,Math.min(1,d)),p[i]=f,k(p),S()}}},[u,v,y,i,S]),P=(0,a.useCallback)(function(e){if(f&&"custom"===u){var n=c.current,t=n.getBoundingClientRect(),a=n.width/t.width,o=n.height/t.height,r=(e.clientX-t.left)*a,l=(e.clientY-t.top)*o,s=Math.floor(r/n.width*v),d=1-l/n.height*2;if(s>=0&&s<v){var p=jn(y),m=new Float32Array(p[i]);m[s]=Math.max(-1,Math.min(1,d)),s>0&&(m[s-1]=(m[s-1]+d)/2),s<v-1&&(m[s+1]=(m[s+1]+d)/2),p[i]=m,k(p),S()}}},[f,u,v,y,i,S]),w=(0,a.useCallback)(function(){f&&(m(!1),t(n.id,"wavetables",y))},[f,y,n.id,t]),C=(0,a.useCallback)(function(e){var a=x(e),o=jn(y);o[i]=a,k(o),t(n.id,"wavetables",o),S()},[i,y,x,S,n.id,t]),I=(0,a.useCallback)(function(){for(var e=jn(y),a=e[i],o=0,c=0;c<v;c++)o=Math.max(o,Math.abs(a[c]));if(o>0){for(var r=new Float32Array(v),l=0;l<v;l++)r[l]=a[l]/o;e[i]=r}k(e),t(n.id,"wavetables",e),S()},[i,y,v,S,n.id,t]),R=(0,a.useCallback)(function(){for(var e=jn(y),a=e[i],o=new Float32Array(v),c=0;c<v;c++){var r=a[(c-1+v)%v],l=a[c],s=a[(c+1)%v];o[c]=(r+2*l+s)/4}e[i]=o,k(e),t(n.id,"wavetables",e),S()},[i,y,v,S,n.id,t]),L=(0,a.useCallback)(function(){var e=y[i];localStorage.setItem("wavetable_clipboard",JSON.stringify(Array.from(e)))},[i,y]),M=(0,a.useCallback)(function(){var e=localStorage.getItem("wavetable_clipboard");if(e)try{var a=JSON.parse(e),o=jn(y);o[i]=new Float32Array(a),k(o),t(n.id,"wavetables",o),S()}catch(e){console.error("Failed to paste wavetable:",e)}},[i,y,S,n.id,t]);return(0,a.useEffect)(function(){S()},[S,y,i]),(0,a.useEffect)(function(){var e=function(){return S()};return window.addEventListener("resize",e),function(){return window.removeEventListener("resize",e)}},[S]),(0,a.useEffect)(function(){y&&y.length>0&&t(n.id,"wavetables",y)},[y,n.id]),(0,a.useEffect)(function(){var e=function(e){"Escape"===e.key&&o()};return document.addEventListener("keydown",e),function(){return document.removeEventListener("keydown",e)}},[o]),a.createElement("div",{className:"modal-overlay",onClick:o},a.createElement("div",{className:"modal-content wavetable-editor",onClick:function(e){return e.stopPropagation()}},a.createElement("div",{className:"modal-header",style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"12px",paddingBottom:"12px",borderBottom:"1px solid #334155"}},a.createElement("h2",{style:{margin:0,color:"#22c55e",fontSize:"18px"}}," Wavetable Editor - ",n.id),a.createElement("button",{onClick:o,style:{width:"32px",height:"32px",borderRadius:"4px",border:"none",background:"#dc2626",color:"#fff",fontSize:"18px",fontWeight:"bold",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",boxShadow:"0 2px 4px rgba(0, 0, 0, 0.3)"},title:"Close Editor (ESC)"},"")),a.createElement("div",{className:"wavetable-canvas-container"},a.createElement("canvas",{ref:c,width:800,height:300,onMouseDown:E,onMouseMove:P,onMouseUp:w,onMouseLeave:w,style:{cursor:"custom"===u?"crosshair":"default",width:"100%",height:"300px"}})),a.createElement("div",{className:"wavetable-controls"},a.createElement("div",{className:"control-section"},a.createElement("label",null,"Table Slot:"),a.createElement("div",{className:"table-selector"},[0,1,2,3].map(function(e){return a.createElement("button",{key:e,className:"table-btn ".concat(i===e?"active":""),onClick:function(){return l(e)}},e+1)}))),a.createElement("div",{className:"control-section"},a.createElement("label",null,"Presets:"),a.createElement("div",{className:"preset-buttons"},a.createElement("button",{onClick:function(){return C("sine")}},"Sine"),a.createElement("button",{onClick:function(){return C("saw")}},"Saw"),a.createElement("button",{onClick:function(){return C("square")}},"Square"),a.createElement("button",{onClick:function(){return C("triangle")}},"Triangle"),a.createElement("button",{onClick:function(){return C("pulse25")}},"Pulse 25%"),a.createElement("button",{onClick:function(){return C("pulse12")}},"Pulse 12%"),a.createElement("button",{onClick:function(){return C("noise")}},"Noise"))),a.createElement("div",{className:"control-section"},a.createElement("label",null,"Tools:"),a.createElement("div",{className:"tool-buttons"},a.createElement("button",{className:"custom"===u?"active":"",onClick:function(){return d("custom")}},"Draw"),a.createElement("button",{onClick:I},"Normalize"),a.createElement("button",{onClick:R},"Smooth"),a.createElement("button",{onClick:L},"Copy"),a.createElement("button",{onClick:M},"Paste")))),a.createElement("div",{className:"morphing-section"},a.createElement("h3",null,"ADSR Morphing"),a.createElement("div",{className:"morphing-controls"},a.createElement("label",null,a.createElement("input",{type:"checkbox",checked:n.params.adsr_morph||!1,onChange:function(e){return t(n.id,"adsr_morph",e.target.checked)}}),"Enable ADSR Morphing"),n.params.adsr_morph&&a.createElement(a.Fragment,null,a.createElement("div",{className:"morph-mapping"},a.createElement("div",{className:"morph-row"},a.createElement("label",null,"Attack Table:"),a.createElement("select",{value:n.params.attack_table||0,onChange:function(e){return t(n.id,"attack_table",parseInt(e.target.value))}},[0,1,2,3].map(function(e){return a.createElement("option",{key:e,value:e},"Table ",e+1)}))),a.createElement("div",{className:"morph-row"},a.createElement("label",null,"Decay Table:"),a.createElement("select",{value:n.params.decay_table||1,onChange:function(e){return t(n.id,"decay_table",parseInt(e.target.value))}},[0,1,2,3].map(function(e){return a.createElement("option",{key:e,value:e},"Table ",e+1)}))),a.createElement("div",{className:"morph-row"},a.createElement("label",null,"Sustain Table:"),a.createElement("select",{value:n.params.sustain_table||2,onChange:function(e){return t(n.id,"sustain_table",parseInt(e.target.value))}},[0,1,2,3].map(function(e){return a.createElement("option",{key:e,value:e},"Table ",e+1)}))),a.createElement("div",{className:"morph-row"},a.createElement("label",null,"Release Table:"),a.createElement("select",{value:n.params.release_table||3,onChange:function(e){return t(n.id,"release_table",parseInt(e.target.value))}},[0,1,2,3].map(function(e){return a.createElement("option",{key:e,value:e},"Table ",e+1)})))),a.createElement("label",{style:{marginTop:"10px"}},a.createElement("input",{type:"checkbox",checked:g,onChange:function(e){return h(e.target.checked)}}),"Show All Tables (Preview Morphing)")))),"PolyOscillator"===n.type&&a.createElement("div",{className:"fm-section",style:{marginTop:"16px",padding:"12px",backgroundColor:"#0f172a",borderRadius:"8px",border:"1px solid #334155"}},a.createElement("h3",{style:{margin:"0 0 12px 0",color:"#f59e0b",fontSize:"14px",display:"flex",alignItems:"center",gap:"8px"}},"FM Synthesis (2-Op)",a.createElement("span",{style:{fontSize:"10px",color:n.params.fm_enabled?"#22c55e":"#6b7280"}},n.params.fm_enabled?"(Active)":"(Disabled)")),a.createElement("div",{style:{display:"grid",gridTemplateColumns:n.params.fm_enabled?"1fr 1fr":"1fr",gap:"12px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"6px",cursor:"pointer"}},a.createElement("input",{type:"checkbox",checked:n.params.fm_enabled||!1,onChange:function(e){return t(n.id,"fm_enabled",e.target.checked)},style:{width:"16px",height:"16px"}}),a.createElement("span",{style:{color:"#e2e8f0",fontSize:"12px"}},"Enable FM"))),n.params.fm_enabled&&a.createElement(a.Fragment,null,a.createElement("div",null,a.createElement("label",{style:{color:"#94a3b8",fontSize:"11px",display:"block",marginBottom:"4px"}},"Index: ",(n.params.fm_index||0).toFixed(1)),a.createElement("input",{type:"range",min:"0",max:"10",step:"0.1",value:n.params.fm_index||0,onChange:function(e){return t(n.id,"fm_index",parseFloat(e.target.value))},style:{width:"100%"}})),a.createElement("div",null,a.createElement("label",{style:{color:"#94a3b8",fontSize:"11px",display:"block",marginBottom:"4px"}},"Ratio: ",(n.params.fm_ratio||1).toFixed(2),":1"),a.createElement("input",{type:"range",min:"0.5",max:"8",step:"0.01",value:n.params.fm_ratio||1,onChange:function(e){return t(n.id,"fm_ratio",parseFloat(e.target.value))},style:{width:"100%"}})),a.createElement("div",null,a.createElement("label",{style:{color:"#94a3b8",fontSize:"11px",display:"block",marginBottom:"4px"}},"Fine: ",(100*(n.params.fm_ratio_fine||0)).toFixed(1),"%"),a.createElement("input",{type:"range",min:"-0.1",max:"0.1",step:"0.001",value:n.params.fm_ratio_fine||0,onChange:function(e){return t(n.id,"fm_ratio_fine",parseFloat(e.target.value))},style:{width:"100%"}})),a.createElement("div",null,a.createElement("label",{style:{color:"#94a3b8",fontSize:"11px",display:"block",marginBottom:"4px"}},"Env Depth: ",(100*(n.params.fm_env_depth||1)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:n.params.fm_env_depth||1,onChange:function(e){return t(n.id,"fm_env_depth",parseFloat(e.target.value))},style:{width:"100%"}})),a.createElement("div",null,a.createElement("label",{style:{color:"#94a3b8",fontSize:"11px",display:"block",marginBottom:"4px"}},"Mod Amt: ",(n.params.fm_mod_amount||5).toFixed(1)),a.createElement("input",{type:"range",min:"0",max:"10",step:"0.1",value:n.params.fm_mod_amount||5,onChange:function(e){return t(n.id,"fm_mod_amount",parseFloat(e.target.value))},style:{width:"100%"}})))),n.params.fm_enabled&&a.createElement("div",{style:{marginTop:"10px",fontSize:"10px",color:"#6b7280",lineHeight:"1.4"}},a.createElement("strong",null,"Index")," = base amount | ",a.createElement("strong",null,"Mod Amt")," = how much CV adds | Final = Index + (CV  Mod Amt)")),a.createElement("div",{className:"wavetable-info"},a.createElement("p",null,"Table Size: ",v," samples"),a.createElement("p",null,"Click and drag to draw custom waveforms when Draw mode is active"))),a.createElement("style",{jsx:!0},"\n                .wavetable-editor {\n                    width: 900px;\n                    max-width: 90vw;\n                    max-height: 90vh;\n                    overflow-y: auto;\n                }\n                \n                .wavetable-controls {\n                    padding: 20px;\n                    background: #0f172a;\n                    border-radius: 8px;\n                    margin-bottom: 20px;\n                }\n                \n                .control-section {\n                    margin-bottom: 15px;\n                }\n                \n                .control-section label {\n                    display: block;\n                    margin-bottom: 8px;\n                    color: #94a3b8;\n                    font-size: 12px;\n                    text-transform: uppercase;\n                    letter-spacing: 0.5px;\n                }\n                \n                .table-selector {\n                    display: flex;\n                    gap: 10px;\n                }\n                \n                .table-btn {\n                    padding: 8px 16px;\n                    background: #1e293b;\n                    border: 1px solid #334155;\n                    border-radius: 4px;\n                    color: #94a3b8;\n                    cursor: pointer;\n                    transition: all 0.2s;\n                }\n                \n                .table-btn.active {\n                    background: #22c55e;\n                    color: white;\n                    border-color: #22c55e;\n                }\n                \n                .preset-buttons, .tool-buttons {\n                    display: flex;\n                    gap: 8px;\n                    flex-wrap: wrap;\n                }\n                \n                .preset-buttons button, .tool-buttons button {\n                    padding: 6px 12px;\n                    background: #1e293b;\n                    border: 1px solid #334155;\n                    border-radius: 4px;\n                    color: #94a3b8;\n                    cursor: pointer;\n                    font-size: 12px;\n                    transition: all 0.2s;\n                }\n                \n                .preset-buttons button:hover, .tool-buttons button:hover {\n                    background: #334155;\n                    color: white;\n                }\n                \n                .tool-buttons button.active {\n                    background: #3b82f6;\n                    color: white;\n                    border-color: #3b82f6;\n                }\n                \n                .wavetable-canvas-container {\n                    background: #0f172a;\n                    border-radius: 8px;\n                    padding: 20px;\n                    margin-bottom: 20px;\n                }\n                \n                .morphing-section {\n                    background: #0f172a;\n                    border-radius: 8px;\n                    padding: 20px;\n                    margin-bottom: 20px;\n                }\n                \n                .morphing-section h3 {\n                    color: #22c55e;\n                    margin-bottom: 15px;\n                }\n                \n                .morphing-controls label {\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: #94a3b8;\n                    margin-bottom: 10px;\n                }\n                \n                .morph-mapping {\n                    margin-top: 15px;\n                    padding: 15px;\n                    background: #1e293b;\n                    border-radius: 6px;\n                }\n                \n                .morph-row {\n                    display: flex;\n                    align-items: center;\n                    gap: 10px;\n                    margin-bottom: 10px;\n                }\n                \n                .morph-row label {\n                    flex: 0 0 120px;\n                    margin-bottom: 0;\n                }\n                \n                .morph-row select {\n                    flex: 1;\n                    padding: 4px 8px;\n                    background: #0f172a;\n                    border: 1px solid #334155;\n                    border-radius: 4px;\n                    color: white;\n                }\n                \n                .wavetable-info {\n                    padding: 15px;\n                    background: #0f172a;\n                    border-radius: 8px;\n                    color: #64748b;\n                    font-size: 12px;\n                }\n                \n                .wavetable-info p {\n                    margin: 5px 0;\n                }\n            "))};function Zn(e){return Zn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Zn(e)}function Qn(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function Jn(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?Qn(Object(t),!0).forEach(function(n){et(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):Qn(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function et(e,n,t){return(n=function(e){var n=function(e){if("object"!=Zn(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=Zn(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==Zn(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function nt(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,c,r,i=[],l=!0,s=!1;try{if(c=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=c.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(r=t.return(),Object(r)!==r))return}finally{if(s)throw o}}return i}}(e,n)||tt(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function tt(e,n){if(e){if("string"==typeof e)return at(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?at(e,n):void 0}}function at(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}const ot=function(e){var n,t,o,c,r=e.module,i=e.onUpdateParam,l=e.onClose,s=e.fullscreen,u=void 0!==s&&s,d=(0,a.useRef)(null),p=nt((0,a.useState)((null==r||null===(n=r.params)||void 0===n?void 0:n.tuning)||"12-TET"),2),f=p[0],m=p[1],_=nt((0,a.useState)((null==r||null===(t=r.params)||void 0===t?void 0:t.scale)||"major"),2),g=_[0],h=_[1],v=nt((0,a.useState)((null==r||null===(o=r.params)||void 0===o?void 0:o.root_note)||"C"),2),b=v[0],y=v[1],k=nt((0,a.useState)((null==r||null===(c=r.params)||void 0===c?void 0:c.base_octave)||4),2),x=k[0],S=k[1],E=nt((0,a.useState)(!1),2),P=E[0],w=E[1],C=nt((0,a.useState)([]),2),I=C[0],R=C[1],L=nt((0,a.useState)({}),2),M=(L[0],L[1]),D=nt((0,a.useState)(!1),2),A=D[0],O=D[1],B=nt((0,a.useState)(""),2),T=B[0],F=B[1],N=nt((0,a.useState)(null),2),z=N[0],G=N[1],q=nt((0,a.useState)(.5),2),U=q[0],W=q[1],V={"12-TET":{name:"12-Tone Equal Temperament",intervals:[0,100,200,300,400,500,600,700,800,900,1e3,1100],noteNames:["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]},"19-TET":{name:"19-Tone Equal Temperament",intervals:Array.from({length:19},function(e,n){return 1200*n/19}),noteNames:["C","C+","C#","Db-","D","D+","D#","Eb-","E","E+","F","F+","F#","Gb-","G","G+","G#","Ab-","A"]},"24-TET":{name:"24-Tone Equal Temperament (Quarter-tone)",intervals:Array.from({length:24},function(e,n){return 1200*n/24}),noteNames:["C","C","C#","C#","D","D","D#","D#","E","E","F","F","F#","F#","G","G","G#","G#","A","A","A#","A#","B","B"]},"31-TET":{name:"31-Tone Equal Temperament",intervals:Array.from({length:31},function(e,n){return 1200*n/31}),noteNames:Array.from({length:31},function(e,n){return"".concat(n)})},Just:{name:"Just Intonation (5-limit)",intervals:[0,111.73,203.91,315.64,386.31,498.04,590.22,701.96,813.69,884.36,1017.6,1088.27],noteNames:["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]},Pythagorean:{name:"Pythagorean Tuning",intervals:[0,113.69,203.91,294.13,407.82,498.04,611.73,701.96,792.18,905.87,996.09,1109.78],noteNames:["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]}},H={chromatic:{name:"Chromatic (All Notes)",pattern:[0,1,2,3,4,5,6,7,8,9,10,11]},major:{name:"Major (Ionian)",pattern:[0,2,4,5,7,9,11]},minor:{name:"Natural Minor (Aeolian)",pattern:[0,2,3,5,7,8,10]},dorian:{name:"Dorian",pattern:[0,2,3,5,7,9,10]},phrygian:{name:"Phrygian",pattern:[0,1,3,5,7,8,10]},lydian:{name:"Lydian",pattern:[0,2,4,6,7,9,11]},mixolydian:{name:"Mixolydian",pattern:[0,2,4,5,7,9,10]},locrian:{name:"Locrian",pattern:[0,1,3,5,6,8,10]},pentatonic:{name:"Pentatonic Major",pattern:[0,2,4,7,9]},blues:{name:"Blues",pattern:[0,3,5,6,7,10]},harmonic_minor:{name:"Harmonic Minor",pattern:[0,2,3,5,7,8,11]},whole_tone:{name:"Whole Tone",pattern:[0,2,4,6,8,10]}},j=function(e){return(arguments.length>1&&void 0!==arguments[1]?arguments[1]:440)*Math.pow(2,e/1200)},K=function(e,n){var t=n-80,a=440*Math.pow(2,x-4)*Math.pow(2,-.75),o=a,c=2*a,r=Math.log10(o),i=Math.log10(c);return n-40-(Math.log10(e)-r)/(i-r)*t},Y=function(){for(var e=V[f],n=P?{pattern:I}:H[g],t=440*Math.pow(2,x-4),a=[],o=0;o<e.intervals.length;o++){var c=e.intervals[o]-900,r=j(c,t);a.push({freq:r,cents:c,noteIndex:o,octave:x,noteName:e.noteNames[o],inScale:n.pattern.includes(o),isCustom:P})}return a},$=function(){if(0!==I.length)if(T.trim()){var e={name:T.trim(),pattern:I,tuningSystem:f,created:(new Date).toISOString()};M(function(n){return Jn(Jn({},n),{},et({},T.trim(),e))}),H[T.trim()]={name:T.trim()+" (Custom)",pattern:I},h(T.trim()),w(!1),O(!1),F(""),R([]),alert('Scale "'.concat(T.trim(),'" saved successfully!'))}else alert("Please enter a name for your scale!");else alert("Please select some notes first!")},X=function(e,n){i&&r&&i(r.id,e,n)};(0,a.useEffect)(function(){var e=function(e){"Escape"===e.key&&(A?(O(!1),F("")):l())};return document.addEventListener("keydown",e),function(){return document.removeEventListener("keydown",e)}},[l,A]),(0,a.useEffect)(function(){!function(){var e=d.current;if(e){var n=e.getContext("2d"),t=e.width,a=e.height;n.fillStyle="#0c1428",n.fillRect(0,0,t,a);var o=40,c=t-80;n.strokeStyle="#334155",n.fillStyle="#94a3b8",n.font="10px monospace";var r=440*Math.pow(2,x-4)*Math.pow(2,-.75);[Math.round(10*r)/10,Math.round(1.25992*r*10)/10,Math.round(1.49831*r*10)/10,Math.round(2*r*10)/10].forEach(function(e){var c=K(e,a);c>=o&&c<=a-o&&(n.beginPath(),n.moveTo(o,c),n.lineTo(t-o,c),n.stroke(),n.fillText("".concat(e,"Hz"),5,c+3))});var i=o+U*c;n.strokeStyle="#22c55e",n.lineWidth=2,n.beginPath(),n.moveTo(i,o),n.lineTo(i,a-o),n.stroke();var l=Y();l.forEach(function(e,t){var r=o+t/(l.length-1)*c,i=K(e.freq,a);n.strokeStyle="#10b981",n.lineWidth=1,n.beginPath(),n.moveTo(r,o),n.lineTo(r,a-o),n.stroke(),e.inScale?(n.fillStyle="#eab308",n.strokeStyle="#fbbf24"):(n.fillStyle="#10b981",n.strokeStyle="#34d399"),n.lineWidth=2,n.beginPath(),n.arc(r,i,9,0,2*Math.PI),n.fill(),n.stroke(),n.fillStyle=e.inScale?"#eab308":"#10b981",n.font="12px monospace";var s=n.measureText(e.noteName+e.octave).width;n.fillText(e.noteName+e.octave,r-s/2,i-15)}),n.strokeStyle="#22c55e",n.lineWidth=3,n.beginPath();var s=l.filter(function(e){return e.inScale});s.forEach(function(e,t){var r=o+s.indexOf(e)/(s.length-1)*c,i=K(e.freq,a);0===t?n.moveTo(r,i):n.lineTo(r,i)}),n.stroke();var u=Math.floor(U*(s.length-1)),p=s[u];if(p){var f=o+U*c,m=K(p.freq,a);n.fillStyle="#f59e0b",n.beginPath(),n.arc(f,m,6,0,2*Math.PI),n.fill(),n.fillStyle="#f59e0b",n.font="12px monospace",n.fillText("".concat(p.noteName).concat(p.octave,": ").concat(p.freq.toFixed(1),"Hz"),f+10,m-10)}z&&(n.fillStyle="#ffffff",n.font="11px monospace",n.fillText("".concat(z.noteName).concat(z.octave,": ").concat(z.freq.toFixed(1),"Hz (").concat(z.cents.toFixed(1)," cents)"),10,a-10))}}()},[f,g,x,P,I,U,z]),(0,a.useEffect)(function(){X("tuning",f)},[f]),(0,a.useEffect)(function(){X("scale",g)},[g]),(0,a.useEffect)(function(){X("base_octave",x)},[x]),(0,a.useEffect)(function(){X("root_note",b)},[b]);var Z=a.createElement("div",{style:{display:"flex",flexDirection:"column",height:"100%",gap:"12px"}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",paddingBottom:"12px",borderBottom:"1px solid #334155"}},a.createElement("h3",{style:{color:"#22c55e",margin:0,fontSize:"18px"}}," Scale & Tuning Visualizer"),a.createElement("button",{onClick:l,style:{width:"32px",height:"32px",borderRadius:"4px",border:"none",background:"#dc2626",color:"#fff",fontSize:"18px",fontWeight:"bold",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",boxShadow:"0 2px 4px rgba(0, 0, 0, 0.3)"},title:"Close Editor (ESC)"},"")),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr",gap:"16px",marginBottom:"12px"}},a.createElement("div",null,a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Tuning System"),a.createElement("select",{value:f,onChange:function(e){return m(e.target.value)},style:{width:"100%",padding:"6px",borderRadius:"4px",border:"1px solid #334155",background:"#0f172a",color:"#e2e8f0",fontSize:"12px"}},Object.entries(V).map(function(e){var n=nt(e,2),t=n[0],o=n[1];return a.createElement("option",{key:t,value:t},o.name)}))),a.createElement("div",null,P?a.createElement("div",{style:{display:"flex",gap:"4px",marginBottom:"8px"}},a.createElement("button",{onClick:function(){I.length>0?O(!0):alert("Please select some notes first!")},style:{flex:1,padding:"8px",borderRadius:"4px",border:"1px solid #334155",background:I.length>0?"#eab308":"#374151",color:I.length>0?"#0f172a":"#9ca3af",fontSize:"12px",cursor:I.length>0?"pointer":"not-allowed",fontWeight:"bold"},disabled:0===I.length}," Save Scale (",I.length,")"),a.createElement("button",{onClick:function(){w(!1),R([])},style:{padding:"8px 12px",borderRadius:"4px",border:"1px solid #334155",background:"#dc2626",color:"#fff",fontSize:"12px",cursor:"pointer",fontWeight:"bold"}},"")):a.createElement("button",{onClick:function(){w(!0),R([])},style:{width:"100%",padding:"8px",borderRadius:"4px",border:"1px solid #334155",background:"#0f172a",color:"#e2e8f0",fontSize:"12px",cursor:"pointer",fontWeight:"bold",marginBottom:"8px"}}," Create Custom Scale")),!P&&a.createElement("div",null,a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Scale Pattern"),a.createElement("select",{value:g,onChange:function(e){return h(e.target.value)},style:{width:"100%",padding:"6px",borderRadius:"4px",border:"1px solid #334155",background:"#0f172a",color:"#e2e8f0",fontSize:"12px"}},Object.entries(H).map(function(e){var n=nt(e,2),t=n[0],o=n[1];return a.createElement("option",{key:t,value:t},o.name)}))),P&&a.createElement("div",null,a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Custom Scale: ",I.length," notes selected"),a.createElement("div",{style:{padding:"8px",background:"#0f172a",border:"1px solid #334155",borderRadius:"4px",fontSize:"11px",color:"#94a3b8",fontStyle:"italic"}},"Click on green tuning intervals below to build your custom scale. Selected notes will turn yellow."),I.length>0&&a.createElement("div",{style:{marginTop:"4px",fontSize:"11px",color:"#22c55e"}},"Selected intervals: ",I.join(", "))),a.createElement("div",null,a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Root Note"),a.createElement("select",{value:b,onChange:function(e){return y(e.target.value)},style:{width:"100%",padding:"6px",borderRadius:"4px",border:"1px solid #334155",background:"#0f172a",color:"#e2e8f0",fontSize:"12px"}},["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"].map(function(e){return a.createElement("option",{key:e,value:e},e)}))),a.createElement("div",null,a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Base Octave: ",x),a.createElement("input",{type:"range",min:"0",max:"8",value:x,onChange:function(e){return S(parseInt(e.target.value))},style:{width:"100%"}}))),A&&a.createElement("div",{style:{position:"absolute",top:0,left:0,right:0,bottom:0,background:"rgba(0, 0, 0, 1)",display:"flex",alignItems:"center",justifyContent:"center",zIndex:1e3}},a.createElement("div",{style:{background:"#1e293b",border:"1px solid #334155",borderRadius:"8px",padding:"20px",minWidth:"300px",maxWidth:"400px"}},a.createElement("h3",{style:{color:"#e2e8f0",marginTop:0,marginBottom:"16px"}},"Save Custom Scale"),a.createElement("div",{style:{marginBottom:"16px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Scale Name:"),a.createElement("input",{type:"text",value:T,onChange:function(e){return F(e.target.value)},placeholder:"Enter scale name...",style:{width:"100%",padding:"8px",borderRadius:"4px",border:"1px solid #334155",background:"#0f172a",color:"#e2e8f0",fontSize:"14px"},onKeyDown:function(e){"Enter"===e.key?$():"Escape"===e.key&&(O(!1),F(""))},autoFocus:!0})),a.createElement("div",{style:{marginBottom:"16px",fontSize:"12px",color:"#94a3b8"}},a.createElement("div",null,"Tuning System: ",a.createElement("span",{style:{color:"#22c55e"}},V[f].name)),a.createElement("div",null,"Selected Notes: ",a.createElement("span",{style:{color:"#eab308"}},I.join(", ")))),a.createElement("div",{style:{display:"flex",gap:"8px"}},a.createElement("button",{onClick:$,style:{flex:1,padding:"8px 16px",borderRadius:"4px",border:"1px solid #334155",background:"#22c55e",color:"#0f172a",fontSize:"12px",cursor:"pointer",fontWeight:"bold"}}," Save Scale"),a.createElement("button",{onClick:function(){O(!1),F("")},style:{padding:"8px 16px",borderRadius:"4px",border:"1px solid #334155",background:"#374151",color:"#e2e8f0",fontSize:"12px",cursor:"pointer"}},"Cancel")))),a.createElement("div",{style:{flex:1,border:"1px solid #334155",borderRadius:"8px",overflow:"hidden",minHeight:"400px"}},a.createElement("canvas",{ref:d,width:800,height:400,onMouseMove:function(e){var n=d.current,t=n.getBoundingClientRect(),a=n.width/t.width,o=n.height/t.height,c=(e.clientX-t.left)*a,r=(e.clientY-t.top)*o,i=n.width-80;if(c>=40&&c<=n.width-40){var l=(c-40)/i;W(Math.max(0,Math.min(1,l)))}var s=Y(),u=null,p=1/0;s.forEach(function(e,t){var a=40+t/(s.length-1)*i,o=K(e.freq,n.height),l=Math.sqrt(Math.pow(c-a,2)+Math.pow(r-o,2));l<15&&l<p&&(p=l,u=e)}),G(u)},onClick:function(e){if(P){var n=d.current,t=n.getBoundingClientRect(),a=n.width/t.width,o=n.height/t.height,c=(e.clientX-t.left)*a,r=(e.clientY-t.top)*o,i=n.width-80,l=Y(),s=null,u=1/0;if(l.forEach(function(e,t){var a=40+t/(l.length-1)*i,o=K(e.freq,n.height),d=Math.sqrt(Math.pow(c-a,2)+Math.pow(r-o,2));d<20&&d<u&&(u=d,s=e)}),s){var p=s.noteIndex;I.includes(p)?R(function(e){return e.filter(function(e){return e!==p})}):R(function(e){return[].concat((n=e,function(e){if(Array.isArray(e))return at(e)}(n)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(n)||tt(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),[p]).sort(function(e,n){return e-n});var n})}}},style:{width:"100%",height:"100%",display:"block",cursor:P?"pointer":"crosshair"}})),a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",display:"flex",gap:"16px",flexWrap:"wrap"}},a.createElement("span",null," ",a.createElement("span",{style:{color:"#10b981"}},"Tuning System Intervals")),a.createElement("span",null," ",a.createElement("span",{style:{color:"#eab308"}},"Scale Notes")),a.createElement("span",null," ",a.createElement("span",{style:{color:"#22c55e"}},"S&H Input Position")),z&&a.createElement("span",null," ",a.createElement("span",{style:{color:"#22c55e"}},z.noteName,z.octave,": ",Math.round(10*z.freq)/10,"Hz"))));return u?a.createElement("div",{className:"modal-overlay"},a.createElement("div",{className:"modal-content",style:{maxWidth:"95vw",maxHeight:"90vh"}},Z)):Z},ct=function(e){var n=e.module,t=e.modules,o=e.onUpdateParam,c=e.onClose,r=e.fullscreen;return a.createElement(Sn,{module:n,modules:t,onUpdateParam:o,onClose:c,fullscreen:r})};function rt(e){return rt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},rt(e)}function it(e){return function(e){if(Array.isArray(e))return ft(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||pt(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function lt(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function st(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?lt(Object(t),!0).forEach(function(n){ut(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):lt(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function ut(e,n,t){return(n=function(e){var n=function(e){if("object"!=rt(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=rt(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==rt(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function dt(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,c,r,i=[],l=!0,s=!1;try{if(c=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=c.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(r=t.return(),Object(r)!==r))return}finally{if(s)throw o}}return i}}(e,n)||pt(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function pt(e,n){if(e){if("string"==typeof e)return ft(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?ft(e,n):void 0}}function ft(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}const mt=function(e){var n=e.module,t=(e.modules,e.onUpdateParam),o=e.onClose,c=e.fullscreen,r=dt((0,a.useState)(void 0!==n.params.harmonic_linking&&n.params.harmonic_linking),2),i=r[0],l=r[1],s=dt((0,a.useState)(n.params.harmonic_follow_steps||[-1,-1,-1,-1]),2),u=s[0],d=s[1],p=dt((0,a.useState)(n.params.harmonic_intervals||[7,7,7,7]),2),f=p[0],m=p[1];(0,a.useEffect)(function(){console.log("HarmonicSequencer module.params changed:",n.params);var e,t=n.params.bank0_steps;t&&console.log("bank0_steps step 0 pitchRandomness:",null===(e=t[0])||void 0===e?void 0:e.pitchRandomness)},[n.params]);var _,g,h,v,b,y,k,x=dt((0,a.useState)(n.params.show_individual_outputs||!1),2),S=x[0],E=x[1],P=function(){return(n.params.steps||[{pitch:0,duration:1,muted:!1,active:!0,pattern:"static",interval:2,probability:.5},{pitch:.25,duration:1,muted:!1,active:!0,pattern:"up_down",interval:3,probability:.7},{pitch:.5,duration:1,muted:!1,active:!0,pattern:"chord",interval:4,probability:.8},{pitch:.75,duration:1,muted:!1,active:!0,pattern:"static",interval:1,probability:.3}]).map(function(e){return st(st({},e),{},{pitchRandomness:void 0!==e.pitchRandomness?e.pitchRandomness:0,probability:void 0!==e.probability?e.probability:1,patternProbability:void 0!==e.patternProbability?e.patternProbability:1,pattern:e.pattern||"static",interval:void 0!==e.interval?e.interval:2,glissando_time:void 0!==e.glissando_time?e.glissando_time:0,glissando_probability:void 0!==e.glissando_probability?e.glissando_probability:0,glissando_curve:void 0!==e.glissando_curve?e.glissando_curve:"linear"})})},w=function(e,a){var o=it(P());o[e]=st(st({},o[e]),a),console.log("updateStep: step ".concat(e,", updates:"),a),console.log("newSteps[stepIndex]:",o[e]),t(n.id,"steps",o)},C=function(e,n){var t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];console.log("updateStepPitch: step=".concat(e,", pitch=").concat(n));var a=Math.max(0,Math.min(1,n));if(w(e,{pitch:a}),t&&i&&e===harmonicMasterStep){var o=Math.round(12*a);harmonicSlaveSteps.forEach(function(e,n){if(e&&n!==harmonicMasterStep){var t=(o+harmonicInterval)%12/12;w(n,{pitch:Math.max(0,Math.min(1,t))}),console.log("Harmonic link: Step ".concat(harmonicMasterStep+1,"").concat(n+1,", interval=").concat(harmonicInterval," semitones, slavePitch=").concat(t.toFixed(3)))}})}};return a.createElement("div",{style:{position:c?"fixed":"absolute",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(0, 0, 0, 0.9)",zIndex:1e3,display:"flex",alignItems:"flex-start",justifyContent:"center",padding:"40px 20px 20px 20px",overflow:"auto"}},a.createElement("div",{style:{width:"100%",maxWidth:"800px",maxHeight:"calc(100vh - 40px)",backgroundColor:"#0f172a",border:"1px solid #3b82f6",borderRadius:"8px",color:"#e2e8f0",padding:"20px",overflow:"auto"}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"20px"}},a.createElement("h3",{style:{margin:0,color:"#3b82f6"}},"Harmonic Sequencer"),a.createElement("div",{style:{display:"flex",gap:"8px"}},o&&a.createElement("button",{onClick:o,style:{padding:"4px 8px",backgroundColor:"#6b7280",color:"white",border:"none",borderRadius:"4px",cursor:"pointer",fontSize:"12px"}},""))),(h=P(),a.createElement("div",{style:{marginBottom:"20px"}},a.createElement("div",{style:{marginBottom:"20px"}},a.createElement("div",{style:{padding:"16px",backgroundColor:"#1e293b",border:"2px solid #3b82f6",borderRadius:"8px"}},a.createElement("div",{style:{marginBottom:"12px",fontSize:"16px",fontWeight:"bold",color:"#3b82f6"}},"Sequencer Controls"),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"repeat(4, 1fr)",gap:"12px"}},a.createElement("div",null,a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Clock Div: 1/",n.params.clock_div||4),a.createElement("input",{type:"range",min:"1",max:"16",value:n.params.clock_div||4,onChange:function(e){return t(n.id,"clock_div",parseInt(e.target.value))},style:{width:"100%"}})),a.createElement("div",null,a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Gate: ",(100*(n.params.gate_length||.7)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0.1",max:"0.9",step:"0.05",value:n.params.gate_length||.7,onChange:function(e){return t(n.id,"gate_length",parseFloat(e.target.value))},style:{width:"100%"}})),a.createElement("div",null,a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Mode: ",n.params.playback_mode||"iteration"),a.createElement("select",{value:n.params.playback_mode||"iteration",onChange:function(e){return t(n.id,"playback_mode",e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"iteration"},"Iteration (active steps only)"),a.createElement("option",{value:"rest"},"Rest (linear 4 steps)"),a.createElement("option",{value:"reverse"},"Reverse (active steps reversed)"))),a.createElement("div",null,a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"BPM: ",n.params.bpm||120),a.createElement("input",{type:"range",min:"60",max:"200",value:n.params.bpm||120,onChange:function(e){return t(n.id,"bpm",parseInt(e.target.value))},style:{width:"100%",accentColor:"#8b5cf6"}}),a.createElement("div",{style:{color:"#6b7280",fontSize:"10px",marginTop:"2px",textAlign:"center"}},"Auto: Internal when no clock input")),a.createElement("div",null,a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"flex",alignItems:"center",gap:"8px",cursor:"pointer",padding:"4px 0"}},a.createElement("input",{type:"checkbox",checked:i,onChange:function(e){var a=e.target.checked;l(a),t(n.id,"harmonic_linking",a)},style:{accentColor:"#8b5cf6"}}),a.createElement("span",null,"Harmonic Linking")),a.createElement("div",{style:{color:"#6b7280",fontSize:"10px",marginTop:"2px"}},"Master step controls slave steps")),a.createElement("div",null,a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"flex",alignItems:"center",gap:"8px",cursor:"pointer",padding:"4px 0"}},a.createElement("input",{type:"checkbox",checked:n.params.pattern_enabled||!1,onChange:function(e){t(n.id,"pattern_enabled",e.target.checked)},style:{accentColor:"#f59e0b"}}),a.createElement("span",null,"Melodic Patterns")),a.createElement("div",{style:{color:"#6b7280",fontSize:"10px",marginTop:"2px"}},"Patterns around pot position with intervals"))))),a.createElement("div",{style:{marginBottom:"12px",fontSize:"14px",fontWeight:"bold",color:"#e2e8f0"}},"4 Steps"),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"repeat(4, 1fr)",gap:"12px"}},h.map(function(e,o){return a.createElement("div",{key:o,style:{padding:"12px",backgroundColor:e.active?"#1e293b":"#111827",border:"2px solid",borderColor:e.active?"#3b82f6":"#374151",borderRadius:"8px",position:"relative",opacity:e.muted?.5:1}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"8px"}},a.createElement("div",{style:{fontSize:"12px",fontWeight:"bold",color:"#e2e8f0"}},"Step ",o+1),a.createElement("div",{style:{display:"flex",gap:"4px"}},a.createElement("button",{onClick:function(){return function(e){var a=P(),o=!a[e].active;w(e,{active:o});var c=a.filter(function(e){return e.active}).length;t(n.id,"sequence_length",Math.max(1,c))}(o)},style:{width:"16px",height:"16px",backgroundColor:e.active?"#10b981":"#6b7280",border:"none",borderRadius:"2px",cursor:"pointer"},title:e.active?"Step active":"Step inactive"}),a.createElement("button",{onClick:function(){return function(e){var n=!P()[e].muted;w(e,{muted:n})}(o)},style:{width:"16px",height:"16px",backgroundColor:e.muted?"#ef4444":"#6b7280",border:"none",borderRadius:"2px",cursor:"pointer"},title:e.muted?"Step muted":"Step unmuted"}))),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Pitch: ",(100*e.pitch).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:e.pitch,onChange:function(n){console.log("Pitch slider onChange: ".concat(n.target.value,", current step.pitch: ").concat(e.pitch)),C(o,parseFloat(n.target.value))},onInput:function(n){console.log("Pitch slider onInput: ".concat(n.target.value,", current step.pitch: ").concat(e.pitch)),C(o,parseFloat(n.target.value))},style:{width:"100%",height:"4px",backgroundColor:"#374151",borderRadius:"2px",outline:"none"}})),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Duration: ",e.duration.toFixed(2),""),a.createElement("input",{type:"range",min:"0.25",max:"4",step:"0.25",value:e.duration,onChange:function(e){return function(e,n){console.log("updateStepDuration: step=".concat(e,", duration=").concat(n)),w(e,{duration:Math.max(.25,Math.min(4,n))})}(o,parseFloat(e.target.value))},style:{width:"100%",height:"4px",backgroundColor:"#374151",borderRadius:"2px",outline:"none"}})),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Pitch Random: ",(100*(e.pitchRandomness||0)).toFixed(0),"% (val: ",e.pitchRandomness,")"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:e.pitchRandomness||0,onChange:function(e){console.log("Pitch randomness slider onChange: ".concat(e.target.value)),function(e,n){console.log("updateStepPitchRandomness: step=".concat(e,", randomness=").concat(n)),w(e,{pitchRandomness:Math.max(0,Math.min(1,n))})}(o,parseFloat(e.target.value))},style:{width:"100%",height:"20px",backgroundColor:"#374151",borderRadius:"2px",outline:"none",cursor:"pointer",appearance:"auto"}})),n.params.pattern_enabled&&a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Pattern: ",e.pattern||"static"),a.createElement("select",{value:e.pattern||"static",onChange:function(e){var n=e.target.value;w(o,{pattern:n})},style:{width:"100%",padding:"2px 4px",backgroundColor:"#374151",color:"#d1d5db",border:"1px solid #4b5563",borderRadius:"4px",fontSize:"10px"}},a.createElement("option",{value:"static"},"Static"),a.createElement("option",{value:"up_down"},"Up/Down Alt"),a.createElement("option",{value:"chord"},"Chord Arpegg"),a.createElement("option",{value:"random"},"Random Jump"),a.createElement("option",{value:"octave"},"Octave Jump"),a.createElement("option",{value:"fifth"},"Fifth Jump")),e.pattern&&"static"!==e.pattern&&"chord"!==e.pattern&&a.createElement(a.Fragment,null,a.createElement("div",{style:{marginTop:"4px"}},a.createElement("label",{style:{fontSize:"9px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Interval: ",e.interval||2," semitones"),a.createElement("input",{type:"range",min:"1",max:"12",step:"1",value:e.interval||2,onChange:function(e){w(o,{interval:parseInt(e.target.value)})},style:{width:"100%",height:"3px",backgroundColor:"#374151",borderRadius:"2px",outline:"none"}})),a.createElement("div",{style:{marginTop:"4px"}},a.createElement("label",{style:{fontSize:"9px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Pattern Prob: ",(100*(e.patternProbability||1)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.05",value:e.patternProbability||1,onChange:function(e){!function(e,n){console.log("updateStepPatternProbability: step=".concat(e,", patternProbability=").concat(n)),w(e,{patternProbability:Math.max(0,Math.min(1,n))})}(o,parseFloat(e.target.value))},style:{width:"100%",height:"3px",backgroundColor:"#374151",borderRadius:"2px",outline:"none"}}))),"chord"===e.pattern&&a.createElement("div",{style:{marginTop:"8px",padding:"8px",backgroundColor:"#1f2937",borderRadius:"4px",border:"1px solid #374151"}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"4px",fontWeight:"bold"}},"Chord Intervals (semitones from root)"),a.createElement("div",{style:{marginBottom:"6px"}},a.createElement("label",{style:{fontSize:"9px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Presets:"),a.createElement("div",{style:{display:"flex",gap:"4px",flexWrap:"wrap"}},[{name:"Maj",intervals:[0,4,7]},{name:"Min",intervals:[0,3,7]},{name:"Dim",intervals:[0,3,6]},{name:"Aug",intervals:[0,4,8]},{name:"Maj7",intervals:[0,4,7,11]},{name:"Min7",intervals:[0,3,7,10]},{name:"Dom7",intervals:[0,4,7,10]},{name:"Maj9",intervals:[0,4,7,11,14]},{name:"Min9",intervals:[0,3,7,10,14]}].map(function(e){return a.createElement("button",{key:e.name,onClick:function(){w(o,{chordIntervals:e.intervals})},style:{padding:"2px 6px",backgroundColor:"#374151",color:"#d1d5db",border:"1px solid #4b5563",borderRadius:"3px",fontSize:"9px",cursor:"pointer"},onMouseEnter:function(e){return e.target.style.backgroundColor="#4b5563"},onMouseLeave:function(e){return e.target.style.backgroundColor="#374151"}},e.name)}))),a.createElement("div",{style:{marginBottom:"6px"}},a.createElement("label",{style:{fontSize:"9px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Custom: [",(e.chordIntervals||[0,4,7]).join(", "),"]"),a.createElement("input",{type:"text",value:(e.chordIntervals||[0,4,7]).join(", "),onChange:function(e){var n=e.target.value.split(",").map(function(e){var n=parseInt(e.trim());return isNaN(n)?0:Math.max(-12,Math.min(24,n))}).filter(function(e){return!isNaN(e)});n.length>0&&w(o,{chordIntervals:n})},placeholder:"0, 4, 7",style:{width:"100%",padding:"2px 4px",backgroundColor:"#111827",color:"#d1d5db",border:"1px solid #374151",borderRadius:"3px",fontSize:"9px",fontFamily:"monospace"}})),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"6px"}},a.createElement("input",{type:"checkbox",id:"diatonic-".concat(o),checked:!1!==e.chordDiatonic,onChange:function(e){w(o,{chordDiatonic:e.target.checked})},style:{cursor:"pointer"}}),a.createElement("label",{htmlFor:"diatonic-".concat(o),style:{fontSize:"9px",color:"#9ca3af",cursor:"pointer"}},"Diatonic (scale-aware)")))),a.createElement("div",null,a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Step Prob: ",(100*(e.probability||1)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:e.probability||1,onChange:function(e){console.log("Probability slider onChange: ".concat(e.target.value)),function(e,n){console.log("updateStepProbability: step=".concat(e,", probability=").concat(n)),w(e,{probability:Math.max(0,Math.min(1,n))})}(o,parseFloat(e.target.value))},style:{width:"100%",height:"20px",backgroundColor:"#374151",borderRadius:"2px",outline:"none",cursor:"pointer",appearance:"auto"}})),i&&a.createElement("div",{style:{marginTop:"8px"}},a.createElement("div",{style:{display:"flex",gap:"8px"}},a.createElement("div",{style:{flex:1}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Follows: ",-1===u[o]?"None":"Step ".concat(u[o]+1)),a.createElement("select",{value:u[o],onChange:function(e){var a=it(u);a[o]=parseInt(e.target.value),d(a),t(n.id,"harmonic_follow_steps",a)},style:{width:"100%",padding:"2px 4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"10px"}},a.createElement("option",{value:-1},"None"),function(e){return[0,1,2,3].filter(function(n){return n!==e&&!function(e,n){if(-1===n)return!1;if(n===e)return!0;for(var t=new Set,a=n;-1!==a&&!t.has(a);){if(t.add(a),a===e)return!0;a=u[a]}return!1}(e,n)})}(o).map(function(e){return a.createElement("option",{key:e,value:e},"Step ",e+1)}))),a.createElement("div",{style:{flex:1}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Interval: ",7===f[o]?"+5th":5===f[o]?"+4th":12===f[o]?"+Oct":-7===f[o]?"-5th":"".concat(f[o]>0?"+":"").concat(f[o])),a.createElement("select",{value:f[o],onChange:function(e){var a=it(f);a[o]=parseInt(e.target.value),m(a),t(n.id,"harmonic_intervals",a)},disabled:-1===u[o],style:{width:"100%",padding:"2px 4px",backgroundColor:-1===u[o]?"#4b5563":"#374151",color:-1===u[o]?"#9ca3af":"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"10px"}},a.createElement("option",{value:-12},"-Octave"),a.createElement("option",{value:-7},"-5th"),a.createElement("option",{value:-5},"-4th"),a.createElement("option",{value:-4},"-M3rd"),a.createElement("option",{value:-3},"-m3rd"),a.createElement("option",{value:0},"Unison"),a.createElement("option",{value:3},"+m3rd"),a.createElement("option",{value:4},"+M3rd"),a.createElement("option",{value:5},"+4th"),a.createElement("option",{value:7},"+5th"),a.createElement("option",{value:12},"+Octave"))))),a.createElement("div",null,a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Gliss Time: ",(100*(e.glissando_time||0)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:e.glissando_time||0,onChange:function(e){console.log("Glissando time slider onChange: ".concat(e.target.value)),function(e,n){console.log("updateStepGlissandoTime: step=".concat(e,", time=").concat(n)),w(e,{glissando_time:Math.max(0,Math.min(1,n))})}(o,parseFloat(e.target.value))},style:{width:"100%",height:"20px",backgroundColor:"#374151",borderRadius:"2px",outline:"none",cursor:"pointer",appearance:"auto"}})),a.createElement("div",null,a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Gliss Prob: ",(100*(e.glissando_probability||0)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:e.glissando_probability||0,onChange:function(e){console.log("Glissando probability slider onChange: ".concat(e.target.value)),function(e,n){console.log("updateStepGlissandoProbability: step=".concat(e,", probability=").concat(n)),w(e,{glissando_probability:Math.max(0,Math.min(1,n))})}(o,parseFloat(e.target.value))},style:{width:"100%",height:"20px",backgroundColor:"#374151",borderRadius:"2px",outline:"none",cursor:"pointer",appearance:"auto"}})),a.createElement("div",null,a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Gliss Curve: ",e.glissando_curve||"linear"),a.createElement("select",{value:e.glissando_curve||"linear",onChange:function(e){console.log("Glissando curve select onChange: ".concat(e.target.value)),function(e,n){console.log("updateStepGlissandoCurve: step=".concat(e,", curve=").concat(n)),w(e,{glissando_curve:n})}(o,e.target.value)},style:{width:"100%",padding:"4px 8px",backgroundColor:"#374151",color:"#e2e8f0",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"11px"}},a.createElement("option",{value:"linear"},"Linear"),a.createElement("option",{value:"exponential"},"Exponential"),a.createElement("option",{value:"logarithmic"},"Logarithmic"))))})))),(_={chromatic:{name:"Chromatic (12 notes)",intervals:[0,1,2,3,4,5,6,7,8,9,10,11]},major:{name:"Major",intervals:[0,2,4,5,7,9,11]},minor:{name:"Natural Minor",intervals:[0,2,3,5,7,8,10]},dorian:{name:"Dorian",intervals:[0,2,3,5,7,9,10]},phrygian:{name:"Phrygian",intervals:[0,1,3,5,7,8,10]},lydian:{name:"Lydian",intervals:[0,2,4,6,7,9,11]},mixolydian:{name:"Mixolydian",intervals:[0,2,4,5,7,9,10]},pentatonic_major:{name:"Pentatonic Major",intervals:[0,2,4,7,9]},pentatonic_minor:{name:"Pentatonic Minor",intervals:[0,3,5,7,10]},blues:{name:"Blues Scale",intervals:[0,3,5,6,7,10]},wholetone:{name:"Whole Tone",intervals:[0,2,4,6,8,10]},diminished:{name:"Diminished",intervals:[0,2,3,5,6,8,9,11]}},g=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"],a.createElement("div",{style:{marginBottom:"20px"}},a.createElement("div",{style:{padding:"16px",backgroundColor:"#1e293b",border:"2px solid #8b5cf6",borderRadius:"8px"}},a.createElement("div",{style:{marginBottom:"12px",fontSize:"16px",fontWeight:"bold",color:"#8b5cf6"}},"Musical Scale System"),a.createElement("div",{style:{marginBottom:"16px",fontSize:"12px",color:"#94a3b8",fontStyle:"italic"}},"Step pitches are automatically quantized to musical intervals"),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr 1fr",gap:"16px"}},a.createElement("div",null,a.createElement("label",{style:{fontSize:"14px",color:"#e2e8f0",display:"block",marginBottom:"8px",fontWeight:"bold"}},"Scale"),a.createElement("select",{value:n.params.quantization_scale||"major",onChange:function(e){return t(n.id,"quantization_scale",e.target.value)},style:{width:"100%",padding:"8px 12px",backgroundColor:"#374151",color:"#e2e8f0",border:"2px solid #6b7280",borderRadius:"6px",fontSize:"13px"}},Object.entries(_).map(function(e){var n=dt(e,2),t=n[0],o=n[1];return a.createElement("option",{key:t,value:t},o.name)}))),a.createElement("div",null,a.createElement("label",{style:{fontSize:"14px",color:"#e2e8f0",display:"block",marginBottom:"8px",fontWeight:"bold"}},"Root Note"),a.createElement("select",{value:n.params.quantization_root||"C",onChange:function(e){return t(n.id,"quantization_root",e.target.value)},style:{width:"100%",padding:"8px 12px",backgroundColor:"#374151",color:"#e2e8f0",border:"2px solid #6b7280",borderRadius:"6px",fontSize:"13px"}},g.map(function(e){return a.createElement("option",{key:e,value:e},e)}))),a.createElement("div",null,a.createElement("label",{style:{fontSize:"14px",color:"#e2e8f0",display:"block",marginBottom:"8px",fontWeight:"bold"}},"Tuning System"),a.createElement("select",{value:n.params.quantization_tuning||"12tet",onChange:function(e){return t(n.id,"quantization_tuning",e.target.value)},style:{width:"100%",padding:"8px 12px",backgroundColor:"#374151",color:"#e2e8f0",border:"2px solid #6b7280",borderRadius:"6px",fontSize:"13px"}},Object.entries({"12tet":{name:"12TET (Equal Temperament)",cents:100},just:{name:"Just Intonation",cents:null},pythagorean:{name:"Pythagorean",cents:null},quarter_tone:{name:"Quarter Tone (24TET)",cents:50},gamelan5:{name:"Gamelan Slendro (5-tone)",cents:240},gamelan7:{name:"Gamelan Pelog (7-tone)",cents:null}}).map(function(e){var n=dt(e,2),t=n[0],o=n[1];return a.createElement("option",{key:t,value:t},o.name)}))),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"4px",flex:"1"}},a.createElement("label",{style:{fontSize:"11px",fontWeight:"600",color:"#9ca3af",textTransform:"uppercase",letterSpacing:"0.5px"}},"Center Octave"),a.createElement("select",{value:n.params.octave_center||4,onChange:function(e){return t(n.id,"octave_center",parseInt(e.target.value))},style:{width:"100%",padding:"8px 12px",backgroundColor:"#374151",color:"#e2e8f0",border:"2px solid #6b7280",borderRadius:"6px",fontSize:"13px"}},a.createElement("option",{value:2},"Octave 2 (C2-C3)"),a.createElement("option",{value:3},"Octave 3 (C3-C4)"),a.createElement("option",{value:4},"Octave 4 (C4-C5)"),a.createElement("option",{value:5},"Octave 5 (C5-C6)"),a.createElement("option",{value:6},"Octave 6 (C6-C7)")))),a.createElement("div",{style:{marginTop:"12px",padding:"12px",backgroundColor:"#0f172a",borderRadius:"6px"}},a.createElement("div",{style:{fontSize:"12px",fontWeight:"bold",color:"#8b5cf6",marginBottom:"8px"}},"Scale Preview:"),a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8"}},(v=_[n.params.quantization_scale||"major"],b=n.params.quantization_root||"C",y=g.indexOf(b),k=v.intervals.map(function(e){return g[(y+e)%12]}),"".concat(b," ").concat((n.params.quantization_scale||"major").replace("_"," "),": ").concat(k.join(" - ")))))))),a.createElement("div",{style:{marginBottom:"20px"}},a.createElement("div",{style:{marginBottom:"12px",fontSize:"14px",fontWeight:"bold",color:"#e2e8f0"}},"Output Configuration"),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px",marginBottom:"8px"}},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"6px",fontSize:"12px",color:"#d1d5db"}},a.createElement("input",{type:"checkbox",checked:S,onChange:function(e){var a=e.target.checked;E(a),t(n.id,"show_individual_outputs",a),t(n.id,"individual_outputs_enabled",a)}}),"Show Individual Step Outputs")),S&&a.createElement("div",{style:{padding:"12px",backgroundColor:"#111827",borderRadius:"6px",fontSize:"11px",color:"#9ca3af"}},a.createElement("div",{style:{marginBottom:"8px",fontWeight:"bold",color:"#d1d5db"}},"Individual Step Outputs:"),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"repeat(4, 1fr)",gap:"8px"}},Array.from({length:16},function(e,n){return a.createElement("div",{key:n,style:{textAlign:"center"}},a.createElement("div",null,"Step ",n+1),a.createElement("div",{style:{fontSize:"9px"}},"pitch_step",n+1),a.createElement("div",{style:{fontSize:"9px"}},"gate_step",n+1))})))),a.createElement("div",{style:{marginTop:"20px",padding:"12px",backgroundColor:"#1e293b",borderRadius:"6px",fontSize:"11px",color:"#94a3b8"}},a.createElement("div",{style:{fontWeight:"bold",marginBottom:"6px",color:"#e2e8f0"}},"Hardware Control:"),a.createElement("ul",{style:{margin:0,paddingLeft:"16px"}},a.createElement("li",null,"Knobs control pitch for each step in current bank"),a.createElement("li",null,"Buttons toggle step active/inactive (short press) or mute (long press)"),a.createElement("li",null,"Hold button + turn knob to adjust step duration"),a.createElement("li",null,"Encoder navigates banks, encoder button starts/stops"),a.createElement("li",null,"Hold multiple buttons for loop regions")))))};function _t(e){return _t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},_t(e)}function gt(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function ht(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?gt(Object(t),!0).forEach(function(n){vt(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):gt(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function vt(e,n,t){return(n=function(e){var n=function(e){if("object"!=_t(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=_t(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==_t(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}const bt=function(e){var n=e.module,t=(e.modules,e.onUpdateParam),o=e.onClose,c=e.fullscreen,r=n.params||{},i=function(e,a){t(n.id,e,a)},l=c?{position:"fixed",top:0,left:0,right:0,bottom:0,backgroundColor:"#0f172a",zIndex:2e3,display:"flex",flexDirection:"column",padding:"20px",overflowY:"auto"}:{backgroundColor:"#1e293b",borderRadius:"8px",padding:"16px",color:"#e2e8f0"},s={fontSize:c?"24px":"18px",fontWeight:"600",color:"#f1f5f9"},u={marginBottom:"24px",padding:"16px",backgroundColor:"#1e293b",borderRadius:"8px",border:"1px solid #334155"},d={fontSize:"14px",fontWeight:"600",color:"#94a3b8",marginBottom:"12px",textTransform:"uppercase",letterSpacing:"0.5px"},p={display:"grid",gridTemplateColumns:"repeat(auto-fit, minmax(200px, 1fr))",gap:"16px",marginBottom:"12px"},f={display:"flex",flexDirection:"column",gap:"6px"},m={fontSize:"12px",color:"#cbd5e1",fontWeight:"500"},_={backgroundColor:"#0f172a",border:"1px solid #334155",borderRadius:"4px",padding:"8px",color:"#e2e8f0",fontSize:"13px",outline:"none"},g=ht(ht({},_),{},{cursor:"pointer"}),h={fontSize:"10px",color:"#64748b",fontStyle:"italic",marginTop:"4px"};return a.createElement("div",{style:l},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"20px",paddingBottom:"12px",borderBottom:"1px solid #334155"}},a.createElement("div",{style:s},"Drum Designer"),o&&a.createElement("button",{style:{background:"#334155",border:"none",borderRadius:"4px",padding:"8px 16px",color:"#e2e8f0",cursor:"pointer",fontSize:"14px"},onClick:o},c?"Close":"")),a.createElement("div",{style:u},a.createElement("div",{style:d},"Karplus-Strong Engine"),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Mode"),a.createElement("select",{style:g,value:r.ks_mode||"tonal",onChange:function(e){return i("ks_mode",e.target.value)}},a.createElement("option",{value:"tonal"},"Tonal (guitar/bass decay)"),a.createElement("option",{value:"percussive"},"Percussive (marimba/xylophone)"),a.createElement("option",{value:"noise"},"Noise (short drums)"))),a.createElement("div",{style:f},a.createElement("label",{style:m},"Damping (Decay Rate)"),a.createElement("input",{style:_,type:"number",min:"0.8",max:"0.9999",step:"0.001",value:r.ks_damping||.995,onChange:function(e){return i("ks_damping",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"0.8 = fast decay, 0.999 = long sustain")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Brightness"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:r.ks_brightness||.5,onChange:function(e){return i("ks_brightness",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"0 = dark, 1 = bright harmonics")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Level"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:r.ks_level||.3,onChange:function(e){return i("ks_level",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"K-S harmonics volume (0-1)"))),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Stretch (Inharmonicity)"),a.createElement("input",{style:_,type:"number",min:"1.0",max:"1.02",step:"0.001",value:r.ks_stretch||1,onChange:function(e){return i("ks_stretch",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"1.0 = harmonic, higher = bell-like")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Strike Position"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:r.ks_position||.5,onChange:function(e){return i("ks_position",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Affects harmonic content")))),a.createElement("div",{style:u},a.createElement("div",{style:d},"Sine Oscillator (808-Style Bass)"),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Enable Sine"),a.createElement("select",{style:g,value:r.sine_enabled?"true":"false",onChange:function(e){return i("sine_enabled","true"===e.target.value)}},a.createElement("option",{value:"true"},"Enabled"),a.createElement("option",{value:"false"},"Disabled"))),a.createElement("div",{style:f},a.createElement("label",{style:m},"Sine Level"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:r.sine_level||.7,onChange:function(e){return i("sine_level",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Sine fundamental volume (0-1)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Pitch Envelope Amount"),a.createElement("input",{style:_,type:"number",min:"0",max:"6",step:"0.1",value:r.sine_pitch_amount||2,onChange:function(e){return i("sine_pitch_amount",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Octaves of pitch sweep (808 style)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Pitch Decay Time"),a.createElement("input",{style:_,type:"number",min:"10",max:"500",step:"5",value:r.sine_pitch_decay||80,onChange:function(e){return i("sine_pitch_decay",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Pitch envelope decay (ms)")))),a.createElement("div",{style:u},a.createElement("div",{style:d},"Pitch Sweep Mode"),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Sweep Mode"),a.createElement("select",{style:g,value:r.pitch_sweep_mode||"none",onChange:function(e){return i("pitch_sweep_mode",e.target.value)}},a.createElement("option",{value:"none"},"None (static pitch)"),a.createElement("option",{value:"sine"},"Sine (808 pitch drop)"),a.createElement("option",{value:"delay"},"Delay (Boss feedback)")),a.createElement("div",{style:h},"none"===r.pitch_sweep_mode&&"No pitch sweep - static sine/K-S","sine"===r.pitch_sweep_mode&&"808 kick - sine sweeps from high to low","delay"===r.pitch_sweep_mode&&"Boss delay trick - K-S delay modulation")),"delay"===r.pitch_sweep_mode&&a.createElement(a.Fragment,null,a.createElement("div",{style:f},a.createElement("label",{style:m},"Delay Sweep Time"),a.createElement("input",{style:_,type:"number",min:"10",max:"500",step:"5",value:r.delay_sweep_time||150,onChange:function(e){return i("delay_sweep_time",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Time for delay pitch drop (ms)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Delay Sweep Amount"),a.createElement("input",{style:_,type:"number",min:"1",max:"4",step:"0.1",value:r.delay_sweep_amount||2,onChange:function(e){return i("delay_sweep_amount",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Pitch drop multiplier (1 = none, 4 = extreme)"))))),a.createElement("div",{style:u},a.createElement("div",{style:d},"Body Resonance (Formant Filter)"),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Enable Body"),a.createElement("select",{style:g,value:r.body_enabled?"true":"false",onChange:function(e){return i("body_enabled","true"===e.target.value)}},a.createElement("option",{value:"true"},"Enabled"),a.createElement("option",{value:"false"},"Disabled"))),a.createElement("div",{style:f},a.createElement("label",{style:m},"Body Type"),a.createElement("select",{style:g,value:r.body_type||"wood",onChange:function(e){return i("body_type",e.target.value)}},a.createElement("option",{value:"wood"},"Wood (marimba/warm)"),a.createElement("option",{value:"metal"},"Metal (bells/bright)"),a.createElement("option",{value:"glass"},"Glass (crystalline)"))),a.createElement("div",{style:f},a.createElement("label",{style:m},"Body Resonance"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:r.body_resonance||.3,onChange:function(e){return i("body_resonance",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Resonance intensity (0-1)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Body Size"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:r.body_size||.3,onChange:function(e){return i("body_size",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Size scaling (0 = small/dark, 1 = large/bright)")))),a.createElement("div",{style:u},a.createElement("div",{style:d},"Amplitude Envelope"),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Attack"),a.createElement("input",{style:_,type:"number",min:"0",max:"100",step:"0.5",value:r.amp_attack||1,onChange:function(e){return i("amp_attack",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Attack time (ms)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Decay"),a.createElement("input",{style:_,type:"number",min:"10",max:"5000",step:"10",value:r.amp_decay||1500,onChange:function(e){return i("amp_decay",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Decay time (ms)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Sustain"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:r.amp_sustain||.2,onChange:function(e){return i("amp_sustain",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Sustain level (0-1)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Release"),a.createElement("input",{style:_,type:"number",min:"10",max:"2000",step:"10",value:r.amp_release||200,onChange:function(e){return i("amp_release",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Release time (ms)")))),a.createElement("div",{style:u},a.createElement("div",{style:d},"Output"),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Velocity Sensitivity"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:r.velocity_sensitivity||.7,onChange:function(e){return i("velocity_sensitivity",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"0 = ignore velocity, 1 = full range")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Output Gain"),a.createElement("input",{style:_,type:"number",min:"0.1",max:"10",step:"0.1",value:r.output_gain||3,onChange:function(e){return i("output_gain",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Master volume multiplier")))))};function yt(e,n){var t="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=Mt(e))||n&&e&&"number"==typeof e.length){t&&(e=t);var a=0,o=function(){};return{s:o,n:function(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function(e){throw e},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var c,r=!0,i=!1;return{s:function(){t=t.call(e)},n:function(){var e=t.next();return r=e.done,e},e:function(e){i=!0,c=e},f:function(){try{r||null==t.return||t.return()}finally{if(i)throw c}}}}function kt(){var e,n,t="function"==typeof Symbol?Symbol:{},a=t.iterator||"@@iterator",o=t.toStringTag||"@@toStringTag";function c(t,a,o,c){var l=a&&a.prototype instanceof i?a:i,s=Object.create(l.prototype);return xt(s,"_invoke",function(t,a,o){var c,i,l,s=0,u=o||[],d=!1,p={p:0,n:0,v:e,a:f,f:f.bind(e,4),d:function(n,t){return c=n,i=0,l=e,p.n=t,r}};function f(t,a){for(i=t,l=a,n=0;!d&&s&&!o&&n<u.length;n++){var o,c=u[n],f=p.p,m=c[2];t>3?(o=m===a)&&(l=c[(i=c[4])?5:(i=3,3)],c[4]=c[5]=e):c[0]<=f&&((o=t<2&&f<c[1])?(i=0,p.v=a,p.n=c[1]):f<m&&(o=t<3||c[0]>a||a>m)&&(c[4]=t,c[5]=a,p.n=m,i=0))}if(o||t>1)return r;throw d=!0,a}return function(o,u,m){if(s>1)throw TypeError("Generator is already running");for(d&&1===u&&f(u,m),i=u,l=m;(n=i<2?e:l)||!d;){c||(i?i<3?(i>1&&(p.n=-1),f(i,l)):p.n=l:p.v=l);try{if(s=2,c){if(i||(o="next"),n=c[o]){if(!(n=n.call(c,l)))throw TypeError("iterator result is not an object");if(!n.done)return n;l=n.value,i<2&&(i=0)}else 1===i&&(n=c.return)&&n.call(c),i<2&&(l=TypeError("The iterator does not provide a '"+o+"' method"),i=1);c=e}else if((n=(d=p.n<0)?l:t.call(a,p))!==r)break}catch(n){c=e,i=1,l=n}finally{s=1}}return{value:n,done:d}}}(t,o,c),!0),s}var r={};function i(){}function l(){}function s(){}n=Object.getPrototypeOf;var u=[][a]?n(n([][a]())):(xt(n={},a,function(){return this}),n),d=s.prototype=i.prototype=Object.create(u);function p(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,s):(e.__proto__=s,xt(e,o,"GeneratorFunction")),e.prototype=Object.create(d),e}return l.prototype=s,xt(d,"constructor",s),xt(s,"constructor",l),l.displayName="GeneratorFunction",xt(s,o,"GeneratorFunction"),xt(d),xt(d,o,"Generator"),xt(d,a,function(){return this}),xt(d,"toString",function(){return"[object Generator]"}),(kt=function(){return{w:c,m:p}})()}function xt(e,n,t,a){var o=Object.defineProperty;try{o({},"",{})}catch(e){o=0}xt=function(e,n,t,a){function c(n,t){xt(e,n,function(e){return this._invoke(n,t,e)})}n?o?o(e,n,{value:t,enumerable:!a,configurable:!a,writable:!a}):e[n]=t:(c("next",0),c("throw",1),c("return",2))},xt(e,n,t,a)}function St(e,n,t,a,o,c,r){try{var i=e[c](r),l=i.value}catch(e){return void t(e)}i.done?n(l):Promise.resolve(l).then(a,o)}function Et(e){return function(){var n=this,t=arguments;return new Promise(function(a,o){var c=e.apply(n,t);function r(e){St(c,a,o,r,i,"next",e)}function i(e){St(c,a,o,r,i,"throw",e)}r(void 0)})}}function Pt(e){return Pt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Pt(e)}function wt(e){return function(e){if(Array.isArray(e))return Dt(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||Mt(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Ct(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function It(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?Ct(Object(t),!0).forEach(function(n){Rt(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):Ct(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function Rt(e,n,t){return(n=function(e){var n=function(e){if("object"!=Pt(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=Pt(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==Pt(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function Lt(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,c,r,i=[],l=!0,s=!1;try{if(c=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=c.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(r=t.return(),Object(r)!==r))return}finally{if(s)throw o}}return i}}(e,n)||Mt(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Mt(e,n){if(e){if("string"==typeof e)return Dt(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Dt(e,n):void 0}}function Dt(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}var At=function(e){var n=e.onGenerateCode,t=e.onCodePreview,o=e.onLoadPatch,c=e.onSavePatch,r=e.onSaveRuntimePatch,i=e.onClearCanvas,l=e.onZoomToFit,s=e.onSnapToGrid,u=e.onOpenSampleEditor,d=e.copyButtonState,p=sn(),f=p.hasActiveTransfers,m=(0,p.getOverallProgress)(),_=f();return a.createElement("div",{className:"toolbar"},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"16px",flex:1}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("img",{src:Qe,alt:"Soniphorm",style:{height:"32px",width:"auto",filter:"invert(1) brightness(1.2)"}}),a.createElement("h1",{style:{margin:0,fontSize:"24px",color:"#e5e7eb"}},"Gen Patcher")),_&&a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px",flex:1,maxWidth:"400px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px",fontSize:"12px",color:"#fbbf24",fontWeight:"500"}},a.createElement("span",null,""),a.createElement("span",null,"Transferring ",m.current,"/",m.total)),a.createElement("div",{style:{flex:1,height:"4px",backgroundColor:"#374151",borderRadius:"2px",overflow:"hidden",position:"relative"}},a.createElement("div",{style:{width:"".concat(m.percentage,"%"),height:"100%",backgroundColor:"#fbbf24",borderRadius:"2px",transition:"width 0.3s ease"}})),a.createElement("div",{style:{fontSize:"11px",color:"#cbd5e1",minWidth:"40px",textAlign:"right"}},m.percentage.toFixed(0),"%"),m.currentFile&&a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",maxWidth:"100px",overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}},m.currentFile))),a.createElement("div",{className:"toolbar-actions"},a.createElement("button",{className:"btn btn-ghost",onClick:l},"Zoom to Fit"),a.createElement("button",{className:"btn btn-ghost",onClick:s},"Snap to Grid"),a.createElement("button",{className:"btn btn-red",onClick:i},"Clear Canvas"),a.createElement("button",{className:"btn btn-ghost",onClick:o},"Load Patch"),a.createElement("button",{className:"btn btn-ghost",onClick:c},"Save Patch"),a.createElement("button",{className:"btn btn-blue",onClick:r,title:"Export patch in runtime interpreter format"},"Export for Runtime"),a.createElement("button",{className:"btn btn-amber",onClick:u},"Sample Editor"),a.createElement("button",{className:"btn btn-green",onClick:n},"copied"===d?"Code Copied!":"Generate Code"),a.createElement("button",{className:"btn btn-ghost",onClick:t},"Code Preview")))},Ot=function(e){var n=e.onAddModule,t=e.onLoadExamplePatch,o=Lt((0,a.useState)({examples:!0,audioSources:!1,mixers:!1,audioProcessors:!1,granularLooping:!1,sequencers:!1,midiEffects:!1,audioIO:!1,control:!1,hardware:!1}),2),c=o[0],r=o[1],i=function(e){try{n(e)}catch(e){alert(e.message)}},l=function(e){var n=e.title,t=e.categoryKey,o=e.count;return a.createElement("h3",{onClick:function(){return function(e){r(function(n){return It(It({},n),{},Rt({},e,!n[e]))})}(t)},style:{cursor:"pointer",userSelect:"none",display:"flex",justifyContent:"space-between",alignItems:"center"}},a.createElement("span",null,n),a.createElement("span",{style:{fontSize:"0.8em",color:"#94a3b8"}},c[t]?"":""," ",o>0?"(".concat(o,")"):""))};return a.createElement("div",{className:"module-palette"},a.createElement("h2",null,"Modules"),a.createElement("div",{className:"module-categories"},a.createElement("div",{className:"category"},a.createElement(l,{title:"Examples",categoryKey:"examples",count:F.EXAMPLES.length}),c.examples&&a.createElement("div",{className:"module-list"},0===F.EXAMPLES.length?a.createElement("div",{style:{padding:"8px",fontSize:"12px",opacity:.5,fontStyle:"italic"}},"No example patches yet"):F.EXAMPLES.map(function(e,n){return a.createElement("div",{key:n,className:"module-item",onClick:function(){return n=e,void(confirm('Load "'.concat(n.name,'"? This will clear your current patch.'))&&t(n.patch));var n},title:e.description},e.name)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Audio I/O",categoryKey:"audioIO",count:F.AUDIO_IO.length}),c.audioIO&&a.createElement("div",{className:"module-list"},F.AUDIO_IO.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},O[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Hardware",categoryKey:"hardware",count:F.HW.length}),c.hardware&&a.createElement("div",{className:"module-list"},F.HW.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},O[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Audio Sources",categoryKey:"audioSources",count:F.AUDIO_SOURCES.length}),c.audioSources&&a.createElement("div",{className:"module-list"},F.AUDIO_SOURCES.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},O[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Mixers",categoryKey:"mixers",count:F.MIXERS.length}),c.mixers&&a.createElement("div",{className:"module-list"},F.MIXERS.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},O[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Audio Processors",categoryKey:"audioProcessors",count:F.AUDIO_PROCESSORS.length}),c.audioProcessors&&a.createElement("div",{className:"module-list"},F.AUDIO_PROCESSORS.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},O[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Granular & Looping",categoryKey:"granularLooping",count:F.GRANULAR_LOOPING.length}),c.granularLooping&&a.createElement("div",{className:"module-list"},F.GRANULAR_LOOPING.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},O[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Sequencers",categoryKey:"sequencers",count:F.SEQUENCERS.length}),c.sequencers&&a.createElement("div",{className:"module-list"},F.SEQUENCERS.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},O[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"MIDI Effects",categoryKey:"midiEffects",count:F.MIDI_EFFECTS.length}),c.midiEffects&&a.createElement("div",{className:"module-list"},F.MIDI_EFFECTS.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},O[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Control",categoryKey:"control",count:F.CTRL.length}),c.control&&a.createElement("div",{className:"module-list"},F.CTRL.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},O[e].label)})))))},Bt=["#dc2626","#16a34a","#2563eb","#ca8a04","#0891b2","#9333ea"],Tt=function(e){return z.includes(e.type)},Ft=function(e){return Tt(e)?17*(G(e).length||1)+6:0},Nt=function(e){return"Pot"!==e.type&&"LEDButton"!==e.type||!e.params||"number"!=typeof e.params.bank?Tt(e)?"#f8fafc":"#1e293b":Bt[e.params.bank-1]||"#1e293b"},zt=function(e,n,t){if(!n)return console.warn('Module type "'.concat(e.type,'" not found in CATALOG for module ').concat(e.id)),"".concat(e.type," (UNKNOWN)");var a=t.filter(function(n){return n.type===e.type}),o=a.length;if(("Pot"===e.type||"LEDButton"===e.type)&&e.params){var c,r=e.params.bank||1,i=(null===(c=e.id.match(/\d+$/))||void 0===c?void 0:c[0])||"1",l="Pot"===e.type?"Pot":"Button";return"".concat(l," ").concat(i," (Bank ").concat(r,")")}if("HarmonicSequencer"===e.type&&e.params){var s=e.params.start_bank||1;if(o>1){var u=a.sort(function(e,n){return parseInt(e.id.match(/\d+$/)[0])-parseInt(n.id.match(/\d+$/)[0])}).findIndex(function(n){return n.id===e.id})+1;return"".concat(n.label," ").concat(u," (B").concat(s,")")}return"".concat(n.label," (B").concat(s,")")}if(o>1){var d=a.sort(function(e,n){return parseInt(e.id.match(/\d+$/)[0])-parseInt(n.id.match(/\d+$/)[0])}).findIndex(function(n){return n.id===e.id})+1;return"".concat(n.label," ").concat(d)}return n.label},Gt=function(e){var n=e.module,t=e.isSelected,o=(e.isGroupSelected,e.onSelect),c=e.onMove,r=e.onPortClick,i=e.onPortRightClick,l=e.connectingFrom,s=e.allModules,u=e.onDelete,d=e.onUpdateParam,p=e.canvasRef,f=e.canvasTransform,m=e.onOpenClockSequencer,_=e.onOpenHarmonicSequencer,g=e.connections,h=(e.selectedBank,Lt((0,a.useState)(!1),2)),v=h[0],b=h[1],y=Lt((0,a.useState)({x:0,y:0}),2),k=y[0],x=y[1],S=Lt((0,a.useState)({x:0,y:0}),2),E=S[0],P=S[1],w=Lt((0,a.useState)(!1),2),C=w[0],I=w[1],R=Lt((0,a.useState)(!1),2),L=R[0],M=R[1],D=(0,a.useRef)(),A=j(n),B=O[n.type];if(!B)return a.createElement("g",{transform:"translate(".concat(n.x,", ").concat(n.y,")")},a.createElement("rect",{x:-150,y:-40,width:300,height:80,fill:"#ff0000",stroke:"#ffffff",strokeWidth:"2",rx:8}),a.createElement("text",{x:0,y:0,textAnchor:"middle",fill:"#ffffff",fontSize:"14",fontWeight:"bold"},'ERROR: Module type "',n.type,'" not found'),a.createElement("text",{x:0,y:20,textAnchor:"middle",fill:"#ffffff",fontSize:"12"},"Delete this module (module ID: ",n.id,")"));var T,F,N=(0,a.useCallback)(function(e){if(e.stopPropagation(),e.preventDefault(),M(e.ctrlKey||e.metaKey),p.current){var t=p.current.getBoundingClientRect(),a=e.clientX-t.left,o=e.clientY-t.top,c=(a-f.x)/f.scale,r=(o-f.y)/f.scale;x({x:c-n.x,y:r-n.y}),P({x:c,y:r})}b(!0),I(!1)},[n.x,n.y,n.type,p,f]),z=(0,a.useCallback)(function(e){if(v&&p.current){var t=p.current.getBoundingClientRect(),a=e.clientX-t.left,o=e.clientY-t.top,r=(a-f.x)/f.scale,i=(o-f.y)/f.scale;Math.sqrt(Math.pow(r-E.x,2)+Math.pow(i-E.y,2))>5&&I(!0);var l=r-k.x,s=i-k.y;c(n.id,l,s)}},[v,k.x,k.y,E.x,E.y,c,n.id,p,f]),q=(0,a.useCallback)(function(){C||o(It(It({},n),{},{openEditor:!1,ctrlKey:L})),b(!1),I(!1),M(!1)},[C,L,o,n]);return(0,a.useEffect)(function(){if(v)return document.addEventListener("mousemove",z),document.addEventListener("mouseup",q),function(){document.removeEventListener("mousemove",z),document.removeEventListener("mouseup",q)}},[v,z,q]),a.createElement("g",{ref:D,className:"node ".concat(t?"selected":"")},a.createElement("rect",{x:n.x,y:n.y,width:A.width,height:Tt(n)?A.height+Ft(n):A.height,fill:"#0b1220",stroke:t?"#22c55e":"#1f2937",strokeWidth:t?"2":"1",rx:"10",onMouseDown:N,style:{cursor:v?"grabbing":"grab"},filter:t?"drop-shadow(0 6px 16px rgba(0,0,0,0.35)) drop-shadow(0 0 0 2px #22c55e)":"drop-shadow(0 6px 16px rgba(0,0,0,0.35))"}),a.createElement("rect",{x:n.x,y:n.y,width:A.width,height:"24",fill:Nt(n),rx:"10",ry:"10",onMouseDown:N,style:{cursor:v?"grabbing":"grab"}}),a.createElement("rect",{x:n.x,y:n.y+12,width:A.width,height:"12",fill:Nt(n),onMouseDown:N,style:{cursor:v?"grabbing":"grab"}}),a.createElement("text",{x:n.x+A.width/2,y:n.y+16,fill:Tt(n)?"#1e293b":"#e2e8f0",fontSize:"12",fontWeight:"600",textAnchor:"middle",style:{pointerEvents:"auto",cursor:"pointer",userSelect:"none"},onClick:function(e){e.stopPropagation(),e.preventDefault(),"Clock"===n.type&&m?m(n):"HarmonicSequencer"===n.type&&_?_(n):o(It(It({},n),{},{openEditor:!0}))}},zt(n,B,s)),a.createElement("g",{className:"delete-btn",onClick:function(e){e.stopPropagation(),u&&u(n.id)},style:{cursor:"pointer"}},a.createElement("rect",{x:n.x+A.width-20,y:n.y+4,width:"16",height:"16",fill:"#1f2937",stroke:"#374151",strokeWidth:"1",rx:"3",ry:"3",opacity:"0.9"}),a.createElement("text",{x:n.x+A.width-12,y:n.y+14,fill:"#e2e8f0",fontSize:"11",fontWeight:"700",textAnchor:"middle",style:{pointerEvents:"none"}},"")),A.left.map(function(e,t){var o,c,l,s,u="BPMLooper"===n.type&&"clock"===e.port,p="Wavetable"===n.type&&"pitch_cv"===e.port,f="Matrix2x2"===n.type&&"inBR"===e.port,m=["fm","fm_ratio_cv","fm_amount"].includes(e.port);return"Wavetable"!==n.type||!m||null!==(o=n.params)&&void 0!==o&&o.show_fm_inputs?a.createElement(a.Fragment,{key:e.id},a.createElement("g",null,a.createElement("circle",{cx:e.x,cy:e.y,r:"6",fill:"audio"===e.kind?"#34d399":"#9333ea",stroke:"#1f2937",strokeWidth:"2",className:"jack jack-".concat("audio"===e.kind?"audio":"ctrl"),onClick:function(n){n.stopPropagation(),r&&r(e)},onContextMenu:function(t){i&&i(t,e,n.id)},style:{cursor:"pointer"}}),a.createElement("text",{x:e.x+12,y:e.y+4,fill:"#e2e8f0",fontSize:"10",textAnchor:"start",className:"jack-label",style:{pointerEvents:"none"}},e.port),g&&function(n,t,o){var c=g.find(function(n){var t,a,o,c,r,i;return(null===(t=n.to)||void 0===t?void 0:t.id)===e.id&&(null===(a=n.from)||void 0===a||null===(a=a.id)||void 0===a?void 0:a.includes("panel_"))&&((null===(o=n.from)||void 0===o||null===(o=o.id)||void 0===o?void 0:o.includes("Pot"))||(null===(c=n.from)||void 0===c||null===(c=c.id)||void 0===c?void 0:c.includes("pot"))||(null===(r=n.from)||void 0===r||null===(r=r.id)||void 0===r?void 0:r.includes("Btn"))||(null===(i=n.from)||void 0===i||null===(i=i.id)||void 0===i?void 0:i.includes("btn")))});if(!c)return null;var r=(null===(n=c.from)||void 0===n?void 0:n.bank)||1,i=["#ef4444","#22c55e","#3b82f6","#eab308","#06b6d4","#d946ef"][r-1]||"#888",l=null===(t=c.from)||void 0===t||null===(t=t.id)||void 0===t?void 0:t.match(/[Pp]ot.*?(\d+)/),s=null===(o=c.from)||void 0===o||null===(o=o.id)||void 0===o?void 0:o.match(/[Bb]tn.*?(\d+)/),u=l?"P".concat(l[1]):s?"B".concat(s[1]):"?",d=e.x-45,p=e.y;return a.createElement("g",{style:{pointerEvents:"none"}},a.createElement("line",{x1:d+38,y1:p,x2:e.x-8,y2:e.y,stroke:i,strokeWidth:2,opacity:.8}),a.createElement("path",{d:"M ".concat(e.x-10," ").concat(e.y," L ").concat(e.x-15," ").concat(e.y-4," L ").concat(e.x-15," ").concat(e.y+4," Z"),fill:i}),a.createElement("rect",{x:d,y:p-7,width:38,height:14,rx:3,fill:i,opacity:.9}),a.createElement("text",{x:d+19,y:p+4,fill:"white",fontSize:"9",fontWeight:"bold",textAnchor:"middle"},"B",r," ",u))}()),u&&a.createElement("g",{onClick:function(e){var t;e.stopPropagation(),d&&d(n.id,"show_trigger_inputs",!(null!==(t=n.params)&&void 0!==t&&t.show_trigger_inputs))},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x+12,y:e.y+8,width:"12",height:"12",rx:"2",fill:"#475569",stroke:"#64748b",strokeWidth:"1"}),a.createElement("text",{x:e.x+18,y:e.y+17,fill:"#e2e8f0",fontSize:"8",fontWeight:"600",textAnchor:"middle",style:{pointerEvents:"none"}},null!==(c=n.params)&&void 0!==c&&c.show_trigger_inputs?"":"")),p&&a.createElement("g",{onClick:function(e){var t;e.stopPropagation(),d&&d(n.id,"show_fm_inputs",!(null!==(t=n.params)&&void 0!==t&&t.show_fm_inputs))},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x+12,y:e.y+8,width:"28",height:"12",rx:"2",fill:"#475569",stroke:"#64748b",strokeWidth:"1"}),a.createElement("text",{x:e.x+16,y:e.y+17,fill:"#e2e8f0",fontSize:"8",fontWeight:"600",textAnchor:"start",style:{pointerEvents:"none"}},null!==(l=n.params)&&void 0!==l&&l.show_fm_inputs?"":""," FM")),f&&a.createElement("g",{onClick:function(e){var t;e.stopPropagation(),d&&d(n.id,"show_control_inputs",!(null!==(t=n.params)&&void 0!==t&&t.show_control_inputs))},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x+12,y:e.y+8,width:"28",height:"12",rx:"2",fill:"#475569",stroke:"#64748b",strokeWidth:"1"}),a.createElement("text",{x:e.x+16,y:e.y+17,fill:"#e2e8f0",fontSize:"8",fontWeight:"600",textAnchor:"start",style:{pointerEvents:"none"}},null!==(s=n.params)&&void 0!==s&&s.show_control_inputs?"":""," CV"))):null}),A.right.map(function(e,t){var o,c,s=l&&l.id===e.id,u="HarmonicSequencer"===n.type&&"gate_sum"===e.port,p="DrumDesigner4"===n.type&&"mixR"===e.port;return a.createElement(a.Fragment,{key:e.id},a.createElement("g",null,a.createElement("circle",{cx:e.x,cy:e.y,r:"6",fill:"audio"===e.kind?"#34d399":"#9333ea",stroke:s?"#22d3ee":"#1f2937",strokeWidth:s?"3":"2",className:"jack jack-".concat("audio"===e.kind?"audio":"ctrl"),onClick:function(n){n.stopPropagation(),r&&r(e)},onContextMenu:function(t){i&&i(t,e,n.id)},style:{cursor:"pointer"}}),a.createElement("text",{x:e.x-12,y:e.y+4,fill:"#e2e8f0",fontSize:"10",textAnchor:"end",className:"jack-label",style:{pointerEvents:"none"}},e.port)),u&&a.createElement("g",{onClick:function(e){var t;e.stopPropagation(),d&&d(n.id,"show_individual_outputs",!(null!==(t=n.params)&&void 0!==t&&t.show_individual_outputs))},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x-20,y:e.y+12,width:"16",height:"12",fill:"#374151",stroke:"#6b7280",strokeWidth:"1",rx:"2",opacity:"0.8"}),a.createElement("text",{x:e.x-12,y:e.y+21,fill:"#e2e8f0",fontSize:"8",fontWeight:"600",textAnchor:"middle",style:{pointerEvents:"none"}},null!==(o=n.params)&&void 0!==o&&o.show_individual_outputs?"":"")),p&&a.createElement("g",{onClick:function(e){var t;e.stopPropagation(),d&&d(n.id,"show_individual_outputs",!(null!==(t=n.params)&&void 0!==t&&t.show_individual_outputs))},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x-28,y:e.y+12,width:"24",height:"12",fill:"#374151",stroke:"#6b7280",strokeWidth:"1",rx:"2",opacity:"0.8"}),a.createElement("text",{x:e.x-20,y:e.y+21,fill:"#e2e8f0",fontSize:"8",fontWeight:"600",textAnchor:"start",style:{pointerEvents:"none"}},null!==(c=n.params)&&void 0!==c&&c.show_individual_outputs?"":""," V")))}),Tt(n)&&(F=12+17*(T=G(n)).length+6,a.createElement("g",null,a.createElement("rect",{x:n.x,y:n.y+A.height-12,width:A.width,height:F,fill:Nt(n),rx:"10",ry:"10",onMouseDown:N,style:{cursor:v?"grabbing":"grab"}}),a.createElement("rect",{x:n.x,y:n.y+A.height-12,width:A.width,height:"12",fill:Nt(n),onMouseDown:N,style:{cursor:v?"grabbing":"grab"}}),T.map(function(e,t){var o=Bt[e-1]||"#888",c=n.y+A.height+7+17*t;return a.createElement("g",{key:"bank-row-".concat(e)},[0,1,2,3].map(function(t){return a.createElement("circle",{key:"bank-".concat(e,"-circle-").concat(t),cx:n.x+A.width/2-36+24*t,cy:c,r:"6",fill:o,stroke:"#1e293b",strokeWidth:"1",style:{pointerEvents:"none"}})}))}))))},qt=(0,a.forwardRef)(function(e,n){var o=e.modules,c=e.connections,r=e.selectedModule,i=e.selectedModules,l=e.onSelectModule,s=e.onSelectModules,u=e.onMoveModule,d=e.onPortClick,p=e.onPortRightClick,f=e.connectingFrom,m=e.selectedConnection,_=e.onConnectionClick,g=e.onConnectionDoubleClick,h=e.mousePos,v=e.onMouseMove,b=e.onDeleteModule,y=e.onUpdateParam,k=e.onClearSelections,x=e.onOpenClockSequencer,S=e.onOpenHarmonicSequencer,E=e.groups,P=e.selectedGroup,w=e.onSelectGroup,C=e.onMoveGroup,I=e.onToggleGroupCollapse,R=e.onDeleteGroup,L=e.onUpdateGroupLabel,M=e.onEnterGroup,D=e.onExitToRoot,A=e.onMoveStub,O=e.currentContext,B=e.selectedBank,T=e.onBankChange,F=e.panelExploded,N=e.onTogglePanelExplode,q=e.panelPieces,U=e.onMovePanelPiece,W=(0,a.useRef)(),V=Lt((0,a.useState)({x:0,y:0,scale:1}),2),H=V[0],K=V[1],Y=Lt((0,a.useState)(!1),2),$=Y[0],X=Y[1],Z=Lt((0,a.useState)({x:0,y:0}),2),Q=Z[0],J=Z[1],ee=Lt((0,a.useState)(!1),2),ne=ee[0],te=ee[1],ae=Lt((0,a.useState)({x:0,y:0}),2),oe=ae[0],ce=ae[1],re=Lt((0,a.useState)(null),2),ie=re[0],le=re[1],se=Lt((0,a.useState)(null),2),ue=se[0],de=se[1],pe=Lt((0,a.useState)(""),2),fe=pe[0],me=pe[1],_e=Lt((0,a.useState)(null),2),ge=_e[0],he=_e[1],ve=Lt((0,a.useState)({x:0,y:0}),2),be=ve[0],ye=ve[1],ke=(0,a.useCallback)(function(){if(W.current&&0!==o.length){console.log("Zoom to fit: calculating bounding box for",o.length,"modules");var e=1/0,n=1/0,t=-1/0,a=-1/0;o.forEach(function(o){var c=j(o);e=Math.min(e,o.x),n=Math.min(n,o.y),t=Math.max(t,o.x+c.width),a=Math.max(a,o.y+c.height)}),console.log("Bounding box:",{minX:e,minY:n,maxX:t,maxY:a});var c=100;e-=c,n-=c,t+=c,a+=c;var r=W.current.getBoundingClientRect(),i=r.width,l=r.height;console.log("Canvas dimensions:",{canvasWidth:i,canvasHeight:l});var s=t-e,u=a-n,d=i/s,p=l/u,f=Math.min(d,p,1),m=(i-s*f)/2-e*f,_=(l-u*f)/2-n*f;console.log("New transform:",{x:m,y:_,scale:f}),K({x:m,y:_,scale:f})}else console.log("Zoom to fit: no canvas or no modules",{canvasRef:!!W.current,moduleCount:o.length})},[o]),xe=(0,a.useCallback)(function(e){if(!W.current)return!0;var n=W.current.getBoundingClientRect(),t=H.x,a=H.y,o=H.scale,c=(e.x+t)*o,r=(e.y+a)*o,i=j(e),l=i.width*o,s=i.height*o;return c<n.width&&r<n.height&&c+l>0&&r+s>0},[H]);(0,a.useImperativeHandle)(n,function(){return{zoomToFit:ke,isModuleVisible:xe,getCanvasInfo:function(){var e;return{transform:H,rect:null===(e=W.current)||void 0===e?void 0:e.getBoundingClientRect()}},screenToCanvas:function(e,n){var t,a=null===(t=W.current)||void 0===t?void 0:t.getBoundingClientRect();return a?{x:(e-a.left-H.x)/H.scale,y:(n-a.top-H.y)/H.scale}:{x:0,y:0}}}},[ke,xe,H]);var Se,Ee,Pe,we,Ce,Ie,Re,Le,Me,De,Ae,Oe,Be,Te,Fe,Ne,ze,Ge,qe,Ue,We,Ve,He,je,Ke,Ye=function(e){if(ne){var n=W.current.getBoundingClientRect(),t=(e.clientX-n.left-H.x)/H.scale,a=(e.clientY-n.top-H.y)/H.scale,c=Math.min(t,oe.x),r=Math.min(a,oe.y),i=Math.abs(t-oe.x),l=Math.abs(a-oe.y);le({x:c,y:r,width:i,height:l});var u=o.filter(function(e){var n=j(e),t=e.x+n.width,a=e.y+n.height;return!(e.x>c+i||t<c||e.y>r+l||a<r)});s&&s(u)}else $&&K(function(n){return It(It({},n),{},{x:e.clientX-Q.x,y:e.clientY-Q.y})});if(v){var d=W.current.getBoundingClientRect(),p=(e.clientX-d.left-H.x)/H.scale,f=(e.clientY-d.top-H.y)/H.scale;v({x:p,y:f})}},$e=function(){if(ne&&ie){var e=ie.x,n=ie.y,t=ie.width,a=ie.height,c=o.filter(function(o){var c=j(o),r=o.x+c.width,i=o.y+c.height;return!(o.x>e+t||r<e||o.y>n+a||i<n)});s&&c.length>0&&s(c)}X(!1),te(!1),le(null)};return(0,a.useEffect)(function(){if($)return document.addEventListener("mousemove",Ye),document.addEventListener("mouseup",$e),function(){document.removeEventListener("mousemove",Ye),document.removeEventListener("mouseup",$e)}},[$,Q]),a.createElement("div",{className:"patch-canvas ".concat($?"panning":""," ").concat(O?"subpatch-context":""),ref:W,onMouseDown:function(e){if(e.target===e.currentTarget||"svg"===e.target.tagName){var n=W.current.getBoundingClientRect(),t=(e.clientX-n.left-H.x)/H.scale,a=(e.clientY-n.top-H.y)/H.scale;e.shiftKey?(te(!0),ce({x:t,y:a}),le({x:t,y:a,width:0,height:0})):(X(!0),J({x:e.clientX-H.x,y:e.clientY-H.y}),!k||e.ctrlKey||e.metaKey||k())}},onMouseMove:Ye,onWheel:function(e){e.preventDefault();var n=e.deltaY>0?.9:1.1;K(function(e){return It(It({},e),{},{scale:Math.max(.1,Math.min(3,e.scale*n))})})},onDoubleClick:function(e){O&&(e.target.classList.contains("patch-canvas")||e.target.classList.contains("patch-svg")||"svg"===e.target.tagName||"g"===e.target.tagName)&&(e.stopPropagation(),D&&D())}},a.createElement("svg",{className:"patch-svg",width:"100%",height:"100%"},a.createElement("g",{transform:"translate(".concat(H.x,", ").concat(H.y,") scale(").concat(H.scale,")")},(Be=.15,Te=321.9,Fe=504.15,Ne=20,ze={top:{id:"top",label:"Gates & MIDI",cropX:0,cropY:0,cropWidth:2146,cropHeight:700,ports:[{id:"panel_gateIn1",x:252,y:411,label:"Gate In 1",color:"#22c55e",side:"right",kind:"ctrl",port:"gate"},{id:"panel_gateIn2",x:577,y:411,label:"Gate In 2",color:"#22c55e",side:"right",kind:"ctrl",port:"gate"},{id:"panel_midiIn",x:903,y:411,label:"MIDI In",color:"#f59e0b",side:"right",kind:"ctrl",port:"midi"},{id:"panel_midiOut",x:1228,y:411,label:"MIDI Out",color:"#f59e0b",side:"left",kind:"ctrl",port:"midi"},{id:"panel_gateOut1",x:1554,y:411,label:"Gate Out 1",color:"#ef4444",side:"left",kind:"ctrl",port:"gate"},{id:"panel_gateOut2",x:1879,y:411,label:"Gate Out 2",color:"#ef4444",side:"left",kind:"ctrl",port:"gate"}]},audioIn:{id:"audioIn",label:"Audio In",cropX:0,cropY:700,cropWidth:658,cropHeight:500,ports:[{id:"panel_lineInL",x:252,y:850,label:"L",color:"#3b82f6",side:"right",kind:"audio",port:"inL"},{id:"panel_lineInR",x:252,y:970,label:"R",color:"#60a5fa",side:"right",kind:"audio",port:"inR"}]},speaker:{id:"speaker",label:"Speaker",cropX:658,cropY:700,cropWidth:812,cropHeight:500,ports:[{id:"panel_speakerOut",x:1064,y:909,label:"Speaker Out",color:"#f97316",side:"left",kind:"audio",port:"speaker"}]},lineOut:{id:"lineOut",label:"Line Out",cropX:1470,cropY:700,cropWidth:676,cropHeight:500,ports:[{id:"panel_lineOutL",x:1878,y:850,label:"L",color:"#3b82f6",side:"left",kind:"audio",port:"inL"},{id:"panel_lineOutR",x:1878,y:970,label:"R",color:"#60a5fa",side:"left",kind:"audio",port:"inR"}]},controls:{id:"controls",label:"Controls",cropX:0,cropY:2100,cropWidth:2146,cropHeight:1261,ports:[{id:"panel_pot1",x:380,y:2352,label:"Pot 1",color:"#22c55e",side:"right",kind:"ctrl",port:"cv",index:1},{id:"panel_pot2",x:830,y:2352,label:"Pot 2",color:"#22c55e",side:"right",kind:"ctrl",port:"cv",index:2},{id:"panel_pot3",x:1282,y:2352,label:"Pot 3",color:"#22c55e",side:"right",kind:"ctrl",port:"cv",index:3},{id:"panel_pot4",x:1734,y:2352,label:"Pot 4",color:"#22c55e",side:"right",kind:"ctrl",port:"cv",index:4},{id:"panel_btn1",x:373,y:2881,label:"Button 1",color:"#f59e0b",side:"right",kind:"ctrl",port:"gate",index:1},{id:"panel_btn2",x:822,y:2881,label:"Button 2",color:"#f59e0b",side:"right",kind:"ctrl",port:"gate",index:2},{id:"panel_btn3",x:1274,y:2881,label:"Button 3",color:"#f59e0b",side:"right",kind:"ctrl",port:"gate",index:3},{id:"panel_btn4",x:1725,y:2881,label:"Button 4",color:"#f59e0b",side:"right",kind:"ctrl",port:"gate",index:4}]}},Ge={id:"panel_encoderBtn",x:1065,y:1585,label:"Encoder Button",color:"#9333ea",side:"right",kind:"ctrl",port:"gate"},qe=o.find(function(e){return!!z.includes(e.type)&&G(e).includes(B)}),Ue=void 0!==qe,We=function(e,n,t,a){var o=e.id.includes("pot")||e.id.includes("btn");if(!Ue||!o){var c,r,i=a.cropX||0;F?(c=n+(e.x-i)*Be,r=t+(e.y-a.cropY)*Be):(c=Ne+e.x*Be,r=0+e.y*Be);var l={id:"".concat(e.id,":").concat(e.port),moduleId:e.id,port:e.port,side:e.side,kind:e.kind,panelElement:!0,bank:B||1,x:c,y:r};d&&d(l)}},Ve=function(e){return!!f&&("right"===f.side&&"left"===e.side&&f.kind===e.kind||"left"===f.side&&"right"===e.side&&f.kind===e.kind)},He=function(e){if(ge){var n=W.current.getBoundingClientRect(),t=e.clientX-n.left,a=e.clientY-n.top,o=(t-H.x)/H.scale,c=(a-H.y)/H.scale;U(ge,o-be.x,c-be.y)}},je=function(){he(null)},Ke=function(e,n){var o=e.cropX||0,c=(e.cropWidth||2146)*Be,r=e.cropHeight*Be,i=ge===e.id;return a.createElement("g",{key:e.id,className:"panel-piece panel-piece-".concat(e.id),style:{cursor:F?i?"grabbing":"grab":"default"}},a.createElement("g",{transform:"translate(".concat(n.x,", ").concat(n.y,")")},a.createElement("defs",null,a.createElement("clipPath",{id:"clip-".concat(e.id)},a.createElement("rect",{x:0,y:0,width:c,height:r}))),a.createElement("rect",{x:-2,y:-2,width:c+4,height:r+4,fill:"#1a1a2e",stroke:i?"#22c55e":"#333",strokeWidth:i?2:1,rx:5,onMouseDown:function(n){return function(e,n){if(F){e.stopPropagation();var t=W.current.getBoundingClientRect(),a=e.clientX-t.left,o=e.clientY-t.top,c=(a-H.x)/H.scale,r=(o-H.y)/H.scale;he(n),ye({x:c-q[n].x,y:r-q[n].y})}}(n,e.id)}}),a.createElement("g",{clipPath:"url(#clip-".concat(e.id,")")},a.createElement("image",{href:t(853),x:-o*Be,y:-e.cropY*Be,width:Te,height:Fe,style:{pointerEvents:"none"},preserveAspectRatio:"xMidYMid slice"})),a.createElement("text",{x:c/2,y:-8,textAnchor:"middle",fill:"#888",fontSize:"10",style:{pointerEvents:"none"}},e.label),e.ports.map(function(t){var c=(t.x-o)*Be,r=(t.y-e.cropY)*Be,i=null!==f,l=Ve(t),s=t.id.includes("btn")?19.95:t.id.includes("pot")?15.75:t.id.includes("encoder")?12:t.id.includes("lineIn")||t.id.includes("lineOut")?7.5:17.55,u=["#ef4444","#22c55e","#3b82f6","#eab308","#06b6d4","#d946ef"],d=u[(B||1)-1]||u[0],p=t.id.includes("pot")||t.id.includes("btn"),m=Ue&&p,_=m?"#666666":"controls"===e.id&&p?d:t.color,g=t.id.includes("lineIn")||t.id.includes("lineOut");return a.createElement("g",{key:t.id},a.createElement("circle",{cx:c,cy:r,r:s,fill:l&&!m?"#fbbf24":_,fillOpacity:m?.5:1,stroke:l&&!m?"#ffffff":_,strokeWidth:l&&!m?3:2,style:{cursor:m?"not-allowed":i?l?"crosshair":"not-allowed":"pointer"},onClick:function(a){a.stopPropagation(),We(t,n.x,n.y,e)}},a.createElement("title",null,m?"Reserved by ".concat((null==qe?void 0:qe.type)||"module"):"".concat(t.label," (").concat("right"===t.side?"Output":"Input",")"))),g&&a.createElement("text",{x:c+s+4,y:r+3,fill:_,fontSize:"10",fontWeight:"bold",style:{pointerEvents:"none"}},t.label))}),"controls"===e.id&&a.createElement(a.Fragment,null,Ue&&a.createElement(a.Fragment,null,a.createElement("rect",{x:0,y:0,width:c,height:r-50,fill:"#000000",fillOpacity:.3,style:{pointerEvents:"none"}}),a.createElement("text",{x:c/2,y:30,textAnchor:"middle",fill:"#ff6b6b",fontSize:"12",fontWeight:"bold",style:{pointerEvents:"none"}},"Reserved by ",(null==qe?void 0:qe.type)||"module")),function(){var e=["#ef4444","#22c55e","#3b82f6","#eab308","#06b6d4","#d946ef"],n=e[(B||1)-1]||e[0];return a.createElement(a.Fragment,null,a.createElement("g",{className:"bank-nav-left",onClick:function(e){e.stopPropagation(),T((B||1)<=1?6:(B||1)-1)},style:{cursor:"pointer"}},a.createElement("circle",{cx:20,cy:r-20,r:18,fill:"#1a1a2e",stroke:n,strokeWidth:2}),a.createElement("path",{d:"M ".concat(25," ",r-20," L ",15," ").concat(r-20," M ",18," ").concat(r-25," L ",15," ").concat(r-20," L ",18," ").concat(r-15),stroke:n,strokeWidth:2,fill:"none"}),a.createElement("title",null,"Previous Bank")),a.createElement("text",{x:c/2,y:r-12,textAnchor:"middle",fill:n,fontSize:"14",fontWeight:"bold",style:{pointerEvents:"none"}},"Bank ",B||1),a.createElement("g",{className:"bank-nav-right",onClick:function(e){e.stopPropagation(),T((B||1)>=6?1:(B||1)+1)},style:{cursor:"pointer"}},a.createElement("circle",{cx:c-20,cy:r-20,r:18,fill:"#1a1a2e",stroke:n,strokeWidth:2}),a.createElement("path",{d:"M ".concat(c-25," ").concat(r-20," L ").concat(c-15," ").concat(r-20," M ").concat(c-18," ").concat(r-25," L ").concat(c-15," ").concat(r-20," L ").concat(c-18," ").concat(r-15),stroke:n,strokeWidth:2,fill:"none"}),a.createElement("title",null,"Next Bank")))}())))},F?a.createElement("g",{className:"hardware-panel exploded",onMouseMove:He,onMouseUp:je,onMouseLeave:je},a.createElement("g",{className:"collapse-button",onClick:N,style:{cursor:"pointer"}},a.createElement("rect",{x:Ne,y:0,width:70,height:24,fill:"#1a1a2e",stroke:"#ef4444",strokeWidth:1,rx:4}),a.createElement("text",{x:55,y:16,textAnchor:"middle",fill:"#ef4444",fontSize:"10",fontWeight:"bold"},"COLLAPSE")),Object.values(ze).map(function(e){return Ke(e,q[e.id])}),(Le=Ge,Me=q.controls,De={x:Me.x+Le.x*Be,y:Me.y-30},Ae=null!==f,Oe=Ve(Le),a.createElement("g",{className:"encoder-button-exploded"},a.createElement("rect",{x:De.x-50,y:De.y-12,width:100,height:24,fill:"#1a1a2e",stroke:Le.color,strokeWidth:1,rx:12}),a.createElement("text",{x:De.x-30,y:De.y+4,fill:"#888",fontSize:"9",style:{pointerEvents:"none"}},"Enc Btn"),a.createElement("circle",{cx:De.x+30,cy:De.y,r:10,fill:Oe?"#fbbf24":Le.color,fillOpacity:1,stroke:Oe?"#ffffff":Le.color,strokeWidth:Oe?3:2,style:{cursor:Ae?Oe?"crosshair":"not-allowed":"pointer"},onClick:function(){var e={id:"".concat(Le.id,":").concat(Le.port),moduleId:Le.id,port:Le.port,side:Le.side,kind:Le.kind,panelElement:!0,bank:B||1,x:De.x+30,y:De.y};d&&d(e)}},a.createElement("title",null,Le.label," (Gate Output)"))))):function(){return a.createElement("g",{className:"hardware-panel assembled"},a.createElement("image",{href:t(853),x:Ne,y:0,width:Te,height:Fe,style:{pointerEvents:"none"}}),Object.values(ze).flatMap(function(e){return e.ports.map(function(n){var t={x:Ne+n.x*Be,y:0+n.y*Be},o=null!==f,c=Ve(n),r=n.id.includes("btn")?19.95:n.id.includes("pot")?15.75:n.id.includes("encoder")?12:n.id.includes("lineIn")||n.id.includes("lineOut")?7.5:17.55,i=["#ef4444","#22c55e","#3b82f6","#eab308","#06b6d4","#d946ef"],l=i[(B||1)-1]||i[0],s=n.id.includes("pot")||n.id.includes("btn"),u=Ue&&s,d=u?"#666666":"controls"===e.id&&s?l:n.color,p=n.id.includes("lineIn")||n.id.includes("lineOut");return a.createElement("g",{key:n.id},a.createElement("circle",{cx:t.x,cy:t.y,r,fill:c&&!u?"#fbbf24":d,fillOpacity:u?.5:1,stroke:c&&!u?"#ffffff":d,strokeWidth:c&&!u?3:2,style:{cursor:u?"not-allowed":o?c?"crosshair":"not-allowed":"pointer"},onClick:function(){return We(n,Ne,0,{cropY:0})}},a.createElement("title",null,u?"Reserved by ".concat((null==qe?void 0:qe.type)||"module"):"".concat(n.label," (").concat("right"===n.side?"Output":"Input",")"))),p&&a.createElement("text",{x:t.x+r+4,y:t.y+3,fill:d,fontSize:"10",fontWeight:"bold",style:{pointerEvents:"none"}},n.label))})}),Ue&&a.createElement(a.Fragment,null,a.createElement("rect",{x:Ne,y:0+ze.controls.cropY*Be,width:Te,height:ze.controls.cropHeight*Be-50,fill:"#000000",fillOpacity:.3,style:{pointerEvents:"none"}}),a.createElement("text",{x:180.95,y:0+ze.controls.cropY*Be+25,textAnchor:"middle",fill:"#ff6b6b",fontSize:"10",fontWeight:"bold",style:{pointerEvents:"none"}},"Reserved: ",(null==qe?void 0:qe.type)||"module")),a.createElement("circle",{cx:179.75,cy:237.75,r:26.7,fill:"#1a1a1a",fillOpacity:1,stroke:"#333",strokeWidth:1,style:{pointerEvents:"none"}},a.createElement("title",null,"Encoder Rotary (Bank Navigation - Reserved)")),(n={x:Ne+(e=Ge).x*Be,y:0+e.y*Be},o=null!==f,c=Ve(e),a.createElement("circle",{cx:n.x,cy:n.y,r:12,fill:c?"#fbbf24":e.color,fillOpacity:1,stroke:c?"#ffffff":e.color,strokeWidth:c?3:2,style:{cursor:o?c?"crosshair":"not-allowed":"pointer"},onClick:function(){return We(e,Ne,0,{cropY:0})}},a.createElement("title",null,e.label," (Gate Output)"))),a.createElement("g",{className:"explode-button",onClick:N,style:{cursor:"pointer"}},a.createElement("rect",{x:Ne,y:0,width:70,height:24,fill:"#1a1a2e",stroke:"#22c55e",strokeWidth:1,rx:4}),a.createElement("text",{x:55,y:16,textAnchor:"middle",fill:"#22c55e",fontSize:"10",fontWeight:"bold"},"EXPLODE")));var e,n,o,c}()),E&&E.map(function(e){if(null!==O)return null;if(e.collapsed){var n=Math.max(e.inputPorts.length,e.outputPorts.length),t=Math.max(80,25*n+60),r=200;return a.createElement("g",{key:e.id},a.createElement("rect",{x:e.x,y:e.y,width:r,height:t,fill:"#cbd5e1",stroke:(null==P?void 0:P.id)===e.id?"#22c55e":"#334155",strokeWidth:(null==P?void 0:P.id)===e.id?"3":"2",rx:"10",style:{cursor:"move"},onMouseDown:function(n){n.stopPropagation(),w&&w(e);var t=n.clientX,a=n.clientY,o=e.x,c=e.y,r=function(n){var r=n.clientX-t,i=n.clientY-a,l=o+r,s=c+i;C&&C(e.id,l,s)},i=function(){document.removeEventListener("mousemove",r),document.removeEventListener("mouseup",i)};document.addEventListener("mousemove",r),document.addEventListener("mouseup",i)},onDoubleClick:function(n){n.stopPropagation(),M&&M(e.id)}}),a.createElement("rect",{x:e.x,y:e.y,width:r,height:32,fill:e.color,rx:"10",style:{pointerEvents:"none"}}),a.createElement("rect",{x:e.x,y:e.y+16,width:r,height:16,fill:e.color,style:{pointerEvents:"none"}}),a.createElement("text",{x:e.x+100,y:e.y+20,fill:"#1f2937",fontSize:"14",fontWeight:"700",textAnchor:"middle",style:{userSelect:"none",pointerEvents:"none"}},e.label),a.createElement("text",{x:e.x+100,y:e.y+50,fill:"rgba(31, 41, 55, 0.7)",fontSize:"11",textAnchor:"middle",style:{userSelect:"none",pointerEvents:"none"}},e.moduleIds.length," modules"),a.createElement("g",{onClick:function(n){n.stopPropagation(),R&&R(e.id)},style:{cursor:"pointer"}},a.createElement("circle",{cx:e.x+r-12,cy:e.y+12,r:"10",fill:"rgba(220, 38, 38, 0.9)"}),a.createElement("text",{x:e.x+r-12,y:e.y+16,fill:"white",fontSize:"14",fontWeight:"700",textAnchor:"middle",style:{pointerEvents:"none"}},"")),e.inputPorts.map(function(n,t){var o=e.y+60+25*t,c="audio"===n.kind?"#34d399":"#9333ea";return a.createElement("g",{key:"".concat(e.id,"-in-").concat(t)},a.createElement("circle",{cx:e.x,cy:o,r:"6",fill:c,stroke:"white",strokeWidth:"2",style:{cursor:"pointer"},onClick:function(t){t.stopPropagation();var a={id:"".concat(e.id,":in_").concat(n.targetPort),side:"left",port:"in_".concat(n.targetPort),kind:n.kind,x:e.x,y:o,_internalTarget:{moduleId:n.targetModuleId,port:n.targetPort}};d&&d(a)}}),a.createElement("text",{x:e.x+15,y:o+4,fill:"#1f2937",fontSize:"10",style:{userSelect:"none",pointerEvents:"none"}},n.port))}),e.outputPorts.map(function(n,t){var o=e.y+60+25*t,c="audio"===n.kind?"#34d399":"#9333ea";return a.createElement("g",{key:"".concat(e.id,"-out-").concat(t)},a.createElement("circle",{cx:e.x+r,cy:o,r:"6",fill:c,stroke:"white",strokeWidth:"2",style:{cursor:"pointer"},onClick:function(t){t.stopPropagation();var a={id:"".concat(e.id,":out_").concat(n.sourcePort),side:"right",port:"out_".concat(n.sourcePort),kind:n.kind,x:e.x+r,y:o,_internalSource:{moduleId:n.sourceModuleId,port:n.sourcePort}};d&&d(a)}}),a.createElement("text",{x:e.x+r-15,y:o+4,fill:"#1f2937",fontSize:"10",textAnchor:"end",style:{userSelect:"none",pointerEvents:"none"}},n.port))}),e.inputPorts.map(function(n,t){var r=e.y+60+25*t,i=e.x,l=r,s=c.find(function(t){var a=t.to.id.split(":")[0],o=t.to.port;return a===e.id&&o==="in_".concat(n.targetPort)||e.moduleIds.includes(a)&&o===n.targetPort&&!e.moduleIds.includes(t.from.id.split(":")[0])});if(!s)return null;var u=s.from.id.split(":")[0],d=o.find(function(e){return e.id===u});if(!d)return null;var p=j(d),f=[].concat(wt(p.right),wt(p.left)).find(function(e){return e.id===s.from.id});if(!f)return null;var g=f.x,h=f.y,v=i,b=l,y=v-g,k=.3*Math.abs(y),x="M ".concat(g," ").concat(h," C ").concat(g+k," ").concat(h,", ").concat(v-k," ").concat(b,", ").concat(v," ").concat(b),S="".concat(s.from.id,"-").concat(s.to.id),E=m===S;return a.createElement("path",{key:"group-cable-in-".concat(e.id,"-").concat(t),d:x,stroke:E?"#22c55e":"audio"===n.kind?"#34d399":"#9333ea",strokeWidth:E?"4":"2",fill:"none",className:"cable",style:{cursor:"pointer",filter:E?"drop-shadow(0 0 4px #22c55e)":"none",opacity:E?1:.8},onClick:function(e){e.stopPropagation(),e.preventDefault(),_&&_(S)},onMouseDown:function(e){e.stopPropagation()}})}),e.outputPorts.map(function(n,t){var i=e.y+60+25*t,l=e.x+r,s=i,u=c.find(function(t){var a=t.from.id.split(":")[0],o=t.from.port;return a===e.id&&o==="out_".concat(n.sourcePort)||e.moduleIds.includes(a)&&o===n.sourcePort&&!e.moduleIds.includes(t.to.id.split(":")[0])});if(!u)return null;console.log(" Rendering cable from ".concat(e.id,":out_").concat(n.sourcePort," to ").concat(u.to.id));var d=u.to.id.split(":")[0],p=o.find(function(e){return e.id===d});if(!p)return null;var f=j(p),g=[].concat(wt(f.right),wt(f.left)).find(function(e){return e.id===u.to.id});if(!g)return null;var h=l,v=s,b=g.x,y=g.y,k=b-h,x=.3*Math.abs(k),S="M ".concat(h," ").concat(v," C ").concat(h+x," ").concat(v,", ").concat(b-x," ").concat(y,", ").concat(b," ").concat(y),E="".concat(u.from.id,"-").concat(u.to.id),P=m===E;return a.createElement("path",{key:"group-cable-out-".concat(e.id,"-").concat(t),d:S,stroke:P?"#22c55e":"audio"===n.kind?"#34d399":"#9333ea",strokeWidth:P?"4":"2",fill:"none",className:"cable",style:{cursor:"pointer",filter:P?"drop-shadow(0 0 4px #22c55e)":"none",opacity:P?1:.8},onClick:function(e){e.stopPropagation(),e.preventDefault(),_&&_(E)},onMouseDown:function(e){e.stopPropagation()}})}))}return a.createElement("g",{key:e.id},a.createElement("rect",{x:e.x,y:e.y,width:e.width,height:e.height,fill:e.color,fillOpacity:"0.1",stroke:e.color,strokeWidth:"2",strokeDasharray:"5,5",rx:"10",style:{pointerEvents:"none"}}),a.createElement("g",null,a.createElement("rect",{x:e.x,y:e.y-25,width:Math.max(100,8*e.label.length+60),height:"22",fill:e.color,fillOpacity:"0.9",rx:"4",style:{cursor:ue===e.id?"text":"pointer"},onClick:function(n){n.stopPropagation(),de(e.id),me(e.label)}}),ue===e.id?a.createElement("foreignObject",{x:e.x+8,y:e.y-24,width:Math.max(100,8*e.label.length+40),height:"20"},a.createElement("input",{type:"text",value:fe,onChange:function(e){return me(e.target.value)},onBlur:function(){L&&fe.trim()&&L(e.id,fe.trim()),de(null)},onKeyDown:function(n){"Enter"===n.key?(L&&fe.trim()&&L(e.id,fe.trim()),de(null)):"Escape"===n.key&&de(null)},autoFocus:!0,style:{width:"100%",height:"18px",fontSize:"12px",fontWeight:"600",backgroundColor:"rgba(255, 255, 255, 0.95)",border:"1px solid white",borderRadius:"2px",padding:"2px 4px",color:"#1f2937"},onClick:function(e){return e.stopPropagation()}})):a.createElement("text",{x:e.x+10,y:e.y-10,fill:"white",fontSize:"12",fontWeight:"600",style:{userSelect:"none",cursor:"pointer",pointerEvents:"none"}},e.label),a.createElement("g",{onClick:function(n){n.stopPropagation(),I&&I(e.id)},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x+e.width-50,y:e.y-24,width:"20",height:"20",fill:"rgba(59, 130, 246, 0.9)",rx:"3"}),a.createElement("text",{x:e.x+e.width-40,y:e.y-9,fill:"white",fontSize:"12",fontWeight:"700",textAnchor:"middle",style:{pointerEvents:"none"}},e.collapsed?"":"")),a.createElement("g",{onClick:function(n){n.stopPropagation(),R&&R(e.id)},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x+e.width-25,y:e.y-24,width:"20",height:"20",fill:"rgba(220, 38, 38, 0.9)",rx:"3"}),a.createElement("text",{x:e.x+e.width-15,y:e.y-9,fill:"white",fontSize:"14",fontWeight:"700",textAnchor:"middle",style:{pointerEvents:"none"}},""))))}),function(){var e=.15,n={top:{cropX:0,cropY:0},audioIn:{cropX:0,cropY:700},speaker:{cropX:658,cropY:700},lineOut:{cropX:1470,cropY:700},controls:{cropX:0,cropY:2100}},t={panel_gateIn1:"top",panel_gateIn2:"top",panel_midiIn:"top",panel_midiOut:"top",panel_gateOut1:"top",panel_gateOut2:"top",panel_lineInL:"audioIn",panel_lineInR:"audioIn",panel_speakerOut:"speaker",panel_lineOutL:"lineOut",panel_lineOutR:"lineOut",panel_pot1:"controls",panel_pot2:"controls",panel_pot3:"controls",panel_pot4:"controls",panel_btn1:"controls",panel_btn2:"controls",panel_btn3:"controls",panel_btn4:"controls",panel_encoderBtn:"controls"},r={panel_gateIn1:{x:252,y:411},panel_gateIn2:{x:577,y:411},panel_midiIn:{x:903,y:411},panel_midiOut:{x:1228,y:411},panel_gateOut1:{x:1554,y:411},panel_gateOut2:{x:1879,y:411},panel_lineInL:{x:252,y:850},panel_lineInR:{x:252,y:970},panel_speakerOut:{x:1064,y:909},panel_lineOutL:{x:1878,y:850},panel_lineOutR:{x:1878,y:970},panel_pot1:{x:380,y:2352},panel_pot2:{x:830,y:2352},panel_pot3:{x:1282,y:2352},panel_pot4:{x:1734,y:2352},panel_btn1:{x:373,y:2881},panel_btn2:{x:822,y:2881},panel_btn3:{x:1274,y:2881},panel_btn4:{x:1725,y:2881},panel_encoderBtn:{x:1065,y:1585}},i=function(a){var o=r[a];if(!o)return null;if(F){var c=t[a],i=n[c],l=q[c];return i&&l?{x:l.x+(o.x-i.cropX)*e,y:l.y+(o.y-i.cropY)*e}:null}return{x:20+o.x*e,y:0+o.y*e}};return c.map(function(e){var n,t,c=e.from.id.split(":")[0],r=e.to.id.split(":")[0],l=o.find(function(e){return e.id===c}),s=o.find(function(e){return e.id===r}),u=E&&E.find(function(e){return e.id===c}),d=E&&E.find(function(e){return e.id===r}),p=e.from.panelElement,f=e.to.panelElement;if(!l&&!u&&!p)return null;if(!s&&!d&&!f)return null;var h=["panel_midiIn","panel_midiOut","panel_gateIn1","panel_gateIn2","panel_gateOut1","panel_gateOut2","panel_lineOutL","panel_lineOutR","panel_lineInL","panel_lineInR"],v=null===(n=e.from.id)||void 0===n?void 0:n.split(":")[0],b=null===(t=e.to.id)||void 0===t?void 0:t.split(":")[0],y=h.includes(v),k=h.includes(b),x=p&&e.from.bank&&!y,S=f&&e.to.bank&&!k;if(x&&e.from.bank!==B)return null;if(S&&e.to.bank!==B)return null;var P,w,C,I,R=l?E&&E.find(function(e){return e.moduleIds.includes(c)}):u,L=s?E&&E.find(function(e){return e.moduleIds.includes(r)}):d;if(null===O){if(l&&R&&R.collapsed&&!u)return null;if(s&&L&&L.collapsed&&!d)return null}else{var M=R&&R.id===O,D=L&&L.id===O;if(!M||!D)return null}if(p){var A=i(c);if(!A)return null;P=A.x,w=A.y}else if(l){var T=j(l),F=[].concat(wt(T.right),wt(T.left)).find(function(n){return n.id===e.from.id});if(!F)return null;P=F.x,w=F.y}else{if(!u||!u.collapsed)return null;var N=u.outputPorts.findIndex(function(n){return"".concat(u.id,":out_").concat(n.sourcePort)===e.from.id});if(-1===N)return null;P=u.x+200,w=u.y+60+25*N}if(f){var z=i(r);if(!z)return null;C=z.x,I=z.y}else if(s){var G=j(s),q=[].concat(wt(G.right),wt(G.left)).find(function(n){return n.id===e.to.id});if(!q)return null;C=q.x,I=q.y}else{if(!d||!d.collapsed)return null;var U=d.inputPorts.findIndex(function(n){return"".concat(d.id,":in_").concat(n.targetPort)===e.to.id});if(-1===U)return null;C=d.x,I=d.y+60+25*U}var W=C-P,V=.3*Math.abs(W),H="M ".concat(P," ").concat(w," C ").concat(P+V," ").concat(w,", ").concat(C-V," ").concat(I,", ").concat(C," ").concat(I),K="".concat(e.from.id,"-").concat(e.to.id),Y=m===K;return a.createElement("g",{key:"".concat(e.from.id,"-").concat(e.to.id),className:"cable",style:{cursor:"pointer"},onClick:function(e){e.stopPropagation(),e.preventDefault(),_&&_(K)},onDoubleClick:function(e){e.stopPropagation(),e.preventDefault(),g&&g(K)},onMouseDown:function(e){e.stopPropagation()}},a.createElement("path",{d:H,stroke:"transparent",strokeWidth:"15",fill:"none",style:{pointerEvents:"stroke"}}),a.createElement("path",{d:H,stroke:Y?"#22c55e":"audio"===e.kind?"#34d399":"#9333ea",strokeWidth:Y?"4":"2",fill:"none",style:{filter:Y?"drop-shadow(0 0 4px #22c55e)":"none",opacity:Y?1:.8,pointerEvents:"none"}}))})}(),f&&h&&(Se=f.x,Ee=f.y,Pe=h.x,we=h.y,Ce=Pe-Se,Ie=.3*Math.abs(Ce),Re="M ".concat(Se," ").concat(Ee," C ").concat(Se+Ie," ").concat(Ee,", ").concat(Pe-Ie," ").concat(we,", ").concat(Pe," ").concat(we),a.createElement("path",{d:Re,stroke:"audio"===f.kind?"#34d399":"#9333ea",strokeWidth:"2",strokeDasharray:"5,5",fill:"none",opacity:"0.6",style:{pointerEvents:"none"}})),o.map(function(e){var n=E&&E.find(function(n){return n.moduleIds.includes(e.id)});if(null===O){if(n&&n.collapsed)return null}else if(!n||n.id!==O)return null;var t=i.some(function(n){return n.id===e.id});return a.createElement(Gt,{key:e.id,module:e,isSelected:(null==r?void 0:r.id)===e.id||t,isGroupSelected:t,onSelect:l,onMove:u,onPortClick:d,onPortRightClick:p,connectingFrom:f,allModules:o,onDelete:b,onUpdateParam:y,canvasRef:W,canvasTransform:H,onOpenClockSequencer:x,onOpenHarmonicSequencer:S,connections:c,selectedBank:B})}),O&&function(e,n){var t=E&&E.find(function(e){return e.id===O});if(!t)return null;var c=[];return null===(e=t.inputPorts)||void 0===e||e.forEach(function(e,n){var t="audio"===e.kind?"#34d399":"#9333ea",r=Math.max(100,7*"".concat(e.externalSource,":").concat(e.port).length),i=e.x||50,l=e.y||50+40*n,s=o.find(function(n){return n.id===e.targetModuleId});if(s){var u=j(s).left.find(function(n){return n.id==="".concat(s.id,":").concat(e.targetPort)});if(u){var d=u.x,p=u.y,f=i+r+20,m=l;c.push(a.createElement("path",{key:"stub-cable-in-".concat(n),d:"M ".concat(f," ").concat(m," C ").concat(f+50," ").concat(m,", ").concat(d-50," ").concat(p,", ").concat(d," ").concat(p),stroke:t,strokeWidth:"3",fill:"none",className:"cable",style:{pointerEvents:"none"}}))}}}),null===(n=t.outputPorts)||void 0===n||n.forEach(function(e,n){var t="audio"===e.kind?"#34d399":"#9333ea",r=(Math.max(100,7*"".concat(e.externalTarget,":").concat(e.port).length),e.x||1200),i=e.y||50+40*n,l=o.find(function(n){return n.id===e.sourceModuleId});if(l){var s=j(l).right.find(function(n){return n.id==="".concat(l.id,":").concat(e.sourcePort)});if(s){var u=s.x,d=s.y,p=r-20,f=i;c.push(a.createElement("path",{key:"stub-cable-out-".concat(n),d:"M ".concat(u," ").concat(d," C ").concat(u+50," ").concat(d,", ").concat(p-50," ").concat(f,", ").concat(p," ").concat(f),stroke:t,strokeWidth:"3",fill:"none",className:"cable",style:{pointerEvents:"none"}}))}}}),c}(),o.map(function(e){var n=E&&E.find(function(n){return n.moduleIds.includes(e.id)});if(null===O){if(n&&n.collapsed)return null}else if(!n||n.id!==O)return null;var t=i.some(function(n){return n.id===e.id});return a.createElement(Gt,{key:e.id,module:e,isSelected:(null==r?void 0:r.id)===e.id||t,isGroupSelected:t,onSelect:l,onMove:u,onPortClick:d,onPortRightClick:p,connectingFrom:f,allModules:o,onDelete:b,onUpdateParam:y,canvasRef:W,canvasTransform:H,onOpenClockSequencer:x,onOpenHarmonicSequencer:S,connections:c,selectedBank:B})}),O&&function(e,n){var t=E&&E.find(function(e){return e.id===O});if(!t)return null;var o=[];return null===(e=t.inputPorts)||void 0===e||e.forEach(function(e,n){var t="audio"===e.kind?"#34d399":"#9333ea",c="".concat(e.externalSource,":").concat(e.port),r=Math.max(100,7*c.length),i=e.x||50,l=e.y||50+40*n,s=i+r+20,u=l;o.push(a.createElement("g",{key:"stub-in-".concat(n)},a.createElement("g",{style:{cursor:"move"},onMouseDown:function(e){e.stopPropagation();var t=e.clientX,a=e.clientY,o=i,c=l,r=function(e){var r=e.clientX-t,i=e.clientY-a;A&&A(O,"input",n,o+r,c+i)},s=function(){document.removeEventListener("mousemove",r),document.removeEventListener("mouseup",s)};document.addEventListener("mousemove",r),document.addEventListener("mouseup",s)}},a.createElement("rect",{x:i,y:l-10,width:r,height:20,fill:"rgba(31, 41, 55, 0.9)",stroke:t,strokeWidth:"1",rx:"3"}),a.createElement("text",{x:i+5,y:l+4,fill:"white",fontSize:"11",fontWeight:"500",style:{userSelect:"none",pointerEvents:"none"}},c),a.createElement("path",{d:"M ".concat(i+r+5," ").concat(l-5," l 8 5 l -8 5 z"),fill:t,style:{pointerEvents:"none"}}),a.createElement("circle",{cx:s,cy:u,r:"6",fill:t,stroke:"white",strokeWidth:"2",style:{cursor:"pointer"}}))))}),null===(n=t.outputPorts)||void 0===n||n.forEach(function(e,n){var t="audio"===e.kind?"#34d399":"#9333ea",c="".concat(e.externalTarget,":").concat(e.port),r=Math.max(100,7*c.length),i=e.x||1200,l=e.y||50+40*n,s=i-20,u=l;o.push(a.createElement("g",{key:"stub-out-".concat(n)},a.createElement("g",{style:{cursor:"move"},onMouseDown:function(e){e.stopPropagation();var t=e.clientX,a=e.clientY,o=i,c=l,r=function(e){var r=e.clientX-t,i=e.clientY-a;A&&A(O,"output",n,o+r,c+i)},s=function(){document.removeEventListener("mousemove",r),document.removeEventListener("mouseup",s)};document.addEventListener("mousemove",r),document.addEventListener("mouseup",s)}},a.createElement("circle",{cx:s,cy:u,r:"6",fill:t,stroke:"white",strokeWidth:"2",style:{cursor:"pointer"}}),a.createElement("path",{d:"M ".concat(i-8," ").concat(l-5," l 8 5 l -8 5 z"),fill:t,style:{pointerEvents:"none"}}),a.createElement("rect",{x:i,y:l-10,width:r,height:20,fill:"rgba(31, 41, 55, 0.9)",stroke:t,strokeWidth:"1",rx:"3"}),a.createElement("text",{x:i+5,y:l+4,fill:"white",fontSize:"11",fontWeight:"500",style:{userSelect:"none",pointerEvents:"none"}},c))))}),o}(),ie&&ie.width>0&&ie.height>0&&a.createElement("rect",{x:ie.x,y:ie.y,width:ie.width,height:ie.height,fill:"rgba(34, 197, 94, 0.1)",stroke:"#22c55e",strokeWidth:"2",strokeDasharray:"5,5",style:{pointerEvents:"none"}}))))}),Ut=function(e){var n,t,o=e.selectedModule,c=e.selectedModules,r=e.selectedGroup,i=e.selectedConnection,l=e.onUpdateParam,s=e.onUpdateGroupLabel,u=e.onUngroupModules,d=e.onUpdateConnection,p=e.modules,f=e.connections,m=e.onShowNetlist,_=e.netlistCopyState,g=e.onCreateGroup,h=e.cpuEstimate,v=e.selectedBank,b=e.onBankChange,y=Lt((0,a.useState)(!1),2),k=y[0],x=y[1],S=Lt((0,a.useState)(!1),2),E=S[0],P=S[1],w=Lt((0,a.useState)(!1),2),C=w[0],I=w[1],R=Lt((0,a.useState)(!1),2),L=R[0],M=R[1],D=Lt((0,a.useState)(!1),2),A=D[0],B=D[1],T=Lt((0,a.useState)(!1),2),F=T[0],N=T[1],z=Lt((0,a.useState)(!1),2),G=z[0],q=z[1],U=Lt((0,a.useState)(!1),2),W=U[0],V=U[1],H=Lt((0,a.useState)(!1),2),j=H[0],$=H[1],X=Lt((0,a.useState)(!1),2),Z=X[0],Q=X[1],J=Lt((0,a.useState)(!1),2),ee=J[0],ne=J[1],te=Lt((0,a.useState)(!1),2),ae=te[0],oe=te[1],ce=Lt((0,a.useState)(!1),2),re=ce[0],ie=ce[1],le=Lt((0,a.useState)(!1),2),se=le[0],ue=le[1],de=Lt((0,a.useState)(!1),2),pe=de[0],fe=de[1],me=Lt((0,a.useState)(!1),2),_e=me[0],ge=me[1],he=Lt((0,a.useState)(!1),2),ve=he[0],be=he[1],ye=Lt((0,a.useState)(!1),2),ke=ye[0],xe=ye[1],Se=b,Ee=o?Y(p).conflicts.find(function(e){return e.modules.some(function(e){return e.module===o.id})}):null,Pe=o&&("SamplePlayer"===o.type||"SDPlayer"===o.type||"KickDrum"===o.type||"SnareDrum"===o.type),we=o&&"KickDrum"===o.type,Ce=o&&"SnareDrum"===o.type,Ie=o&&"DrumDesigner"===o.type,Re=o&&"ADSR"===o.type,Le=o&&"Clock"===o.type,Me=o&&("Wavetable"===o.type||"PolyOscillator"===o.type),De=o&&"Scale"===o.type,Ae=o&&"HarmonicSequencer"===o.type,Oe=o&&"Distortion"===o.type;if((0,a.useEffect)(function(){o&&o.openEditor&&(Pe?x(!0):Re?P(!0):Le?I(!0):Me?B(!0):De?N(!0):Ae?Q(!0):Oe&&ne(!0))},[null==o?void 0:o.id,null==o?void 0:o.openEditor]),(0,a.useEffect)(function(){o||(x(!1),P(!1),I(!1),B(!1),N(!1),q(!1),V(!1),$(!1),Q(!1),ne(!1),oe(!1),ie(!1),ue(!1),fe(!1),ge(!1),be(!1),xe(!1),M(!1))},[o]),r)return a.createElement("div",{className:"inspector"},a.createElement("h2",null,"Group Properties"),a.createElement("div",{className:"inspector-content"},a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginBottom:"8px"}},r.moduleIds.length," modules in group")),a.createElement("div",{className:"params"},a.createElement("h3",null,"Group Settings"),a.createElement("div",{className:"param"},a.createElement("label",null,"Group Name"),a.createElement("input",{type:"text",value:r.label,onChange:function(e){s&&s(r.id,e.target.value)},placeholder:"Enter group name"})),a.createElement("button",{className:"btn btn-red",onClick:function(){u&&u(r.id)},style:{width:"100%",marginTop:"12px"}},"Ungroup"),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"8px"}},"Double-click the group to enter subpatch view")));if(i){var Be=f.find(function(e){return e.id===i});if(Be){var Te,Fe,Ne,ze,Ge,qe,Ue,We,Ve,He,je=(null===(Te=Be.from.id)||void 0===Te?void 0:Te.startsWith("panel_midiIn"))||(null===(Fe=Be.to.id)||void 0===Fe?void 0:Fe.startsWith("panel_midiOut")),Ke=(null===(Ne=Be.from.id)||void 0===Ne?void 0:Ne.split(":")[1])||(null===(ze=Be.to.id)||void 0===ze?void 0:ze.split(":")[1]);return a.createElement("div",{className:"inspector"},a.createElement("h2",null,"Connection Properties"),a.createElement("div",{className:"inspector-content"},a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginBottom:"8px"}},null===(Ge=Be.from.id)||void 0===Ge?void 0:Ge.split(":")[0],"  ",null===(qe=Be.to.id)||void 0===qe?void 0:qe.split(":")[0]),a.createElement("div",{style:{fontSize:"10px",color:"#6b7280"}},"Type: ","audio"===Be.from.kind?"Audio":"Control")),je&&a.createElement("div",{className:"params"},a.createElement("h3",null,"MIDI Settings"),a.createElement("div",{className:"param"},a.createElement("label",null,"MIDI Channel"),a.createElement("select",{value:(null===(Ue=Be.params)||void 0===Ue?void 0:Ue.midiChannel)||0,onChange:function(e){return d&&d(Be.id,{midiChannel:parseInt(e.target.value)})}},a.createElement("option",{value:0},"Omni (All)"),wt(Array(16)).map(function(e,n){return a.createElement("option",{key:n+1,value:n+1},"Channel ",n+1)}))),"cc"===Ke&&a.createElement("div",{className:"param"},a.createElement("label",null,"CC Number"),a.createElement("input",{type:"number",min:"0",max:"127",value:(null===(We=Be.params)||void 0===We?void 0:We.ccNumber)||1,onChange:function(e){return d&&d(Be.id,{ccNumber:parseInt(e.target.value)})}})),"note"===Ke&&a.createElement(a.Fragment,null,a.createElement("div",{className:"param"},a.createElement("label",null,"Note Range Low"),a.createElement("input",{type:"number",min:"0",max:"127",value:(null===(Ve=Be.params)||void 0===Ve?void 0:Ve.noteRangeLow)||0,onChange:function(e){return d&&d(Be.id,{noteRangeLow:parseInt(e.target.value)})}})),a.createElement("div",{className:"param"},a.createElement("label",null,"Note Range High"),a.createElement("input",{type:"number",min:"0",max:"127",value:(null===(He=Be.params)||void 0===He?void 0:He.noteRangeHigh)||127,onChange:function(e){return d&&d(Be.id,{noteRangeHigh:parseInt(e.target.value)})}}))),a.createElement("div",{style:{fontSize:"10px",color:"#6b7280",marginTop:"8px"}},"Port: ",Ke||"midi")),a.createElement("div",{className:"params"},a.createElement("div",{style:{fontSize:"10px",color:"#6b7280"}},"Press Delete or Backspace to remove this connection")))}}if(c.length>0)return a.createElement("div",{className:"inspector"},a.createElement("h2",null,"Group Selection"),a.createElement("div",{className:"inspector-content"},a.createElement("p",null,c.length," modules selected"),a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginTop:"8px"}},c.map(function(e){var n;return(null===(n=O[e.type])||void 0===n?void 0:n.label)||e.type}).join(", "))),a.createElement("div",{className:"params"},a.createElement("h3",null,"Group Actions"),a.createElement("button",{className:"btn btn-green",onClick:g,style:{width:"100%",marginBottom:"8px"}},"Create Visual Group"),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"4px",marginBottom:"12px"}},"Group modules with colored background for organization")),a.createElement("div",{className:"params"},a.createElement("h3",null,"Keyboard Shortcuts"),a.createElement("div",{style:{fontSize:"11px",lineHeight:"1.6"}},a.createElement("div",null,a.createElement("kbd",null,"Ctrl+C")," / ",a.createElement("kbd",null,"Cmd+C")," - Copy"),a.createElement("div",null,a.createElement("kbd",null,"Ctrl+V")," / ",a.createElement("kbd",null,"Cmd+V")," - Paste"),a.createElement("div",null,a.createElement("kbd",null,"Delete")," - Delete selected"),a.createElement("div",null,a.createElement("kbd",null,"Esc")," - Clear selection"))),a.createElement("div",{className:"params"},a.createElement("h3",null,"Debug Tools"),a.createElement("button",{className:"btn ".concat("copied"===_?"btn-green":"btn-amber"),onClick:m,style:{width:"100%",marginBottom:"8px"},disabled:"copying"===_},"copied"===_?"Copied!":"copying"===_?"Copying...":"Copy Netlist")));if(!o){var Ye=(null==h?void 0:h.percentage)||0,$e=Ye>80?"#ef4444":Ye>50?"#f59e0b":"#10b981";return a.createElement("div",{className:"inspector"},a.createElement("h2",null,"Properties"),a.createElement("div",{style:{display:"flex",alignItems:"center",justifyContent:"space-between",marginBottom:"8px",padding:"8px",backgroundColor:"#1e293b",borderRadius:"4px"}},a.createElement("button",{onClick:function(){return Se(Math.max(1,v-1))},disabled:1===v,style:{background:1===v?"#334155":"#475569",border:"none",color:1===v?"#64748b":"#e2e8f0",padding:"4px 12px",borderRadius:"3px",cursor:1===v?"not-allowed":"pointer",fontSize:"14px",fontWeight:"bold"}},""),a.createElement("div",{style:{textAlign:"center"}},a.createElement("div",{style:{fontSize:"14px",fontWeight:"bold",color:"#e2e8f0",marginBottom:"2px"}},"Bank ",v),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8"}},(n=p.filter(function(e){var n,t,a,o=(null===(n=e.params)||void 0===n?void 0:n.bank)||(null===(t=e.params)||void 0===t?void 0:t.start_bank);if(!o)return!1;var c=null!==(a=e.params)&&void 0!==a&&a.use_outputs_5_8?o+1:o;return v>=o&&v<=c}),t=f.filter(function(e){var n,t;return(null===(n=e.from)||void 0===n?void 0:n.bank)===v||(null===(t=e.to)||void 0===t?void 0:t.bank)===v}),0===n.length&&0===t.length?"Unassigned":wt(new Set(n.map(function(e){return e.type}))).join(", ")||"Panel connections"))),a.createElement("button",{onClick:function(){return Se(Math.min(6,v+1))},disabled:6===v,style:{background:6===v?"#334155":"#475569",border:"none",color:6===v?"#64748b":"#e2e8f0",padding:"4px 12px",borderRadius:"3px",cursor:6===v?"not-allowed":"pointer",fontSize:"14px",fontWeight:"bold"}},"")),a.createElement("div",{style:{fontSize:"11px",color:"#e2e8f0",marginTop:"12px",marginBottom:"12px"}},a.createElement("div",{onClick:function(){return xe(!ke)},style:{fontWeight:"bold",marginBottom:"8px",color:"#f1f5f9",fontSize:"12px",cursor:"pointer",display:"flex",alignItems:"center",userSelect:"none"}},a.createElement("span",{style:{marginRight:"6px",fontSize:"10px",transform:ke?"rotate(90deg)":"rotate(0deg)",transition:"transform 0.2s",display:"inline-block"}},""),"Control Mappings"),ke&&a.createElement(a.Fragment,null,a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("div",{style:{fontWeight:"bold",color:"#6366f1",marginBottom:"4px"}},"Pots (Blue)"),[1,2,3,4].map(function(e){return a.createElement("div",{key:"pot-".concat(e),style:{marginBottom:"6px",paddingLeft:"8px",borderLeft:"2px solid #6366f1"}},a.createElement("div",{style:{fontWeight:"bold"}},"Pot ",e),a.createElement("div",{style:{color:"#94a3b8",fontSize:"10px"}},"Range: 0.0 - 1.0"),a.createElement("div",{style:{color:"#cbd5e1",fontSize:"10px",marginTop:"2px"}},(t=f.filter(function(n){var t,a,o;return(null===(t=n.from)||void 0===t||null===(t=t.id)||void 0===t?void 0:t.includes("panel_pot".concat(e)))&&((null===(a=n.from)||void 0===a?void 0:a.bank)===v||!(null!==(o=n.from)&&void 0!==o&&o.bank))}),(o=p.filter(function(e){var n,t,a,o=(null===(n=e.params)||void 0===n?void 0:n.bank)||(null===(t=e.params)||void 0===t?void 0:t.start_bank),c=null!==(a=e.params)&&void 0!==a&&a.use_outputs_5_8?o+1:o;return o&&v>=o&&v<=c}).find(function(e){return["Clock","StereoMixer4","Matrix2x2","DrumDesigner4","HarmonicSequencer","MIDILooper"].includes(e.type)}))?"Clock"===o.type?"Rate ".concat(e):"StereoMixer4"===o.type?"Ch".concat(e," Vol"):"Matrix2x2"===o.type?["aa","ab","ba","bb"][e-1]:"DrumDesigner4"===o.type?"Voice ".concat(e):"MIDILooper"===o.type?["Velocity","Transpose","TimingRnd","PitchRnd"][e-1]:o.type:t.length>0?(null===(n=t[0].to)||void 0===n||null===(n=n.id)||void 0===n?void 0:n.split(":")[0])||"Connected":"Unassigned")));var n,t,o})),a.createElement("div",null,a.createElement("div",{style:{fontWeight:"bold",color:"#f59e0b",marginBottom:"4px"}},"Buttons (Orange)"),[1,2,3,4].map(function(e){return a.createElement("div",{key:"btn-".concat(e),style:{marginBottom:"6px",paddingLeft:"8px",borderLeft:"2px solid #f59e0b"}},a.createElement("div",{style:{fontWeight:"bold"}},"Button ",e),a.createElement("div",{style:{color:"#94a3b8",fontSize:"10px"}},"Type: Gate / Toggle"),a.createElement("div",{style:{color:"#cbd5e1",fontSize:"10px",marginTop:"2px"}},(t=f.filter(function(n){var t,a,o;return(null===(t=n.from)||void 0===t||null===(t=t.id)||void 0===t?void 0:t.includes("panel_btn".concat(e)))&&((null===(a=n.from)||void 0===a?void 0:a.bank)===v||!(null!==(o=n.from)&&void 0!==o&&o.bank))}),(o=p.filter(function(e){var n,t,a,o=(null===(n=e.params)||void 0===n?void 0:n.bank)||(null===(t=e.params)||void 0===t?void 0:t.start_bank),c=null!==(a=e.params)&&void 0!==a&&a.use_outputs_5_8?o+1:o;return o&&v>=o&&v<=c}).find(function(e){return["Clock","StereoMixer4","Matrix2x2","DrumDesigner4","HarmonicSequencer","MIDILooper"].includes(e.type)}))?"Clock"===o.type?"Fill ".concat(e):"StereoMixer4"===o.type?"Ch".concat(e," Mute"):"DrumDesigner4"===o.type?"Trigger ".concat(e):"MIDILooper"===o.type?1===e?"Rec/Play/Clr":2===e?"Scale Lock":"-":o.type:t.length>0?(null===(n=t[0].to)||void 0===n||null===(n=n.id)||void 0===n?void 0:n.split(":")[0])||"Connected":"Unassigned")));var n,t,o})))),a.createElement("div",{className:"params",style:{marginTop:"8px"}},a.createElement("h3",{onClick:function(){return be(!ve)},style:{cursor:"pointer",display:"flex",alignItems:"center",userSelect:"none"}},a.createElement("span",{style:{marginRight:"6px",fontSize:"10px",transform:ve?"rotate(90deg)":"rotate(0deg)",transition:"transform 0.2s",display:"inline-block"}},""),"Properties Inspector"),ve&&a.createElement("div",{style:{marginTop:"12px"}},a.createElement("div",{className:"inspector-content"},a.createElement("p",null,"Select a module to view properties"),a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginTop:"12px",lineHeight:"1.6"}},a.createElement("div",null,a.createElement("strong",null,"Selection:")),a.createElement("div",null," Click module to select"),a.createElement("div",null," ",a.createElement("kbd",null,"Shift+Drag")," for rectangle select"),a.createElement("div",null," ",a.createElement("kbd",null,"Ctrl+Click")," to toggle selection"))))),a.createElement("div",{className:"params",style:{marginTop:"8px"}},a.createElement("h3",null,"CPU Usage Estimate"),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",fontSize:"12px",marginBottom:"4px",color:$e}},a.createElement("span",{style:{fontWeight:"bold"}},Ye.toFixed(1),"%"),a.createElement("span",{style:{fontSize:"10px",color:"#94a3b8"}},(null==h?void 0:h.estimatedCycles)||0," / ",(null==h?void 0:h.availableCycles)||5442," cycles")),a.createElement("div",{style:{width:"100%",height:"20px",backgroundColor:"#1e293b",borderRadius:"4px",overflow:"hidden",border:"1px solid #334155"}},a.createElement("div",{style:{width:"".concat(Math.min(Ye,100),"%"),height:"100%",backgroundColor:$e,transition:"width 0.3s ease, background-color 0.3s ease"}})),Ye>80&&a.createElement("div",{style:{fontSize:"10px",color:"#ef4444",marginTop:"4px",fontWeight:"bold"}}," WARNING: High CPU usage!"),a.createElement("div",{style:{fontSize:"10px",color:"#64748b",marginTop:"6px",fontStyle:"italic"}},"Core 1 (Audio)  Dual-core optimized"),(null==h?void 0:h.core0ModuleCount)>0&&a.createElement("div",{style:{fontSize:"10px",color:"#64748b",marginTop:"2px",fontStyle:"italic"}},"Core 0 (Control): ",h.core0ModuleCount," modules @ 100Hz"))),a.createElement("div",{className:"params"},a.createElement("h3",null,"Debug Tools"),a.createElement("button",{className:"btn ".concat("copied"===_?"btn-green":"btn-amber"),onClick:m,style:{width:"100%",marginBottom:"8px"},disabled:"copying"===_},"copied"===_?"Copied!":"copying"===_?"Copying...":"Copy Netlist")))}var Xe,Ze,Qe,Je,en,nn,tn,an=O[o.type];return a.createElement("div",{className:"inspector"},a.createElement("h2",{style:{borderLeft:"Pot"!==o.type&&"LEDButton"!==o.type||void 0===o.params.bank?"none":"4px solid ".concat(Bt[o.params.bank-1]),paddingLeft:"Pot"!==o.type&&"LEDButton"!==o.type||void 0===o.params.bank?"0":"12px",cursor:Ie?"pointer":"default"},onClick:function(){Ie&&$(!0)}},an.label,("Pot"===o.type||"LEDButton"===o.type)&&void 0!==o.params.bank&&a.createElement("span",{style:{fontSize:"10px",opacity:.7,marginLeft:"8px"}},"(Bank ",o.params.bank,")")),a.createElement("p",{className:"module-desc"},an.desc),Ee&&a.createElement("div",{style:{backgroundColor:"#7f1d1d",border:"1px solid #dc2626",borderRadius:"4px",padding:"8px",marginBottom:"12px",fontSize:"11px",color:"#fca5a5"}},a.createElement("div",{style:{fontWeight:"bold",marginBottom:"4px"}}," Bank ",Ee.bank," Conflict"),a.createElement("div",null,Ee.modules.map(function(e){return"".concat(e.module," (").concat(e.type,")")}).join(", ")),a.createElement("div",{style:{marginTop:"4px",fontSize:"10px",opacity:.9}},"These modules control the same hardware. Change bank assignment to resolve.")),(Pe||we||Ce||Ie||Re||Le||Me||De||Ae||Oe)&&a.createElement("div",{style:{fontSize:"10px",color:"#6b7280",marginBottom:"12px",fontStyle:"italic"}}," Click the module title to open the dedicated editor"),a.createElement("div",{className:"params"},a.createElement("h3",null,"Parameters"),console.log("INSPECTOR RENDERING - Module type:",o.type,"Params:",Object.keys(o.params)),Object.entries(o.params).map(function(e){var n=Lt(e,2),t=n[0],c=n[1];if(console.log("Processing param:",t,"=",c,"type:",Pt(c)),"Wavetable"===o.type&&t.startsWith("fm_"))return console.log(" Skipping FM param:",t),null;if("PolyOscillator"===o.type&&t.startsWith("fm_"))return console.log(" Skipping PolyOsc FM param:",t),null;if("StereoMixer4"===o.type&&["g1","g2","g3","g4","pan1","pan2","pan3","pan4","mute1","mute2","mute3","mute4","solo_channel"].includes(t))return console.log(" Skipping mixer control param:",t),null;if("Matrix2x2"===o.type&&["aa","ab","ba","bb","show_control_inputs"].includes(t))return console.log(" Skipping matrix control param:",t),null;if("DrumDesigner4"===o.type&&(t.startsWith("voice1_")||t.startsWith("voice2_")||t.startsWith("voice3_")||t.startsWith("voice4_")||"voice1_enabled"===t||"voice2_enabled"===t||"voice3_enabled"===t||"voice4_enabled"===t||"selected_voice"===t))return console.log(" Skipping DrumDesigner4 voice param:",t),null;if("bank"===t&&("Pot"===o.type||"LEDButton"===o.type))return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,t," (1-8):"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,parseInt(e.target.value))}},[1,2,3,4,5,6].map(function(e){return a.createElement("option",{key:e,value:e},"Bank ",e," (",["red","green","blue","yellow","cyan","magenta"][e-1],")")})));if("locked"===t&&("Pot"===o.type||"LEDButton"===o.type))return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},"Banking Mode:",a.createElement("button",{className:"btn ".concat(c?"btn-amber":"btn-ghost"),onClick:function(){l(o.id,t,!c)},style:{fontSize:"12px",padding:"4px 8px",minWidth:"80px"}},c?" Locked":" Banked")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px",fontStyle:"italic"}},c?"Control active in ALL banks (persistent)":"Control only active in Bank ".concat(o.params.bank||1)),a.createElement("div",{style:{fontSize:"9px",color:"#6b7280",marginTop:"4px",padding:"4px",backgroundColor:"#1e293b",borderRadius:"3px"}}," ",a.createElement("strong",null,"Lock Button:")," Essential controls (like triggers) should be locked so they're always accessible. When adding new controls, locked slots are automatically skipped."));if("Pot"===o.type&&"pin"===t||"LEDButton"===o.type&&("pin"===t||"ledPin"===t))return null;if("index"===t&&"GateIn"===o.type)return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Gate Input:"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,parseInt(e.target.value))}},a.createElement("option",{value:1},"Gate In 1 (GPA4)"),a.createElement("option",{value:2},"Gate In 2 (GPA5)")));if("mode"===t&&"GateIn"===o.type)return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Mode:"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,e.target.value)}},a.createElement("option",{value:"trigger"},"Trigger (pulse on rising edge)"),a.createElement("option",{value:"gate"},"Gate (sustained high)")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px",fontStyle:"italic"}},"trigger"===c?"Pulse output on rising edge (for piezo/drums)":"Sustained high while input active (for CV gates)"));if("device_name"===t&&"BLEMIDIIn"===o.type)return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"BLE Device Name:"),a.createElement("input",{type:"text",value:c,onChange:function(e){l(o.id,t,e.target.value)},placeholder:"e.g., FP-10, FP-30, Seaboard",style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px",fontStyle:"italic"}},"Enter exact Bluetooth name of your MIDI device"));if("channel"===t&&"BLEMIDIIn"===o.type)return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"MIDI Channel:"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,parseInt(e.target.value))}},a.createElement("option",{value:0},"Omni (All Channels)"),wt(Array(16)).map(function(e,n){return a.createElement("option",{key:n+1,value:n+1},"Channel ",n+1)})));if("auto_reconnect"===t&&"BLEMIDIIn"===o.type)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},"Auto-Reconnect:",a.createElement("button",{className:"btn ".concat(c?"btn-green":"btn-ghost"),onClick:function(){l(o.id,t,!c)},style:{fontSize:"12px",padding:"4px 8px",minWidth:"60px"}},c?"On":"Off")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px",fontStyle:"italic"}},c?"Will automatically reconnect if connection lost":"Manual reconnect required after disconnection"));if("ks_mode"===t&&"DrumDesigner"===o.type)return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"K-S Mode:"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,e.target.value)}},a.createElement("option",{value:"tonal"},"Tonal (guitar/bass decay)"),a.createElement("option",{value:"percussive"},"Percussive (marimba/xylophone)"),a.createElement("option",{value:"noise"},"Noise (short drums)")));if("body_type"===t&&"DrumDesigner"===o.type)return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Body Type:"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,e.target.value)}},a.createElement("option",{value:"wood"},"Wood"),a.createElement("option",{value:"metal"},"Metal"),a.createElement("option",{value:"glass"},"Glass")));if("pitch_sweep_mode"===t&&"DrumDesigner"===o.type)return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Pitch Sweep Mode:"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,e.target.value)}},a.createElement("option",{value:"none"},"None (static pitch)"),a.createElement("option",{value:"sine"},"Sine (808 pitch drop)"),a.createElement("option",{value:"delay"},"Delay (Boss feedback)")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px",fontStyle:"italic"}},"none"===c&&"No pitch sweep - static sine/K-S","sine"===c&&"808 kick - sine sweeps from high to low","delay"===c&&"Boss delay trick - K-S delay modulation"));if("mode"===t&&"Filter"===o.type)return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Filter Mode:"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,e.target.value)}},a.createElement("option",{value:"lowpass"},"Lowpass (cuts highs)"),a.createElement("option",{value:"highpass"},"Highpass (cuts lows)"),a.createElement("option",{value:"bandpass"},"Bandpass (narrow band)"),a.createElement("option",{value:"notch"},"Notch (removes band)")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px",fontStyle:"italic"}},"lowpass"===c&&"Removes frequencies above cutoff","highpass"===c&&"Removes frequencies below cutoff","bandpass"===c&&"Only frequencies around cutoff pass","notch"===c&&"Removes frequencies around cutoff"));if("index"===t&&("Pot"===o.type||"LEDButton"===o.type)){var r=o.params.bank||1,i=p.filter(function(e){var n;return e.type===o.type&&e.id!==o.id&&((null===(n=e.params)||void 0===n?void 0:n.bank)||1)===r}).map(function(e){var n;return(null===(n=e.params)||void 0===n?void 0:n.index)||1}),s={};i.forEach(function(e){s[e]=(s[e]||0)+1});var u=p.filter(function(e){return e.type===o.type}).length;return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Physical ","Pot"===o.type?"Pot":"Button"," (1-",4,"):"),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginBottom:"4px"}},"Bank ",r,": ",u,"/",24," total ",o.type,"s used"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,parseInt(e.target.value))}},Array.from({length:4},function(e,n){var t=n+1,c=s[t]||0,r=c>0?" (".concat(c," used)"):" (free)";return a.createElement("option",{key:t,value:t},"Pot"===o.type?"Pot":"Button"," ",t,r)})))}if("ADSR"===o.type&&["attack_ms","decay_ms","sustain","release_ms"].includes(t))return null;if("Clock"===o.type&&"bank"!==t&&"use_outputs_5_8"!==t&&"show_advanced_outputs"!==t)return null;if("Arpeggiator"===o.type){if(["held_notes"].includes(t))return null;if("pattern"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Pattern"),a.createElement("select",{value:c,onChange:function(e){return l(o.id,t,e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"up"},"Up"),a.createElement("option",{value:"down"},"Down"),a.createElement("option",{value:"updown"},"Up-Down"),a.createElement("option",{value:"downup"},"Down-Up"),a.createElement("option",{value:"random"},"Random"),a.createElement("option",{value:"asplayed"},"As Played")));if("octaves"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Octaves: ",c),a.createElement("input",{type:"range",min:"1",max:"4",step:"1",value:c,onChange:function(e){return l(o.id,t,parseInt(e.target.value))},style:{width:"100%"}}));if("rate_mode"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Rate Mode"),a.createElement("select",{value:c,onChange:function(e){return l(o.id,t,e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"sync"},"Sync to Clock"),a.createElement("option",{value:"free"},"Free Rate (Hz)")));if("clock_div"===t)return"sync"!==o.params.rate_mode?null:a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Clock Division"),a.createElement("select",{value:c,onChange:function(e){return l(o.id,t,parseInt(e.target.value))},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:1},"1 (every clock)"),a.createElement("option",{value:2},"2 (half)"),a.createElement("option",{value:4},"4 (quarter)"),a.createElement("option",{value:8},"8 (eighth)"),a.createElement("option",{value:16},"16 (sixteenth)")));if("rate_hz"===t)return"free"!==o.params.rate_mode?null:a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Rate: ",c.toFixed(1)," Hz"),a.createElement("input",{type:"range",min:"0.5",max:"20",step:"0.1",value:c,onChange:function(e){return l(o.id,t,parseFloat(e.target.value))},style:{width:"100%"}}));if("velocity_mode"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Velocity Mode"),a.createElement("select",{value:c,onChange:function(e){return l(o.id,t,e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"original"},"Original"),a.createElement("option",{value:"fixed"},"Fixed"),a.createElement("option",{value:"accent"},"Accent Beat 1")));if("note_select_mode"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Note Selection"),a.createElement("select",{value:c,onChange:function(e){return l(o.id,t,e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"all"},"Full Arpeggio"),a.createElement("option",{value:"single"},"Single Note")));if("note_select_index"===t)return"single"!==o.params.note_select_mode?null:a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Select Note: ",c+1," (1st, 2nd, 3rd...)"),a.createElement("input",{type:"range",min:"0",max:"15",step:"1",value:c,onChange:function(e){return l(o.id,t,parseInt(e.target.value))},style:{width:"100%"}}));if("midi_channel"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"MIDI Channel"),a.createElement("select",{value:c,onChange:function(e){return l(o.id,t,parseInt(e.target.value))},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:0},"Pass-through"),wt(Array(16)).map(function(e,n){return a.createElement("option",{key:n+1,value:n+1},n+1)})))}if("MIDILooper"===o.type){if(["recorded_events","loop_ticks","playhead","state","transpose","scale_lock","pitch_random","timing_random","scan_position","random_mode","voice_stealing","midi_channel"].includes(t))return null;if("bank"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Bank"),a.createElement("select",{value:c,onChange:function(e){return l(o.id,"bank",parseInt(e.target.value))},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},[1,2,3,4,5,6].map(function(e){return a.createElement("option",{key:e,value:e},"Bank ",e)})));if("loop_bars"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Loop Length (Bars)"),a.createElement("select",{value:c,onChange:function(e){return l(o.id,t,parseInt(e.target.value))},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},[1,2,4,8,16].map(function(e){return a.createElement("option",{key:e,value:e},e," bar",e>1?"s":"")})));if("count_in_bars"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Count-In"),a.createElement("select",{value:c,onChange:function(e){return l(o.id,t,parseInt(e.target.value))},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:0},"None"),a.createElement("option",{value:1},"1 bar"),a.createElement("option",{value:2},"2 bars"),a.createElement("option",{value:4},"4 bars")));if("quantize"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Quantize"),a.createElement("select",{value:c,onChange:function(e){return l(o.id,t,e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"off"},"Off"),a.createElement("option",{value:"1/4"},"1/4 note"),a.createElement("option",{value:"1/8"},"1/8 note"),a.createElement("option",{value:"1/16"},"1/16 note"),a.createElement("option",{value:"1/32"},"1/32 note")));if("random_mode"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Randomization"),a.createElement("select",{value:c,onChange:function(e){return l(o.id,t,e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"off"},"Off"),a.createElement("option",{value:"pitch"},"Pitch (in key)"),a.createElement("option",{value:"timing"},"Timing"),a.createElement("option",{value:"both"},"Both")));if("detected_key"===t){var d=o.params.detected_scale||"major";return a.createElement("div",{key:t,className:"param",style:{padding:"8px",backgroundColor:"#1e293b",borderRadius:"4px",marginBottom:"8px"}},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Detected Key"),a.createElement("div",{style:{fontSize:"14px",color:"#22c55e",fontWeight:"bold"}},["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][c]||"C"," ",d),a.createElement("div",{style:{fontSize:"10px",color:"#6b7280",marginTop:"2px"}},"Confidence: ",(100*(o.params.key_confidence||0)).toFixed(0),"%"))}if("voice_stealing"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Voice Stealing"),a.createElement("select",{value:c,onChange:function(e){return l(o.id,t,e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"oldest"},"Oldest"),a.createElement("option",{value:"lowest"},"Lowest"),a.createElement("option",{value:"highest"},"Highest")))}if("HarmonicSequencer"===o.type){if("step_count"===t){var f=c,m=o.params.start_bank||1,_=K(0,m,p.filter(function(e){return e.id!==o.id}));return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Step Count (Inspector Only)"),a.createElement("select",{value:f,onChange:function(e){var n=parseInt(e.target.value),t=K(0,m,p.filter(function(e){return e.id!==o.id}));l(o.id,"step_count",n),l(o.id,"banks_required",t.banksRequired),l(o.id,"end_bank",t.endBank)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:4},"4 steps (1 bank)"),a.createElement("option",{value:8},"8 steps (2 banks)"),a.createElement("option",{value:12},"12 steps (3 banks)"),a.createElement("option",{value:16},"16 steps (4 banks)")),a.createElement("div",{style:{fontSize:"9px",color:_.isValid?"#22c55e":"#ef4444",marginTop:"4px",padding:"4px",backgroundColor:"#1e293b",borderRadius:"3px"}},_.isValid?a.createElement(a.Fragment,null," Will use banks ",m,"-",_.endBank):a.createElement(a.Fragment,null," Cannot fit ",f," steps starting at bank ",m),!_.isValid&&_.conflicts.length>0&&a.createElement("div",{style:{color:"#ef4444",marginTop:"2px"}},"Conflicts with: ",_.conflicts.map(function(e){return"".concat(e.type," ").concat(e.id)}).join(", ")),_.endBank>8&&a.createElement("div",{style:{color:"#ef4444",marginTop:"2px"}},"Would need bank ",_.endBank," (only 6 banks available)")))}if("start_bank"===t){o.params.step_count;var g=c,h=K(0,g,p.filter(function(e){return e.id!==o.id}));return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Starting Bank"),a.createElement("select",{value:g,onChange:function(e){var n=parseInt(e.target.value),t=K(0,n,p.filter(function(e){return e.id!==o.id}));l(o.id,"start_bank",n),l(o.id,"banks_required",t.banksRequired),l(o.id,"end_bank",t.endBank)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},[1,2,3,4,5,6].map(function(e){var n=K(0,e,p.filter(function(e){return e.id!==o.id}));return a.createElement("option",{key:e,value:e,style:{color:n.isValid?"white":"#ef4444"}},"Bank ",e," ",n.isValid?"":"(conflicts)")})),a.createElement("div",{style:{fontSize:"9px",color:h.isValid?"#22c55e":"#ef4444",marginTop:"4px",padding:"4px",backgroundColor:"#1e293b",borderRadius:"3px"}},h.isValid?a.createElement(a.Fragment,null," Will use banks ",g,"-",h.endBank):a.createElement(a.Fragment,null," Cannot place sequencer at bank ",g),!h.isValid&&h.conflicts.length>0&&a.createElement("div",{style:{color:"#ef4444",marginTop:"2px"}},"Conflicts with: ",h.conflicts.map(function(e){return"".concat(e.type," ").concat(e.id)}).join(", ")),h.endBank>8&&a.createElement("div",{style:{color:"#ef4444",marginTop:"2px"}},"Would need bank ",h.endBank," (only 6 available)")))}if(["banks_required","end_bank"].includes(t))return null;if(["hardware_pots","hardware_btns"].includes(t))return null;if(t.includes("pin")||t.includes("Pin")||t.includes("_pins"))return null;if(t.includes("encoder")||t.includes("Encoder")||t.includes("enc_")||t.includes("encBtn"))return null;if(["loop_start","loop_end","loop_active"].includes(t))return null;if(t.match(/^bank[0-3]_steps$/)||["sequence_length","steps","clock_div","swing","gate_length","playback_mode","running","current_step","show_individual_outputs","individual_outputs_enabled","scale_connected","scale_root","quantization_scale","quantization_root","quantization_tuning","octave_center"].includes(t))return null}if(["KickDrum","SnareDrum","Percussion","PercussionSynth"].includes(o.type))return null;if("SamplePlayer"===o.type){if("polyphonic"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("input",{type:"checkbox",checked:c,onChange:function(e){l(o.id,t,e.target.checked)}}),t,":",a.createElement("span",{style:{fontSize:"10px",color:c?"#22c55e":"#94a3b8",fontWeight:"bold"}},c?"6-Voice PSRAM Mode":"Single Voice Mode")),c&&a.createElement("div",{style:{fontSize:"9px",color:"#6b7280",marginTop:"4px",padding:"4px",backgroundColor:"#1e293b",borderRadius:"3px"}}," ",a.createElement("strong",null,"Polyphonic Mode:")," Enables concurrent voices with PSRAM sample caching. Auto-loads sample1.wav to sample8.wav into memory for instant triggering."));if("max_voices"===t&&o.params.polyphonic)return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Voice Count (affects performance):"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,parseInt(e.target.value))}},a.createElement("option",{value:1},"1 Voice (Minimal CPU)"),a.createElement("option",{value:2},"2 Voices (Light CPU)"),a.createElement("option",{value:3},"3 Voices (Low CPU)"),a.createElement("option",{value:4},"4 Voices (Medium CPU)"),a.createElement("option",{value:6},"6 Voices (Standard)"),a.createElement("option",{value:8},"8 Voices (High CPU)")),a.createElement("div",{style:{fontSize:"9px",color:"#6b7280",marginTop:"2px",fontStyle:"italic"}},"More voices = higher CPU usage but richer polyphony"));if("auto_load_samples"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("input",{type:"checkbox",checked:c,onChange:function(e){l(o.id,t,e.target.checked)}}),"Auto-load samples:",a.createElement("span",{style:{fontSize:"10px",color:c?"#22c55e":"#94a3b8"}},c?"Load sample1-8.wav on first trigger":"Manual loading only")));if("voice_allocation"===t)return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Voice allocation strategy:"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,e.target.value)}},a.createElement("option",{value:"round_robin"},"Round Robin (balanced)"),a.createElement("option",{value:"oldest_first"},"Oldest First (voice stealing)"),a.createElement("option",{value:"random"},"Random (chaotic)")))}return"Oscillator"===o.type&&"waveform"===t?a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Waveform:"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"sine"},"Sine Wave"),a.createElement("option",{value:"triangle"},"Triangle Wave"),a.createElement("option",{value:"saw"},"Sawtooth Wave"),a.createElement("option",{value:"square"},"Square Wave"))):"Distortion"===o.type&&"preset"===t?a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Preset:"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,e.target.value)}},a.createElement("option",{value:"clean"},"Clean (soft clipping)"),a.createElement("option",{value:"overdrive"},"Overdrive (smooth saturation)"),a.createElement("option",{value:"fuzz"},"Fuzz (hard clipping)"),a.createElement("option",{value:"speaker"},"Speaker (cabinet compression)"),a.createElement("option",{value:"bitcrush"},"Bitcrush (quantized)"),a.createElement("option",{value:"saturatorlive"},"SaturatorLive (Ableton OD+Sat)"))):"Distortion"===o.type&&"bypassMode"===t?a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Bypass Mode:"),a.createElement("select",{value:c,onChange:function(e){l(o.id,t,e.target.value)}},a.createElement("option",{value:"toggle"},"Toggle (button switches on/off)"),a.createElement("option",{value:"gate"},"Gate (active while held)"))):"Distortion"===o.type&&"presetCrossfade"===t?a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Preset Crossfade: ",c.toFixed(2)," (0=instant, 1=smooth)"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:c,onChange:function(e){l(o.id,t,parseFloat(e.target.value))},style:{width:"100%"}})):"Distortion"===o.type&&"drive"===t?a.createElement("div",{key:t,className:"param"},a.createElement("label",null,"Drive: ",c.toFixed(1)," (0-10)"),a.createElement("input",{type:"range",min:"0",max:"10",step:"0.1",value:c,onChange:function(e){l(o.id,t,parseFloat(e.target.value))},style:{width:"100%"}})):"boolean"==typeof c?a.createElement("div",{key:t,className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("input",{type:"checkbox",checked:c,onChange:function(e){l(o.id,t,e.target.checked)}}),t,":",a.createElement("span",{style:{fontSize:"10px",color:c?"#22c55e":"#94a3b8",fontWeight:"bold"}},c?"ENABLED":"DISABLED"))):a.createElement("div",{key:t,className:"param"},a.createElement("label",null,t,":"),a.createElement("input",{type:"number"==typeof c?"number":"text",defaultValue:c,onBlur:function(e){var n="number"==typeof c?parseFloat(e.target.value)||0:e.target.value;l(o.id,t,n)},onKeyDown:function(e){if("Enter"===e.key){var n="number"==typeof c?parseFloat(e.target.value)||0:e.target.value;l(o.id,t,n),e.target.blur()}}}))})),"Wavetable"===o.type&&(console.log(" FM SECTION RENDERING for module:",o.id,"expanded:",ae),a.createElement("div",{className:"params"},a.createElement("h3",{style:{cursor:"pointer",display:"flex",alignItems:"center",gap:"8px",userSelect:"none"},onClick:function(){oe(!ae)}},ae?"":""," FM Synthesis"),ae&&a.createElement(a.Fragment,null,a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginBottom:"8px",lineHeight:"1.4"}},"Connect an audio signal to the FM input jack to enable frequency modulation. Modulator can track carrier frequency at a ratio, or run independently."),a.createElement("div",{className:"param"},a.createElement("label",null,"FM Amount: ",(null===(en=o.params.fm_amount)||void 0===en?void 0:en.toFixed(2))||"0.00"," (modulation depth)"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:o.params.fm_amount||0,onChange:function(e){l(o.id,"fm_amount",parseFloat(e.target.value))},style:{width:"100%"}})),a.createElement("div",{className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("input",{type:"checkbox",checked:o.params.fm_tracking||!1,onChange:function(e){l(o.id,"fm_tracking",e.target.checked)}}),"FM Tracking:",a.createElement("span",{style:{fontSize:"10px",color:o.params.fm_tracking?"#22c55e":"#94a3b8"}},o.params.fm_tracking?"Modulator tracks carrier  ratio":"Independent modulator freq"))),o.params.fm_tracking&&a.createElement(a.Fragment,null,a.createElement("div",{className:"param"},a.createElement("label",null,"C:M Ratio: ",(null===(nn=o.params.fm_ratio)||void 0===nn?void 0:nn.toFixed(2))||"1.00"," (carrier:modulator)"),a.createElement("input",{type:"range",min:"0.25",max:"8",step:"0.01",value:o.params.fm_ratio||1,onChange:function(e){l(o.id,"fm_ratio",parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"4px"}},o.params.fm_ratio>=1?"1:".concat((null===(tn=o.params.fm_ratio)||void 0===tn?void 0:tn.toFixed(2))||"1.00"," (modulator ").concat(o.params.fm_ratio," carrier)"):"".concat((1/(o.params.fm_ratio||1)).toFixed(2),":1 (modulator ").concat((1/(o.params.fm_ratio||1)).toFixed(2),")"))),a.createElement("div",{className:"param"},a.createElement("label",null,"Ratio Mode:"),a.createElement("select",{value:o.params.fm_ratio_mode||"zones",onChange:function(e){l(o.id,"fm_ratio_mode",e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"free"},"Free (continuous sweep)"),a.createElement("option",{value:"quantized"},"Quantized (snap to pure ratios)"),a.createElement("option",{value:"zones"},"Zones (detents at pure ratios)")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"4px"}},"free"===o.params.fm_ratio_mode&&"Smooth continuous ratio control","quantized"===o.params.fm_ratio_mode&&"Snaps to 1:1, 1:2, 2:1, 1:3, etc.","zones"===o.params.fm_ratio_mode&&"Magnetic zones near pure ratios")))))),"PolyOscillator"===o.type&&a.createElement("div",{className:"params"},a.createElement("h3",{style:{cursor:"pointer",display:"flex",alignItems:"center",gap:"8px",userSelect:"none"},onClick:function(){ie(!re)}},re?"":""," FM Synthesis (2-Op)"),re&&a.createElement(a.Fragment,null,a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginBottom:"8px",lineHeight:"1.4"}},"Self-contained FM: each voice has a sine modulator that tracks carrier frequency. No patching needed - just enable and adjust."),a.createElement("div",{className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("input",{type:"checkbox",checked:o.params.fm_enabled||!1,onChange:function(e){l(o.id,"fm_enabled",e.target.checked)}}),"FM Enabled:",a.createElement("span",{style:{fontSize:"10px",color:o.params.fm_enabled?"#22c55e":"#94a3b8"}},o.params.fm_enabled?"Active (adds CPU load)":"Bypassed (zero CPU cost)"))),o.params.fm_enabled&&a.createElement(a.Fragment,null,a.createElement("div",{className:"param"},a.createElement("label",null,"FM Index: ",(o.params.fm_index||0).toFixed(2)," (modulation depth)"),a.createElement("input",{type:"range",min:"0",max:"10",step:"0.1",value:o.params.fm_index||0,onChange:function(e){l(o.id,"fm_index",parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"0-2: subtle warmth | 2-5: metallic/bell | 5-10: harsh/clangy")),a.createElement("div",{className:"param"},a.createElement("label",null,"FM Ratio: ",(o.params.fm_ratio||1).toFixed(2)," (mod:carrier)"),a.createElement("input",{type:"range",min:"0.5",max:"8",step:"0.01",value:o.params.fm_ratio||1,onChange:function(e){l(o.id,"fm_ratio",parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"1:1 = brass/organ | 2:1 = clarinet | 1:2 = bass | 1.4:1 = bells")),a.createElement("div",{className:"param"},a.createElement("label",null,"Ratio Fine: ",(100*(o.params.fm_ratio_fine||0)).toFixed(1),"% (inharmonicity)"),a.createElement("input",{type:"range",min:"-0.1",max:"0.1",step:"0.001",value:o.params.fm_ratio_fine||0,onChange:function(e){l(o.id,"fm_ratio_fine",parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"0% = pure harmonic | Non-zero = bell/metallic inharmonics")),a.createElement("div",{className:"param"},a.createElement("label",null,"Env Depth: ",(100*(o.params.fm_env_depth||1)).toFixed(0),"% (envelope to mod)"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:o.params.fm_env_depth||1,onChange:function(e){l(o.id,"fm_env_depth",parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"100% = classic DX (bright attack) | 0% = constant FM (sustained brightness)")),a.createElement("div",{className:"param"},a.createElement("label",null,"Mod Amount: ",(o.params.fm_mod_amount||5).toFixed(1)," (CV input scale)"),a.createElement("input",{type:"range",min:"0",max:"10",step:"0.1",value:o.params.fm_mod_amount||5,onChange:function(e){l(o.id,"fm_mod_amount",parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"How much ADSR/LFO/velocity adds to Index. Final = Index + (CV  Mod Amount)")),a.createElement("div",{style:{fontSize:"10px",color:"#6b7280",marginTop:"8px",padding:"6px",backgroundColor:"#1e293b",borderRadius:"4px"}},a.createElement("strong",null,"Quick presets:"),a.createElement("br",null),"Electric Piano: ratio 1:1, index 2-3, env 100%",a.createElement("br",null),"Brass: ratio 1:1, index 1-2, env 80%",a.createElement("br",null),"Bell: ratio 1.4:1, fine +5%, index 4-6",a.createElement("br",null),"Bass: ratio 2:1, index 1-2, env 50%")))),"StereoMixer4"===o.type&&a.createElement("div",{className:"params"},a.createElement("h3",{style:{cursor:"pointer",display:"flex",alignItems:"center",gap:"8px",userSelect:"none"},onClick:function(){ue(!se)}},se?"":""," Channel Controls"),se&&a.createElement(a.Fragment,null,a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginBottom:"8px",lineHeight:"1.4"}},"Hardware controls via banking (Banks ",o.params.start_bank||2," & ",(o.params.start_bank||2)+1,"). These parameters set initial values."),a.createElement("div",{style:{marginBottom:"12px",paddingTop:"8px",borderTop:"1px solid #374151"}},a.createElement("h4",{style:{fontSize:"12px",color:"#60a5fa",marginBottom:"8px"}},"Channel Volumes (Bank ",o.params.start_bank||2,")"),["g1","g2","g3","g4"].map(function(e,n){return a.createElement("div",{key:e,className:"param"},a.createElement("label",null,"Ch",n+1," Volume: ",(o.params[e]||0).toFixed(2)),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:o.params[e]||0,onChange:function(n){l(o.id,e,parseFloat(n.target.value))},style:{width:"100%"}}))})),a.createElement("div",{style:{marginBottom:"12px",paddingTop:"8px",borderTop:"1px solid #374151"}},a.createElement("h4",{style:{fontSize:"12px",color:"#60a5fa",marginBottom:"8px"}},"Channel Panning (Bank ",(o.params.start_bank||2)+1,")"),["pan1","pan2","pan3","pan4"].map(function(e,n){var t=o.params[e]||.5,c=t<.4?"L":t>.6?"R":"C";return a.createElement("div",{key:e,className:"param"},a.createElement("label",null,"Ch",n+1," Pan: ",c," (",t.toFixed(2),")"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:t,onChange:function(n){l(o.id,e,parseFloat(n.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"0.0 = Left, 0.5 = Center, 1.0 = Right"))})))),"Matrix2x2"===o.type&&a.createElement("div",{className:"params"},a.createElement("h3",{style:{cursor:"pointer",display:"flex",alignItems:"center",gap:"8px",userSelect:"none"},onClick:function(){ge(!_e)}},_e?"":""," Matrix Coefficients"),_e&&a.createElement(a.Fragment,null,a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginBottom:"8px",lineHeight:"1.4"}},"Hardware controls via banking (Bank ",o.params.start_bank||1,"). Pots 1-4 control aa, ab, ba, bb (-1.0 to +1.0). These parameters set initial values."),a.createElement("div",{className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("input",{type:"checkbox",checked:o.params.show_control_inputs||!1,onChange:function(e){l(o.id,"show_control_inputs",e.target.checked)}}),"Show Control Input Jacks"),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px",fontStyle:"italic"}},o.params.show_control_inputs?"Control jacks visible - patch LFOs/envelopes to coefficients":"Control jacks hidden - hardware pots control coefficients")),a.createElement("div",{style:{marginBottom:"12px",paddingTop:"8px",borderTop:"1px solid #374151"}},a.createElement("h4",{style:{fontSize:"12px",color:"#60a5fa",marginBottom:"8px"}},"Routing Coefficients (Bank ",o.params.start_bank||1,")"),a.createElement("div",{className:"param"},a.createElement("label",null,"aa (In A  Out A): ",(o.params.aa||0).toFixed(2)),a.createElement("input",{type:"range",min:"-1",max:"1",step:"0.01",value:o.params.aa||0,onChange:function(e){l(o.id,"aa",parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"Hardware: Pot 1 (maps 0.0-1.0  -1.0 to +1.0)")),a.createElement("div",{className:"param"},a.createElement("label",null,"ab (In A  Out B): ",(o.params.ab||0).toFixed(2)),a.createElement("input",{type:"range",min:"-1",max:"1",step:"0.01",value:o.params.ab||0,onChange:function(e){l(o.id,"ab",parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"Hardware: Pot 2 (maps 0.0-1.0  -1.0 to +1.0)")),a.createElement("div",{className:"param"},a.createElement("label",null,"ba (In B  Out A): ",(o.params.ba||0).toFixed(2)),a.createElement("input",{type:"range",min:"-1",max:"1",step:"0.01",value:o.params.ba||0,onChange:function(e){l(o.id,"ba",parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"Hardware: Pot 3 (maps 0.0-1.0  -1.0 to +1.0)")),a.createElement("div",{className:"param"},a.createElement("label",null,"bb (In B  Out B): ",(o.params.bb||0).toFixed(2)),a.createElement("input",{type:"range",min:"-1",max:"1",step:"0.01",value:o.params.bb||0,onChange:function(e){l(o.id,"bb",parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"Hardware: Pot 4 (maps 0.0-1.0  -1.0 to +1.0)"))),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"8px",fontStyle:"italic",padding:"8px",backgroundColor:"#1e293b",borderRadius:"4px"}}," ",a.createElement("strong",null,"Tip:")," Negative values invert phase. For feedback, try aa/bb at ~0.8, ab/ba at varying amounts."))),"DrumDesigner4"===o.type&&a.createElement("div",{className:"params"},a.createElement("h3",{style:{cursor:"pointer",display:"flex",alignItems:"center",gap:"8px",userSelect:"none"},onClick:function(){fe(!pe)}},pe?"":""," Voice Controls"),pe&&a.createElement(a.Fragment,null,a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginBottom:"12px",lineHeight:"1.4"}},"Configure each of the 4 percussion voices. Disable unused voices to save CPU."),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr",gap:"8px",marginBottom:"16px"}},[1,2,3,4].map(function(e){var n=!1!==o.params["voice".concat(e,"_enabled")];return a.createElement("div",{key:e,style:{padding:"8px",backgroundColor:n?"#1e293b":"#0f172a",border:"2px solid ".concat(n?"#3b82f6":"#334155"),borderRadius:"4px",cursor:"pointer",opacity:n?1:.5,transition:"all 0.2s"},onClick:function(){l(o.id,"voice".concat(e,"_enabled"),!n)}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"6px",marginBottom:"4px"}},a.createElement("input",{type:"checkbox",checked:n,onChange:function(){},style:{cursor:"pointer"}}),a.createElement("span",{style:{fontWeight:"bold",fontSize:"12px"}},"Voice ",e)),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8"}},["marimba","snare","hihat","tom"][e-1]))})),a.createElement("div",{className:"param",style:{marginBottom:"16px"}},a.createElement("label",{style:{fontWeight:"bold",color:"#60a5fa"}},"Edit Voice:"),a.createElement("select",{value:o.params.selected_voice||1,onChange:function(e){l(o.id,"selected_voice",parseInt(e.target.value))},style:{width:"100%",padding:"6px",backgroundColor:"#1e293b",border:"1px solid #475569",borderRadius:"4px",color:"#e2e8f0"}},[1,2,3,4].map(function(e){var n=!1!==o.params["voice".concat(e,"_enabled")];return a.createElement("option",{key:e,value:e,disabled:!n},"Voice ",e," ",n?"":"(disabled)")}))),function(){var e=o.params.selected_voice||1;if(!1===o.params["voice".concat(e,"_enabled")])return a.createElement("div",{style:{padding:"12px",backgroundColor:"#0f172a",borderRadius:"4px",fontSize:"12px",color:"#94a3b8",textAlign:"center"}},"Voice ",e," is disabled. Enable it above to edit parameters.");var n=[{key:"voice".concat(e,"_pitch"),label:"Pitch (MIDI)",min:24,max:96,step:1},{key:"voice".concat(e,"_ks_damping"),label:"Damping",min:0,max:1,step:.01},{key:"voice".concat(e,"_ks_level"),label:"K-S Level",min:0,max:1,step:.01},{key:"voice".concat(e,"_sine_level"),label:"Sine Level",min:0,max:1,step:.01},{key:"voice".concat(e,"_amp_attack"),label:"Attack (ms)",min:.1,max:100,step:.1},{key:"voice".concat(e,"_amp_decay"),label:"Decay (ms)",min:10,max:2e3,step:10},{key:"voice".concat(e,"_amp_release"),label:"Release (ms)",min:10,max:1e3,step:10},{key:"voice".concat(e,"_output_gain"),label:"Output Gain",min:0,max:5,step:.1}];return a.createElement("div",null,a.createElement("h4",{style:{fontSize:"12px",color:"#60a5fa",marginBottom:"8px",paddingTop:"8px",borderTop:"1px solid #374151"}},"Voice ",e," Parameters"),n.map(function(e){var n=e.key,t=e.label,c=e.min,r=e.max,i=e.step,s=o.params[n]||0;return a.createElement("div",{key:n,className:"param"},a.createElement("label",null,t,": ",s.toFixed(i>=1?0:2)),a.createElement("input",{type:"range",min:c,max:r,step:i,value:s,onChange:function(e){l(o.id,n,parseFloat(e.target.value))},style:{width:"100%"}}))}))}())),p.some(function(e){return"Pot"===e.type||"LEDButton"===e.type})&&a.createElement("div",{className:"params"},a.createElement("h3",{style:{cursor:"pointer",display:"flex",alignItems:"center",gap:"8px",userSelect:"none"},onClick:function(){M(!L)}},L?"":""," Hardware Banking Overview"),L&&a.createElement(a.Fragment,null,a.createElement("div",{style:{fontSize:"11px",lineHeight:"1.4"}},(Qe=p.filter(function(e){return"Pot"===e.type}),Je={},Qe.forEach(function(e){var n,t=(null===(n=e.params)||void 0===n?void 0:n.bank)||1;Je[t]||(Je[t]=[]),Je[t].push(e)}),a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("div",{style:{fontWeight:"bold",color:"#22c55e",marginBottom:"4px"}}," Pots: ",Qe.length,"/32 total (",Qe.length>32?"OVER LIMIT!":"OK",")"),[1,2,3,4,5,6].map(function(e){var n=Je[e]||[],t=0===n.length;return a.createElement("div",{key:e,style:{display:"flex",alignItems:"center",marginBottom:"2px",opacity:t?.5:1}},a.createElement("div",{style:{width:"12px",height:"12px",backgroundColor:Bt[e-1],borderRadius:"2px",marginRight:"6px"}}),a.createElement("div",{style:{minWidth:"60px"}},"Bank ",e,":"),a.createElement("div",{style:{flex:1}},t?"empty":n.map(function(e,t){var c,r=(null===(c=e.params)||void 0===c?void 0:c.index)||1;return a.createElement("span",{key:e.id,style:{marginRight:"4px",color:e.id===(null==o?void 0:o.id)?"#22c55e":"#cbd5e1"}},"P",r,t<n.length-1?",":"")})))}))),(Xe=p.filter(function(e){return"LEDButton"===e.type}),Ze={},Xe.forEach(function(e){var n,t=(null===(n=e.params)||void 0===n?void 0:n.bank)||1;Ze[t]||(Ze[t]=[]),Ze[t].push(e)}),a.createElement("div",null,a.createElement("div",{style:{fontWeight:"bold",color:"#22c55e",marginBottom:"4px"}}," Buttons: ",Xe.length,"/32 total (",Xe.length>32?"OVER LIMIT!":"OK",")"),[1,2,3,4,5,6].map(function(e){var n=Ze[e]||[],t=0===n.length;return a.createElement("div",{key:e,style:{display:"flex",alignItems:"center",marginBottom:"2px",opacity:t?.5:1}},a.createElement("div",{style:{width:"12px",height:"12px",backgroundColor:Bt[e-1],borderRadius:"2px",marginRight:"6px"}}),a.createElement("div",{style:{minWidth:"60px"}},"Bank ",e,":"),a.createElement("div",{style:{flex:1}},t?"empty":n.map(function(e,t){var c,r=(null===(c=e.params)||void 0===c?void 0:c.index)||1;return a.createElement("span",{key:e.id,style:{marginRight:"4px",color:e.id===(null==o?void 0:o.id)?"#22c55e":"#cbd5e1"}},"B",r,t<n.length-1?",":"")})))}))),a.createElement("div",{style:{marginTop:"8px",padding:"6px",backgroundColor:"#0f172a",borderRadius:"4px",border:"1px solid #334155"}},a.createElement("div",{style:{fontWeight:"bold",color:"#f59e0b",marginBottom:"2px"}}," Dedicated Banking System"),a.createElement("div",null,"4 physical pots  6 banks = 24 virtual pots max"),a.createElement("div",null,"4 physical buttons  6 banks = 24 virtual buttons max"),a.createElement("div",{style:{marginTop:"6px",fontSize:"10px",color:"#94a3b8"}},a.createElement("div",{style:{fontWeight:"bold",color:"#22c55e",marginBottom:"2px"}}," Encoder Navigation (clockwise):"),a.createElement("div",null,"Bank 1: Gate1 LED  Bank 2: Gate2 LED  Bank 3: MIDI-IN LED"),a.createElement("div",null,"Bank 4: MIDI-OUT LED  Bank 5: Gate3 LED  Bank 6: Gate4 LED"),a.createElement("div",null,"Bank 5: Gate3 LED  Bank 6: Gate4 LED  wraps to Bank 1"),a.createElement("div",{style:{marginTop:"4px",fontStyle:"italic"}}," Encoder button: confirm bank selection"),a.createElement("div",{style:{fontStyle:"italic"}}," LEDs fade back to normal operation after selection"),a.createElement("div",{style:{fontStyle:"italic"}}," Second encoder press: show current bank")),a.createElement("div",{style:{marginTop:"6px",fontSize:"10px",padding:"4px",backgroundColor:"#1e293b",borderRadius:"3px"}},a.createElement("span",{style:{color:"#f59e0b"}}," Future:")," WS2812B LEDs under pots/buttons will match bank colors"))))),a.createElement("div",{className:"params"},a.createElement("h3",null,"Debug Tools"),a.createElement("button",{className:"btn ".concat("copied"===_?"btn-green":"btn-amber"),onClick:m,style:{width:"100%",marginBottom:"8px"},disabled:"copying"===_},"copied"===_?"Copied!":"copying"===_?"Copying...":"Copy Netlist")),k&&o&&a.createElement(An,{componentName:"Sample Editor",onRetry:function(){x(!1),setTimeout(function(){return x(!0)},100)}},a.createElement(Sn,{module:o,onUpdateParam:l,onClose:function(){return x(!1)},modules:p})),E&&o&&a.createElement(Wn,{module:o,onUpdateParam:l,onClose:function(){return P(!1)},fullscreen:!0}),C&&o&&a.createElement(Hn,{module:o,onUpdateParam:l,onClose:function(){return I(!1)},fullscreen:!0}),A&&o&&a.createElement(Xn,{module:o,onUpdateParam:l,onClose:function(){return B(!1)}}),F&&o&&a.createElement(ot,{module:o,onUpdateParam:l,onClose:function(){return N(!1)},fullscreen:!0}),Z&&o&&a.createElement(mt,{module:o,modules:p,onUpdateParam:l,onClose:function(){return Q(!1)},fullscreen:!0}),G&&o&&a.createElement(ct,{module:o,modules:p,onUpdateParam:l,onClose:function(){return q(!1)},fullscreen:!0}),W&&o&&a.createElement(ct,{module:o,modules:p,onUpdateParam:l,onClose:function(){return V(!1)},fullscreen:!0}),j&&o&&a.createElement(bt,{module:o,modules:p,onUpdateParam:l,onClose:function(){return $(!1)},fullscreen:!0}),ee&&o&&a.createElement(wn,{module:o,onUpdateParam:l,onClose:function(){return ne(!1)}}))},Wt=function(){var e=[],n=Lt((0,a.useState)([]),2),t=n[0],o=n[1],c=Lt((0,a.useState)(function(){return console.log("Loading default connections:",e),e}),2),r=c[0],i=c[1],l=Lt((0,a.useState)(null),2),s=l[0],u=l[1],d=Lt((0,a.useState)([]),2),p=d[0],f=d[1],m=Lt((0,a.useState)(null),2),_=m[0],g=m[1],h=Lt((0,a.useState)(null),2),v=h[0],b=h[1],y=Lt((0,a.useState)(null),2),k=(y[0],y[1]),x=Lt((0,a.useState)([]),2),S=x[0],E=x[1],P=Lt((0,a.useState)(null),2),w=P[0],C=P[1],I=Lt((0,a.useState)(null),2),R=I[0],L=I[1],M=Lt((0,a.useState)(!1),2),D=(M[0],M[1],Lt((0,a.useState)({x:0,y:0}),2)),A=(D[0],D[1],Lt((0,a.useState)(!1),2)),B=(A[0],A[1],Lt((0,a.useState)(null),2)),T=B[0],F=B[1],N=Lt((0,a.useState)({x:0,y:0}),2),z=N[0],G=N[1],V=Lt((0,a.useState)({x:0,y:0}),2),H=V[0],K=V[1],$=Lt((0,a.useState)(1),2),X=$[0],Z=$[1],Q=Lt((0,a.useState)(""),2),J=Q[0],ee=Q[1],ne=Lt((0,a.useState)(!1),2),te=ne[0],ae=ne[1],oe=Lt((0,a.useState)("idle"),2),ce=oe[0],re=oe[1],ie=Lt((0,a.useState)({percentage:0,breakdown:[]}),2),le=ie[0],se=ie[1],ue=Lt((0,a.useState)(!1),2),de=(ue[0],ue[1]),pe=Lt((0,a.useState)(!1),2),fe=pe[0],me=pe[1],_e=Lt((0,a.useState)(""),2),ge=_e[0],he=_e[1],ve=Lt((0,a.useState)(null),2),be=(ve[0],ve[1]),ye=Lt((0,a.useState)(!1),2),ke=(ye[0],ye[1]),xe=Lt((0,a.useState)(null),2),Se=(xe[0],xe[1]),Ee=Lt((0,a.useState)(null),2),Pe=Ee[0],we=Ee[1],Ce=Lt((0,a.useState)(!1),2),Ie=Ce[0],Re=Ce[1],Le=Lt((0,a.useState)(null),2),Me=Le[0],De=Le[1],Ae=Lt((0,a.useState)(!1),2),Oe=Ae[0],Be=Ae[1],Te=Lt((0,a.useState)(null),2),Fe=Te[0],Ne=Te[1],ze=Lt((0,a.useState)(!1),2),Ge=(ze[0],ze[1]),qe=Lt((0,a.useState)(null),2),Ue=(qe[0],qe[1]),We=Lt((0,a.useState)(!1),2),Ve=(We[0],We[1]),He=Lt((0,a.useState)(null),2),je=(He[0],He[1]),Ke=Lt((0,a.useState)(!1),2),Ye=Ke[0],$e=Ke[1],Xe=Lt((0,a.useState)({id:"standalone",type:"SampleEditor",params:{sample_number:1,custom_suffix:"",sample_name:""}}),2),Qe=Xe[0],Je=Xe[1],en=Lt((0,a.useState)("idle"),2),nn=en[0],tn=en[1],an=Lt((0,a.useState)(!1),2),on=an[0],cn=an[1],rn=Lt((0,a.useState)({top:{x:340,y:20},audioIn:{x:20,y:170},speaker:{x:860,y:120},lineOut:{x:860,y:270},controls:{x:340,y:360}}),2),ln=rn[0],sn=rn[1],un=Lt((0,a.useState)(null),2),dn=(un[0],un[1],Lt((0,a.useState)({x:0,y:0}),2)),pn=(dn[0],dn[1],(0,a.useRef)()),fn=(0,a.useRef)(!1),mn=Lt((0,a.useState)(null),2),_n=mn[0],gn=mn[1],hn=Lt((0,a.useState)([]),2),vn=hn[0],bn=hn[1],yn=Lt((0,a.useState)(-1),2),kn=yn[0],xn=yn[1],En=Lt((0,a.useState)(!1),2),Pn=En[0],wn=En[1],Cn=(0,a.useCallback)(function(){if(Pn)console.log("Skipping history save during undo/redo");else{var e={modules:JSON.parse(JSON.stringify(t)),connections:JSON.parse(JSON.stringify(r)),groups:JSON.parse(JSON.stringify(S))};console.log("Saving to history. Current index: ".concat(kn,", Snapshot:"),{modules:e.modules.length,connections:e.connections.length,groups:e.groups.length}),bn(function(n){var t=n.slice(0,kn+1);return t.push(e),t.length>50?(t.shift(),t):(console.log("History updated. New length: ".concat(t.length)),t)}),xn(function(e){return Math.min(e+1,49)})}},[t,r,S,kn,Pn]);(0,a.useEffect)(function(){var e={modules:JSON.parse(JSON.stringify(t)),connections:JSON.parse(JSON.stringify(r)),groups:JSON.parse(JSON.stringify(S))};bn([e]),xn(0),console.log("Saved initial state to history")},[]),(0,a.useEffect)(function(){return document.addEventListener("keydown",Mn),function(){return document.removeEventListener("keydown",Mn)}},[_,s,p,w,v,r,t,S,vn,kn]),(0,a.useEffect)(function(){var e=function(e){"Shift"===e.key&&(fn.current=!0)},n=function(e){"Shift"===e.key&&(fn.current=!1)};return document.addEventListener("keydown",e),document.addEventListener("keyup",n),function(){document.removeEventListener("keydown",e),document.removeEventListener("keyup",n)}},[]),(0,a.useEffect)(function(){try{var e=new Ze(t,r,S).estimateCPU();se(e)}catch(e){console.error("CPU estimation error:",e),se({percentage:0,breakdown:[]})}},[t,r,S]);var In=function(e,n,a){o(function(t){return t.map(function(o){if(o.id!==e)return o;var c=It(It({},o.params),{},Rt({},n,a));if("LEDButton"===o.type&&"index"===n){var r={1:{pin:0,ledPin:6},2:{pin:1,ledPin:7},3:{pin:2,ledPin:8},4:{pin:3,ledPin:9}}[a];r&&(c.pin=r.pin,c.ledPin=r.ledPin)}if("Pot"===o.type&&"index"===n){var i={1:7,2:3,3:4,4:5}[a];void 0!==i&&(c.pin=i)}if("Clock"===o.type&&"use_outputs_5_8"===n&&!0===a){var l=c.bank||1,s=t.filter(function(e){return e.id!==o.id});if(q(s).has(l+1)||l>5){var u=U(2,s);c.bank=u}}return It(It({},o),{},{params:c})})}),(null==s?void 0:s.id)===e&&u(function(e){var o=It(It({},e.params),{},Rt({},n,a));if("LEDButton"===e.type&&"index"===n){var c={1:{pin:0,ledPin:6},2:{pin:1,ledPin:7},3:{pin:2,ledPin:8},4:{pin:3,ledPin:9}}[a];c&&(o.pin=c.pin,o.ledPin=c.ledPin)}if("Pot"===e.type&&"index"===n){var r={1:7,2:3,3:4,4:5}[a];void 0!==r&&(o.pin=r)}if("Clock"===e.type&&"use_outputs_5_8"===n&&!0===a){var i=o.bank||1,l=t.filter(function(n){return n.id!==e.id});if(q(l).has(i+1)||i>5){var s=U(2,l);o.bank=s}}return It(It({},e),{},{params:o})})},Rn=function(e){Cn(),i(function(n){return n.filter(function(n){return"".concat(n.from.id,"-").concat(n.to.id)!==e})}),g(null)},Ln=function(e){console.log("Deleting module: ".concat(e)),Cn(),o(function(n){var t=n.filter(function(n){return n.id!==e});return console.log("Modules after delete: ".concat(t.length," (was ").concat(n.length,")")),t}),i(function(n){return n.filter(function(n){var t=n.from.id.split(":")[0],a=n.to.id.split(":")[0];return t!==e&&a!==e})}),E(function(n){return n.map(function(n){var t,a,o,c;if(!n.moduleIds.includes(e))return n;var r=(null===(t=n.inputPorts)||void 0===t?void 0:t.filter(function(n){return n.targetModuleId!==e}))||[],i=(null===(a=n.outputPorts)||void 0===a?void 0:a.filter(function(n){return n.sourceModuleId!==e}))||[],l=n.moduleIds.filter(function(n){return n!==e});return console.log("Cleaned up group ".concat(n.id,": removed ").concat((null===(o=n.inputPorts)||void 0===o?void 0:o.length)-r.length," input ports, ").concat((null===(c=n.outputPorts)||void 0===c?void 0:c.length)-i.length," output ports")),It(It({},n),{},{moduleIds:l,inputPorts:r,outputPorts:i})})}),(null==s?void 0:s.id)===e&&u(null)},Mn=function(e){if("INPUT"!==e.target.tagName&&"SELECT"!==e.target.tagName&&"TEXTAREA"!==e.target.tagName)if(!e.ctrlKey&&!e.metaKey||"z"!==e.key||e.shiftKey)if((e.ctrlKey||e.metaKey)&&"z"===e.key&&e.shiftKey){if(e.preventDefault(),kn<vn.length-1){var n=vn[kn+1];wn(!0),o(n.modules),i(n.connections),E(n.groups),xn(function(e){return e+1}),u(null),f([]),g(null),C(null),setTimeout(function(){return wn(!1)},100),console.log("Redo to history index ".concat(kn+1))}}else if(!e.ctrlKey&&!e.metaKey||"c"!==e.key){if(!e.ctrlKey&&!e.metaKey||"v"!==e.key){if("Delete"===e.key||"Backspace"===e.key)if(_)Rn(_);else if(w)Cn(),On(w.id);else if(p.length>0){Cn();var a=new Set(p.map(function(e){return e.id}));o(function(e){return e.filter(function(e){return!a.has(e.id)})}),i(function(e){return e.filter(function(e){var n=e.from.id.split(":")[0],t=e.to.id.split(":")[0];return!a.has(n)&&!a.has(t)})}),f([])}else s&&Ln(s.id);"Escape"===e.key&&(F(null),g(null),u(null),f([]),k(null),C(null))}else if(e.preventDefault(),v&&v.modules.length>0){Cn();var c=50;if(v.group)for(var l=v.group.x,d=v.group.y,m=!0,h=function(){var e=l+c,n=d+c;(m=S.some(function(t){return Math.abs(t.x-e)<20&&Math.abs(t.y-n)<20}))&&(c+=50)};m&&c<500;)h();else for(var y=v.modules.map(function(e){return{x:e.x,y:e.y}}),x=!0;x&&c<500;)(x=y.some(function(e){var n=e.x+c,a=e.y+c;return t.some(function(e){return Math.abs(e.x-n)<20&&Math.abs(e.y-a)<20})}))&&(c+=50);var P=new Map,I=v.modules.map(function(e){var n=W(e.type,e.x+c,e.y+c,t);return P.set(e.id,n.id),n.params=It({},e.params),n}),R=v.connections.map(function(e){var n=e.from.id.split(":")[0],t=e.to.id.split(":")[0],a=e.from.id.split(":")[1],o=e.to.id.split(":")[1],c=P.get(n),r=P.get(t);return c&&r?{from:{id:"".concat(c,":").concat(a),port:e.from.port,kind:e.from.kind},to:{id:"".concat(r,":").concat(o),port:e.to.port,kind:e.to.kind}}:null}).filter(function(e){return null!==e});if(o(function(e){return[].concat(wt(e),wt(I))}),i(function(e){return[].concat(wt(e),wt(R))}),v.group){var L=v.group.moduleIds.map(function(e){return P.get(e)}).filter(function(e){return e}),M=S.filter(function(e){return e.label.startsWith(v.group.label)}).length,D=M>0?"".concat(v.group.label," (").concat(M,")"):v.group.label,A={id:"group".concat(Date.now()),label:D,moduleIds:L,x:v.group.x+c,y:v.group.y+c,color:v.group.color,collapsed:v.group.collapsed,inputPorts:v.group.inputPorts?v.group.inputPorts.map(function(e){var n=P.get(e.targetModuleId)||e.targetModuleId;return{id:"".concat(n,":").concat(e.port),port:e.port,kind:e.kind,targetModuleId:n,targetPort:e.targetPort||e.port,x:e.x?e.x+c:e.x,y:e.y?e.y+c:e.y}}):[],outputPorts:v.group.outputPorts?v.group.outputPorts.map(function(e){var n=P.get(e.sourceModuleId)||e.sourceModuleId;return{id:"".concat(n,":").concat(e.port),port:e.port,kind:e.kind,sourceModuleId:n,sourcePort:e.sourcePort||e.port,x:e.x?e.x+c:e.x,y:e.y?e.y+c:e.y}}):[]};E(function(e){return[].concat(wt(e),[A])}),C(A),f([]),u(null),console.log("Pasted group with ".concat(I.length," modules and ").concat(R.length," connections"))}else f(I),u(null),console.log("Pasted ".concat(I.length," modules and ").concat(R.length," connections"))}}else{if(e.preventDefault(),w){var O=t.filter(function(e){return w.moduleIds.includes(e.id)}),B=new Set(O.map(function(e){return e.id})),T=r.filter(function(e){var n=e.from.id.split(":")[0],t=e.to.id.split(":")[0];return B.has(n)&&B.has(t)});return b({modules:O,connections:T,group:w}),void console.log("Copied group with ".concat(O.length," modules and ").concat(T.length," connections"))}var N=p.length>0?p:s?[s]:[];if(N.length>0){var z=new Set(N.map(function(e){return e.id})),G=r.filter(function(e){var n=e.from.id.split(":")[0],t=e.to.id.split(":")[0];return z.has(n)&&z.has(t)});b({modules:N,connections:G}),console.log("Copied ".concat(N.length," modules and ").concat(G.length," connections"))}}else if(e.preventDefault(),console.log("Undo requested. Current index: ".concat(kn,", History length: ").concat(vn.length)),kn>0){var q=vn[kn-1];console.log("Restoring state from index ".concat(kn-1,":"),{modules:q.modules.length,connections:q.connections.length,groups:q.groups.length}),wn(!0),o(q.modules),i(q.connections),E(q.groups),xn(function(e){return e-1}),u(null),f([]),g(null),C(null),setTimeout(function(){return wn(!1)},100)}else console.log("Cannot undo: at oldest history state")},Dn=function(){var e=Et(kt().m(function e(){var n,a,o,c,i,l,s,u;return kt().w(function(e){for(;;)switch(e.p=e.n){case 0:if(0!==t.length){e.n=1;break}return alert("No modules in patch. Add some modules first."),e.a(2);case 1:if((n=Y(t)).isValid){e.n=2;break}if(a=n.conflicts.map(function(e){return"Bank ".concat(e.bank,": ").concat(e.modules.map(function(e){return"".concat(e.module," (").concat(e.type,")")}).join(", "))}).join("\n"),confirm(" BANK CONFLICTS DETECTED:\n\n".concat(a,"\n\n")+"These modules are trying to control the same hardware pots/buttons.\nThe generated code may not work as expected.\n\nGenerate code anyway?")){e.n=2;break}return e.a(2);case 2:if(e.p=2,console.log("Generating code using frontend CodeGenerator..."),console.log("Modules: ".concat(t.length,", Connections: ").concat(r.length)),o=new Ze(t,r,S),c=o.estimateCPU(),console.log("CPU Estimate:",c),console.log("  Estimated: ".concat(c.percentage,"% (").concat(c.estimatedCycles," / ").concat(c.availableCycles," cycles)")),c.breakdown.forEach(function(e){console.log("  ".concat(e.id," (").concat(e.type,"): ").concat(e.cost," units"))}),i=o.generate(),ee(i),e.p=3,!navigator.clipboard||!window.isSecureContext){e.n=5;break}return e.n=4,navigator.clipboard.writeText(i);case 4:e.n=6;break;case 5:(l=document.createElement("textarea")).value=i,l.style.position="fixed",l.style.left="-999999px",l.style.top="-999999px",document.body.appendChild(l),l.focus(),l.select(),document.execCommand("copy"),document.body.removeChild(l);case 6:console.log(" Code copied to clipboard successfully"),console.log("Estimated CPU: ".concat(c.percentage,"% (").concat(c.estimatedCycles," / ").concat(c.availableCycles," cycles per sample)")),c.percentage>80&&console.warn(" WARNING: High CPU usage!"),re("copied"),setTimeout(function(){return re("idle")},2e3),e.n=8;break;case 7:e.p=7,s=e.v,console.error("Failed to copy to clipboard:",s),alert("Failed to copy to clipboard. Use Code Preview to manually copy.");case 8:console.log(" Code generated successfully"),console.log("Code length: ".concat(i.length," characters")),e.n=10;break;case 9:e.p=9,u=e.v,console.error("Code generation error:",u),alert("Code generation failed: ".concat(u.message));case 10:return e.a(2)}},e,null,[[3,7],[2,9]])}));return function(){return e.apply(this,arguments)}}(),On=function(e){var n=S.find(function(n){return n.id===e});if(n){var t=new Set(n.moduleIds);o(function(e){return e.filter(function(e){return!t.has(e.id)})}),i(function(n){return n.filter(function(n){var a=n.from.id.split(":")[0],o=n.to.id.split(":")[0];return!t.has(a)&&!t.has(o)&&a!==e&&o!==e})}),E(function(n){return n.filter(function(n){return n.id!==e})}),(null==w?void 0:w.id)===e&&C(null),R===e&&L(null),console.log("Deleted group ".concat(e," and ").concat(t.size," contained modules"))}},Bn=function(e,n){E(function(t){return t.map(function(t){return t.id===e?It(It({},t),{},{label:n}):t})}),(null==w?void 0:w.id)===e&&C(function(e){return It(It({},e),{},{label:n})})},Tn=function(){var e=Et(kt().m(function e(){var n,a,o,c,i;return kt().w(function(e){for(;;)switch(e.p=e.n){case 0:if(0!==t.length){e.n=1;break}return tn("idle"),e.a(2);case 1:return tn("copying"),n=function(e){return S.find(function(n){return n.moduleIds.includes(e)})},a="",o=[],c={},r.forEach(function(e){var a=e.from.id.split(":"),r=e.to.id.split(":"),i=a[0],l=r[0],s=a[1]||"",u=r[1]||"",d=t.find(function(e){return e.id===i}),p=t.find(function(e){return e.id===l}),f=n(i),m=n(l),_=e.from.kind||"unknown";if("unknown"===_&&(s.match(/^(L|R|left|right|outL|outR|inL|inR)$/i)||u.match(/^(L|R|left|right|outL|outR|inL|inR)$/i)?_="audio":(s.match(/^(value|press|freq|wave|fm|btn\d+)$/i)||u.match(/^(value|press|freq|wave|fm|btn\d+)$/i))&&(_="control")),f||m)if(f&&m&&f.id===m.id){c[f.id]||(c[f.id]=[]);var g=d?zt(d,O[d.type],t):i,h=p?zt(p,O[p.type],t):l;c[f.id].push("  [".concat(_,"] ").concat(g,":").concat(s,"  ").concat(h,":").concat(u))}else{var v,b;if(f){var y=f.outputPorts.find(function(e){return e.sourceModuleId===i&&e.sourcePort===s});v=y?"".concat(f.label,":out_").concat(y.port):"".concat(f.label,":").concat(s)}else v=d?zt(d,O[d.type],t):i,v="".concat(v,":").concat(s);if(m){var k=m.inputPorts.find(function(e){return e.targetModuleId===l&&e.targetPort===u});b=k?"".concat(m.label,":in_").concat(k.port):"".concat(m.label,":").concat(u)}else b=p?zt(p,O[p.type],t):l,b="".concat(b,":").concat(u);o.push("[".concat(_,"] ").concat(v,"  ").concat(b))}else{var x=d?zt(d,O[d.type],t):i,S=p?zt(p,O[p.type],t):l;o.push("[".concat(_,"] ").concat(x,":").concat(s,"  ").concat(S,":").concat(u))}}),o.length>0&&(a+="=== EXTERNAL CONNECTIONS ===\n",a+=o.join("\n")+"\n"),Object.keys(c).length>0&&(a+="\n=== INTERNAL GROUP CONNECTIONS ===\n",Object.keys(c).forEach(function(e){var n=S.find(function(n){return n.id===e});a+="\n".concat(n?n.label:e,":\n"),a+=c[e].join("\n")+"\n"})),e.p=2,e.n=3,navigator.clipboard.writeText(a);case 3:tn("copied"),setTimeout(function(){tn("idle")},1e3),e.n=5;break;case 4:e.p=4,i=e.v,console.error("Failed to copy to clipboard:",i),tn("idle"),alert("Failed to copy to clipboard. Check console for details.");case 5:return e.a(2)}},e,null,[[2,4]])}));return function(){return e.apply(this,arguments)}}(),Fn=function(){console.log("handleZoomToFit called, canvasRef:",pn.current),pn.current&&pn.current.zoomToFit?pn.current.zoomToFit():console.log("No zoomToFit function available")};return a.createElement("div",{className:"app",onMouseMove:function(e){T&&K({x:e.clientX,y:e.clientY})},onClick:T?function(e){"app"!==e.target.className&&"main-content"!==e.target.className||F(null)}:void 0},T&&function(){var e=function(){if(!T||!pn.current)return null;var e=pn.current.getCanvasInfo();return null!=e&&e.rect?{x:e.rect.left+e.transform.x+T.x*e.transform.scale,y:e.rect.top+e.transform.y+T.y*e.transform.scale}:null}();if(!e)return null;var n=H.x,t=H.y,o=e.x,c=e.y,r=n-o,i=.3*Math.abs(r),l="M ".concat(o," ").concat(c," C ").concat(o+i," ").concat(c,", ").concat(n-i," ").concat(t,", ").concat(n," ").concat(t);return a.createElement("svg",{style:{position:"fixed",top:0,left:0,width:"100vw",height:"100vh",pointerEvents:"none",zIndex:2147483647,isolation:"isolate"}},a.createElement("path",{d:l,stroke:"audio"===T.kind?"#34d399":"#9333ea",strokeWidth:"4",strokeDasharray:"8,4",fill:"none",opacity:"1",style:{filter:"drop-shadow(0 0 3px rgba(0,0,0,0.5))"}}),a.createElement("circle",{cx:o,cy:c,r:"8",fill:"audio"===T.kind?"#34d399":"#9333ea",stroke:"#ffffff",strokeWidth:"2"}),a.createElement("circle",{cx:n,cy:t,r:"6",fill:"audio"===T.kind?"#34d399":"#9333ea",stroke:"#ffffff",strokeWidth:"2",opacity:"0.9"}))}(),a.createElement(At,{onGenerateCode:Dn,onCodePreview:function(){if(!J){if(0===t.length)return void alert("No modules in patch. Add some modules first.");try{var e=new Ze(t,r,S).generate();ee(e)}catch(e){return console.error("Code generation error:",e),void alert("Code generation failed: ".concat(e.message))}}ae(!0)},onSavePatch:function(){var e=prompt("Enter patch name:","Untitled Patch");if(null!==e){var n=e.trim().replace(/[^a-z0-9_\- ]/gi,"_")||"Untitled",a={version:"1.0",name:e,created:(new Date).toISOString(),modules:t.map(function(e){return{id:e.id,type:e.type,x:e.x,y:e.y,params:e.params}}),connections:r.map(function(e){return{from:e.from,to:e.to}})},o=JSON.stringify(a,null,2),c=new Blob([o],{type:"application/json"}),i=URL.createObjectURL(c),l=document.createElement("a");l.href=i,l.download="".concat(n,".json"),document.body.appendChild(l),l.click(),document.body.removeChild(l),URL.revokeObjectURL(i),console.log("Patch saved as: ".concat(n,".json"))}else console.log("Patch save cancelled")},onSaveRuntimePatch:function(){var e=prompt("Enter patch name for runtime:","Untitled Patch");if(null!==e){var n=e.trim().replace(/[^a-z0-9_\- ]/gi,"_")||"Untitled",a={version:"1.0",name:e,created:(new Date).toISOString(),modules:t.map(function(e){return{id:e.id,type:e.type,x:e.x,y:e.y,params:e.params}}),connections:r.map(function(e){return{from:e.from,to:e.to}})},o={version:a.version,name:a.name,description:"Exported from Gen CodegenApp on ".concat((new Date).toLocaleString()),author:"",created:a.created,modules:a.modules.map(function(e){return{id:e.id,type:e.type,position:{x:e.x||100,y:e.y||100},params:e.params}}),connections:a.connections.map(function(e){var n=e.from.id.split(":"),t=e.to.id.split(":");return{from:{module:n[0],output:n[1]||e.from.port||"out"},to:{module:t[0],input:t[1]||e.to.port||"in"}}})},c=JSON.stringify(o,null,2),i=new Blob([c],{type:"application/json"}),l=URL.createObjectURL(i),s=document.createElement("a");s.href=l,s.download="".concat(n,"_runtime.json"),document.body.appendChild(s),s.click(),document.body.removeChild(s),URL.revokeObjectURL(l),console.log("Runtime patch saved as: ".concat(n,"_runtime.json")),console.log("Runtime patch format:",o)}else console.log("Runtime patch save cancelled")},onLoadPatch:function(){var e=document.createElement("input");e.type="file",e.accept=".json",e.onchange=function(e){var n=e.target.files[0];if(n){var t=new FileReader;t.onload=function(e){try{var n=JSON.parse(e.target.result);if(!n.modules||!n.connections)throw new Error("Invalid patch format: missing modules or connections");o([]),i([]);var t=n.modules.map(function(e){return{id:e.id,type:e.type,x:e.x||100,y:e.y||100,params:e.params||{}}}),a=new Set(t.map(function(e){return e.id})),c=n.connections.map(function(e){return{from:e.from,to:e.to}}).filter(function(e){var n=e.from.id.split(":")[0],t=e.to.id.split(":")[0],o=a.has(n)&&a.has(t);return o||console.warn("  Skipping invalid connection: ".concat(e.from.id,"  ").concat(e.to.id," (module not found)")),o}),r=n.connections.length-c.length;r>0&&console.warn("  Removed ".concat(r," invalid connection(s) referencing non-existent modules")),o(t),i(c),console.log("Patch loaded: ".concat(t.length," modules, ").concat(c.length," connections"))}catch(e){console.error("Error loading patch:",e),alert("Error loading patch: ".concat(e.message))}},t.readAsText(n)}},e.click()},onClearCanvas:function(){0!==t.length||0!==r.length||0!==S.length?window.confirm("Clear all ".concat(t.length," modules, ").concat(r.length," connections, and ").concat(S.length," groups from the canvas?\n\nThis cannot be undone."))&&(o([]),i([]),E([]),u(null),F(null),g(null),C(null),de(!1),be(null),ke(!1),Se(null),Re(!1),De(null),Be(!1),Ne(null),Ge(!1),Ue(null),Ve(!1),je(null),console.log("Canvas cleared")):alert("Canvas is already empty")},onZoomToFit:Fn,onSnapToGrid:function(){var e=50,n=200,a=function(e,n){return!(e.x+140+10<=n.x||n.x+140+10<=e.x||e.y+100+10<=n.y||n.y+100+10<=e.y)},c=function(n,t,o){var c,r=yt(arguments.length>3&&void 0!==arguments[3]?arguments[3]:[]);try{var i,l=function(){var n=c.value,t=Math.round(n.x/e)*e,r=Math.round(n.y/e)*e,i={x:t,y:r};if(!o.some(function(e){return a(i,e)}))return{v:{x:t,y:r}}};for(r.s();!(c=r.n()).done;)if(i=l())return i.v}catch(e){r.e(e)}finally{r.f()}var s=Math.round(n/e)*e,u=Math.round(t/e)*e,d={x:s,y:u};if(!o.some(function(e){return a(d,e)}))return{x:s,y:u};for(var p=1;p<=20;p++)for(var f,m=function(){var e=g[_];if(e.x>=0&&e.y>=0){var n={x:e.x,y:e.y};if(!o.some(function(e){return a(n,e)}))return{v:e}}},_=0,g=[{x:s+p*e,y:u},{x:s-p*e,y:u},{x:s,y:u+p*e},{x:s,y:u-p*e},{x:s+p*e,y:u+p*e},{x:s-p*e,y:u-p*e},{x:s+p*e,y:u-p*e},{x:s-p*e,y:u+p*e}];_<g.length;_++)if(f=m())return f.v;return{x:s,y:u}},i=t.filter(function(e){return"Pot"===e.type||"LEDButton"===e.type}),l=t.filter(function(e){return"Pot"!==e.type&&"LEDButton"!==e.type}),s=[];l.forEach(function(e){var n=c(e.x,e.y,s);s.push(It(It({},e),{},{x:n.x,y:n.y}))}),i.forEach(function(t){var a=function(e,n){var t=e.id,a=r.filter(function(e){var n=e.from.id.split(":")[0],a=e.to.id.split(":")[0];return n===t||a===t}),o=new Set;return a.forEach(function(e){var n=e.from.id.split(":")[0],a=e.to.id.split(":")[0];n!==t&&o.add(n),a!==t&&o.add(a)}),n.filter(function(e){return o.has(e.id)})}(t,s);if(a.length>0){for(var o=a.reduce(function(e,n){return e+n.x},0)/a.length,i=a.reduce(function(e,n){return e+n.y},0)/a.length,l=[],u=0;u<=300;u+=e)l.push({x:o-n,y:i+u}),0!==u&&l.push({x:o-n,y:i-u});for(var d=0;d<=300;d+=e)l.push({x:o-n-e,y:i+d}),0!==d&&l.push({x:o-n-e,y:i-d});var p=c(t.x,t.y,s,l);s.push(It(It({},t),{},{x:p.x,y:p.y}))}else{var f=c(t.x,t.y,s);s.push(It(It({},t),{},{x:f.x,y:f.y}))}}),o(s),console.log("Snapped ".concat(t.length," modules to ").concat(e,"px grid (controls near connected modules)"))},onOpenSampleEditor:function(){$e(!0)},copyButtonState:ce}),a.createElement("div",{className:"main-content"},a.createElement(Ot,{onAddModule:function(e){try{Cn(),console.log("Adding ".concat(e," module. Current modules:"),t.map(function(e){return e.id}));var n=W(e,null,null,t);console.log("Created new module:",n),o(function(e){var t=[].concat(wt(e),[n]);return console.log("Updated modules:",t.map(function(e){return e.id})),setTimeout(function(){pn.current&&pn.current.isModuleVisible&&(pn.current.isModuleVisible(n)||(console.log("New module is outside viewport, auto-zooming to fit"),Fn()))},50),t}),R&&(E(function(e){return e.map(function(e){return e.id===R?It(It({},e),{},{moduleIds:[].concat(wt(e.moduleIds),[n.id])}):e})}),console.log("Added module ".concat(n.id," to group ").concat(R)))}catch(n){console.error("Error adding ".concat(e," module:"),n),alert("Error adding ".concat(e," module: ").concat(n.message))}},onLoadExamplePatch:function(e){try{if(!e.modules||!e.connections)throw new Error("Invalid patch format: missing modules or connections");console.log(" LOADING EXAMPLE PATCH - Original modules:",e.modules.map(function(e){return{id:e.id,type:e.type}})),o([]),i([]);var n=e.modules.map(function(e){var n={id:e.id,type:e.type,x:e.x||100,y:e.y||100,params:e.params||{}};return console.log("   Loaded module:",n.id,n.type),n}),t=new Set(n.map(function(e){return e.id})),a=e.connections.map(function(e){return{from:e.from,to:e.to}}).filter(function(e){var n=e.from.id.split(":")[0],a=e.to.id.split(":")[0],o=t.has(n)&&t.has(a);return o||console.warn("  Example patch: Skipping invalid connection: ".concat(e.from.id,"  ").concat(e.to.id," (module not found)")),o}),c=e.connections.length-a.length;c>0&&(console.warn("  Example patch: Removed ".concat(c," invalid connection(s) referencing non-existent modules")),alert("Warning: Example patch had ".concat(c," invalid connection(s) that were removed. This example patch needs to be fixed."))),o(n),i(a),console.log("Example patch loaded: ".concat(n.length," modules, ").concat(a.length," connections"))}catch(e){console.error("Error loading example patch:",e),alert("Error loading example patch: ".concat(e.message))}}}),a.createElement(qt,{ref:pn,modules:t,connections:r,selectedModule:s,selectedModules:p,onSelectModule:function(e){if(e.ctrlKey){var n=p.some(function(n){return n.id===e.id});f(n?function(n){return n.filter(function(n){return n.id!==e.id})}:function(n){return[].concat(wt(n),[e])}),u(null)}else u(e),f([]);g(null)},onSelectModules:function(e){f(e),u(null),g(null)},onMoveModule:function(e,n,a){if(p.some(function(n){return n.id===e})&&p.length>1){var c=t.find(function(n){return n.id===e});if(!c)return;var r=n-c.x,i=a-c.y,l=new Set(p.map(function(e){return e.id}));o(function(e){return e.map(function(e){return l.has(e.id)?It(It({},e),{},{x:e.x+r,y:e.y+i}):e})}),f(function(e){return e.map(function(e){return It(It({},e),{},{x:e.x+r,y:e.y+i})})})}else o(function(t){return t.map(function(t){return t.id===e?It(It({},t),{},{x:n,y:a}):t})}),(null==s?void 0:s.id)===e&&u(function(e){return It(It({},e),{},{x:n,y:a})})},onPortClick:function(e){var n;console.log("Port clicked:",e);var a=null===(n=e.id)||void 0===n?void 0:n.split(":")[0];if("panel_midiIn"!==a||T)if("panel_midiOut"===a&&T){console.log("Showing MIDI Out dropdown");var c=e.x,l=e.y;if(pn.current){var s=pn.current.getCanvasInfo();null!=s&&s.rect&&(c=s.rect.left+s.transform.x+e.x*s.transform.scale,l=s.rect.top+s.transform.y+e.y*s.transform.scale)}we({portId:a,screenX:c,screenY:l,basePort:e,options:[{label:"Note",port:"note",desc:"0-1 CV input"},{label:"Gate",port:"gate",desc:"Note trigger"},{label:"Velocity",port:"velocity",desc:"0-1"},{label:"CC",port:"cc",desc:"Control Change"},{label:"Clock",port:"clock",desc:"24 PPQ tick"},{label:"Start",port:"start",desc:"Transport start"},{label:"Stop",port:"stop",desc:"Transport stop"}]})}else if(T){if(console.log("Completing connection. From:",T,"To:",e),console.log("Validation: port.side =",e.side,", connectingFrom.kind =",T.kind,", port.kind =",e.kind),"left"===e.side&&e.kind===T.kind){var u={id:"".concat(T.id,"->").concat(e.id),from:T,to:e,kind:T.kind},d=r.some(function(n){return n.from.id===T.id&&n.to.id===e.id});if(r.some(function(n){return n.to.id===e.id}))return console.log("Input already has connection:",e.id),void F(null);if(d)console.log("Connection already exists");else{console.log("Creating new connection:",u),Cn();var p=null;if(fn.current&&"audio"===T.kind){var f=T.port,m=e.port,_=T.id.split(":")[0],g=e.id.split(":")[0],h=function(e){return e.endsWith("L")?e.slice(0,-1)+"R":e.endsWith("R")?e.slice(0,-1)+"L":null},v=function(e){return e.endsWith("L")?e.slice(0,-1)+"R":e.endsWith("R")?e.slice(0,-1)+"L":e},b=h(f),y=h(m),k=v(_),x=v(g);if(b){var S,E="".concat(k,":").concat(b);if(S=e.panelElement&&x!==g?"".concat(x,":").concat(m):y?"".concat(g,":").concat(y):null){var P=r.some(function(e){return e.from.id===E&&e.to.id===S}),w=r.some(function(e){return e.to.id===S});P||w||(p={id:"".concat(E,"->").concat(S),from:It(It({},T),{},{id:E,port:b,moduleId:k}),to:It(It({},e),{},{id:S,port:y||m,moduleId:x}),kind:"audio"})}}}i(p?function(e){return[].concat(wt(e),[u,p])}:function(e){return[].concat(wt(e),[u])});var C=e.id.split(":")[0],I=t.find(function(e){return e.id===C});if(I&&"Automation"===I.type){var R=e.port;if(R.startsWith("in_")){var L,M=parseInt(R.split("_")[1]),D=(null===(L=I.params)||void 0===L?void 0:L.num_inputs)||1;M===D&&D<8&&(console.log("Automation ".concat(I.id,": Expanding from ").concat(D," to ").concat(D+1," inputs")),o(function(e){return e.map(function(e){return e.id===C?It(It({},e),{},{params:It(It({},e.params),{},{num_inputs:D+1})}):e})}))}}if(I&&"MIDIOut"===I.type){var A=e.port;if(A.startsWith("cc_")){var O,B=parseInt(A.split("_")[1]),N=(null===(O=I.params)||void 0===O?void 0:O.num_cc)||1;B===N&&N<8&&(console.log("MIDIOut ".concat(I.id,": Expanding from ").concat(N," to ").concat(N+1," CC ports")),o(function(e){return e.map(function(e){return e.id===C?It(It({},e),{},{params:It(It({},e.params),{},{num_cc:N+1})}):e})}))}}if(I&&"Wavetable"===I.type&&"fm"===e.port){var z,q,U=(null===(z=I.params)||void 0===z?void 0:z.fm_amount)||0,W=(null===(q=I.params)||void 0===q?void 0:q.fm_tracking)||!1;0!==U||W||(console.log("Oscillator ".concat(I.id,": Auto-enabling FM (amount: 0.5, tracking: true)")),o(function(e){return e.map(function(e){return e.id===C?It(It({},e),{},{params:It(It({},e.params),{},{fm_amount:.5,fm_tracking:!0})}):e})}))}}}else console.log("Invalid connection - validation failed:",{portSide:e.side,expectedSide:"left",portKind:e.kind,connectingFromKind:T.kind,kindsMatch:e.kind===T.kind});F(null)}else if("right"===e.side){if(console.log("Starting connection from output port:",e.id),console.log("Full port object:",e),void 0!==e.x&&void 0!==e.y&&(G({x:e.x,y:e.y}),pn.current)){var V=pn.current.getCanvasInfo();if(null!=V&&V.rect){var H=V.rect.left+V.transform.x+e.x*V.transform.scale,j=V.rect.top+V.transform.y+e.y*V.transform.scale;K({x:H,y:j})}}F(e)}else console.log("Cannot start connection from input port");else{console.log("Showing MIDI In dropdown");var Y=e.x,$=e.y;if(pn.current){var X=pn.current.getCanvasInfo();null!=X&&X.rect&&(Y=X.rect.left+X.transform.x+e.x*X.transform.scale,$=X.rect.top+X.transform.y+e.y*X.transform.scale)}we({portId:a,screenX:Y,screenY:$,basePort:e,options:[{label:"Note",port:"note",desc:"0-1 CV (C3-C7)"},{label:"Gate",port:"gate",desc:"Note on/off"},{label:"Velocity",port:"velocity",desc:"0-1"},{label:"Clock",port:"clock_tick",desc:"24 PPQ tick"},{label:"Start",port:"start",desc:"Transport start"},{label:"Stop",port:"stop",desc:"Transport stop"},{label:"Running",port:"running",desc:"Transport state"}]})}},onPortRightClick:function(e,n,t){console.log("handlePortRightClick called:",{port:n,moduleId:t,currentContext:R}),e.preventDefault(),e.stopPropagation(),R?(console.log("Port right-clicked:",n,"Module:",t,"Context:",R),gn({x:e.clientX,y:e.clientY,port:n,moduleId:t,groupId:R}),console.log("Context menu set at:",e.clientX,e.clientY)):console.log("Not inside a group - context menu not available. CurrentContext:",R)},connectingFrom:T,selectedConnection:_,onConnectionClick:function(e){g(e),u(null)},onConnectionDoubleClick:function(e){Rn(e),g(null)},mousePos:z,onMouseMove:G,onDeleteModule:Ln,onUpdateParam:In,onOpenClockSequencer:function(e){De(e),Re(!0)},onOpenHarmonicSequencer:function(e){Ne(e),Be(!0)},onClearSelections:function(){u(null),f([]),g(null),C(null)},groups:S,selectedGroup:w,onSelectGroup:function(e){C(e),u(null),f([]),g(null)},onMoveGroup:function(e,n,t){E(function(a){return a.map(function(a){return a.id===e?It(It({},a),{},{x:n,y:t}):a})}),(null==w?void 0:w.id)===e&&C(function(e){return It(It({},e),{},{x:n,y:t})})},onToggleGroupCollapse:function(e){E(function(n){return n.map(function(n){return n.id===e?It(It({},n),{},{collapsed:!n.collapsed}):n})})},onDeleteGroup:On,onUpdateGroupLabel:Bn,onEnterGroup:function(e){console.log("Entering subpatch:",e),L(e),u(null),f([])},onExitToRoot:function(){console.log("Exiting to root patch"),L(null),u(null),f([])},onMoveStub:function(e,n,t,a,o){E(function(c){return c.map(function(c){if(c.id===e){if("input"===n){var r=wt(c.inputPorts);return r[t]=It(It({},r[t]),{},{x:a,y:o}),It(It({},c),{},{inputPorts:r})}if("output"===n){var i=wt(c.outputPorts);return i[t]=It(It({},i[t]),{},{x:a,y:o}),It(It({},c),{},{outputPorts:i})}}return c})})},currentContext:R,selectedBank:X,onBankChange:Z,panelExploded:on,onTogglePanelExplode:function(){if(!on){var e,n,t=null===(e=pn.current)||void 0===e||null===(n=e.getCanvasInfo)||void 0===n?void 0:n.call(e),a=null==t?void 0:t.rect,o=(null==a?void 0:a.width)||Math.max(.5*window.innerWidth,600),c=(null==a?void 0:a.height)||Math.max(.7*window.innerHeight,400),r=30,i=(o-322)/2,l=o-120-r,s=c-200-r,u=(c-100)/2;sn({top:{x:Math.max(i,r),y:r},audioIn:{x:r,y:u},speaker:{x:l,y:u-60},lineOut:{x:l,y:u+60},controls:{x:Math.max(i,r),y:s}})}cn(!on)},panelPieces:ln,onMovePanelPiece:function(e,n,t){sn(function(a){return It(It({},a),{},Rt({},e,{x:n,y:t}))})}}),a.createElement(Ut,{selectedModule:s,selectedModules:p,selectedGroup:w,selectedConnection:_,onUpdateParam:In,onUpdateGroupLabel:Bn,onUngroupModules:function(e){console.log("Ungrouping:",e),E(function(n){return n.filter(function(n){return n.id!==e})}),C(null),R===e&&L(null)},onUpdateConnection:function(e,n){i(function(t){return t.map(function(t){return t.id!==e?t:It(It({},t),{},{params:It(It({},t.params),n)})})})},modules:t,connections:r,onShowNetlist:Tn,netlistCopyState:nn,onCreateGroup:function(){var e=p.length>0?p:s?[s]:[];if(0!==e.length){Cn();var n=new Set(e.map(function(e){return e.id})),a=[],o=[];r.forEach(function(c){var r=c.from.id.split(":")[0],i=c.to.id.split(":")[0],l=n.has(r),s=n.has(i);if(!l&&s){var u=e.find(function(e){return e.id===i}),d=t.find(function(e){return e.id===r}),p=u.x-180,f=u.y+20;a.push({id:"".concat(c.to.id),port:c.to.port,kind:c.to.kind,targetModuleId:i,targetPort:c.to.port,x:p,y:f,externalSource:d.type})}if(l&&!s){var m=e.find(function(e){return e.id===r}),_=t.find(function(e){return e.id===i}),g=j(m),h=m.x+g.width+50,v=m.y+20;o.push({id:"".concat(c.from.id),port:c.from.port,kind:c.from.kind,sourceModuleId:r,sourcePort:c.from.port,x:h,y:v,externalTarget:_.type})}});var c=1/0,i=1/0,l=-1/0,d=-1/0;e.forEach(function(e){var n=j(e);c=Math.min(c,e.x),i=Math.min(i,e.y),l=Math.max(l,e.x+n.width),d=Math.max(d,e.y+n.height)});var m=(c+l)/2,_=(i+d)/2,g={id:"Group".concat(S.length+1),label:"Group ".concat(S.length+1),x:m-100,y:_-75,moduleIds:e.map(function(e){return e.id}),collapsed:!0,inputPorts:a,outputPorts:o,color:"hsl(".concat(60*S.length%360,", 70%, 50%)")};E(function(e){return[].concat(wt(e),[g])}),f([]),u(null),console.log("Created subpatch: ".concat(g.id," with ").concat(g.moduleIds.length," modules, ").concat(a.length," inputs, ").concat(o.length," outputs"))}else alert("Select modules to group first")},cpuEstimate:le,selectedBank:X,onBankChange:Z})),te&&a.createElement("div",{className:"modal-backdrop",onClick:function(){return ae(!1)}},a.createElement("div",{className:"modal-content",onClick:function(e){return e.stopPropagation()},style:{maxWidth:"90%",maxHeight:"90%",width:"1000px"}},a.createElement("div",{className:"modal-header"},a.createElement("h2",null,"Generated Arduino Code"),a.createElement("button",{className:"modal-close",onClick:function(){return ae(!1)}},"")),a.createElement("div",{className:"modal-body",style:{display:"flex",flexDirection:"column",height:"600px"}},a.createElement("div",{style:{display:"flex",justifyContent:"flex-end",gap:"8px",marginBottom:"12px"}},a.createElement("button",{className:"btn btn-ghost",onClick:function(){var e=new Blob([J],{type:"text/plain"}),n=URL.createObjectURL(e),t=document.createElement("a");t.href=n,t.download="2409Code.ino",document.body.appendChild(t),t.click(),document.body.removeChild(t),URL.revokeObjectURL(n)}}," Download .ino"),a.createElement("button",{className:"btn ".concat("btn-green"),onClick:Et(kt().m(function e(){var n,t;return kt().w(function(e){for(;;)switch(e.p=e.n){case 0:if(e.p=0,!navigator.clipboard||!window.isSecureContext){e.n=2;break}return e.n=1,navigator.clipboard.writeText(J);case 1:e.n=3;break;case 2:(n=document.createElement("textarea")).value=J,n.style.position="fixed",n.style.left="-999999px",n.style.top="-999999px",document.body.appendChild(n),n.focus(),n.select(),document.execCommand("copy"),document.body.removeChild(n);case 3:re("copied"),setTimeout(function(){return re("idle")},1500),e.n=5;break;case 4:e.p=4,t=e.v,console.error("Failed to copy:",t),alert("Failed to copy to clipboard. Check console for details.");case 5:return e.a(2)}},e,null,[[0,4]])}))},"copied"===ce?" Code Copied!":" Copy Code")),a.createElement("textarea",{value:J,readOnly:!0,style:{flex:1,fontFamily:'Monaco, "Cascadia Code", "Fira Code", Consolas, monospace',fontSize:"12px",padding:"12px",border:"1px solid #374151",borderRadius:"6px",backgroundColor:"#0f172a",color:"#e2e8f0",resize:"none",whiteSpace:"pre"}})))),fe&&a.createElement("div",{className:"modal-backdrop",onClick:function(){return me(!1)}},a.createElement("div",{className:"modal-content",onClick:function(e){return e.stopPropagation()},style:{maxWidth:"800px",maxHeight:"80%"}},a.createElement("div",{className:"modal-header"},a.createElement("h2",null,"Load Patch from Netlist"),a.createElement("button",{className:"modal-close",onClick:function(){return me(!1)}},"")),a.createElement("div",{className:"modal-body",style:{display:"flex",flexDirection:"column",gap:"16px"}},a.createElement("div",{style:{color:"#94a3b8",fontSize:"13px"}},a.createElement("p",{style:{marginBottom:"8px"}},"Paste netlist from generated Arduino sketch header or manually format:"),a.createElement("pre",{style:{backgroundColor:"#0f172a",padding:"8px",borderRadius:"4px",fontSize:"11px",overflow:"auto"}},"[audio] Oscillator 1:L  VCA:inL\n[audio] Oscillator 1:R  VCA:inR\n[ctrl] Pot 1 (Bank 1):value  Oscillator 1:freq")),a.createElement("textarea",{value:ge,onChange:function(e){return he(e.target.value)},placeholder:"Paste netlist here...",style:{minHeight:"300px",fontFamily:'Monaco, "Cascadia Code", "Fira Code", Consolas, monospace',fontSize:"12px",padding:"12px",border:"1px solid #374151",borderRadius:"6px",backgroundColor:"#1e293b",color:"#e2e8f0",resize:"vertical"}}),a.createElement("div",{style:{display:"flex",justifyContent:"flex-end",gap:"8px"}},a.createElement("button",{className:"btn btn-ghost",onClick:function(){me(!1),he("")}},"Cancel"),a.createElement("button",{className:"btn btn-green",onClick:function(){try{var e=function(e){var n,t=e.split("\n"),a=[],o=new Set,c=/\[(audio|ctrl|control)\]\s+([^:]+):(\S+)\s+\s+([^:]+):(\S+)/,r=yt(t);try{for(r.s();!(n=r.n()).done;){var i=n.value.match(c);if(i){var l=Lt(i,6),s=(l[0],l[1]),u=l[2],d=l[3],p=l[4],f=l[5];a.push({kind:"control"===s?"ctrl":s,from:{module:u.trim(),port:d.trim()},to:{module:p.trim(),port:f.trim()}}),o.add(u.trim()),o.add(p.trim())}}}catch(e){r.e(e)}finally{r.f()}return{connections:a,moduleNames:Array.from(o)}}(ge),n=e.connections,t=e.moduleNames;if(0===n.length)return void alert("No valid connections found in netlist. Expected format:\n[audio] Module1:port  Module2:port\n[ctrl] Module3:port  Module4:port");console.log("Parsed connections:",n),console.log("Module names:",t),Cn();var a=[],c={},r=100,l=100;t.forEach(function(e,n){for(var t=e.split(/\s+\d+/)[0].trim(),o=null,i=0,s=Object.entries(O);i<s.length;i++){var u=Lt(s[i],2),d=u[0];if(u[1].label===t||d===t){o=d;break}}if(o){var p=W(o,r,l,a);(r+=200)>1e3&&(r=100,l+=150),a.push(p),c[e]=p.id}else console.warn("Unknown module type: ".concat(e,", skipping"))});var s=[];n.forEach(function(e){var n=c[e.from.module],t=c[e.to.module];n&&t?s.push({from:{id:"".concat(n,":").concat(e.from.port),port:e.from.port,kind:e.kind},to:{id:"".concat(t,":").concat(e.to.port),port:e.to.port,kind:e.kind}}):console.warn("Skipping connection: ".concat(e.from.module,":").concat(e.from.port,"  ").concat(e.to.module,":").concat(e.to.port," (module not found)"))}),o(a),i(s),me(!1),he(""),console.log("Loaded ".concat(a.length," modules and ").concat(s.length," connections from netlist"))}catch(e){console.error("Netlist parsing error:",e),alert("Failed to load netlist: ".concat(e.message))}},disabled:!ge.trim()},"Load Patch"))))),Ie&&Me&&a.createElement(Hn,{module:t.find(function(e){return e.id===Me.id})||Me,onUpdateParam:In,onClose:function(){Re(!1),De(null)},fullscreen:!0}),Oe&&Fe&&a.createElement(mt,{module:t.find(function(e){return e.id===Fe.id})||Fe,modules:t,onUpdateParam:In,onClose:function(){Be(!1),Ne(null)},fullscreen:!0}),_n&&a.createElement(a.Fragment,null,a.createElement("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,zIndex:9999},onClick:function(){return gn(null)}}),a.createElement("div",{style:{position:"fixed",left:_n.x,top:_n.y,backgroundColor:"#1e293b",border:"1px solid #334155",borderRadius:"8px",padding:"4px 0",minWidth:"200px",boxShadow:"0 4px 12px rgba(0, 0, 0, 0.5)",zIndex:1e4,color:"#e2e8f0"},onClick:function(e){return e.stopPropagation()}},a.createElement("div",{style:{padding:"8px 16px",cursor:"pointer",fontSize:"14px",transition:"background 0.2s"},onMouseEnter:function(e){return e.target.style.background="#334155"},onMouseLeave:function(e){return e.target.style.background="transparent"},onClick:function(){if(_n){var e=_n.groupId,n=_n.moduleId,t=_n.port;(function(e,n,t,a,o){console.log("Exposing port ".concat(t," on group ").concat(e," from module ").concat(n)),E(function(c){return c.map(function(c){if(c.id!==e)return c;var r="".concat(n,":").concat(t);if("left"===o){if(c.inputPorts.some(function(e){return e.id===r}))return console.log("Port ".concat(r," already exposed as input")),c;var i={id:r,port:t,kind:a,targetModuleId:n,targetPort:t};return It(It({},c),{},{inputPorts:[].concat(wt(c.inputPorts),[i])})}if(c.outputPorts.some(function(e){return e.id===r}))return console.log("Port ".concat(r," already exposed as output")),c;var l={id:r,port:t,kind:a,sourceModuleId:n,sourcePort:t};return It(It({},c),{},{outputPorts:[].concat(wt(c.outputPorts),[l])})})}),console.log("Port exposed successfully")})(e,n,t.port,t.kind,t.side),gn(null)}}},"Expose as Group Port"),a.createElement("div",{style:{padding:"4px 16px",fontSize:"12px",color:"#94a3b8",borderTop:"1px solid #334155",marginTop:"4px"}},"left"===_n.port.side?"Input":"Output","  ","audio"===_n.port.kind?"Audio":"Control"))),Pe&&a.createElement(a.Fragment,null,a.createElement("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,zIndex:9999},onClick:function(){we(null)}}),a.createElement("div",{style:{position:"fixed",left:Pe.screenX+10,top:Pe.screenY-40,backgroundColor:"#1e293b",border:"2px solid #f59e0b",borderRadius:"8px",padding:"8px 0",minWidth:"180px",boxShadow:"0 4px 16px rgba(245, 158, 11, 0.3)",zIndex:1e4,color:"#e2e8f0"},onClick:function(e){return e.stopPropagation()}},a.createElement("div",{style:{padding:"4px 12px 8px",fontSize:"11px",color:"#f59e0b",fontWeight:"bold",borderBottom:"1px solid #334155",marginBottom:"4px"}},"panel_midiIn"===Pe.portId?"MIDI In Output":"MIDI Out Input"),Pe.options.map(function(e,n){return a.createElement("div",{key:n,style:{padding:"10px 16px",cursor:"pointer",fontSize:"14px",display:"flex",justifyContent:"space-between",alignItems:"center",transition:"background 0.2s"},onMouseEnter:function(e){return e.currentTarget.style.background="#334155"},onMouseLeave:function(e){return e.currentTarget.style.background="transparent"},onClick:function(){!function(e){if(console.log("MIDI port selected:",e),we(null),T){if(r.some(function(n){return n.to.id===e.id}))return console.log("Input already has connection:",e.id),void F(null);var n={id:"".concat(T.id,"->").concat(e.id),from:T,to:e,kind:T.kind};r.some(function(n){return n.from.id===T.id&&n.to.id===e.id})||(Cn(),i(function(e){return[].concat(wt(e),[n])})),F(null)}else void 0!==e.x&&void 0!==e.y&&G({x:e.x,y:e.y}),F(e)}(It(It({},Pe.basePort),{},{id:"".concat(Pe.portId,":").concat(e.port),port:e.port,label:"".concat(Pe.basePort.label," ").concat(e.label)}))}},a.createElement("span",{style:{fontWeight:"bold"}},e.label),a.createElement("span",{style:{fontSize:"11px",color:"#94a3b8"}},e.desc))}))),Ye&&a.createElement(An,{componentName:"Standalone Sample Editor",onRetry:function(){$e(!1),setTimeout(function(){return $e(!0)},100)}},a.createElement(Sn,{module:Qe,onUpdateParam:function(e,n,t){var a=void 0!==t?n:e,o=void 0!==t?t:n;console.log(" Standalone Sample Editor onUpdateParam called"),console.log("   Raw args:",{idOrKey:e,keyOrValue:n,value:t}),console.log("   Parsed:",{actualKey:a,actualValue:o}),Je(function(e){var n=It(It({},e),{},{params:It(It({},e.params),{},Rt({},a,o))});return console.log("   State update:",e.params,"",n.params),n})},onClose:function(){return $e(!1)},modules:[]})))};o.createRoot(document.getElementById("root")).render(a.createElement(un,null,a.createElement(Wt,null)))})();