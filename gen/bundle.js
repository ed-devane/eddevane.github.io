/*! For license information please see bundle.js.LICENSE.txt */
(()=>{"use strict";var e={56:(e,n,t)=>{e.exports=function(e){var n=t.nc;n&&e.setAttribute("nonce",n)}},72:e=>{var n=[];function t(e){for(var t=-1,a=0;a<n.length;a++)if(n[a].identifier===e){t=a;break}return t}function a(e,a){for(var r={},c=[],i=0;i<e.length;i++){var l=e[i],s=a.base?l[0]+a.base:l[0],u=r[s]||0,d="".concat(s," ").concat(u);r[s]=u+1;var p=t(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)n[p].references++,n[p].updater(f);else{var m=o(f,a);a.byIndex=i,n.splice(i,0,{identifier:d,updater:m,references:1})}c.push(d)}return c}function o(e,n){var t=n.domAPI(n);return t.update(e),function(n){if(n){if(n.css===e.css&&n.media===e.media&&n.sourceMap===e.sourceMap&&n.supports===e.supports&&n.layer===e.layer)return;t.update(e=n)}else t.remove()}}e.exports=function(e,o){var r=a(e=e||[],o=o||{});return function(e){e=e||[];for(var c=0;c<r.length;c++){var i=t(r[c]);n[i].references--}for(var l=a(e,o),s=0;s<r.length;s++){var u=t(r[s]);0===n[u].references&&(n[u].updater(),n.splice(u,1))}r=l}}},113:e=>{e.exports=function(e,n){if(n.styleSheet)n.styleSheet.cssText=e;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(e))}}},159:e=>{e.exports=function(e){var n=document.createElement("style");return e.setAttributes(n,e.attributes),e.insert(n,e.options),n}},249:(e,n,t)=>{t.d(n,{A:()=>i});var a=t(601),o=t.n(a),r=t(314),c=t.n(r)()(o());c.push([e.id,"/* CSS Variables from original */\n:root{\n  --bg-canvas:#e5e7eb;\n  --bg-panel:#0c1428;\n  --fg:#e2e8f0;\n  --muted:#94a3b8;\n  --border:#1f2937;\n}\n\n/* Reset and body */\nhtml, body, #root { \n  height:100%; \n  margin:0; \n  background:var(--bg-canvas); \n  color:var(--fg); \n  font-family: ui-sans-serif, system-ui, sans-serif;\n}\n\nbutton { cursor:pointer }\n\n/* Real-time parameter system animations */\n@keyframes pulse {\n    0%, 100% { opacity: 1; }\n    50% { opacity: 0.5; }\n}\n\n/* Original button styles */\n.btn { \n  padding:6px 8px; \n  border-radius:8px; \n  border:0; \n  font-size:12px;\n}\n\n.btn-blue{ background:#0ea5e9; color:#fff }\n.btn-green{ background:#22c55e; color:#052e16; font-weight:800 }\n.btn-amber{ background:#f59e0b; color:#1f2937; font-weight:800 }\n.btn-red{ background:#dc2626; color:#fff; font-weight:800 }\n.btn-ghost{ background:#111827; color:#e2e8f0; border:1px solid #334155; }\n\n/* Main Layout - Simple 3 column structure */\n.app {\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n    background: var(--bg-canvas);\n    color: var(--fg);\n}\n\n/* Toolbar */\n.toolbar {\n    height: 50px;\n    background: var(--bg-panel);\n    border-bottom: 1px solid var(--border);\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 0 20px;\n    flex-shrink: 0;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    z-index: 1001;\n    width: 100%;\n}\n\n.toolbar h1 {\n    font-size: 18px;\n    font-weight: 700;\n    color: #22c55e;\n}\n\n.toolbar-actions {\n    display: flex;\n    gap: 8px;\n}\n\n/* Main Content - 3 columns: palette, canvas, inspector */\n.main-content {\n    flex: 1;\n    display: flex;\n    height: calc(100vh - 50px);\n    overflow: hidden;\n    width: 100%;\n    margin-top: 50px;\n}\n\n/* Module Palette - Left panel */\n.module-palette {\n    width: 250px;\n    background: var(--bg-panel);\n    border-right: 1px solid var(--border);\n    padding: 12px;\n    overflow-y: auto;\n    flex-shrink: 0;\n}\n\n.module-palette h2 {\n    font-size: 14px;\n    font-weight: 700;\n    color: var(--fg);\n    margin-bottom: 16px;\n}\n\n.module-categories {\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.category h3 {\n    font-size: 12px;\n    color: #22c55e;\n    margin-bottom: 8px;\n    text-transform: uppercase;\n    font-weight: 700;\n}\n\n.module-list {\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n}\n\n.module-item {\n    padding: 8px 12px;\n    background: #111827;\n    border: 1px solid #334155;\n    border-radius: 8px;\n    font-size: 12px;\n    cursor: pointer;\n    transition: all 0.2s;\n    color: var(--fg);\n    font-weight: 500;\n}\n\n.module-item:hover {\n    background: #1e293b;\n    border-color: #22c55e;\n    color: #22c55e;\n}\n\n/* Patch Canvas - Center panel */\n.patch-canvas {\n    width: calc(100vw - 570px); /* Full viewport minus left sidebar (250px) + wider right sidebar (320px) */\n    position: relative;\n    overflow: auto;\n    background: #e5e7eb;\n    cursor: grab;\n    min-height: 100%;\n}\n\n.patch-canvas.panning {\n    cursor: grabbing;\n}\n\n.patch-canvas.subpatch-context {\n    background: #9ca3af; /* Darker shade when inside subpatch */\n}\n\n.patch-svg {\n    width: 100%;\n    height: 100%;\n}\n\n/* Inspector - Right panel */\n.inspector {\n    background: var(--bg-panel);\n    border-left: 1px solid var(--border);\n    padding: 12px;\n    overflow-y: auto;\n    position: fixed;\n    top: 50px;\n    right: 0;\n    width: 320px;\n    height: calc(100vh - 50px);\n    z-index: 1000;\n}\n\n.inspector h2 {\n    font-size: 14px;\n    font-weight: 700;\n    color: var(--fg);\n    margin-bottom: 8px;\n}\n\n.inspector-content {\n    font-size: 12px;\n    color: var(--muted);\n}\n\n.module-desc {\n    font-size: 12px;\n    color: var(--muted);\n    margin-bottom: 16px;\n    font-style: italic;\n}\n\n.params {\n    margin-top: 12px;\n}\n\n.params h3 {\n    font-size: 12px;\n    color: var(--muted);\n    margin-bottom: 8px;\n    font-weight: 700;\n}\n\n.param {\n    margin-bottom: 8px;\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n}\n\n.param label {\n    font-size: 12px;\n    color: #cbd5e1;\n    margin-bottom: 4px;\n    display: block;\n}\n\n.param input,\n.param select {\n    width: 100%;\n    padding: 6px;\n    border-radius: 8px;\n    border: 1px solid #334155;\n    background: #0f172a;\n    color: var(--fg);\n    font-size: 12px;\n}\n\n.param input:focus,\n.param select:focus {\n    outline: none;\n    border-color: #22c55e;\n    box-shadow: 0 0 0 1px #22c55e;\n}\n\n.param select option {\n    background: #0f172a;\n    color: var(--fg);\n}\n\n/* Original Module Node Styles */\n.node { \n    position: absolute; \n    border-radius: 10px; \n    background: #0b1220; \n    box-shadow: 0 6px 16px rgba(0,0,0,0.35); \n    user-select: none; \n    cursor: move; \n    z-index: 10; \n    overflow: visible;\n}\n\n.node.selected {\n    box-shadow: 0 6px 16px rgba(0,0,0,0.35), 0 0 0 2px #22c55e;\n}\n\n.node-head{ \n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 2px 6px;\n    height: 24px;\n    border-top-left-radius: 8px;\n    border-top-right-radius: 8px;\n}\n\n/* Original Jack Styles */\n.jack { \n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    border: 2px solid #1f2937;\n    cursor: pointer; \n    position: absolute; \n    z-index: 20;\n}\n\n.jack-audio { \n    background: #10b981;\n}\n\n.jack-ctrl { \n    background: #9333ea;\n}\n\n.jack-armed { \n    box-shadow: 0 0 0 2px #22d3ee inset;\n}\n\n.jack-label { \n    position: absolute; \n    font-size: 10px; \n    white-space: nowrap; \n    pointer-events: none; \n    color: #cbd5e1;\n}\n\n/* Cable styles */\n.cables { \n    position: absolute; \n    left: 0; \n    top: 0; \n    z-index: 30;\n}\n\n.cable-hit { \n    cursor: pointer;\n}\n\n.cable-selected { \n    filter: drop-shadow(0 0 2px #22c55e);\n}\n\n.cable:hover {\n    opacity: 1 !important;\n    stroke-width: 3px;\n}\n\n/* Delete button styles */\n.delete-btn:hover rect {\n    opacity: 1;\n    fill: #374151;\n    stroke: #6b7280;\n}\n\n.delete-btn:hover text {\n    fill: #ffffff;\n}\n\n.delete-btn:active rect {\n    fill: #4b5563;\n}\n\n/* Toolbar button updates */\n.toolbar button {\n    font-size: 12px;\n    padding: 6px 8px;\n    border-radius: 8px;\n    border: 0;\n}\n\n.toolbar button.primary {\n    background: #22c55e;\n    color: #052e16;\n    font-weight: 800;\n}\n\n/* Scrollbar styling for better visibility */\n::-webkit-scrollbar {\n    width: 12px;\n    height: 12px;\n}\n\n::-webkit-scrollbar-track {\n    background: #1f2937;\n    border-radius: 6px;\n}\n\n::-webkit-scrollbar-thumb {\n    background: #4b5563;\n    border-radius: 6px;\n    border: 2px solid #1f2937;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: #6b7280;\n}\n\n::-webkit-scrollbar-corner {\n    background: #1f2937;\n}\n\n/* For Firefox */\n* {\n    scrollbar-width: auto;\n    scrollbar-color: #4b5563 #1f2937;\n}\n\n/* Modal Styles for WavetableEditor and other modals */\n.modal-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.8);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 1000;\n}\n\n.modal-content {\n    background: #1e293b;\n    border-radius: 12px;\n    padding: 20px;\n    max-width: 90vw;\n    max-height: 90vh;\n    overflow-y: auto;\n    position: relative;\n}\n\n.modal-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 20px;\n    padding-bottom: 10px;\n    border-bottom: 1px solid #334155;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #f1f5f9;\n}\n\n.close-btn {\n    background: transparent;\n    border: none;\n    color: #94a3b8;\n    font-size: 24px;\n    cursor: pointer;\n    padding: 4px 8px;\n    transition: color 0.2s;\n}\n\n.close-btn:hover {\n    color: #f1f5f9;\n}",""]);const i=c},287:(e,n)=>{var t=Symbol.for("react.element"),a=Symbol.for("react.portal"),o=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),c=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),l=Symbol.for("react.context"),s=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),p=Symbol.for("react.lazy"),f=Symbol.iterator,m={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},_=Object.assign,g={};function h(e,n,t){this.props=e,this.context=n,this.refs=g,this.updater=t||m}function v(){}function b(e,n,t){this.props=e,this.context=n,this.refs=g,this.updater=t||m}h.prototype.isReactComponent={},h.prototype.setState=function(e,n){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,n,"setState")},h.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},v.prototype=h.prototype;var y=b.prototype=new v;y.constructor=b,_(y,h.prototype),y.isPureReactComponent=!0;var k=Array.isArray,S=Object.prototype.hasOwnProperty,x={current:null},E={key:!0,ref:!0,__self:!0,__source:!0};function P(e,n,a){var o,r={},c=null,i=null;if(null!=n)for(o in void 0!==n.ref&&(i=n.ref),void 0!==n.key&&(c=""+n.key),n)S.call(n,o)&&!E.hasOwnProperty(o)&&(r[o]=n[o]);var l=arguments.length-2;if(1===l)r.children=a;else if(1<l){for(var s=Array(l),u=0;u<l;u++)s[u]=arguments[u+2];r.children=s}if(e&&e.defaultProps)for(o in l=e.defaultProps)void 0===r[o]&&(r[o]=l[o]);return{$$typeof:t,type:e,key:c,ref:i,props:r,_owner:x.current}}function w(e){return"object"==typeof e&&null!==e&&e.$$typeof===t}var C=/\/+/g;function R(e,n){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var n={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(e){return n[e]})}(""+e.key):n.toString(36)}function L(e,n,o,r,c){var i=typeof e;"undefined"!==i&&"boolean"!==i||(e=null);var l=!1;if(null===e)l=!0;else switch(i){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case t:case a:l=!0}}if(l)return c=c(l=e),e=""===r?"."+R(l,0):r,k(c)?(o="",null!=e&&(o=e.replace(C,"$&/")+"/"),L(c,n,o,"",function(e){return e})):null!=c&&(w(c)&&(c=function(e,n){return{$$typeof:t,type:e.type,key:n,ref:e.ref,props:e.props,_owner:e._owner}}(c,o+(!c.key||l&&l.key===c.key?"":(""+c.key).replace(C,"$&/")+"/")+e)),n.push(c)),1;if(l=0,r=""===r?".":r+":",k(e))for(var s=0;s<e.length;s++){var u=r+R(i=e[s],s);l+=L(i,n,o,u,c)}else if(u=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=f&&e[f]||e["@@iterator"])?e:null}(e),"function"==typeof u)for(e=u.call(e),s=0;!(i=e.next()).done;)l+=L(i=i.value,n,o,u=r+R(i,s++),c);else if("object"===i)throw n=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===n?"object with keys {"+Object.keys(e).join(", ")+"}":n)+"). If you meant to render a collection of children, use an array instead.");return l}function I(e,n,t){if(null==e)return e;var a=[],o=0;return L(e,a,"","",function(e){return n.call(t,e,o++)}),a}function M(e){if(-1===e._status){var n=e._result;(n=n()).then(function(n){0!==e._status&&-1!==e._status||(e._status=1,e._result=n)},function(n){0!==e._status&&-1!==e._status||(e._status=2,e._result=n)}),-1===e._status&&(e._status=0,e._result=n)}if(1===e._status)return e._result.default;throw e._result}var D={current:null},A={transition:null},O={ReactCurrentDispatcher:D,ReactCurrentBatchConfig:A,ReactCurrentOwner:x};function T(){throw Error("act(...) is not supported in production builds of React.")}n.Children={map:I,forEach:function(e,n,t){I(e,function(){n.apply(this,arguments)},t)},count:function(e){var n=0;return I(e,function(){n++}),n},toArray:function(e){return I(e,function(e){return e})||[]},only:function(e){if(!w(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},n.Component=h,n.Fragment=o,n.Profiler=c,n.PureComponent=b,n.StrictMode=r,n.Suspense=u,n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=O,n.act=T,n.cloneElement=function(e,n,a){if(null==e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var o=_({},e.props),r=e.key,c=e.ref,i=e._owner;if(null!=n){if(void 0!==n.ref&&(c=n.ref,i=x.current),void 0!==n.key&&(r=""+n.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(s in n)S.call(n,s)&&!E.hasOwnProperty(s)&&(o[s]=void 0===n[s]&&void 0!==l?l[s]:n[s])}var s=arguments.length-2;if(1===s)o.children=a;else if(1<s){l=Array(s);for(var u=0;u<s;u++)l[u]=arguments[u+2];o.children=l}return{$$typeof:t,type:e.type,key:r,ref:c,props:o,_owner:i}},n.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:i,_context:e},e.Consumer=e},n.createElement=P,n.createFactory=function(e){var n=P.bind(null,e);return n.type=e,n},n.createRef=function(){return{current:null}},n.forwardRef=function(e){return{$$typeof:s,render:e}},n.isValidElement=w,n.lazy=function(e){return{$$typeof:p,_payload:{_status:-1,_result:e},_init:M}},n.memo=function(e,n){return{$$typeof:d,type:e,compare:void 0===n?null:n}},n.startTransition=function(e){var n=A.transition;A.transition={};try{e()}finally{A.transition=n}},n.unstable_act=T,n.useCallback=function(e,n){return D.current.useCallback(e,n)},n.useContext=function(e){return D.current.useContext(e)},n.useDebugValue=function(){},n.useDeferredValue=function(e){return D.current.useDeferredValue(e)},n.useEffect=function(e,n){return D.current.useEffect(e,n)},n.useId=function(){return D.current.useId()},n.useImperativeHandle=function(e,n,t){return D.current.useImperativeHandle(e,n,t)},n.useInsertionEffect=function(e,n){return D.current.useInsertionEffect(e,n)},n.useLayoutEffect=function(e,n){return D.current.useLayoutEffect(e,n)},n.useMemo=function(e,n){return D.current.useMemo(e,n)},n.useReducer=function(e,n,t){return D.current.useReducer(e,n,t)},n.useRef=function(e){return D.current.useRef(e)},n.useState=function(e){return D.current.useState(e)},n.useSyncExternalStore=function(e,n,t){return D.current.useSyncExternalStore(e,n,t)},n.useTransition=function(){return D.current.useTransition()},n.version="18.3.1"},314:e=>{e.exports=function(e){var n=[];return n.toString=function(){return this.map(function(n){var t="",a=void 0!==n[5];return n[4]&&(t+="@supports (".concat(n[4],") {")),n[2]&&(t+="@media ".concat(n[2]," {")),a&&(t+="@layer".concat(n[5].length>0?" ".concat(n[5]):""," {")),t+=e(n),a&&(t+="}"),n[2]&&(t+="}"),n[4]&&(t+="}"),t}).join("")},n.i=function(e,t,a,o,r){"string"==typeof e&&(e=[[null,e,void 0]]);var c={};if(a)for(var i=0;i<this.length;i++){var l=this[i][0];null!=l&&(c[l]=!0)}for(var s=0;s<e.length;s++){var u=[].concat(e[s]);a&&c[u[0]]||(void 0!==r&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=r),t&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=t):u[2]=t),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),n.push(u))}},n}},338:(e,n,t)=>{var a=t(961);n.createRoot=a.createRoot,n.hydrateRoot=a.hydrateRoot},463:(e,n)=>{function t(e,n){var t=e.length;e.push(n);e:for(;0<t;){var a=t-1>>>1,o=e[a];if(!(0<r(o,n)))break e;e[a]=n,e[t]=o,t=a}}function a(e){return 0===e.length?null:e[0]}function o(e){if(0===e.length)return null;var n=e[0],t=e.pop();if(t!==n){e[0]=t;e:for(var a=0,o=e.length,c=o>>>1;a<c;){var i=2*(a+1)-1,l=e[i],s=i+1,u=e[s];if(0>r(l,t))s<o&&0>r(u,l)?(e[a]=u,e[s]=t,a=s):(e[a]=l,e[i]=t,a=i);else{if(!(s<o&&0>r(u,t)))break e;e[a]=u,e[s]=t,a=s}}}return n}function r(e,n){var t=e.sortIndex-n.sortIndex;return 0!==t?t:e.id-n.id}if("object"==typeof performance&&"function"==typeof performance.now){var c=performance;n.unstable_now=function(){return c.now()}}else{var i=Date,l=i.now();n.unstable_now=function(){return i.now()-l}}var s=[],u=[],d=1,p=null,f=3,m=!1,_=!1,g=!1,h="function"==typeof setTimeout?setTimeout:null,v="function"==typeof clearTimeout?clearTimeout:null,b="undefined"!=typeof setImmediate?setImmediate:null;function y(e){for(var n=a(u);null!==n;){if(null===n.callback)o(u);else{if(!(n.startTime<=e))break;o(u),n.sortIndex=n.expirationTime,t(s,n)}n=a(u)}}function k(e){if(g=!1,y(e),!_)if(null!==a(s))_=!0,A(S);else{var n=a(u);null!==n&&O(k,n.startTime-e)}}function S(e,t){_=!1,g&&(g=!1,v(w),w=-1),m=!0;var r=f;try{for(y(t),p=a(s);null!==p&&(!(p.expirationTime>t)||e&&!L());){var c=p.callback;if("function"==typeof c){p.callback=null,f=p.priorityLevel;var i=c(p.expirationTime<=t);t=n.unstable_now(),"function"==typeof i?p.callback=i:p===a(s)&&o(s),y(t)}else o(s);p=a(s)}if(null!==p)var l=!0;else{var d=a(u);null!==d&&O(k,d.startTime-t),l=!1}return l}finally{p=null,f=r,m=!1}}"undefined"!=typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var x,E=!1,P=null,w=-1,C=5,R=-1;function L(){return!(n.unstable_now()-R<C)}function I(){if(null!==P){var e=n.unstable_now();R=e;var t=!0;try{t=P(!0,e)}finally{t?x():(E=!1,P=null)}}else E=!1}if("function"==typeof b)x=function(){b(I)};else if("undefined"!=typeof MessageChannel){var M=new MessageChannel,D=M.port2;M.port1.onmessage=I,x=function(){D.postMessage(null)}}else x=function(){h(I,0)};function A(e){P=e,E||(E=!0,x())}function O(e,t){w=h(function(){e(n.unstable_now())},t)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(e){e.callback=null},n.unstable_continueExecution=function(){_||m||(_=!0,A(S))},n.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):C=0<e?Math.floor(1e3/e):5},n.unstable_getCurrentPriorityLevel=function(){return f},n.unstable_getFirstCallbackNode=function(){return a(s)},n.unstable_next=function(e){switch(f){case 1:case 2:case 3:var n=3;break;default:n=f}var t=f;f=n;try{return e()}finally{f=t}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(e,n){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var t=f;f=e;try{return n()}finally{f=t}},n.unstable_scheduleCallback=function(e,o,r){var c=n.unstable_now();switch(r="object"==typeof r&&null!==r&&"number"==typeof(r=r.delay)&&0<r?c+r:c,e){case 1:var i=-1;break;case 2:i=250;break;case 5:i=1073741823;break;case 4:i=1e4;break;default:i=5e3}return e={id:d++,callback:o,priorityLevel:e,startTime:r,expirationTime:i=r+i,sortIndex:-1},r>c?(e.sortIndex=r,t(u,e),null===a(s)&&e===a(u)&&(g?(v(w),w=-1):g=!0,O(k,r-c))):(e.sortIndex=i,t(s,e),_||m||(_=!0,A(S))),e},n.unstable_shouldYield=L,n.unstable_wrapCallback=function(e){var n=f;return function(){var t=f;f=n;try{return e.apply(this,arguments)}finally{f=t}}}},540:(e,n,t)=>{e.exports=t(287)},551:(e,n,t)=>{var a=t(540),o=t(982);function r(e){for(var n="https://reactjs.org/docs/error-decoder.html?invariant="+e,t=1;t<arguments.length;t++)n+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+e+"; visit "+n+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var c=new Set,i={};function l(e,n){s(e,n),s(e+"Capture",n)}function s(e,n){for(i[e]=n,e=0;e<n.length;e++)c.add(n[e])}var u=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement),d=Object.prototype.hasOwnProperty,p=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,f={},m={};function _(e,n,t,a,o,r,c){this.acceptsBooleans=2===n||3===n||4===n,this.attributeName=a,this.attributeNamespace=o,this.mustUseProperty=t,this.propertyName=e,this.type=n,this.sanitizeURL=r,this.removeEmptyString=c}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){g[e]=new _(e,0,!1,e,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var n=e[0];g[n]=new _(n,1,!1,e[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(e){g[e]=new _(e,2,!1,e.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){g[e]=new _(e,2,!1,e,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){g[e]=new _(e,3,!1,e.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(e){g[e]=new _(e,3,!0,e,null,!1,!1)}),["capture","download"].forEach(function(e){g[e]=new _(e,4,!1,e,null,!1,!1)}),["cols","rows","size","span"].forEach(function(e){g[e]=new _(e,6,!1,e,null,!1,!1)}),["rowSpan","start"].forEach(function(e){g[e]=new _(e,5,!1,e.toLowerCase(),null,!1,!1)});var h=/[\-:]([a-z])/g;function v(e){return e[1].toUpperCase()}function b(e,n,t,a){var o=g.hasOwnProperty(n)?g[n]:null;(null!==o?0!==o.type:a||!(2<n.length)||"o"!==n[0]&&"O"!==n[0]||"n"!==n[1]&&"N"!==n[1])&&(function(e,n,t,a){if(null==n||function(e,n,t,a){if(null!==t&&0===t.type)return!1;switch(typeof n){case"function":case"symbol":return!0;case"boolean":return!a&&(null!==t?!t.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,n,t,a))return!0;if(a)return!1;if(null!==t)switch(t.type){case 3:return!n;case 4:return!1===n;case 5:return isNaN(n);case 6:return isNaN(n)||1>n}return!1}(n,t,o,a)&&(t=null),a||null===o?function(e){return!!d.call(m,e)||!d.call(f,e)&&(p.test(e)?m[e]=!0:(f[e]=!0,!1))}(n)&&(null===t?e.removeAttribute(n):e.setAttribute(n,""+t)):o.mustUseProperty?e[o.propertyName]=null===t?3!==o.type&&"":t:(n=o.attributeName,a=o.attributeNamespace,null===t?e.removeAttribute(n):(t=3===(o=o.type)||4===o&&!0===t?"":""+t,a?e.setAttributeNS(a,n,t):e.setAttribute(n,t))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var n=e.replace(h,v);g[n]=new _(n,1,!1,e,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var n=e.replace(h,v);g[n]=new _(n,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(e){var n=e.replace(h,v);g[n]=new _(n,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(e){g[e]=new _(e,1,!1,e.toLowerCase(),null,!1,!1)}),g.xlinkHref=new _("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(e){g[e]=new _(e,1,!1,e.toLowerCase(),null,!0,!0)});var y=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,k=Symbol.for("react.element"),S=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),E=Symbol.for("react.strict_mode"),P=Symbol.for("react.profiler"),w=Symbol.for("react.provider"),C=Symbol.for("react.context"),R=Symbol.for("react.forward_ref"),L=Symbol.for("react.suspense"),I=Symbol.for("react.suspense_list"),M=Symbol.for("react.memo"),D=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var A=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var O=Symbol.iterator;function T(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=O&&e[O]||e["@@iterator"])?e:null}var B,z=Object.assign;function F(e){if(void 0===B)try{throw Error()}catch(e){var n=e.stack.trim().match(/\n( *(at )?)/);B=n&&n[1]||""}return"\n"+B+e}var N=!1;function G(e,n){if(!e||N)return"";N=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(n)if(n=function(){throw Error()},Object.defineProperty(n.prototype,"props",{set:function(){throw Error()}}),"object"==typeof Reflect&&Reflect.construct){try{Reflect.construct(n,[])}catch(e){var a=e}Reflect.construct(e,[],n)}else{try{n.call()}catch(e){a=e}e.call(n.prototype)}else{try{throw Error()}catch(e){a=e}e()}}catch(n){if(n&&a&&"string"==typeof n.stack){for(var o=n.stack.split("\n"),r=a.stack.split("\n"),c=o.length-1,i=r.length-1;1<=c&&0<=i&&o[c]!==r[i];)i--;for(;1<=c&&0<=i;c--,i--)if(o[c]!==r[i]){if(1!==c||1!==i)do{if(c--,0>--i||o[c]!==r[i]){var l="\n"+o[c].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}}while(1<=c&&0<=i);break}}}finally{N=!1,Error.prepareStackTrace=t}return(e=e?e.displayName||e.name:"")?F(e):""}function q(e){switch(e.tag){case 5:return F(e.type);case 16:return F("Lazy");case 13:return F("Suspense");case 19:return F("SuspenseList");case 0:case 2:case 15:return G(e.type,!1);case 11:return G(e.type.render,!1);case 1:return G(e.type,!0);default:return""}}function U(e){if(null==e)return null;if("function"==typeof e)return e.displayName||e.name||null;if("string"==typeof e)return e;switch(e){case x:return"Fragment";case S:return"Portal";case P:return"Profiler";case E:return"StrictMode";case L:return"Suspense";case I:return"SuspenseList"}if("object"==typeof e)switch(e.$$typeof){case C:return(e.displayName||"Context")+".Consumer";case w:return(e._context.displayName||"Context")+".Provider";case R:var n=e.render;return(e=e.displayName)||(e=""!==(e=n.displayName||n.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case M:return null!==(n=e.displayName||null)?n:U(e.type)||"Memo";case D:n=e._payload,e=e._init;try{return U(e(n))}catch(e){}}return null}function W(e){var n=e.type;switch(e.tag){case 24:return"Cache";case 9:return(n.displayName||"Context")+".Consumer";case 10:return(n._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=n.render).displayName||e.name||"",n.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return n;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return U(n);case 8:return n===E?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"==typeof n)return n.displayName||n.name||null;if("string"==typeof n)return n}return null}function V(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function H(e){var n=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===n||"radio"===n)}function j(e){e._valueTracker||(e._valueTracker=function(e){var n=H(e)?"checked":"value",t=Object.getOwnPropertyDescriptor(e.constructor.prototype,n),a=""+e[n];if(!e.hasOwnProperty(n)&&void 0!==t&&"function"==typeof t.get&&"function"==typeof t.set){var o=t.get,r=t.set;return Object.defineProperty(e,n,{configurable:!0,get:function(){return o.call(this)},set:function(e){a=""+e,r.call(this,e)}}),Object.defineProperty(e,n,{enumerable:t.enumerable}),{getValue:function(){return a},setValue:function(e){a=""+e},stopTracking:function(){e._valueTracker=null,delete e[n]}}}}(e))}function K(e){if(!e)return!1;var n=e._valueTracker;if(!n)return!0;var t=n.getValue(),a="";return e&&(a=H(e)?e.checked?"true":"false":e.value),(e=a)!==t&&(n.setValue(e),!0)}function $(e){if(void 0===(e=e||("undefined"!=typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(n){return e.body}}function Y(e,n){var t=n.checked;return z({},n,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=t?t:e._wrapperState.initialChecked})}function X(e,n){var t=null==n.defaultValue?"":n.defaultValue,a=null!=n.checked?n.checked:n.defaultChecked;t=V(null!=n.value?n.value:t),e._wrapperState={initialChecked:a,initialValue:t,controlled:"checkbox"===n.type||"radio"===n.type?null!=n.checked:null!=n.value}}function Z(e,n){null!=(n=n.checked)&&b(e,"checked",n,!1)}function Q(e,n){Z(e,n);var t=V(n.value),a=n.type;if(null!=t)"number"===a?(0===t&&""===e.value||e.value!=t)&&(e.value=""+t):e.value!==""+t&&(e.value=""+t);else if("submit"===a||"reset"===a)return void e.removeAttribute("value");n.hasOwnProperty("value")?ee(e,n.type,t):n.hasOwnProperty("defaultValue")&&ee(e,n.type,V(n.defaultValue)),null==n.checked&&null!=n.defaultChecked&&(e.defaultChecked=!!n.defaultChecked)}function J(e,n,t){if(n.hasOwnProperty("value")||n.hasOwnProperty("defaultValue")){var a=n.type;if(!("submit"!==a&&"reset"!==a||void 0!==n.value&&null!==n.value))return;n=""+e._wrapperState.initialValue,t||n===e.value||(e.value=n),e.defaultValue=n}""!==(t=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==t&&(e.name=t)}function ee(e,n,t){"number"===n&&$(e.ownerDocument)===e||(null==t?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+t&&(e.defaultValue=""+t))}var ne=Array.isArray;function te(e,n,t,a){if(e=e.options,n){n={};for(var o=0;o<t.length;o++)n["$"+t[o]]=!0;for(t=0;t<e.length;t++)o=n.hasOwnProperty("$"+e[t].value),e[t].selected!==o&&(e[t].selected=o),o&&a&&(e[t].defaultSelected=!0)}else{for(t=""+V(t),n=null,o=0;o<e.length;o++){if(e[o].value===t)return e[o].selected=!0,void(a&&(e[o].defaultSelected=!0));null!==n||e[o].disabled||(n=e[o])}null!==n&&(n.selected=!0)}}function ae(e,n){if(null!=n.dangerouslySetInnerHTML)throw Error(r(91));return z({},n,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function oe(e,n){var t=n.value;if(null==t){if(t=n.children,n=n.defaultValue,null!=t){if(null!=n)throw Error(r(92));if(ne(t)){if(1<t.length)throw Error(r(93));t=t[0]}n=t}null==n&&(n=""),t=n}e._wrapperState={initialValue:V(t)}}function re(e,n){var t=V(n.value),a=V(n.defaultValue);null!=t&&((t=""+t)!==e.value&&(e.value=t),null==n.defaultValue&&e.defaultValue!==t&&(e.defaultValue=t)),null!=a&&(e.defaultValue=""+a)}function ce(e){var n=e.textContent;n===e._wrapperState.initialValue&&""!==n&&null!==n&&(e.value=n)}function ie(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function le(e,n){return null==e||"http://www.w3.org/1999/xhtml"===e?ie(n):"http://www.w3.org/2000/svg"===e&&"foreignObject"===n?"http://www.w3.org/1999/xhtml":e}var se,ue,de=(ue=function(e,n){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=n;else{for((se=se||document.createElement("div")).innerHTML="<svg>"+n.valueOf().toString()+"</svg>",n=se.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;n.firstChild;)e.appendChild(n.firstChild)}},"undefined"!=typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,n,t,a){MSApp.execUnsafeLocalFunction(function(){return ue(e,n)})}:ue);function pe(e,n){if(n){var t=e.firstChild;if(t&&t===e.lastChild&&3===t.nodeType)return void(t.nodeValue=n)}e.textContent=n}var fe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},me=["Webkit","ms","Moz","O"];function _e(e,n,t){return null==n||"boolean"==typeof n||""===n?"":t||"number"!=typeof n||0===n||fe.hasOwnProperty(e)&&fe[e]?(""+n).trim():n+"px"}function ge(e,n){for(var t in e=e.style,n)if(n.hasOwnProperty(t)){var a=0===t.indexOf("--"),o=_e(t,n[t],a);"float"===t&&(t="cssFloat"),a?e.setProperty(t,o):e[t]=o}}Object.keys(fe).forEach(function(e){me.forEach(function(n){n=n+e.charAt(0).toUpperCase()+e.substring(1),fe[n]=fe[e]})});var he=z({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ve(e,n){if(n){if(he[e]&&(null!=n.children||null!=n.dangerouslySetInnerHTML))throw Error(r(137,e));if(null!=n.dangerouslySetInnerHTML){if(null!=n.children)throw Error(r(60));if("object"!=typeof n.dangerouslySetInnerHTML||!("__html"in n.dangerouslySetInnerHTML))throw Error(r(61))}if(null!=n.style&&"object"!=typeof n.style)throw Error(r(62))}}function be(e,n){if(-1===e.indexOf("-"))return"string"==typeof n.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ye=null;function ke(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var Se=null,xe=null,Ee=null;function Pe(e){if(e=yo(e)){if("function"!=typeof Se)throw Error(r(280));var n=e.stateNode;n&&(n=So(n),Se(e.stateNode,e.type,n))}}function we(e){xe?Ee?Ee.push(e):Ee=[e]:xe=e}function Ce(){if(xe){var e=xe,n=Ee;if(Ee=xe=null,Pe(e),n)for(e=0;e<n.length;e++)Pe(n[e])}}function Re(e,n){return e(n)}function Le(){}var Ie=!1;function Me(e,n,t){if(Ie)return e(n,t);Ie=!0;try{return Re(e,n,t)}finally{Ie=!1,(null!==xe||null!==Ee)&&(Le(),Ce())}}function De(e,n){var t=e.stateNode;if(null===t)return null;var a=So(t);if(null===a)return null;t=a[n];e:switch(n){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(a=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!a;break e;default:e=!1}if(e)return null;if(t&&"function"!=typeof t)throw Error(r(231,n,typeof t));return t}var Ae=!1;if(u)try{var Oe={};Object.defineProperty(Oe,"passive",{get:function(){Ae=!0}}),window.addEventListener("test",Oe,Oe),window.removeEventListener("test",Oe,Oe)}catch(ue){Ae=!1}function Te(e,n,t,a,o,r,c,i,l){var s=Array.prototype.slice.call(arguments,3);try{n.apply(t,s)}catch(e){this.onError(e)}}var Be=!1,ze=null,Fe=!1,Ne=null,Ge={onError:function(e){Be=!0,ze=e}};function qe(e,n,t,a,o,r,c,i,l){Be=!1,ze=null,Te.apply(Ge,arguments)}function Ue(e){var n=e,t=e;if(e.alternate)for(;n.return;)n=n.return;else{e=n;do{!!(4098&(n=e).flags)&&(t=n.return),e=n.return}while(e)}return 3===n.tag?t:null}function We(e){if(13===e.tag){var n=e.memoizedState;if(null===n&&null!==(e=e.alternate)&&(n=e.memoizedState),null!==n)return n.dehydrated}return null}function Ve(e){if(Ue(e)!==e)throw Error(r(188))}function He(e){return null!==(e=function(e){var n=e.alternate;if(!n){if(null===(n=Ue(e)))throw Error(r(188));return n!==e?null:e}for(var t=e,a=n;;){var o=t.return;if(null===o)break;var c=o.alternate;if(null===c){if(null!==(a=o.return)){t=a;continue}break}if(o.child===c.child){for(c=o.child;c;){if(c===t)return Ve(o),e;if(c===a)return Ve(o),n;c=c.sibling}throw Error(r(188))}if(t.return!==a.return)t=o,a=c;else{for(var i=!1,l=o.child;l;){if(l===t){i=!0,t=o,a=c;break}if(l===a){i=!0,a=o,t=c;break}l=l.sibling}if(!i){for(l=c.child;l;){if(l===t){i=!0,t=c,a=o;break}if(l===a){i=!0,a=c,t=o;break}l=l.sibling}if(!i)throw Error(r(189))}}if(t.alternate!==a)throw Error(r(190))}if(3!==t.tag)throw Error(r(188));return t.stateNode.current===t?e:n}(e))?je(e):null}function je(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var n=je(e);if(null!==n)return n;e=e.sibling}return null}var Ke=o.unstable_scheduleCallback,$e=o.unstable_cancelCallback,Ye=o.unstable_shouldYield,Xe=o.unstable_requestPaint,Ze=o.unstable_now,Qe=o.unstable_getCurrentPriorityLevel,Je=o.unstable_ImmediatePriority,en=o.unstable_UserBlockingPriority,nn=o.unstable_NormalPriority,tn=o.unstable_LowPriority,an=o.unstable_IdlePriority,on=null,rn=null,cn=Math.clz32?Math.clz32:function(e){return 0===(e>>>=0)?32:31-(ln(e)/sn|0)|0},ln=Math.log,sn=Math.LN2,un=64,dn=4194304;function pn(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function fn(e,n){var t=e.pendingLanes;if(0===t)return 0;var a=0,o=e.suspendedLanes,r=e.pingedLanes,c=268435455&t;if(0!==c){var i=c&~o;0!==i?a=pn(i):0!==(r&=c)&&(a=pn(r))}else 0!==(c=t&~o)?a=pn(c):0!==r&&(a=pn(r));if(0===a)return 0;if(0!==n&&n!==a&&0===(n&o)&&((o=a&-a)>=(r=n&-n)||16===o&&4194240&r))return n;if(4&a&&(a|=16&t),0!==(n=e.entangledLanes))for(e=e.entanglements,n&=a;0<n;)o=1<<(t=31-cn(n)),a|=e[t],n&=~o;return a}function mn(e,n){switch(e){case 1:case 2:case 4:return n+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return n+5e3;default:return-1}}function _n(e){return 0!=(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function gn(){var e=un;return!(4194240&(un<<=1))&&(un=64),e}function hn(e){for(var n=[],t=0;31>t;t++)n.push(e);return n}function vn(e,n,t){e.pendingLanes|=n,536870912!==n&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[n=31-cn(n)]=t}function bn(e,n){var t=e.entangledLanes|=n;for(e=e.entanglements;t;){var a=31-cn(t),o=1<<a;o&n|e[a]&n&&(e[a]|=n),t&=~o}}var yn=0;function kn(e){return 1<(e&=-e)?4<e?268435455&e?16:536870912:4:1}var Sn,xn,En,Pn,wn,Cn=!1,Rn=[],Ln=null,In=null,Mn=null,Dn=new Map,An=new Map,On=[],Tn="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Bn(e,n){switch(e){case"focusin":case"focusout":Ln=null;break;case"dragenter":case"dragleave":In=null;break;case"mouseover":case"mouseout":Mn=null;break;case"pointerover":case"pointerout":Dn.delete(n.pointerId);break;case"gotpointercapture":case"lostpointercapture":An.delete(n.pointerId)}}function zn(e,n,t,a,o,r){return null===e||e.nativeEvent!==r?(e={blockedOn:n,domEventName:t,eventSystemFlags:a,nativeEvent:r,targetContainers:[o]},null!==n&&null!==(n=yo(n))&&xn(n),e):(e.eventSystemFlags|=a,n=e.targetContainers,null!==o&&-1===n.indexOf(o)&&n.push(o),e)}function Fn(e){var n=bo(e.target);if(null!==n){var t=Ue(n);if(null!==t)if(13===(n=t.tag)){if(null!==(n=We(t)))return e.blockedOn=n,void wn(e.priority,function(){En(t)})}else if(3===n&&t.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===t.tag?t.stateNode.containerInfo:null)}e.blockedOn=null}function Nn(e){if(null!==e.blockedOn)return!1;for(var n=e.targetContainers;0<n.length;){var t=Xn(e.domEventName,e.eventSystemFlags,n[0],e.nativeEvent);if(null!==t)return null!==(n=yo(t))&&xn(n),e.blockedOn=t,!1;var a=new(t=e.nativeEvent).constructor(t.type,t);ye=a,t.target.dispatchEvent(a),ye=null,n.shift()}return!0}function Gn(e,n,t){Nn(e)&&t.delete(n)}function qn(){Cn=!1,null!==Ln&&Nn(Ln)&&(Ln=null),null!==In&&Nn(In)&&(In=null),null!==Mn&&Nn(Mn)&&(Mn=null),Dn.forEach(Gn),An.forEach(Gn)}function Un(e,n){e.blockedOn===n&&(e.blockedOn=null,Cn||(Cn=!0,o.unstable_scheduleCallback(o.unstable_NormalPriority,qn)))}function Wn(e){function n(n){return Un(n,e)}if(0<Rn.length){Un(Rn[0],e);for(var t=1;t<Rn.length;t++){var a=Rn[t];a.blockedOn===e&&(a.blockedOn=null)}}for(null!==Ln&&Un(Ln,e),null!==In&&Un(In,e),null!==Mn&&Un(Mn,e),Dn.forEach(n),An.forEach(n),t=0;t<On.length;t++)(a=On[t]).blockedOn===e&&(a.blockedOn=null);for(;0<On.length&&null===(t=On[0]).blockedOn;)Fn(t),null===t.blockedOn&&On.shift()}var Vn=y.ReactCurrentBatchConfig,Hn=!0;function jn(e,n,t,a){var o=yn,r=Vn.transition;Vn.transition=null;try{yn=1,$n(e,n,t,a)}finally{yn=o,Vn.transition=r}}function Kn(e,n,t,a){var o=yn,r=Vn.transition;Vn.transition=null;try{yn=4,$n(e,n,t,a)}finally{yn=o,Vn.transition=r}}function $n(e,n,t,a){if(Hn){var o=Xn(e,n,t,a);if(null===o)Va(e,n,a,Yn,t),Bn(e,a);else if(function(e,n,t,a,o){switch(n){case"focusin":return Ln=zn(Ln,e,n,t,a,o),!0;case"dragenter":return In=zn(In,e,n,t,a,o),!0;case"mouseover":return Mn=zn(Mn,e,n,t,a,o),!0;case"pointerover":var r=o.pointerId;return Dn.set(r,zn(Dn.get(r)||null,e,n,t,a,o)),!0;case"gotpointercapture":return r=o.pointerId,An.set(r,zn(An.get(r)||null,e,n,t,a,o)),!0}return!1}(o,e,n,t,a))a.stopPropagation();else if(Bn(e,a),4&n&&-1<Tn.indexOf(e)){for(;null!==o;){var r=yo(o);if(null!==r&&Sn(r),null===(r=Xn(e,n,t,a))&&Va(e,n,a,Yn,t),r===o)break;o=r}null!==o&&a.stopPropagation()}else Va(e,n,a,null,t)}}var Yn=null;function Xn(e,n,t,a){if(Yn=null,null!==(e=bo(e=ke(a))))if(null===(n=Ue(e)))e=null;else if(13===(t=n.tag)){if(null!==(e=We(n)))return e;e=null}else if(3===t){if(n.stateNode.current.memoizedState.isDehydrated)return 3===n.tag?n.stateNode.containerInfo:null;e=null}else n!==e&&(e=null);return Yn=e,null}function Zn(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Qe()){case Je:return 1;case en:return 4;case nn:case tn:return 16;case an:return 536870912;default:return 16}default:return 16}}var Qn=null,Jn=null,et=null;function nt(){if(et)return et;var e,n,t=Jn,a=t.length,o="value"in Qn?Qn.value:Qn.textContent,r=o.length;for(e=0;e<a&&t[e]===o[e];e++);var c=a-e;for(n=1;n<=c&&t[a-n]===o[r-n];n++);return et=o.slice(e,1<n?1-n:void 0)}function tt(e){var n=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===n&&(e=13):e=n,10===e&&(e=13),32<=e||13===e?e:0}function at(){return!0}function ot(){return!1}function rt(e){function n(n,t,a,o,r){for(var c in this._reactName=n,this._targetInst=a,this.type=t,this.nativeEvent=o,this.target=r,this.currentTarget=null,e)e.hasOwnProperty(c)&&(n=e[c],this[c]=n?n(o):o[c]);return this.isDefaultPrevented=(null!=o.defaultPrevented?o.defaultPrevented:!1===o.returnValue)?at:ot,this.isPropagationStopped=ot,this}return z(n.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!=typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=at)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!=typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=at)},persist:function(){},isPersistent:at}),n}var ct,it,lt,st={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},ut=rt(st),dt=z({},st,{view:0,detail:0}),pt=rt(dt),ft=z({},dt,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Pt,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==lt&&(lt&&"mousemove"===e.type?(ct=e.screenX-lt.screenX,it=e.screenY-lt.screenY):it=ct=0,lt=e),ct)},movementY:function(e){return"movementY"in e?e.movementY:it}}),mt=rt(ft),_t=rt(z({},ft,{dataTransfer:0})),gt=rt(z({},dt,{relatedTarget:0})),ht=rt(z({},st,{animationName:0,elapsedTime:0,pseudoElement:0})),vt=z({},st,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),bt=rt(vt),yt=rt(z({},st,{data:0})),kt={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},St={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},xt={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Et(e){var n=this.nativeEvent;return n.getModifierState?n.getModifierState(e):!!(e=xt[e])&&!!n[e]}function Pt(){return Et}var wt=z({},dt,{key:function(e){if(e.key){var n=kt[e.key]||e.key;if("Unidentified"!==n)return n}return"keypress"===e.type?13===(e=tt(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?St[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Pt,charCode:function(e){return"keypress"===e.type?tt(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tt(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Ct=rt(wt),Rt=rt(z({},ft,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Lt=rt(z({},dt,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Pt})),It=rt(z({},st,{propertyName:0,elapsedTime:0,pseudoElement:0})),Mt=z({},ft,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Dt=rt(Mt),At=[9,13,27,32],Ot=u&&"CompositionEvent"in window,Tt=null;u&&"documentMode"in document&&(Tt=document.documentMode);var Bt=u&&"TextEvent"in window&&!Tt,zt=u&&(!Ot||Tt&&8<Tt&&11>=Tt),Ft=String.fromCharCode(32),Nt=!1;function Gt(e,n){switch(e){case"keyup":return-1!==At.indexOf(n.keyCode);case"keydown":return 229!==n.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function qt(e){return"object"==typeof(e=e.detail)&&"data"in e?e.data:null}var Ut=!1,Wt={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Vt(e){var n=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===n?!!Wt[e.type]:"textarea"===n}function Ht(e,n,t,a){we(a),0<(n=ja(n,"onChange")).length&&(t=new ut("onChange","change",null,t,a),e.push({event:t,listeners:n}))}var jt=null,Kt=null;function $t(e){Fa(e,0)}function Yt(e){if(K(ko(e)))return e}function Xt(e,n){if("change"===e)return n}var Zt=!1;if(u){var Qt;if(u){var Jt="oninput"in document;if(!Jt){var ea=document.createElement("div");ea.setAttribute("oninput","return;"),Jt="function"==typeof ea.oninput}Qt=Jt}else Qt=!1;Zt=Qt&&(!document.documentMode||9<document.documentMode)}function na(){jt&&(jt.detachEvent("onpropertychange",ta),Kt=jt=null)}function ta(e){if("value"===e.propertyName&&Yt(Kt)){var n=[];Ht(n,Kt,e,ke(e)),Me($t,n)}}function aa(e,n,t){"focusin"===e?(na(),Kt=t,(jt=n).attachEvent("onpropertychange",ta)):"focusout"===e&&na()}function oa(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Yt(Kt)}function ra(e,n){if("click"===e)return Yt(n)}function ca(e,n){if("input"===e||"change"===e)return Yt(n)}var ia="function"==typeof Object.is?Object.is:function(e,n){return e===n&&(0!==e||1/e==1/n)||e!=e&&n!=n};function la(e,n){if(ia(e,n))return!0;if("object"!=typeof e||null===e||"object"!=typeof n||null===n)return!1;var t=Object.keys(e),a=Object.keys(n);if(t.length!==a.length)return!1;for(a=0;a<t.length;a++){var o=t[a];if(!d.call(n,o)||!ia(e[o],n[o]))return!1}return!0}function sa(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ua(e,n){var t,a=sa(e);for(e=0;a;){if(3===a.nodeType){if(t=e+a.textContent.length,e<=n&&t>=n)return{node:a,offset:n-e};e=t}e:{for(;a;){if(a.nextSibling){a=a.nextSibling;break e}a=a.parentNode}a=void 0}a=sa(a)}}function da(e,n){return!(!e||!n)&&(e===n||(!e||3!==e.nodeType)&&(n&&3===n.nodeType?da(e,n.parentNode):"contains"in e?e.contains(n):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(n))))}function pa(){for(var e=window,n=$();n instanceof e.HTMLIFrameElement;){try{var t="string"==typeof n.contentWindow.location.href}catch(e){t=!1}if(!t)break;n=$((e=n.contentWindow).document)}return n}function fa(e){var n=e&&e.nodeName&&e.nodeName.toLowerCase();return n&&("input"===n&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===n||"true"===e.contentEditable)}function ma(e){var n=pa(),t=e.focusedElem,a=e.selectionRange;if(n!==t&&t&&t.ownerDocument&&da(t.ownerDocument.documentElement,t)){if(null!==a&&fa(t))if(n=a.start,void 0===(e=a.end)&&(e=n),"selectionStart"in t)t.selectionStart=n,t.selectionEnd=Math.min(e,t.value.length);else if((e=(n=t.ownerDocument||document)&&n.defaultView||window).getSelection){e=e.getSelection();var o=t.textContent.length,r=Math.min(a.start,o);a=void 0===a.end?r:Math.min(a.end,o),!e.extend&&r>a&&(o=a,a=r,r=o),o=ua(t,r);var c=ua(t,a);o&&c&&(1!==e.rangeCount||e.anchorNode!==o.node||e.anchorOffset!==o.offset||e.focusNode!==c.node||e.focusOffset!==c.offset)&&((n=n.createRange()).setStart(o.node,o.offset),e.removeAllRanges(),r>a?(e.addRange(n),e.extend(c.node,c.offset)):(n.setEnd(c.node,c.offset),e.addRange(n)))}for(n=[],e=t;e=e.parentNode;)1===e.nodeType&&n.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"==typeof t.focus&&t.focus(),t=0;t<n.length;t++)(e=n[t]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var _a=u&&"documentMode"in document&&11>=document.documentMode,ga=null,ha=null,va=null,ba=!1;function ya(e,n,t){var a=t.window===t?t.document:9===t.nodeType?t:t.ownerDocument;ba||null==ga||ga!==$(a)||(a="selectionStart"in(a=ga)&&fa(a)?{start:a.selectionStart,end:a.selectionEnd}:{anchorNode:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset},va&&la(va,a)||(va=a,0<(a=ja(ha,"onSelect")).length&&(n=new ut("onSelect","select",null,n,t),e.push({event:n,listeners:a}),n.target=ga)))}function ka(e,n){var t={};return t[e.toLowerCase()]=n.toLowerCase(),t["Webkit"+e]="webkit"+n,t["Moz"+e]="moz"+n,t}var Sa={animationend:ka("Animation","AnimationEnd"),animationiteration:ka("Animation","AnimationIteration"),animationstart:ka("Animation","AnimationStart"),transitionend:ka("Transition","TransitionEnd")},xa={},Ea={};function Pa(e){if(xa[e])return xa[e];if(!Sa[e])return e;var n,t=Sa[e];for(n in t)if(t.hasOwnProperty(n)&&n in Ea)return xa[e]=t[n];return e}u&&(Ea=document.createElement("div").style,"AnimationEvent"in window||(delete Sa.animationend.animation,delete Sa.animationiteration.animation,delete Sa.animationstart.animation),"TransitionEvent"in window||delete Sa.transitionend.transition);var wa=Pa("animationend"),Ca=Pa("animationiteration"),Ra=Pa("animationstart"),La=Pa("transitionend"),Ia=new Map,Ma="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Da(e,n){Ia.set(e,n),l(n,[e])}for(var Aa=0;Aa<Ma.length;Aa++){var Oa=Ma[Aa];Da(Oa.toLowerCase(),"on"+(Oa[0].toUpperCase()+Oa.slice(1)))}Da(wa,"onAnimationEnd"),Da(Ca,"onAnimationIteration"),Da(Ra,"onAnimationStart"),Da("dblclick","onDoubleClick"),Da("focusin","onFocus"),Da("focusout","onBlur"),Da(La,"onTransitionEnd"),s("onMouseEnter",["mouseout","mouseover"]),s("onMouseLeave",["mouseout","mouseover"]),s("onPointerEnter",["pointerout","pointerover"]),s("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Ta="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Ba=new Set("cancel close invalid load scroll toggle".split(" ").concat(Ta));function za(e,n,t){var a=e.type||"unknown-event";e.currentTarget=t,function(e,n,t,a,o,c,i,l,s){if(qe.apply(this,arguments),Be){if(!Be)throw Error(r(198));var u=ze;Be=!1,ze=null,Fe||(Fe=!0,Ne=u)}}(a,n,void 0,e),e.currentTarget=null}function Fa(e,n){n=!!(4&n);for(var t=0;t<e.length;t++){var a=e[t],o=a.event;a=a.listeners;e:{var r=void 0;if(n)for(var c=a.length-1;0<=c;c--){var i=a[c],l=i.instance,s=i.currentTarget;if(i=i.listener,l!==r&&o.isPropagationStopped())break e;za(o,i,s),r=l}else for(c=0;c<a.length;c++){if(l=(i=a[c]).instance,s=i.currentTarget,i=i.listener,l!==r&&o.isPropagationStopped())break e;za(o,i,s),r=l}}}if(Fe)throw e=Ne,Fe=!1,Ne=null,e}function Na(e,n){var t=n[go];void 0===t&&(t=n[go]=new Set);var a=e+"__bubble";t.has(a)||(Wa(n,e,2,!1),t.add(a))}function Ga(e,n,t){var a=0;n&&(a|=4),Wa(t,e,a,n)}var qa="_reactListening"+Math.random().toString(36).slice(2);function Ua(e){if(!e[qa]){e[qa]=!0,c.forEach(function(n){"selectionchange"!==n&&(Ba.has(n)||Ga(n,!1,e),Ga(n,!0,e))});var n=9===e.nodeType?e:e.ownerDocument;null===n||n[qa]||(n[qa]=!0,Ga("selectionchange",!1,n))}}function Wa(e,n,t,a){switch(Zn(n)){case 1:var o=jn;break;case 4:o=Kn;break;default:o=$n}t=o.bind(null,n,t,e),o=void 0,!Ae||"touchstart"!==n&&"touchmove"!==n&&"wheel"!==n||(o=!0),a?void 0!==o?e.addEventListener(n,t,{capture:!0,passive:o}):e.addEventListener(n,t,!0):void 0!==o?e.addEventListener(n,t,{passive:o}):e.addEventListener(n,t,!1)}function Va(e,n,t,a,o){var r=a;if(!(1&n||2&n||null===a))e:for(;;){if(null===a)return;var c=a.tag;if(3===c||4===c){var i=a.stateNode.containerInfo;if(i===o||8===i.nodeType&&i.parentNode===o)break;if(4===c)for(c=a.return;null!==c;){var l=c.tag;if((3===l||4===l)&&((l=c.stateNode.containerInfo)===o||8===l.nodeType&&l.parentNode===o))return;c=c.return}for(;null!==i;){if(null===(c=bo(i)))return;if(5===(l=c.tag)||6===l){a=r=c;continue e}i=i.parentNode}}a=a.return}Me(function(){var a=r,o=ke(t),c=[];e:{var i=Ia.get(e);if(void 0!==i){var l=ut,s=e;switch(e){case"keypress":if(0===tt(t))break e;case"keydown":case"keyup":l=Ct;break;case"focusin":s="focus",l=gt;break;case"focusout":s="blur",l=gt;break;case"beforeblur":case"afterblur":l=gt;break;case"click":if(2===t.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=mt;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=_t;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=Lt;break;case wa:case Ca:case Ra:l=ht;break;case La:l=It;break;case"scroll":l=pt;break;case"wheel":l=Dt;break;case"copy":case"cut":case"paste":l=bt;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=Rt}var u=!!(4&n),d=!u&&"scroll"===e,p=u?null!==i?i+"Capture":null:i;u=[];for(var f,m=a;null!==m;){var _=(f=m).stateNode;if(5===f.tag&&null!==_&&(f=_,null!==p&&null!=(_=De(m,p))&&u.push(Ha(m,_,f))),d)break;m=m.return}0<u.length&&(i=new l(i,s,null,t,o),c.push({event:i,listeners:u}))}}if(!(7&n)){if(l="mouseout"===e||"pointerout"===e,(!(i="mouseover"===e||"pointerover"===e)||t===ye||!(s=t.relatedTarget||t.fromElement)||!bo(s)&&!s[_o])&&(l||i)&&(i=o.window===o?o:(i=o.ownerDocument)?i.defaultView||i.parentWindow:window,l?(l=a,null!==(s=(s=t.relatedTarget||t.toElement)?bo(s):null)&&(s!==(d=Ue(s))||5!==s.tag&&6!==s.tag)&&(s=null)):(l=null,s=a),l!==s)){if(u=mt,_="onMouseLeave",p="onMouseEnter",m="mouse","pointerout"!==e&&"pointerover"!==e||(u=Rt,_="onPointerLeave",p="onPointerEnter",m="pointer"),d=null==l?i:ko(l),f=null==s?i:ko(s),(i=new u(_,m+"leave",l,t,o)).target=d,i.relatedTarget=f,_=null,bo(o)===a&&((u=new u(p,m+"enter",s,t,o)).target=f,u.relatedTarget=d,_=u),d=_,l&&s)e:{for(p=s,m=0,f=u=l;f;f=Ka(f))m++;for(f=0,_=p;_;_=Ka(_))f++;for(;0<m-f;)u=Ka(u),m--;for(;0<f-m;)p=Ka(p),f--;for(;m--;){if(u===p||null!==p&&u===p.alternate)break e;u=Ka(u),p=Ka(p)}u=null}else u=null;null!==l&&$a(c,i,l,u,!1),null!==s&&null!==d&&$a(c,d,s,u,!0)}if("select"===(l=(i=a?ko(a):window).nodeName&&i.nodeName.toLowerCase())||"input"===l&&"file"===i.type)var g=Xt;else if(Vt(i))if(Zt)g=ca;else{g=oa;var h=aa}else(l=i.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===i.type||"radio"===i.type)&&(g=ra);switch(g&&(g=g(e,a))?Ht(c,g,t,o):(h&&h(e,i,a),"focusout"===e&&(h=i._wrapperState)&&h.controlled&&"number"===i.type&&ee(i,"number",i.value)),h=a?ko(a):window,e){case"focusin":(Vt(h)||"true"===h.contentEditable)&&(ga=h,ha=a,va=null);break;case"focusout":va=ha=ga=null;break;case"mousedown":ba=!0;break;case"contextmenu":case"mouseup":case"dragend":ba=!1,ya(c,t,o);break;case"selectionchange":if(_a)break;case"keydown":case"keyup":ya(c,t,o)}var v;if(Ot)e:{switch(e){case"compositionstart":var b="onCompositionStart";break e;case"compositionend":b="onCompositionEnd";break e;case"compositionupdate":b="onCompositionUpdate";break e}b=void 0}else Ut?Gt(e,t)&&(b="onCompositionEnd"):"keydown"===e&&229===t.keyCode&&(b="onCompositionStart");b&&(zt&&"ko"!==t.locale&&(Ut||"onCompositionStart"!==b?"onCompositionEnd"===b&&Ut&&(v=nt()):(Jn="value"in(Qn=o)?Qn.value:Qn.textContent,Ut=!0)),0<(h=ja(a,b)).length&&(b=new yt(b,e,null,t,o),c.push({event:b,listeners:h}),(v||null!==(v=qt(t)))&&(b.data=v))),(v=Bt?function(e,n){switch(e){case"compositionend":return qt(n);case"keypress":return 32!==n.which?null:(Nt=!0,Ft);case"textInput":return(e=n.data)===Ft&&Nt?null:e;default:return null}}(e,t):function(e,n){if(Ut)return"compositionend"===e||!Ot&&Gt(e,n)?(e=nt(),et=Jn=Qn=null,Ut=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(n.ctrlKey||n.altKey||n.metaKey)||n.ctrlKey&&n.altKey){if(n.char&&1<n.char.length)return n.char;if(n.which)return String.fromCharCode(n.which)}return null;case"compositionend":return zt&&"ko"!==n.locale?null:n.data}}(e,t))&&0<(a=ja(a,"onBeforeInput")).length&&(o=new yt("onBeforeInput","beforeinput",null,t,o),c.push({event:o,listeners:a}),o.data=v)}Fa(c,n)})}function Ha(e,n,t){return{instance:e,listener:n,currentTarget:t}}function ja(e,n){for(var t=n+"Capture",a=[];null!==e;){var o=e,r=o.stateNode;5===o.tag&&null!==r&&(o=r,null!=(r=De(e,t))&&a.unshift(Ha(e,r,o)),null!=(r=De(e,n))&&a.push(Ha(e,r,o))),e=e.return}return a}function Ka(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function $a(e,n,t,a,o){for(var r=n._reactName,c=[];null!==t&&t!==a;){var i=t,l=i.alternate,s=i.stateNode;if(null!==l&&l===a)break;5===i.tag&&null!==s&&(i=s,o?null!=(l=De(t,r))&&c.unshift(Ha(t,l,i)):o||null!=(l=De(t,r))&&c.push(Ha(t,l,i))),t=t.return}0!==c.length&&e.push({event:n,listeners:c})}var Ya=/\r\n?/g,Xa=/\u0000|\uFFFD/g;function Za(e){return("string"==typeof e?e:""+e).replace(Ya,"\n").replace(Xa,"")}function Qa(e,n,t){if(n=Za(n),Za(e)!==n&&t)throw Error(r(425))}function Ja(){}var eo=null,no=null;function to(e,n){return"textarea"===e||"noscript"===e||"string"==typeof n.children||"number"==typeof n.children||"object"==typeof n.dangerouslySetInnerHTML&&null!==n.dangerouslySetInnerHTML&&null!=n.dangerouslySetInnerHTML.__html}var ao="function"==typeof setTimeout?setTimeout:void 0,oo="function"==typeof clearTimeout?clearTimeout:void 0,ro="function"==typeof Promise?Promise:void 0,co="function"==typeof queueMicrotask?queueMicrotask:void 0!==ro?function(e){return ro.resolve(null).then(e).catch(io)}:ao;function io(e){setTimeout(function(){throw e})}function lo(e,n){var t=n,a=0;do{var o=t.nextSibling;if(e.removeChild(t),o&&8===o.nodeType)if("/$"===(t=o.data)){if(0===a)return e.removeChild(o),void Wn(n);a--}else"$"!==t&&"$?"!==t&&"$!"!==t||a++;t=o}while(t);Wn(n)}function so(e){for(;null!=e;e=e.nextSibling){var n=e.nodeType;if(1===n||3===n)break;if(8===n){if("$"===(n=e.data)||"$!"===n||"$?"===n)break;if("/$"===n)return null}}return e}function uo(e){e=e.previousSibling;for(var n=0;e;){if(8===e.nodeType){var t=e.data;if("$"===t||"$!"===t||"$?"===t){if(0===n)return e;n--}else"/$"===t&&n++}e=e.previousSibling}return null}var po=Math.random().toString(36).slice(2),fo="__reactFiber$"+po,mo="__reactProps$"+po,_o="__reactContainer$"+po,go="__reactEvents$"+po,ho="__reactListeners$"+po,vo="__reactHandles$"+po;function bo(e){var n=e[fo];if(n)return n;for(var t=e.parentNode;t;){if(n=t[_o]||t[fo]){if(t=n.alternate,null!==n.child||null!==t&&null!==t.child)for(e=uo(e);null!==e;){if(t=e[fo])return t;e=uo(e)}return n}t=(e=t).parentNode}return null}function yo(e){return!(e=e[fo]||e[_o])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function ko(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(r(33))}function So(e){return e[mo]||null}var xo=[],Eo=-1;function Po(e){return{current:e}}function wo(e){0>Eo||(e.current=xo[Eo],xo[Eo]=null,Eo--)}function Co(e,n){Eo++,xo[Eo]=e.current,e.current=n}var Ro={},Lo=Po(Ro),Io=Po(!1),Mo=Ro;function Do(e,n){var t=e.type.contextTypes;if(!t)return Ro;var a=e.stateNode;if(a&&a.__reactInternalMemoizedUnmaskedChildContext===n)return a.__reactInternalMemoizedMaskedChildContext;var o,r={};for(o in t)r[o]=n[o];return a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=n,e.__reactInternalMemoizedMaskedChildContext=r),r}function Ao(e){return null!=e.childContextTypes}function Oo(){wo(Io),wo(Lo)}function To(e,n,t){if(Lo.current!==Ro)throw Error(r(168));Co(Lo,n),Co(Io,t)}function Bo(e,n,t){var a=e.stateNode;if(n=n.childContextTypes,"function"!=typeof a.getChildContext)return t;for(var o in a=a.getChildContext())if(!(o in n))throw Error(r(108,W(e)||"Unknown",o));return z({},t,a)}function zo(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Ro,Mo=Lo.current,Co(Lo,e),Co(Io,Io.current),!0}function Fo(e,n,t){var a=e.stateNode;if(!a)throw Error(r(169));t?(e=Bo(e,n,Mo),a.__reactInternalMemoizedMergedChildContext=e,wo(Io),wo(Lo),Co(Lo,e)):wo(Io),Co(Io,t)}var No=null,Go=!1,qo=!1;function Uo(e){null===No?No=[e]:No.push(e)}function Wo(){if(!qo&&null!==No){qo=!0;var e=0,n=yn;try{var t=No;for(yn=1;e<t.length;e++){var a=t[e];do{a=a(!0)}while(null!==a)}No=null,Go=!1}catch(n){throw null!==No&&(No=No.slice(e+1)),Ke(Je,Wo),n}finally{yn=n,qo=!1}}return null}var Vo=[],Ho=0,jo=null,Ko=0,$o=[],Yo=0,Xo=null,Zo=1,Qo="";function Jo(e,n){Vo[Ho++]=Ko,Vo[Ho++]=jo,jo=e,Ko=n}function er(e,n,t){$o[Yo++]=Zo,$o[Yo++]=Qo,$o[Yo++]=Xo,Xo=e;var a=Zo;e=Qo;var o=32-cn(a)-1;a&=~(1<<o),t+=1;var r=32-cn(n)+o;if(30<r){var c=o-o%5;r=(a&(1<<c)-1).toString(32),a>>=c,o-=c,Zo=1<<32-cn(n)+o|t<<o|a,Qo=r+e}else Zo=1<<r|t<<o|a,Qo=e}function nr(e){null!==e.return&&(Jo(e,1),er(e,1,0))}function tr(e){for(;e===jo;)jo=Vo[--Ho],Vo[Ho]=null,Ko=Vo[--Ho],Vo[Ho]=null;for(;e===Xo;)Xo=$o[--Yo],$o[Yo]=null,Qo=$o[--Yo],$o[Yo]=null,Zo=$o[--Yo],$o[Yo]=null}var ar=null,or=null,rr=!1,cr=null;function ir(e,n){var t=Ms(5,null,null,0);t.elementType="DELETED",t.stateNode=n,t.return=e,null===(n=e.deletions)?(e.deletions=[t],e.flags|=16):n.push(t)}function lr(e,n){switch(e.tag){case 5:var t=e.type;return null!==(n=1!==n.nodeType||t.toLowerCase()!==n.nodeName.toLowerCase()?null:n)&&(e.stateNode=n,ar=e,or=so(n.firstChild),!0);case 6:return null!==(n=""===e.pendingProps||3!==n.nodeType?null:n)&&(e.stateNode=n,ar=e,or=null,!0);case 13:return null!==(n=8!==n.nodeType?null:n)&&(t=null!==Xo?{id:Zo,overflow:Qo}:null,e.memoizedState={dehydrated:n,treeContext:t,retryLane:1073741824},(t=Ms(18,null,null,0)).stateNode=n,t.return=e,e.child=t,ar=e,or=null,!0);default:return!1}}function sr(e){return!(!(1&e.mode)||128&e.flags)}function ur(e){if(rr){var n=or;if(n){var t=n;if(!lr(e,n)){if(sr(e))throw Error(r(418));n=so(t.nextSibling);var a=ar;n&&lr(e,n)?ir(a,t):(e.flags=-4097&e.flags|2,rr=!1,ar=e)}}else{if(sr(e))throw Error(r(418));e.flags=-4097&e.flags|2,rr=!1,ar=e}}}function dr(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;ar=e}function pr(e){if(e!==ar)return!1;if(!rr)return dr(e),rr=!0,!1;var n;if((n=3!==e.tag)&&!(n=5!==e.tag)&&(n="head"!==(n=e.type)&&"body"!==n&&!to(e.type,e.memoizedProps)),n&&(n=or)){if(sr(e))throw fr(),Error(r(418));for(;n;)ir(e,n),n=so(n.nextSibling)}if(dr(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(r(317));e:{for(e=e.nextSibling,n=0;e;){if(8===e.nodeType){var t=e.data;if("/$"===t){if(0===n){or=so(e.nextSibling);break e}n--}else"$"!==t&&"$!"!==t&&"$?"!==t||n++}e=e.nextSibling}or=null}}else or=ar?so(e.stateNode.nextSibling):null;return!0}function fr(){for(var e=or;e;)e=so(e.nextSibling)}function mr(){or=ar=null,rr=!1}function _r(e){null===cr?cr=[e]:cr.push(e)}var gr=y.ReactCurrentBatchConfig;function hr(e,n,t){if(null!==(e=t.ref)&&"function"!=typeof e&&"object"!=typeof e){if(t._owner){if(t=t._owner){if(1!==t.tag)throw Error(r(309));var a=t.stateNode}if(!a)throw Error(r(147,e));var o=a,c=""+e;return null!==n&&null!==n.ref&&"function"==typeof n.ref&&n.ref._stringRef===c?n.ref:(n=function(e){var n=o.refs;null===e?delete n[c]:n[c]=e},n._stringRef=c,n)}if("string"!=typeof e)throw Error(r(284));if(!t._owner)throw Error(r(290,e))}return e}function vr(e,n){throw e=Object.prototype.toString.call(n),Error(r(31,"[object Object]"===e?"object with keys {"+Object.keys(n).join(", ")+"}":e))}function br(e){return(0,e._init)(e._payload)}function yr(e){function n(n,t){if(e){var a=n.deletions;null===a?(n.deletions=[t],n.flags|=16):a.push(t)}}function t(t,a){if(!e)return null;for(;null!==a;)n(t,a),a=a.sibling;return null}function a(e,n){for(e=new Map;null!==n;)null!==n.key?e.set(n.key,n):e.set(n.index,n),n=n.sibling;return e}function o(e,n){return(e=As(e,n)).index=0,e.sibling=null,e}function c(n,t,a){return n.index=a,e?null!==(a=n.alternate)?(a=a.index)<t?(n.flags|=2,t):a:(n.flags|=2,t):(n.flags|=1048576,t)}function i(n){return e&&null===n.alternate&&(n.flags|=2),n}function l(e,n,t,a){return null===n||6!==n.tag?((n=zs(t,e.mode,a)).return=e,n):((n=o(n,t)).return=e,n)}function s(e,n,t,a){var r=t.type;return r===x?d(e,n,t.props.children,a,t.key):null!==n&&(n.elementType===r||"object"==typeof r&&null!==r&&r.$$typeof===D&&br(r)===n.type)?((a=o(n,t.props)).ref=hr(e,n,t),a.return=e,a):((a=Os(t.type,t.key,t.props,null,e.mode,a)).ref=hr(e,n,t),a.return=e,a)}function u(e,n,t,a){return null===n||4!==n.tag||n.stateNode.containerInfo!==t.containerInfo||n.stateNode.implementation!==t.implementation?((n=Fs(t,e.mode,a)).return=e,n):((n=o(n,t.children||[])).return=e,n)}function d(e,n,t,a,r){return null===n||7!==n.tag?((n=Ts(t,e.mode,a,r)).return=e,n):((n=o(n,t)).return=e,n)}function p(e,n,t){if("string"==typeof n&&""!==n||"number"==typeof n)return(n=zs(""+n,e.mode,t)).return=e,n;if("object"==typeof n&&null!==n){switch(n.$$typeof){case k:return(t=Os(n.type,n.key,n.props,null,e.mode,t)).ref=hr(e,null,n),t.return=e,t;case S:return(n=Fs(n,e.mode,t)).return=e,n;case D:return p(e,(0,n._init)(n._payload),t)}if(ne(n)||T(n))return(n=Ts(n,e.mode,t,null)).return=e,n;vr(e,n)}return null}function f(e,n,t,a){var o=null!==n?n.key:null;if("string"==typeof t&&""!==t||"number"==typeof t)return null!==o?null:l(e,n,""+t,a);if("object"==typeof t&&null!==t){switch(t.$$typeof){case k:return t.key===o?s(e,n,t,a):null;case S:return t.key===o?u(e,n,t,a):null;case D:return f(e,n,(o=t._init)(t._payload),a)}if(ne(t)||T(t))return null!==o?null:d(e,n,t,a,null);vr(e,t)}return null}function m(e,n,t,a,o){if("string"==typeof a&&""!==a||"number"==typeof a)return l(n,e=e.get(t)||null,""+a,o);if("object"==typeof a&&null!==a){switch(a.$$typeof){case k:return s(n,e=e.get(null===a.key?t:a.key)||null,a,o);case S:return u(n,e=e.get(null===a.key?t:a.key)||null,a,o);case D:return m(e,n,t,(0,a._init)(a._payload),o)}if(ne(a)||T(a))return d(n,e=e.get(t)||null,a,o,null);vr(n,a)}return null}function _(o,r,i,l){for(var s=null,u=null,d=r,_=r=0,g=null;null!==d&&_<i.length;_++){d.index>_?(g=d,d=null):g=d.sibling;var h=f(o,d,i[_],l);if(null===h){null===d&&(d=g);break}e&&d&&null===h.alternate&&n(o,d),r=c(h,r,_),null===u?s=h:u.sibling=h,u=h,d=g}if(_===i.length)return t(o,d),rr&&Jo(o,_),s;if(null===d){for(;_<i.length;_++)null!==(d=p(o,i[_],l))&&(r=c(d,r,_),null===u?s=d:u.sibling=d,u=d);return rr&&Jo(o,_),s}for(d=a(o,d);_<i.length;_++)null!==(g=m(d,o,_,i[_],l))&&(e&&null!==g.alternate&&d.delete(null===g.key?_:g.key),r=c(g,r,_),null===u?s=g:u.sibling=g,u=g);return e&&d.forEach(function(e){return n(o,e)}),rr&&Jo(o,_),s}function g(o,i,l,s){var u=T(l);if("function"!=typeof u)throw Error(r(150));if(null==(l=u.call(l)))throw Error(r(151));for(var d=u=null,_=i,g=i=0,h=null,v=l.next();null!==_&&!v.done;g++,v=l.next()){_.index>g?(h=_,_=null):h=_.sibling;var b=f(o,_,v.value,s);if(null===b){null===_&&(_=h);break}e&&_&&null===b.alternate&&n(o,_),i=c(b,i,g),null===d?u=b:d.sibling=b,d=b,_=h}if(v.done)return t(o,_),rr&&Jo(o,g),u;if(null===_){for(;!v.done;g++,v=l.next())null!==(v=p(o,v.value,s))&&(i=c(v,i,g),null===d?u=v:d.sibling=v,d=v);return rr&&Jo(o,g),u}for(_=a(o,_);!v.done;g++,v=l.next())null!==(v=m(_,o,g,v.value,s))&&(e&&null!==v.alternate&&_.delete(null===v.key?g:v.key),i=c(v,i,g),null===d?u=v:d.sibling=v,d=v);return e&&_.forEach(function(e){return n(o,e)}),rr&&Jo(o,g),u}return function e(a,r,c,l){if("object"==typeof c&&null!==c&&c.type===x&&null===c.key&&(c=c.props.children),"object"==typeof c&&null!==c){switch(c.$$typeof){case k:e:{for(var s=c.key,u=r;null!==u;){if(u.key===s){if((s=c.type)===x){if(7===u.tag){t(a,u.sibling),(r=o(u,c.props.children)).return=a,a=r;break e}}else if(u.elementType===s||"object"==typeof s&&null!==s&&s.$$typeof===D&&br(s)===u.type){t(a,u.sibling),(r=o(u,c.props)).ref=hr(a,u,c),r.return=a,a=r;break e}t(a,u);break}n(a,u),u=u.sibling}c.type===x?((r=Ts(c.props.children,a.mode,l,c.key)).return=a,a=r):((l=Os(c.type,c.key,c.props,null,a.mode,l)).ref=hr(a,r,c),l.return=a,a=l)}return i(a);case S:e:{for(u=c.key;null!==r;){if(r.key===u){if(4===r.tag&&r.stateNode.containerInfo===c.containerInfo&&r.stateNode.implementation===c.implementation){t(a,r.sibling),(r=o(r,c.children||[])).return=a,a=r;break e}t(a,r);break}n(a,r),r=r.sibling}(r=Fs(c,a.mode,l)).return=a,a=r}return i(a);case D:return e(a,r,(u=c._init)(c._payload),l)}if(ne(c))return _(a,r,c,l);if(T(c))return g(a,r,c,l);vr(a,c)}return"string"==typeof c&&""!==c||"number"==typeof c?(c=""+c,null!==r&&6===r.tag?(t(a,r.sibling),(r=o(r,c)).return=a,a=r):(t(a,r),(r=zs(c,a.mode,l)).return=a,a=r),i(a)):t(a,r)}}var kr=yr(!0),Sr=yr(!1),xr=Po(null),Er=null,Pr=null,wr=null;function Cr(){wr=Pr=Er=null}function Rr(e){var n=xr.current;wo(xr),e._currentValue=n}function Lr(e,n,t){for(;null!==e;){var a=e.alternate;if((e.childLanes&n)!==n?(e.childLanes|=n,null!==a&&(a.childLanes|=n)):null!==a&&(a.childLanes&n)!==n&&(a.childLanes|=n),e===t)break;e=e.return}}function Ir(e,n){Er=e,wr=Pr=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&n)&&(bi=!0),e.firstContext=null)}function Mr(e){var n=e._currentValue;if(wr!==e)if(e={context:e,memoizedValue:n,next:null},null===Pr){if(null===Er)throw Error(r(308));Pr=e,Er.dependencies={lanes:0,firstContext:e}}else Pr=Pr.next=e;return n}var Dr=null;function Ar(e){null===Dr?Dr=[e]:Dr.push(e)}function Or(e,n,t,a){var o=n.interleaved;return null===o?(t.next=t,Ar(n)):(t.next=o.next,o.next=t),n.interleaved=t,Tr(e,a)}function Tr(e,n){e.lanes|=n;var t=e.alternate;for(null!==t&&(t.lanes|=n),t=e,e=e.return;null!==e;)e.childLanes|=n,null!==(t=e.alternate)&&(t.childLanes|=n),t=e,e=e.return;return 3===t.tag?t.stateNode:null}var Br=!1;function zr(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Fr(e,n){e=e.updateQueue,n.updateQueue===e&&(n.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Nr(e,n){return{eventTime:e,lane:n,tag:0,payload:null,callback:null,next:null}}function Gr(e,n,t){var a=e.updateQueue;if(null===a)return null;if(a=a.shared,2&Rl){var o=a.pending;return null===o?n.next=n:(n.next=o.next,o.next=n),a.pending=n,Tr(e,t)}return null===(o=a.interleaved)?(n.next=n,Ar(a)):(n.next=o.next,o.next=n),a.interleaved=n,Tr(e,t)}function qr(e,n,t){if(null!==(n=n.updateQueue)&&(n=n.shared,4194240&t)){var a=n.lanes;t|=a&=e.pendingLanes,n.lanes=t,bn(e,t)}}function Ur(e,n){var t=e.updateQueue,a=e.alternate;if(null!==a&&t===(a=a.updateQueue)){var o=null,r=null;if(null!==(t=t.firstBaseUpdate)){do{var c={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};null===r?o=r=c:r=r.next=c,t=t.next}while(null!==t);null===r?o=r=n:r=r.next=n}else o=r=n;return t={baseState:a.baseState,firstBaseUpdate:o,lastBaseUpdate:r,shared:a.shared,effects:a.effects},void(e.updateQueue=t)}null===(e=t.lastBaseUpdate)?t.firstBaseUpdate=n:e.next=n,t.lastBaseUpdate=n}function Wr(e,n,t,a){var o=e.updateQueue;Br=!1;var r=o.firstBaseUpdate,c=o.lastBaseUpdate,i=o.shared.pending;if(null!==i){o.shared.pending=null;var l=i,s=l.next;l.next=null,null===c?r=s:c.next=s,c=l;var u=e.alternate;null!==u&&(i=(u=u.updateQueue).lastBaseUpdate)!==c&&(null===i?u.firstBaseUpdate=s:i.next=s,u.lastBaseUpdate=l)}if(null!==r){var d=o.baseState;for(c=0,u=s=l=null,i=r;;){var p=i.lane,f=i.eventTime;if((a&p)===p){null!==u&&(u=u.next={eventTime:f,lane:0,tag:i.tag,payload:i.payload,callback:i.callback,next:null});e:{var m=e,_=i;switch(p=n,f=t,_.tag){case 1:if("function"==typeof(m=_.payload)){d=m.call(f,d,p);break e}d=m;break e;case 3:m.flags=-65537&m.flags|128;case 0:if(null==(p="function"==typeof(m=_.payload)?m.call(f,d,p):m))break e;d=z({},d,p);break e;case 2:Br=!0}}null!==i.callback&&0!==i.lane&&(e.flags|=64,null===(p=o.effects)?o.effects=[i]:p.push(i))}else f={eventTime:f,lane:p,tag:i.tag,payload:i.payload,callback:i.callback,next:null},null===u?(s=u=f,l=d):u=u.next=f,c|=p;if(null===(i=i.next)){if(null===(i=o.shared.pending))break;i=(p=i).next,p.next=null,o.lastBaseUpdate=p,o.shared.pending=null}}if(null===u&&(l=d),o.baseState=l,o.firstBaseUpdate=s,o.lastBaseUpdate=u,null!==(n=o.shared.interleaved)){o=n;do{c|=o.lane,o=o.next}while(o!==n)}else null===r&&(o.shared.lanes=0);Bl|=c,e.lanes=c,e.memoizedState=d}}function Vr(e,n,t){if(e=n.effects,n.effects=null,null!==e)for(n=0;n<e.length;n++){var a=e[n],o=a.callback;if(null!==o){if(a.callback=null,a=t,"function"!=typeof o)throw Error(r(191,o));o.call(a)}}}var Hr={},jr=Po(Hr),Kr=Po(Hr),$r=Po(Hr);function Yr(e){if(e===Hr)throw Error(r(174));return e}function Xr(e,n){switch(Co($r,n),Co(Kr,e),Co(jr,Hr),e=n.nodeType){case 9:case 11:n=(n=n.documentElement)?n.namespaceURI:le(null,"");break;default:n=le(n=(e=8===e?n.parentNode:n).namespaceURI||null,e=e.tagName)}wo(jr),Co(jr,n)}function Zr(){wo(jr),wo(Kr),wo($r)}function Qr(e){Yr($r.current);var n=Yr(jr.current),t=le(n,e.type);n!==t&&(Co(Kr,e),Co(jr,t))}function Jr(e){Kr.current===e&&(wo(jr),wo(Kr))}var ec=Po(0);function nc(e){for(var n=e;null!==n;){if(13===n.tag){var t=n.memoizedState;if(null!==t&&(null===(t=t.dehydrated)||"$?"===t.data||"$!"===t.data))return n}else if(19===n.tag&&void 0!==n.memoizedProps.revealOrder){if(128&n.flags)return n}else if(null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break;for(;null===n.sibling;){if(null===n.return||n.return===e)return null;n=n.return}n.sibling.return=n.return,n=n.sibling}return null}var tc=[];function ac(){for(var e=0;e<tc.length;e++)tc[e]._workInProgressVersionPrimary=null;tc.length=0}var oc=y.ReactCurrentDispatcher,rc=y.ReactCurrentBatchConfig,cc=0,ic=null,lc=null,sc=null,uc=!1,dc=!1,pc=0,fc=0;function mc(){throw Error(r(321))}function _c(e,n){if(null===n)return!1;for(var t=0;t<n.length&&t<e.length;t++)if(!ia(e[t],n[t]))return!1;return!0}function gc(e,n,t,a,o,c){if(cc=c,ic=n,n.memoizedState=null,n.updateQueue=null,n.lanes=0,oc.current=null===e||null===e.memoizedState?Jc:ei,e=t(a,o),dc){c=0;do{if(dc=!1,pc=0,25<=c)throw Error(r(301));c+=1,sc=lc=null,n.updateQueue=null,oc.current=ni,e=t(a,o)}while(dc)}if(oc.current=Qc,n=null!==lc&&null!==lc.next,cc=0,sc=lc=ic=null,uc=!1,n)throw Error(r(300));return e}function hc(){var e=0!==pc;return pc=0,e}function vc(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===sc?ic.memoizedState=sc=e:sc=sc.next=e,sc}function bc(){if(null===lc){var e=ic.alternate;e=null!==e?e.memoizedState:null}else e=lc.next;var n=null===sc?ic.memoizedState:sc.next;if(null!==n)sc=n,lc=e;else{if(null===e)throw Error(r(310));e={memoizedState:(lc=e).memoizedState,baseState:lc.baseState,baseQueue:lc.baseQueue,queue:lc.queue,next:null},null===sc?ic.memoizedState=sc=e:sc=sc.next=e}return sc}function yc(e,n){return"function"==typeof n?n(e):n}function kc(e){var n=bc(),t=n.queue;if(null===t)throw Error(r(311));t.lastRenderedReducer=e;var a=lc,o=a.baseQueue,c=t.pending;if(null!==c){if(null!==o){var i=o.next;o.next=c.next,c.next=i}a.baseQueue=o=c,t.pending=null}if(null!==o){c=o.next,a=a.baseState;var l=i=null,s=null,u=c;do{var d=u.lane;if((cc&d)===d)null!==s&&(s=s.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),a=u.hasEagerState?u.eagerState:e(a,u.action);else{var p={lane:d,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};null===s?(l=s=p,i=a):s=s.next=p,ic.lanes|=d,Bl|=d}u=u.next}while(null!==u&&u!==c);null===s?i=a:s.next=l,ia(a,n.memoizedState)||(bi=!0),n.memoizedState=a,n.baseState=i,n.baseQueue=s,t.lastRenderedState=a}if(null!==(e=t.interleaved)){o=e;do{c=o.lane,ic.lanes|=c,Bl|=c,o=o.next}while(o!==e)}else null===o&&(t.lanes=0);return[n.memoizedState,t.dispatch]}function Sc(e){var n=bc(),t=n.queue;if(null===t)throw Error(r(311));t.lastRenderedReducer=e;var a=t.dispatch,o=t.pending,c=n.memoizedState;if(null!==o){t.pending=null;var i=o=o.next;do{c=e(c,i.action),i=i.next}while(i!==o);ia(c,n.memoizedState)||(bi=!0),n.memoizedState=c,null===n.baseQueue&&(n.baseState=c),t.lastRenderedState=c}return[c,a]}function xc(){}function Ec(e,n){var t=ic,a=bc(),o=n(),c=!ia(a.memoizedState,o);if(c&&(a.memoizedState=o,bi=!0),a=a.queue,Bc(Cc.bind(null,t,a,e),[e]),a.getSnapshot!==n||c||null!==sc&&1&sc.memoizedState.tag){if(t.flags|=2048,Mc(9,wc.bind(null,t,a,o,n),void 0,null),null===Ll)throw Error(r(349));30&cc||Pc(t,n,o)}return o}function Pc(e,n,t){e.flags|=16384,e={getSnapshot:n,value:t},null===(n=ic.updateQueue)?(n={lastEffect:null,stores:null},ic.updateQueue=n,n.stores=[e]):null===(t=n.stores)?n.stores=[e]:t.push(e)}function wc(e,n,t,a){n.value=t,n.getSnapshot=a,Rc(n)&&Lc(e)}function Cc(e,n,t){return t(function(){Rc(n)&&Lc(e)})}function Rc(e){var n=e.getSnapshot;e=e.value;try{var t=n();return!ia(e,t)}catch(e){return!0}}function Lc(e){var n=Tr(e,1);null!==n&&ts(n,e,1,-1)}function Ic(e){var n=vc();return"function"==typeof e&&(e=e()),n.memoizedState=n.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:yc,lastRenderedState:e},n.queue=e,e=e.dispatch=$c.bind(null,ic,e),[n.memoizedState,e]}function Mc(e,n,t,a){return e={tag:e,create:n,destroy:t,deps:a,next:null},null===(n=ic.updateQueue)?(n={lastEffect:null,stores:null},ic.updateQueue=n,n.lastEffect=e.next=e):null===(t=n.lastEffect)?n.lastEffect=e.next=e:(a=t.next,t.next=e,e.next=a,n.lastEffect=e),e}function Dc(){return bc().memoizedState}function Ac(e,n,t,a){var o=vc();ic.flags|=e,o.memoizedState=Mc(1|n,t,void 0,void 0===a?null:a)}function Oc(e,n,t,a){var o=bc();a=void 0===a?null:a;var r=void 0;if(null!==lc){var c=lc.memoizedState;if(r=c.destroy,null!==a&&_c(a,c.deps))return void(o.memoizedState=Mc(n,t,r,a))}ic.flags|=e,o.memoizedState=Mc(1|n,t,r,a)}function Tc(e,n){return Ac(8390656,8,e,n)}function Bc(e,n){return Oc(2048,8,e,n)}function zc(e,n){return Oc(4,2,e,n)}function Fc(e,n){return Oc(4,4,e,n)}function Nc(e,n){return"function"==typeof n?(e=e(),n(e),function(){n(null)}):null!=n?(e=e(),n.current=e,function(){n.current=null}):void 0}function Gc(e,n,t){return t=null!=t?t.concat([e]):null,Oc(4,4,Nc.bind(null,n,e),t)}function qc(){}function Uc(e,n){var t=bc();n=void 0===n?null:n;var a=t.memoizedState;return null!==a&&null!==n&&_c(n,a[1])?a[0]:(t.memoizedState=[e,n],e)}function Wc(e,n){var t=bc();n=void 0===n?null:n;var a=t.memoizedState;return null!==a&&null!==n&&_c(n,a[1])?a[0]:(e=e(),t.memoizedState=[e,n],e)}function Vc(e,n,t){return 21&cc?(ia(t,n)||(t=gn(),ic.lanes|=t,Bl|=t,e.baseState=!0),n):(e.baseState&&(e.baseState=!1,bi=!0),e.memoizedState=t)}function Hc(e,n){var t=yn;yn=0!==t&&4>t?t:4,e(!0);var a=rc.transition;rc.transition={};try{e(!1),n()}finally{yn=t,rc.transition=a}}function jc(){return bc().memoizedState}function Kc(e,n,t){var a=ns(e);t={lane:a,action:t,hasEagerState:!1,eagerState:null,next:null},Yc(e)?Xc(n,t):null!==(t=Or(e,n,t,a))&&(ts(t,e,a,es()),Zc(t,n,a))}function $c(e,n,t){var a=ns(e),o={lane:a,action:t,hasEagerState:!1,eagerState:null,next:null};if(Yc(e))Xc(n,o);else{var r=e.alternate;if(0===e.lanes&&(null===r||0===r.lanes)&&null!==(r=n.lastRenderedReducer))try{var c=n.lastRenderedState,i=r(c,t);if(o.hasEagerState=!0,o.eagerState=i,ia(i,c)){var l=n.interleaved;return null===l?(o.next=o,Ar(n)):(o.next=l.next,l.next=o),void(n.interleaved=o)}}catch(e){}null!==(t=Or(e,n,o,a))&&(ts(t,e,a,o=es()),Zc(t,n,a))}}function Yc(e){var n=e.alternate;return e===ic||null!==n&&n===ic}function Xc(e,n){dc=uc=!0;var t=e.pending;null===t?n.next=n:(n.next=t.next,t.next=n),e.pending=n}function Zc(e,n,t){if(4194240&t){var a=n.lanes;t|=a&=e.pendingLanes,n.lanes=t,bn(e,t)}}var Qc={readContext:Mr,useCallback:mc,useContext:mc,useEffect:mc,useImperativeHandle:mc,useInsertionEffect:mc,useLayoutEffect:mc,useMemo:mc,useReducer:mc,useRef:mc,useState:mc,useDebugValue:mc,useDeferredValue:mc,useTransition:mc,useMutableSource:mc,useSyncExternalStore:mc,useId:mc,unstable_isNewReconciler:!1},Jc={readContext:Mr,useCallback:function(e,n){return vc().memoizedState=[e,void 0===n?null:n],e},useContext:Mr,useEffect:Tc,useImperativeHandle:function(e,n,t){return t=null!=t?t.concat([e]):null,Ac(4194308,4,Nc.bind(null,n,e),t)},useLayoutEffect:function(e,n){return Ac(4194308,4,e,n)},useInsertionEffect:function(e,n){return Ac(4,2,e,n)},useMemo:function(e,n){var t=vc();return n=void 0===n?null:n,e=e(),t.memoizedState=[e,n],e},useReducer:function(e,n,t){var a=vc();return n=void 0!==t?t(n):n,a.memoizedState=a.baseState=n,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:n},a.queue=e,e=e.dispatch=Kc.bind(null,ic,e),[a.memoizedState,e]},useRef:function(e){return e={current:e},vc().memoizedState=e},useState:Ic,useDebugValue:qc,useDeferredValue:function(e){return vc().memoizedState=e},useTransition:function(){var e=Ic(!1),n=e[0];return e=Hc.bind(null,e[1]),vc().memoizedState=e,[n,e]},useMutableSource:function(){},useSyncExternalStore:function(e,n,t){var a=ic,o=vc();if(rr){if(void 0===t)throw Error(r(407));t=t()}else{if(t=n(),null===Ll)throw Error(r(349));30&cc||Pc(a,n,t)}o.memoizedState=t;var c={value:t,getSnapshot:n};return o.queue=c,Tc(Cc.bind(null,a,c,e),[e]),a.flags|=2048,Mc(9,wc.bind(null,a,c,t,n),void 0,null),t},useId:function(){var e=vc(),n=Ll.identifierPrefix;if(rr){var t=Qo;n=":"+n+"R"+(t=(Zo&~(1<<32-cn(Zo)-1)).toString(32)+t),0<(t=pc++)&&(n+="H"+t.toString(32)),n+=":"}else n=":"+n+"r"+(t=fc++).toString(32)+":";return e.memoizedState=n},unstable_isNewReconciler:!1},ei={readContext:Mr,useCallback:Uc,useContext:Mr,useEffect:Bc,useImperativeHandle:Gc,useInsertionEffect:zc,useLayoutEffect:Fc,useMemo:Wc,useReducer:kc,useRef:Dc,useState:function(){return kc(yc)},useDebugValue:qc,useDeferredValue:function(e){return Vc(bc(),lc.memoizedState,e)},useTransition:function(){return[kc(yc)[0],bc().memoizedState]},useMutableSource:xc,useSyncExternalStore:Ec,useId:jc,unstable_isNewReconciler:!1},ni={readContext:Mr,useCallback:Uc,useContext:Mr,useEffect:Bc,useImperativeHandle:Gc,useInsertionEffect:zc,useLayoutEffect:Fc,useMemo:Wc,useReducer:Sc,useRef:Dc,useState:function(){return Sc(yc)},useDebugValue:qc,useDeferredValue:function(e){var n=bc();return null===lc?n.memoizedState=e:Vc(n,lc.memoizedState,e)},useTransition:function(){return[Sc(yc)[0],bc().memoizedState]},useMutableSource:xc,useSyncExternalStore:Ec,useId:jc,unstable_isNewReconciler:!1};function ti(e,n){if(e&&e.defaultProps){for(var t in n=z({},n),e=e.defaultProps)void 0===n[t]&&(n[t]=e[t]);return n}return n}function ai(e,n,t,a){t=null==(t=t(a,n=e.memoizedState))?n:z({},n,t),e.memoizedState=t,0===e.lanes&&(e.updateQueue.baseState=t)}var oi={isMounted:function(e){return!!(e=e._reactInternals)&&Ue(e)===e},enqueueSetState:function(e,n,t){e=e._reactInternals;var a=es(),o=ns(e),r=Nr(a,o);r.payload=n,null!=t&&(r.callback=t),null!==(n=Gr(e,r,o))&&(ts(n,e,o,a),qr(n,e,o))},enqueueReplaceState:function(e,n,t){e=e._reactInternals;var a=es(),o=ns(e),r=Nr(a,o);r.tag=1,r.payload=n,null!=t&&(r.callback=t),null!==(n=Gr(e,r,o))&&(ts(n,e,o,a),qr(n,e,o))},enqueueForceUpdate:function(e,n){e=e._reactInternals;var t=es(),a=ns(e),o=Nr(t,a);o.tag=2,null!=n&&(o.callback=n),null!==(n=Gr(e,o,a))&&(ts(n,e,a,t),qr(n,e,a))}};function ri(e,n,t,a,o,r,c){return"function"==typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(a,r,c):!(n.prototype&&n.prototype.isPureReactComponent&&la(t,a)&&la(o,r))}function ci(e,n,t){var a=!1,o=Ro,r=n.contextType;return"object"==typeof r&&null!==r?r=Mr(r):(o=Ao(n)?Mo:Lo.current,r=(a=null!=(a=n.contextTypes))?Do(e,o):Ro),n=new n(t,r),e.memoizedState=null!==n.state&&void 0!==n.state?n.state:null,n.updater=oi,e.stateNode=n,n._reactInternals=e,a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=o,e.__reactInternalMemoizedMaskedChildContext=r),n}function ii(e,n,t,a){e=n.state,"function"==typeof n.componentWillReceiveProps&&n.componentWillReceiveProps(t,a),"function"==typeof n.UNSAFE_componentWillReceiveProps&&n.UNSAFE_componentWillReceiveProps(t,a),n.state!==e&&oi.enqueueReplaceState(n,n.state,null)}function li(e,n,t,a){var o=e.stateNode;o.props=t,o.state=e.memoizedState,o.refs={},zr(e);var r=n.contextType;"object"==typeof r&&null!==r?o.context=Mr(r):(r=Ao(n)?Mo:Lo.current,o.context=Do(e,r)),o.state=e.memoizedState,"function"==typeof(r=n.getDerivedStateFromProps)&&(ai(e,n,r,t),o.state=e.memoizedState),"function"==typeof n.getDerivedStateFromProps||"function"==typeof o.getSnapshotBeforeUpdate||"function"!=typeof o.UNSAFE_componentWillMount&&"function"!=typeof o.componentWillMount||(n=o.state,"function"==typeof o.componentWillMount&&o.componentWillMount(),"function"==typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount(),n!==o.state&&oi.enqueueReplaceState(o,o.state,null),Wr(e,t,o,a),o.state=e.memoizedState),"function"==typeof o.componentDidMount&&(e.flags|=4194308)}function si(e,n){try{var t="",a=n;do{t+=q(a),a=a.return}while(a);var o=t}catch(e){o="\nError generating stack: "+e.message+"\n"+e.stack}return{value:e,source:n,stack:o,digest:null}}function ui(e,n,t){return{value:e,source:null,stack:null!=t?t:null,digest:null!=n?n:null}}function di(e,n){try{console.error(n.value)}catch(e){setTimeout(function(){throw e})}}var pi="function"==typeof WeakMap?WeakMap:Map;function fi(e,n,t){(t=Nr(-1,t)).tag=3,t.payload={element:null};var a=n.value;return t.callback=function(){Vl||(Vl=!0,Hl=a),di(0,n)},t}function mi(e,n,t){(t=Nr(-1,t)).tag=3;var a=e.type.getDerivedStateFromError;if("function"==typeof a){var o=n.value;t.payload=function(){return a(o)},t.callback=function(){di(0,n)}}var r=e.stateNode;return null!==r&&"function"==typeof r.componentDidCatch&&(t.callback=function(){di(0,n),"function"!=typeof a&&(null===jl?jl=new Set([this]):jl.add(this));var e=n.stack;this.componentDidCatch(n.value,{componentStack:null!==e?e:""})}),t}function _i(e,n,t){var a=e.pingCache;if(null===a){a=e.pingCache=new pi;var o=new Set;a.set(n,o)}else void 0===(o=a.get(n))&&(o=new Set,a.set(n,o));o.has(t)||(o.add(t),e=Ps.bind(null,e,n,t),n.then(e,e))}function gi(e){do{var n;if((n=13===e.tag)&&(n=null===(n=e.memoizedState)||null!==n.dehydrated),n)return e;e=e.return}while(null!==e);return null}function hi(e,n,t,a,o){return 1&e.mode?(e.flags|=65536,e.lanes=o,e):(e===n?e.flags|=65536:(e.flags|=128,t.flags|=131072,t.flags&=-52805,1===t.tag&&(null===t.alternate?t.tag=17:((n=Nr(-1,1)).tag=2,Gr(t,n,1))),t.lanes|=1),e)}var vi=y.ReactCurrentOwner,bi=!1;function yi(e,n,t,a){n.child=null===e?Sr(n,null,t,a):kr(n,e.child,t,a)}function ki(e,n,t,a,o){t=t.render;var r=n.ref;return Ir(n,o),a=gc(e,n,t,a,r,o),t=hc(),null===e||bi?(rr&&t&&nr(n),n.flags|=1,yi(e,n,a,o),n.child):(n.updateQueue=e.updateQueue,n.flags&=-2053,e.lanes&=~o,Vi(e,n,o))}function Si(e,n,t,a,o){if(null===e){var r=t.type;return"function"!=typeof r||Ds(r)||void 0!==r.defaultProps||null!==t.compare||void 0!==t.defaultProps?((e=Os(t.type,null,a,n,n.mode,o)).ref=n.ref,e.return=n,n.child=e):(n.tag=15,n.type=r,xi(e,n,r,a,o))}if(r=e.child,0===(e.lanes&o)){var c=r.memoizedProps;if((t=null!==(t=t.compare)?t:la)(c,a)&&e.ref===n.ref)return Vi(e,n,o)}return n.flags|=1,(e=As(r,a)).ref=n.ref,e.return=n,n.child=e}function xi(e,n,t,a,o){if(null!==e){var r=e.memoizedProps;if(la(r,a)&&e.ref===n.ref){if(bi=!1,n.pendingProps=a=r,0===(e.lanes&o))return n.lanes=e.lanes,Vi(e,n,o);131072&e.flags&&(bi=!0)}}return wi(e,n,t,a,o)}function Ei(e,n,t){var a=n.pendingProps,o=a.children,r=null!==e?e.memoizedState:null;if("hidden"===a.mode)if(1&n.mode){if(!(1073741824&t))return e=null!==r?r.baseLanes|t:t,n.lanes=n.childLanes=1073741824,n.memoizedState={baseLanes:e,cachePool:null,transitions:null},n.updateQueue=null,Co(Al,Dl),Dl|=e,null;n.memoizedState={baseLanes:0,cachePool:null,transitions:null},a=null!==r?r.baseLanes:t,Co(Al,Dl),Dl|=a}else n.memoizedState={baseLanes:0,cachePool:null,transitions:null},Co(Al,Dl),Dl|=t;else null!==r?(a=r.baseLanes|t,n.memoizedState=null):a=t,Co(Al,Dl),Dl|=a;return yi(e,n,o,t),n.child}function Pi(e,n){var t=n.ref;(null===e&&null!==t||null!==e&&e.ref!==t)&&(n.flags|=512,n.flags|=2097152)}function wi(e,n,t,a,o){var r=Ao(t)?Mo:Lo.current;return r=Do(n,r),Ir(n,o),t=gc(e,n,t,a,r,o),a=hc(),null===e||bi?(rr&&a&&nr(n),n.flags|=1,yi(e,n,t,o),n.child):(n.updateQueue=e.updateQueue,n.flags&=-2053,e.lanes&=~o,Vi(e,n,o))}function Ci(e,n,t,a,o){if(Ao(t)){var r=!0;zo(n)}else r=!1;if(Ir(n,o),null===n.stateNode)Wi(e,n),ci(n,t,a),li(n,t,a,o),a=!0;else if(null===e){var c=n.stateNode,i=n.memoizedProps;c.props=i;var l=c.context,s=t.contextType;s="object"==typeof s&&null!==s?Mr(s):Do(n,s=Ao(t)?Mo:Lo.current);var u=t.getDerivedStateFromProps,d="function"==typeof u||"function"==typeof c.getSnapshotBeforeUpdate;d||"function"!=typeof c.UNSAFE_componentWillReceiveProps&&"function"!=typeof c.componentWillReceiveProps||(i!==a||l!==s)&&ii(n,c,a,s),Br=!1;var p=n.memoizedState;c.state=p,Wr(n,a,c,o),l=n.memoizedState,i!==a||p!==l||Io.current||Br?("function"==typeof u&&(ai(n,t,u,a),l=n.memoizedState),(i=Br||ri(n,t,i,a,p,l,s))?(d||"function"!=typeof c.UNSAFE_componentWillMount&&"function"!=typeof c.componentWillMount||("function"==typeof c.componentWillMount&&c.componentWillMount(),"function"==typeof c.UNSAFE_componentWillMount&&c.UNSAFE_componentWillMount()),"function"==typeof c.componentDidMount&&(n.flags|=4194308)):("function"==typeof c.componentDidMount&&(n.flags|=4194308),n.memoizedProps=a,n.memoizedState=l),c.props=a,c.state=l,c.context=s,a=i):("function"==typeof c.componentDidMount&&(n.flags|=4194308),a=!1)}else{c=n.stateNode,Fr(e,n),i=n.memoizedProps,s=n.type===n.elementType?i:ti(n.type,i),c.props=s,d=n.pendingProps,p=c.context,l="object"==typeof(l=t.contextType)&&null!==l?Mr(l):Do(n,l=Ao(t)?Mo:Lo.current);var f=t.getDerivedStateFromProps;(u="function"==typeof f||"function"==typeof c.getSnapshotBeforeUpdate)||"function"!=typeof c.UNSAFE_componentWillReceiveProps&&"function"!=typeof c.componentWillReceiveProps||(i!==d||p!==l)&&ii(n,c,a,l),Br=!1,p=n.memoizedState,c.state=p,Wr(n,a,c,o);var m=n.memoizedState;i!==d||p!==m||Io.current||Br?("function"==typeof f&&(ai(n,t,f,a),m=n.memoizedState),(s=Br||ri(n,t,s,a,p,m,l)||!1)?(u||"function"!=typeof c.UNSAFE_componentWillUpdate&&"function"!=typeof c.componentWillUpdate||("function"==typeof c.componentWillUpdate&&c.componentWillUpdate(a,m,l),"function"==typeof c.UNSAFE_componentWillUpdate&&c.UNSAFE_componentWillUpdate(a,m,l)),"function"==typeof c.componentDidUpdate&&(n.flags|=4),"function"==typeof c.getSnapshotBeforeUpdate&&(n.flags|=1024)):("function"!=typeof c.componentDidUpdate||i===e.memoizedProps&&p===e.memoizedState||(n.flags|=4),"function"!=typeof c.getSnapshotBeforeUpdate||i===e.memoizedProps&&p===e.memoizedState||(n.flags|=1024),n.memoizedProps=a,n.memoizedState=m),c.props=a,c.state=m,c.context=l,a=s):("function"!=typeof c.componentDidUpdate||i===e.memoizedProps&&p===e.memoizedState||(n.flags|=4),"function"!=typeof c.getSnapshotBeforeUpdate||i===e.memoizedProps&&p===e.memoizedState||(n.flags|=1024),a=!1)}return Ri(e,n,t,a,r,o)}function Ri(e,n,t,a,o,r){Pi(e,n);var c=!!(128&n.flags);if(!a&&!c)return o&&Fo(n,t,!1),Vi(e,n,r);a=n.stateNode,vi.current=n;var i=c&&"function"!=typeof t.getDerivedStateFromError?null:a.render();return n.flags|=1,null!==e&&c?(n.child=kr(n,e.child,null,r),n.child=kr(n,null,i,r)):yi(e,n,i,r),n.memoizedState=a.state,o&&Fo(n,t,!0),n.child}function Li(e){var n=e.stateNode;n.pendingContext?To(0,n.pendingContext,n.pendingContext!==n.context):n.context&&To(0,n.context,!1),Xr(e,n.containerInfo)}function Ii(e,n,t,a,o){return mr(),_r(o),n.flags|=256,yi(e,n,t,a),n.child}var Mi,Di,Ai,Oi,Ti={dehydrated:null,treeContext:null,retryLane:0};function Bi(e){return{baseLanes:e,cachePool:null,transitions:null}}function zi(e,n,t){var a,o=n.pendingProps,c=ec.current,i=!1,l=!!(128&n.flags);if((a=l)||(a=(null===e||null!==e.memoizedState)&&!!(2&c)),a?(i=!0,n.flags&=-129):null!==e&&null===e.memoizedState||(c|=1),Co(ec,1&c),null===e)return ur(n),null!==(e=n.memoizedState)&&null!==(e=e.dehydrated)?(1&n.mode?"$!"===e.data?n.lanes=8:n.lanes=1073741824:n.lanes=1,null):(l=o.children,e=o.fallback,i?(o=n.mode,i=n.child,l={mode:"hidden",children:l},1&o||null===i?i=Bs(l,o,0,null):(i.childLanes=0,i.pendingProps=l),e=Ts(e,o,t,null),i.return=n,e.return=n,i.sibling=e,n.child=i,n.child.memoizedState=Bi(t),n.memoizedState=Ti,e):Fi(n,l));if(null!==(c=e.memoizedState)&&null!==(a=c.dehydrated))return function(e,n,t,a,o,c,i){if(t)return 256&n.flags?(n.flags&=-257,Ni(e,n,i,a=ui(Error(r(422))))):null!==n.memoizedState?(n.child=e.child,n.flags|=128,null):(c=a.fallback,o=n.mode,a=Bs({mode:"visible",children:a.children},o,0,null),(c=Ts(c,o,i,null)).flags|=2,a.return=n,c.return=n,a.sibling=c,n.child=a,1&n.mode&&kr(n,e.child,null,i),n.child.memoizedState=Bi(i),n.memoizedState=Ti,c);if(!(1&n.mode))return Ni(e,n,i,null);if("$!"===o.data){if(a=o.nextSibling&&o.nextSibling.dataset)var l=a.dgst;return a=l,Ni(e,n,i,a=ui(c=Error(r(419)),a,void 0))}if(l=0!==(i&e.childLanes),bi||l){if(null!==(a=Ll)){switch(i&-i){case 4:o=2;break;case 16:o=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:o=32;break;case 536870912:o=268435456;break;default:o=0}0!==(o=0!==(o&(a.suspendedLanes|i))?0:o)&&o!==c.retryLane&&(c.retryLane=o,Tr(e,o),ts(a,e,o,-1))}return _s(),Ni(e,n,i,a=ui(Error(r(421))))}return"$?"===o.data?(n.flags|=128,n.child=e.child,n=Cs.bind(null,e),o._reactRetry=n,null):(e=c.treeContext,or=so(o.nextSibling),ar=n,rr=!0,cr=null,null!==e&&($o[Yo++]=Zo,$o[Yo++]=Qo,$o[Yo++]=Xo,Zo=e.id,Qo=e.overflow,Xo=n),(n=Fi(n,a.children)).flags|=4096,n)}(e,n,l,o,a,c,t);if(i){i=o.fallback,l=n.mode,a=(c=e.child).sibling;var s={mode:"hidden",children:o.children};return 1&l||n.child===c?(o=As(c,s)).subtreeFlags=14680064&c.subtreeFlags:((o=n.child).childLanes=0,o.pendingProps=s,n.deletions=null),null!==a?i=As(a,i):(i=Ts(i,l,t,null)).flags|=2,i.return=n,o.return=n,o.sibling=i,n.child=o,o=i,i=n.child,l=null===(l=e.child.memoizedState)?Bi(t):{baseLanes:l.baseLanes|t,cachePool:null,transitions:l.transitions},i.memoizedState=l,i.childLanes=e.childLanes&~t,n.memoizedState=Ti,o}return e=(i=e.child).sibling,o=As(i,{mode:"visible",children:o.children}),!(1&n.mode)&&(o.lanes=t),o.return=n,o.sibling=null,null!==e&&(null===(t=n.deletions)?(n.deletions=[e],n.flags|=16):t.push(e)),n.child=o,n.memoizedState=null,o}function Fi(e,n){return(n=Bs({mode:"visible",children:n},e.mode,0,null)).return=e,e.child=n}function Ni(e,n,t,a){return null!==a&&_r(a),kr(n,e.child,null,t),(e=Fi(n,n.pendingProps.children)).flags|=2,n.memoizedState=null,e}function Gi(e,n,t){e.lanes|=n;var a=e.alternate;null!==a&&(a.lanes|=n),Lr(e.return,n,t)}function qi(e,n,t,a,o){var r=e.memoizedState;null===r?e.memoizedState={isBackwards:n,rendering:null,renderingStartTime:0,last:a,tail:t,tailMode:o}:(r.isBackwards=n,r.rendering=null,r.renderingStartTime=0,r.last=a,r.tail=t,r.tailMode=o)}function Ui(e,n,t){var a=n.pendingProps,o=a.revealOrder,r=a.tail;if(yi(e,n,a.children,t),2&(a=ec.current))a=1&a|2,n.flags|=128;else{if(null!==e&&128&e.flags)e:for(e=n.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Gi(e,t,n);else if(19===e.tag)Gi(e,t,n);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===n)break e;for(;null===e.sibling;){if(null===e.return||e.return===n)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}a&=1}if(Co(ec,a),1&n.mode)switch(o){case"forwards":for(t=n.child,o=null;null!==t;)null!==(e=t.alternate)&&null===nc(e)&&(o=t),t=t.sibling;null===(t=o)?(o=n.child,n.child=null):(o=t.sibling,t.sibling=null),qi(n,!1,o,t,r);break;case"backwards":for(t=null,o=n.child,n.child=null;null!==o;){if(null!==(e=o.alternate)&&null===nc(e)){n.child=o;break}e=o.sibling,o.sibling=t,t=o,o=e}qi(n,!0,t,null,r);break;case"together":qi(n,!1,null,null,void 0);break;default:n.memoizedState=null}else n.memoizedState=null;return n.child}function Wi(e,n){!(1&n.mode)&&null!==e&&(e.alternate=null,n.alternate=null,n.flags|=2)}function Vi(e,n,t){if(null!==e&&(n.dependencies=e.dependencies),Bl|=n.lanes,0===(t&n.childLanes))return null;if(null!==e&&n.child!==e.child)throw Error(r(153));if(null!==n.child){for(t=As(e=n.child,e.pendingProps),n.child=t,t.return=n;null!==e.sibling;)e=e.sibling,(t=t.sibling=As(e,e.pendingProps)).return=n;t.sibling=null}return n.child}function Hi(e,n){if(!rr)switch(e.tailMode){case"hidden":n=e.tail;for(var t=null;null!==n;)null!==n.alternate&&(t=n),n=n.sibling;null===t?e.tail=null:t.sibling=null;break;case"collapsed":t=e.tail;for(var a=null;null!==t;)null!==t.alternate&&(a=t),t=t.sibling;null===a?n||null===e.tail?e.tail=null:e.tail.sibling=null:a.sibling=null}}function ji(e){var n=null!==e.alternate&&e.alternate.child===e.child,t=0,a=0;if(n)for(var o=e.child;null!==o;)t|=o.lanes|o.childLanes,a|=14680064&o.subtreeFlags,a|=14680064&o.flags,o.return=e,o=o.sibling;else for(o=e.child;null!==o;)t|=o.lanes|o.childLanes,a|=o.subtreeFlags,a|=o.flags,o.return=e,o=o.sibling;return e.subtreeFlags|=a,e.childLanes=t,n}function Ki(e,n,t){var a=n.pendingProps;switch(tr(n),n.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ji(n),null;case 1:case 17:return Ao(n.type)&&Oo(),ji(n),null;case 3:return a=n.stateNode,Zr(),wo(Io),wo(Lo),ac(),a.pendingContext&&(a.context=a.pendingContext,a.pendingContext=null),null!==e&&null!==e.child||(pr(n)?n.flags|=4:null===e||e.memoizedState.isDehydrated&&!(256&n.flags)||(n.flags|=1024,null!==cr&&(cs(cr),cr=null))),Di(e,n),ji(n),null;case 5:Jr(n);var o=Yr($r.current);if(t=n.type,null!==e&&null!=n.stateNode)Ai(e,n,t,a,o),e.ref!==n.ref&&(n.flags|=512,n.flags|=2097152);else{if(!a){if(null===n.stateNode)throw Error(r(166));return ji(n),null}if(e=Yr(jr.current),pr(n)){a=n.stateNode,t=n.type;var c=n.memoizedProps;switch(a[fo]=n,a[mo]=c,e=!!(1&n.mode),t){case"dialog":Na("cancel",a),Na("close",a);break;case"iframe":case"object":case"embed":Na("load",a);break;case"video":case"audio":for(o=0;o<Ta.length;o++)Na(Ta[o],a);break;case"source":Na("error",a);break;case"img":case"image":case"link":Na("error",a),Na("load",a);break;case"details":Na("toggle",a);break;case"input":X(a,c),Na("invalid",a);break;case"select":a._wrapperState={wasMultiple:!!c.multiple},Na("invalid",a);break;case"textarea":oe(a,c),Na("invalid",a)}for(var l in ve(t,c),o=null,c)if(c.hasOwnProperty(l)){var s=c[l];"children"===l?"string"==typeof s?a.textContent!==s&&(!0!==c.suppressHydrationWarning&&Qa(a.textContent,s,e),o=["children",s]):"number"==typeof s&&a.textContent!==""+s&&(!0!==c.suppressHydrationWarning&&Qa(a.textContent,s,e),o=["children",""+s]):i.hasOwnProperty(l)&&null!=s&&"onScroll"===l&&Na("scroll",a)}switch(t){case"input":j(a),J(a,c,!0);break;case"textarea":j(a),ce(a);break;case"select":case"option":break;default:"function"==typeof c.onClick&&(a.onclick=Ja)}a=o,n.updateQueue=a,null!==a&&(n.flags|=4)}else{l=9===o.nodeType?o:o.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=ie(t)),"http://www.w3.org/1999/xhtml"===e?"script"===t?((e=l.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"==typeof a.is?e=l.createElement(t,{is:a.is}):(e=l.createElement(t),"select"===t&&(l=e,a.multiple?l.multiple=!0:a.size&&(l.size=a.size))):e=l.createElementNS(e,t),e[fo]=n,e[mo]=a,Mi(e,n,!1,!1),n.stateNode=e;e:{switch(l=be(t,a),t){case"dialog":Na("cancel",e),Na("close",e),o=a;break;case"iframe":case"object":case"embed":Na("load",e),o=a;break;case"video":case"audio":for(o=0;o<Ta.length;o++)Na(Ta[o],e);o=a;break;case"source":Na("error",e),o=a;break;case"img":case"image":case"link":Na("error",e),Na("load",e),o=a;break;case"details":Na("toggle",e),o=a;break;case"input":X(e,a),o=Y(e,a),Na("invalid",e);break;case"option":default:o=a;break;case"select":e._wrapperState={wasMultiple:!!a.multiple},o=z({},a,{value:void 0}),Na("invalid",e);break;case"textarea":oe(e,a),o=ae(e,a),Na("invalid",e)}for(c in ve(t,o),s=o)if(s.hasOwnProperty(c)){var u=s[c];"style"===c?ge(e,u):"dangerouslySetInnerHTML"===c?null!=(u=u?u.__html:void 0)&&de(e,u):"children"===c?"string"==typeof u?("textarea"!==t||""!==u)&&pe(e,u):"number"==typeof u&&pe(e,""+u):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(i.hasOwnProperty(c)?null!=u&&"onScroll"===c&&Na("scroll",e):null!=u&&b(e,c,u,l))}switch(t){case"input":j(e),J(e,a,!1);break;case"textarea":j(e),ce(e);break;case"option":null!=a.value&&e.setAttribute("value",""+V(a.value));break;case"select":e.multiple=!!a.multiple,null!=(c=a.value)?te(e,!!a.multiple,c,!1):null!=a.defaultValue&&te(e,!!a.multiple,a.defaultValue,!0);break;default:"function"==typeof o.onClick&&(e.onclick=Ja)}switch(t){case"button":case"input":case"select":case"textarea":a=!!a.autoFocus;break e;case"img":a=!0;break e;default:a=!1}}a&&(n.flags|=4)}null!==n.ref&&(n.flags|=512,n.flags|=2097152)}return ji(n),null;case 6:if(e&&null!=n.stateNode)Oi(e,n,e.memoizedProps,a);else{if("string"!=typeof a&&null===n.stateNode)throw Error(r(166));if(t=Yr($r.current),Yr(jr.current),pr(n)){if(a=n.stateNode,t=n.memoizedProps,a[fo]=n,(c=a.nodeValue!==t)&&null!==(e=ar))switch(e.tag){case 3:Qa(a.nodeValue,t,!!(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Qa(a.nodeValue,t,!!(1&e.mode))}c&&(n.flags|=4)}else(a=(9===t.nodeType?t:t.ownerDocument).createTextNode(a))[fo]=n,n.stateNode=a}return ji(n),null;case 13:if(wo(ec),a=n.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(rr&&null!==or&&1&n.mode&&!(128&n.flags))fr(),mr(),n.flags|=98560,c=!1;else if(c=pr(n),null!==a&&null!==a.dehydrated){if(null===e){if(!c)throw Error(r(318));if(!(c=null!==(c=n.memoizedState)?c.dehydrated:null))throw Error(r(317));c[fo]=n}else mr(),!(128&n.flags)&&(n.memoizedState=null),n.flags|=4;ji(n),c=!1}else null!==cr&&(cs(cr),cr=null),c=!0;if(!c)return 65536&n.flags?n:null}return 128&n.flags?(n.lanes=t,n):((a=null!==a)!=(null!==e&&null!==e.memoizedState)&&a&&(n.child.flags|=8192,1&n.mode&&(null===e||1&ec.current?0===Ol&&(Ol=3):_s())),null!==n.updateQueue&&(n.flags|=4),ji(n),null);case 4:return Zr(),Di(e,n),null===e&&Ua(n.stateNode.containerInfo),ji(n),null;case 10:return Rr(n.type._context),ji(n),null;case 19:if(wo(ec),null===(c=n.memoizedState))return ji(n),null;if(a=!!(128&n.flags),null===(l=c.rendering))if(a)Hi(c,!1);else{if(0!==Ol||null!==e&&128&e.flags)for(e=n.child;null!==e;){if(null!==(l=nc(e))){for(n.flags|=128,Hi(c,!1),null!==(a=l.updateQueue)&&(n.updateQueue=a,n.flags|=4),n.subtreeFlags=0,a=t,t=n.child;null!==t;)e=a,(c=t).flags&=14680066,null===(l=c.alternate)?(c.childLanes=0,c.lanes=e,c.child=null,c.subtreeFlags=0,c.memoizedProps=null,c.memoizedState=null,c.updateQueue=null,c.dependencies=null,c.stateNode=null):(c.childLanes=l.childLanes,c.lanes=l.lanes,c.child=l.child,c.subtreeFlags=0,c.deletions=null,c.memoizedProps=l.memoizedProps,c.memoizedState=l.memoizedState,c.updateQueue=l.updateQueue,c.type=l.type,e=l.dependencies,c.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),t=t.sibling;return Co(ec,1&ec.current|2),n.child}e=e.sibling}null!==c.tail&&Ze()>Ul&&(n.flags|=128,a=!0,Hi(c,!1),n.lanes=4194304)}else{if(!a)if(null!==(e=nc(l))){if(n.flags|=128,a=!0,null!==(t=e.updateQueue)&&(n.updateQueue=t,n.flags|=4),Hi(c,!0),null===c.tail&&"hidden"===c.tailMode&&!l.alternate&&!rr)return ji(n),null}else 2*Ze()-c.renderingStartTime>Ul&&1073741824!==t&&(n.flags|=128,a=!0,Hi(c,!1),n.lanes=4194304);c.isBackwards?(l.sibling=n.child,n.child=l):(null!==(t=c.last)?t.sibling=l:n.child=l,c.last=l)}return null!==c.tail?(n=c.tail,c.rendering=n,c.tail=n.sibling,c.renderingStartTime=Ze(),n.sibling=null,t=ec.current,Co(ec,a?1&t|2:1&t),n):(ji(n),null);case 22:case 23:return ds(),a=null!==n.memoizedState,null!==e&&null!==e.memoizedState!==a&&(n.flags|=8192),a&&1&n.mode?!!(1073741824&Dl)&&(ji(n),6&n.subtreeFlags&&(n.flags|=8192)):ji(n),null;case 24:case 25:return null}throw Error(r(156,n.tag))}function $i(e,n){switch(tr(n),n.tag){case 1:return Ao(n.type)&&Oo(),65536&(e=n.flags)?(n.flags=-65537&e|128,n):null;case 3:return Zr(),wo(Io),wo(Lo),ac(),65536&(e=n.flags)&&!(128&e)?(n.flags=-65537&e|128,n):null;case 5:return Jr(n),null;case 13:if(wo(ec),null!==(e=n.memoizedState)&&null!==e.dehydrated){if(null===n.alternate)throw Error(r(340));mr()}return 65536&(e=n.flags)?(n.flags=-65537&e|128,n):null;case 19:return wo(ec),null;case 4:return Zr(),null;case 10:return Rr(n.type._context),null;case 22:case 23:return ds(),null;default:return null}}Mi=function(e,n){for(var t=n.child;null!==t;){if(5===t.tag||6===t.tag)e.appendChild(t.stateNode);else if(4!==t.tag&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===n)break;for(;null===t.sibling;){if(null===t.return||t.return===n)return;t=t.return}t.sibling.return=t.return,t=t.sibling}},Di=function(){},Ai=function(e,n,t,a){var o=e.memoizedProps;if(o!==a){e=n.stateNode,Yr(jr.current);var r,c=null;switch(t){case"input":o=Y(e,o),a=Y(e,a),c=[];break;case"select":o=z({},o,{value:void 0}),a=z({},a,{value:void 0}),c=[];break;case"textarea":o=ae(e,o),a=ae(e,a),c=[];break;default:"function"!=typeof o.onClick&&"function"==typeof a.onClick&&(e.onclick=Ja)}for(u in ve(t,a),t=null,o)if(!a.hasOwnProperty(u)&&o.hasOwnProperty(u)&&null!=o[u])if("style"===u){var l=o[u];for(r in l)l.hasOwnProperty(r)&&(t||(t={}),t[r]="")}else"dangerouslySetInnerHTML"!==u&&"children"!==u&&"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&"autoFocus"!==u&&(i.hasOwnProperty(u)?c||(c=[]):(c=c||[]).push(u,null));for(u in a){var s=a[u];if(l=null!=o?o[u]:void 0,a.hasOwnProperty(u)&&s!==l&&(null!=s||null!=l))if("style"===u)if(l){for(r in l)!l.hasOwnProperty(r)||s&&s.hasOwnProperty(r)||(t||(t={}),t[r]="");for(r in s)s.hasOwnProperty(r)&&l[r]!==s[r]&&(t||(t={}),t[r]=s[r])}else t||(c||(c=[]),c.push(u,t)),t=s;else"dangerouslySetInnerHTML"===u?(s=s?s.__html:void 0,l=l?l.__html:void 0,null!=s&&l!==s&&(c=c||[]).push(u,s)):"children"===u?"string"!=typeof s&&"number"!=typeof s||(c=c||[]).push(u,""+s):"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&(i.hasOwnProperty(u)?(null!=s&&"onScroll"===u&&Na("scroll",e),c||l===s||(c=[])):(c=c||[]).push(u,s))}t&&(c=c||[]).push("style",t);var u=c;(n.updateQueue=u)&&(n.flags|=4)}},Oi=function(e,n,t,a){t!==a&&(n.flags|=4)};var Yi=!1,Xi=!1,Zi="function"==typeof WeakSet?WeakSet:Set,Qi=null;function Ji(e,n){var t=e.ref;if(null!==t)if("function"==typeof t)try{t(null)}catch(t){Es(e,n,t)}else t.current=null}function el(e,n,t){try{t()}catch(t){Es(e,n,t)}}var nl=!1;function tl(e,n,t){var a=n.updateQueue;if(null!==(a=null!==a?a.lastEffect:null)){var o=a=a.next;do{if((o.tag&e)===e){var r=o.destroy;o.destroy=void 0,void 0!==r&&el(n,t,r)}o=o.next}while(o!==a)}}function al(e,n){if(null!==(n=null!==(n=n.updateQueue)?n.lastEffect:null)){var t=n=n.next;do{if((t.tag&e)===e){var a=t.create;t.destroy=a()}t=t.next}while(t!==n)}}function ol(e){var n=e.ref;if(null!==n){var t=e.stateNode;e.tag,e=t,"function"==typeof n?n(e):n.current=e}}function rl(e){var n=e.alternate;null!==n&&(e.alternate=null,rl(n)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&null!==(n=e.stateNode)&&(delete n[fo],delete n[mo],delete n[go],delete n[ho],delete n[vo]),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function cl(e){return 5===e.tag||3===e.tag||4===e.tag}function il(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||cl(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function ll(e,n,t){var a=e.tag;if(5===a||6===a)e=e.stateNode,n?8===t.nodeType?t.parentNode.insertBefore(e,n):t.insertBefore(e,n):(8===t.nodeType?(n=t.parentNode).insertBefore(e,t):(n=t).appendChild(e),null!=(t=t._reactRootContainer)||null!==n.onclick||(n.onclick=Ja));else if(4!==a&&null!==(e=e.child))for(ll(e,n,t),e=e.sibling;null!==e;)ll(e,n,t),e=e.sibling}function sl(e,n,t){var a=e.tag;if(5===a||6===a)e=e.stateNode,n?t.insertBefore(e,n):t.appendChild(e);else if(4!==a&&null!==(e=e.child))for(sl(e,n,t),e=e.sibling;null!==e;)sl(e,n,t),e=e.sibling}var ul=null,dl=!1;function pl(e,n,t){for(t=t.child;null!==t;)fl(e,n,t),t=t.sibling}function fl(e,n,t){if(rn&&"function"==typeof rn.onCommitFiberUnmount)try{rn.onCommitFiberUnmount(on,t)}catch(e){}switch(t.tag){case 5:Xi||Ji(t,n);case 6:var a=ul,o=dl;ul=null,pl(e,n,t),dl=o,null!==(ul=a)&&(dl?(e=ul,t=t.stateNode,8===e.nodeType?e.parentNode.removeChild(t):e.removeChild(t)):ul.removeChild(t.stateNode));break;case 18:null!==ul&&(dl?(e=ul,t=t.stateNode,8===e.nodeType?lo(e.parentNode,t):1===e.nodeType&&lo(e,t),Wn(e)):lo(ul,t.stateNode));break;case 4:a=ul,o=dl,ul=t.stateNode.containerInfo,dl=!0,pl(e,n,t),ul=a,dl=o;break;case 0:case 11:case 14:case 15:if(!Xi&&null!==(a=t.updateQueue)&&null!==(a=a.lastEffect)){o=a=a.next;do{var r=o,c=r.destroy;r=r.tag,void 0!==c&&(2&r||4&r)&&el(t,n,c),o=o.next}while(o!==a)}pl(e,n,t);break;case 1:if(!Xi&&(Ji(t,n),"function"==typeof(a=t.stateNode).componentWillUnmount))try{a.props=t.memoizedProps,a.state=t.memoizedState,a.componentWillUnmount()}catch(e){Es(t,n,e)}pl(e,n,t);break;case 21:pl(e,n,t);break;case 22:1&t.mode?(Xi=(a=Xi)||null!==t.memoizedState,pl(e,n,t),Xi=a):pl(e,n,t);break;default:pl(e,n,t)}}function ml(e){var n=e.updateQueue;if(null!==n){e.updateQueue=null;var t=e.stateNode;null===t&&(t=e.stateNode=new Zi),n.forEach(function(n){var a=Rs.bind(null,e,n);t.has(n)||(t.add(n),n.then(a,a))})}}function _l(e,n){var t=n.deletions;if(null!==t)for(var a=0;a<t.length;a++){var o=t[a];try{var c=e,i=n,l=i;e:for(;null!==l;){switch(l.tag){case 5:ul=l.stateNode,dl=!1;break e;case 3:case 4:ul=l.stateNode.containerInfo,dl=!0;break e}l=l.return}if(null===ul)throw Error(r(160));fl(c,i,o),ul=null,dl=!1;var s=o.alternate;null!==s&&(s.return=null),o.return=null}catch(e){Es(o,n,e)}}if(12854&n.subtreeFlags)for(n=n.child;null!==n;)gl(n,e),n=n.sibling}function gl(e,n){var t=e.alternate,a=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(_l(n,e),hl(e),4&a){try{tl(3,e,e.return),al(3,e)}catch(n){Es(e,e.return,n)}try{tl(5,e,e.return)}catch(n){Es(e,e.return,n)}}break;case 1:_l(n,e),hl(e),512&a&&null!==t&&Ji(t,t.return);break;case 5:if(_l(n,e),hl(e),512&a&&null!==t&&Ji(t,t.return),32&e.flags){var o=e.stateNode;try{pe(o,"")}catch(n){Es(e,e.return,n)}}if(4&a&&null!=(o=e.stateNode)){var c=e.memoizedProps,i=null!==t?t.memoizedProps:c,l=e.type,s=e.updateQueue;if(e.updateQueue=null,null!==s)try{"input"===l&&"radio"===c.type&&null!=c.name&&Z(o,c),be(l,i);var u=be(l,c);for(i=0;i<s.length;i+=2){var d=s[i],p=s[i+1];"style"===d?ge(o,p):"dangerouslySetInnerHTML"===d?de(o,p):"children"===d?pe(o,p):b(o,d,p,u)}switch(l){case"input":Q(o,c);break;case"textarea":re(o,c);break;case"select":var f=o._wrapperState.wasMultiple;o._wrapperState.wasMultiple=!!c.multiple;var m=c.value;null!=m?te(o,!!c.multiple,m,!1):f!==!!c.multiple&&(null!=c.defaultValue?te(o,!!c.multiple,c.defaultValue,!0):te(o,!!c.multiple,c.multiple?[]:"",!1))}o[mo]=c}catch(n){Es(e,e.return,n)}}break;case 6:if(_l(n,e),hl(e),4&a){if(null===e.stateNode)throw Error(r(162));o=e.stateNode,c=e.memoizedProps;try{o.nodeValue=c}catch(n){Es(e,e.return,n)}}break;case 3:if(_l(n,e),hl(e),4&a&&null!==t&&t.memoizedState.isDehydrated)try{Wn(n.containerInfo)}catch(n){Es(e,e.return,n)}break;case 4:default:_l(n,e),hl(e);break;case 13:_l(n,e),hl(e),8192&(o=e.child).flags&&(c=null!==o.memoizedState,o.stateNode.isHidden=c,!c||null!==o.alternate&&null!==o.alternate.memoizedState||(ql=Ze())),4&a&&ml(e);break;case 22:if(d=null!==t&&null!==t.memoizedState,1&e.mode?(Xi=(u=Xi)||d,_l(n,e),Xi=u):_l(n,e),hl(e),8192&a){if(u=null!==e.memoizedState,(e.stateNode.isHidden=u)&&!d&&1&e.mode)for(Qi=e,d=e.child;null!==d;){for(p=Qi=d;null!==Qi;){switch(m=(f=Qi).child,f.tag){case 0:case 11:case 14:case 15:tl(4,f,f.return);break;case 1:Ji(f,f.return);var _=f.stateNode;if("function"==typeof _.componentWillUnmount){a=f,t=f.return;try{n=a,_.props=n.memoizedProps,_.state=n.memoizedState,_.componentWillUnmount()}catch(e){Es(a,t,e)}}break;case 5:Ji(f,f.return);break;case 22:if(null!==f.memoizedState){kl(p);continue}}null!==m?(m.return=f,Qi=m):kl(p)}d=d.sibling}e:for(d=null,p=e;;){if(5===p.tag){if(null===d){d=p;try{o=p.stateNode,u?"function"==typeof(c=o.style).setProperty?c.setProperty("display","none","important"):c.display="none":(l=p.stateNode,i=null!=(s=p.memoizedProps.style)&&s.hasOwnProperty("display")?s.display:null,l.style.display=_e("display",i))}catch(n){Es(e,e.return,n)}}}else if(6===p.tag){if(null===d)try{p.stateNode.nodeValue=u?"":p.memoizedProps}catch(n){Es(e,e.return,n)}}else if((22!==p.tag&&23!==p.tag||null===p.memoizedState||p===e)&&null!==p.child){p.child.return=p,p=p.child;continue}if(p===e)break e;for(;null===p.sibling;){if(null===p.return||p.return===e)break e;d===p&&(d=null),p=p.return}d===p&&(d=null),p.sibling.return=p.return,p=p.sibling}}break;case 19:_l(n,e),hl(e),4&a&&ml(e);case 21:}}function hl(e){var n=e.flags;if(2&n){try{e:{for(var t=e.return;null!==t;){if(cl(t)){var a=t;break e}t=t.return}throw Error(r(160))}switch(a.tag){case 5:var o=a.stateNode;32&a.flags&&(pe(o,""),a.flags&=-33),sl(e,il(e),o);break;case 3:case 4:var c=a.stateNode.containerInfo;ll(e,il(e),c);break;default:throw Error(r(161))}}catch(n){Es(e,e.return,n)}e.flags&=-3}4096&n&&(e.flags&=-4097)}function vl(e,n,t){Qi=e,bl(e,n,t)}function bl(e,n,t){for(var a=!!(1&e.mode);null!==Qi;){var o=Qi,r=o.child;if(22===o.tag&&a){var c=null!==o.memoizedState||Yi;if(!c){var i=o.alternate,l=null!==i&&null!==i.memoizedState||Xi;i=Yi;var s=Xi;if(Yi=c,(Xi=l)&&!s)for(Qi=o;null!==Qi;)l=(c=Qi).child,22===c.tag&&null!==c.memoizedState?Sl(o):null!==l?(l.return=c,Qi=l):Sl(o);for(;null!==r;)Qi=r,bl(r,n,t),r=r.sibling;Qi=o,Yi=i,Xi=s}yl(e)}else 8772&o.subtreeFlags&&null!==r?(r.return=o,Qi=r):yl(e)}}function yl(e){for(;null!==Qi;){var n=Qi;if(8772&n.flags){var t=n.alternate;try{if(8772&n.flags)switch(n.tag){case 0:case 11:case 15:Xi||al(5,n);break;case 1:var a=n.stateNode;if(4&n.flags&&!Xi)if(null===t)a.componentDidMount();else{var o=n.elementType===n.type?t.memoizedProps:ti(n.type,t.memoizedProps);a.componentDidUpdate(o,t.memoizedState,a.__reactInternalSnapshotBeforeUpdate)}var c=n.updateQueue;null!==c&&Vr(n,c,a);break;case 3:var i=n.updateQueue;if(null!==i){if(t=null,null!==n.child)switch(n.child.tag){case 5:case 1:t=n.child.stateNode}Vr(n,i,t)}break;case 5:var l=n.stateNode;if(null===t&&4&n.flags){t=l;var s=n.memoizedProps;switch(n.type){case"button":case"input":case"select":case"textarea":s.autoFocus&&t.focus();break;case"img":s.src&&(t.src=s.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===n.memoizedState){var u=n.alternate;if(null!==u){var d=u.memoizedState;if(null!==d){var p=d.dehydrated;null!==p&&Wn(p)}}}break;default:throw Error(r(163))}Xi||512&n.flags&&ol(n)}catch(e){Es(n,n.return,e)}}if(n===e){Qi=null;break}if(null!==(t=n.sibling)){t.return=n.return,Qi=t;break}Qi=n.return}}function kl(e){for(;null!==Qi;){var n=Qi;if(n===e){Qi=null;break}var t=n.sibling;if(null!==t){t.return=n.return,Qi=t;break}Qi=n.return}}function Sl(e){for(;null!==Qi;){var n=Qi;try{switch(n.tag){case 0:case 11:case 15:var t=n.return;try{al(4,n)}catch(e){Es(n,t,e)}break;case 1:var a=n.stateNode;if("function"==typeof a.componentDidMount){var o=n.return;try{a.componentDidMount()}catch(e){Es(n,o,e)}}var r=n.return;try{ol(n)}catch(e){Es(n,r,e)}break;case 5:var c=n.return;try{ol(n)}catch(e){Es(n,c,e)}}}catch(e){Es(n,n.return,e)}if(n===e){Qi=null;break}var i=n.sibling;if(null!==i){i.return=n.return,Qi=i;break}Qi=n.return}}var xl,El=Math.ceil,Pl=y.ReactCurrentDispatcher,wl=y.ReactCurrentOwner,Cl=y.ReactCurrentBatchConfig,Rl=0,Ll=null,Il=null,Ml=0,Dl=0,Al=Po(0),Ol=0,Tl=null,Bl=0,zl=0,Fl=0,Nl=null,Gl=null,ql=0,Ul=1/0,Wl=null,Vl=!1,Hl=null,jl=null,Kl=!1,$l=null,Yl=0,Xl=0,Zl=null,Ql=-1,Jl=0;function es(){return 6&Rl?Ze():-1!==Ql?Ql:Ql=Ze()}function ns(e){return 1&e.mode?2&Rl&&0!==Ml?Ml&-Ml:null!==gr.transition?(0===Jl&&(Jl=gn()),Jl):0!==(e=yn)?e:e=void 0===(e=window.event)?16:Zn(e.type):1}function ts(e,n,t,a){if(50<Xl)throw Xl=0,Zl=null,Error(r(185));vn(e,t,a),2&Rl&&e===Ll||(e===Ll&&(!(2&Rl)&&(zl|=t),4===Ol&&is(e,Ml)),as(e,a),1===t&&0===Rl&&!(1&n.mode)&&(Ul=Ze()+500,Go&&Wo()))}function as(e,n){var t=e.callbackNode;!function(e,n){for(var t=e.suspendedLanes,a=e.pingedLanes,o=e.expirationTimes,r=e.pendingLanes;0<r;){var c=31-cn(r),i=1<<c,l=o[c];-1===l?0!==(i&t)&&0===(i&a)||(o[c]=mn(i,n)):l<=n&&(e.expiredLanes|=i),r&=~i}}(e,n);var a=fn(e,e===Ll?Ml:0);if(0===a)null!==t&&$e(t),e.callbackNode=null,e.callbackPriority=0;else if(n=a&-a,e.callbackPriority!==n){if(null!=t&&$e(t),1===n)0===e.tag?function(e){Go=!0,Uo(e)}(ls.bind(null,e)):Uo(ls.bind(null,e)),co(function(){!(6&Rl)&&Wo()}),t=null;else{switch(kn(a)){case 1:t=Je;break;case 4:t=en;break;case 16:default:t=nn;break;case 536870912:t=an}t=Ls(t,os.bind(null,e))}e.callbackPriority=n,e.callbackNode=t}}function os(e,n){if(Ql=-1,Jl=0,6&Rl)throw Error(r(327));var t=e.callbackNode;if(Ss()&&e.callbackNode!==t)return null;var a=fn(e,e===Ll?Ml:0);if(0===a)return null;if(30&a||0!==(a&e.expiredLanes)||n)n=gs(e,a);else{n=a;var o=Rl;Rl|=2;var c=ms();for(Ll===e&&Ml===n||(Wl=null,Ul=Ze()+500,ps(e,n));;)try{vs();break}catch(n){fs(e,n)}Cr(),Pl.current=c,Rl=o,null!==Il?n=0:(Ll=null,Ml=0,n=Ol)}if(0!==n){if(2===n&&0!==(o=_n(e))&&(a=o,n=rs(e,o)),1===n)throw t=Tl,ps(e,0),is(e,a),as(e,Ze()),t;if(6===n)is(e,a);else{if(o=e.current.alternate,!(30&a||function(e){for(var n=e;;){if(16384&n.flags){var t=n.updateQueue;if(null!==t&&null!==(t=t.stores))for(var a=0;a<t.length;a++){var o=t[a],r=o.getSnapshot;o=o.value;try{if(!ia(r(),o))return!1}catch(e){return!1}}}if(t=n.child,16384&n.subtreeFlags&&null!==t)t.return=n,n=t;else{if(n===e)break;for(;null===n.sibling;){if(null===n.return||n.return===e)return!0;n=n.return}n.sibling.return=n.return,n=n.sibling}}return!0}(o)||(n=gs(e,a),2===n&&(c=_n(e),0!==c&&(a=c,n=rs(e,c))),1!==n)))throw t=Tl,ps(e,0),is(e,a),as(e,Ze()),t;switch(e.finishedWork=o,e.finishedLanes=a,n){case 0:case 1:throw Error(r(345));case 2:case 5:ks(e,Gl,Wl);break;case 3:if(is(e,a),(130023424&a)===a&&10<(n=ql+500-Ze())){if(0!==fn(e,0))break;if(((o=e.suspendedLanes)&a)!==a){es(),e.pingedLanes|=e.suspendedLanes&o;break}e.timeoutHandle=ao(ks.bind(null,e,Gl,Wl),n);break}ks(e,Gl,Wl);break;case 4:if(is(e,a),(4194240&a)===a)break;for(n=e.eventTimes,o=-1;0<a;){var i=31-cn(a);c=1<<i,(i=n[i])>o&&(o=i),a&=~c}if(a=o,10<(a=(120>(a=Ze()-a)?120:480>a?480:1080>a?1080:1920>a?1920:3e3>a?3e3:4320>a?4320:1960*El(a/1960))-a)){e.timeoutHandle=ao(ks.bind(null,e,Gl,Wl),a);break}ks(e,Gl,Wl);break;default:throw Error(r(329))}}}return as(e,Ze()),e.callbackNode===t?os.bind(null,e):null}function rs(e,n){var t=Nl;return e.current.memoizedState.isDehydrated&&(ps(e,n).flags|=256),2!==(e=gs(e,n))&&(n=Gl,Gl=t,null!==n&&cs(n)),e}function cs(e){null===Gl?Gl=e:Gl.push.apply(Gl,e)}function is(e,n){for(n&=~Fl,n&=~zl,e.suspendedLanes|=n,e.pingedLanes&=~n,e=e.expirationTimes;0<n;){var t=31-cn(n),a=1<<t;e[t]=-1,n&=~a}}function ls(e){if(6&Rl)throw Error(r(327));Ss();var n=fn(e,0);if(!(1&n))return as(e,Ze()),null;var t=gs(e,n);if(0!==e.tag&&2===t){var a=_n(e);0!==a&&(n=a,t=rs(e,a))}if(1===t)throw t=Tl,ps(e,0),is(e,n),as(e,Ze()),t;if(6===t)throw Error(r(345));return e.finishedWork=e.current.alternate,e.finishedLanes=n,ks(e,Gl,Wl),as(e,Ze()),null}function ss(e,n){var t=Rl;Rl|=1;try{return e(n)}finally{0===(Rl=t)&&(Ul=Ze()+500,Go&&Wo())}}function us(e){null!==$l&&0===$l.tag&&!(6&Rl)&&Ss();var n=Rl;Rl|=1;var t=Cl.transition,a=yn;try{if(Cl.transition=null,yn=1,e)return e()}finally{yn=a,Cl.transition=t,!(6&(Rl=n))&&Wo()}}function ds(){Dl=Al.current,wo(Al)}function ps(e,n){e.finishedWork=null,e.finishedLanes=0;var t=e.timeoutHandle;if(-1!==t&&(e.timeoutHandle=-1,oo(t)),null!==Il)for(t=Il.return;null!==t;){var a=t;switch(tr(a),a.tag){case 1:null!=(a=a.type.childContextTypes)&&Oo();break;case 3:Zr(),wo(Io),wo(Lo),ac();break;case 5:Jr(a);break;case 4:Zr();break;case 13:case 19:wo(ec);break;case 10:Rr(a.type._context);break;case 22:case 23:ds()}t=t.return}if(Ll=e,Il=e=As(e.current,null),Ml=Dl=n,Ol=0,Tl=null,Fl=zl=Bl=0,Gl=Nl=null,null!==Dr){for(n=0;n<Dr.length;n++)if(null!==(a=(t=Dr[n]).interleaved)){t.interleaved=null;var o=a.next,r=t.pending;if(null!==r){var c=r.next;r.next=o,a.next=c}t.pending=a}Dr=null}return e}function fs(e,n){for(;;){var t=Il;try{if(Cr(),oc.current=Qc,uc){for(var a=ic.memoizedState;null!==a;){var o=a.queue;null!==o&&(o.pending=null),a=a.next}uc=!1}if(cc=0,sc=lc=ic=null,dc=!1,pc=0,wl.current=null,null===t||null===t.return){Ol=1,Tl=n,Il=null;break}e:{var c=e,i=t.return,l=t,s=n;if(n=Ml,l.flags|=32768,null!==s&&"object"==typeof s&&"function"==typeof s.then){var u=s,d=l,p=d.tag;if(!(1&d.mode||0!==p&&11!==p&&15!==p)){var f=d.alternate;f?(d.updateQueue=f.updateQueue,d.memoizedState=f.memoizedState,d.lanes=f.lanes):(d.updateQueue=null,d.memoizedState=null)}var m=gi(i);if(null!==m){m.flags&=-257,hi(m,i,l,0,n),1&m.mode&&_i(c,u,n),s=u;var _=(n=m).updateQueue;if(null===_){var g=new Set;g.add(s),n.updateQueue=g}else _.add(s);break e}if(!(1&n)){_i(c,u,n),_s();break e}s=Error(r(426))}else if(rr&&1&l.mode){var h=gi(i);if(null!==h){!(65536&h.flags)&&(h.flags|=256),hi(h,i,l,0,n),_r(si(s,l));break e}}c=s=si(s,l),4!==Ol&&(Ol=2),null===Nl?Nl=[c]:Nl.push(c),c=i;do{switch(c.tag){case 3:c.flags|=65536,n&=-n,c.lanes|=n,Ur(c,fi(0,s,n));break e;case 1:l=s;var v=c.type,b=c.stateNode;if(!(128&c.flags||"function"!=typeof v.getDerivedStateFromError&&(null===b||"function"!=typeof b.componentDidCatch||null!==jl&&jl.has(b)))){c.flags|=65536,n&=-n,c.lanes|=n,Ur(c,mi(c,l,n));break e}}c=c.return}while(null!==c)}ys(t)}catch(e){n=e,Il===t&&null!==t&&(Il=t=t.return);continue}break}}function ms(){var e=Pl.current;return Pl.current=Qc,null===e?Qc:e}function _s(){0!==Ol&&3!==Ol&&2!==Ol||(Ol=4),null===Ll||!(268435455&Bl)&&!(268435455&zl)||is(Ll,Ml)}function gs(e,n){var t=Rl;Rl|=2;var a=ms();for(Ll===e&&Ml===n||(Wl=null,ps(e,n));;)try{hs();break}catch(n){fs(e,n)}if(Cr(),Rl=t,Pl.current=a,null!==Il)throw Error(r(261));return Ll=null,Ml=0,Ol}function hs(){for(;null!==Il;)bs(Il)}function vs(){for(;null!==Il&&!Ye();)bs(Il)}function bs(e){var n=xl(e.alternate,e,Dl);e.memoizedProps=e.pendingProps,null===n?ys(e):Il=n,wl.current=null}function ys(e){var n=e;do{var t=n.alternate;if(e=n.return,32768&n.flags){if(null!==(t=$i(t,n)))return t.flags&=32767,void(Il=t);if(null===e)return Ol=6,void(Il=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}else if(null!==(t=Ki(t,n,Dl)))return void(Il=t);if(null!==(n=n.sibling))return void(Il=n);Il=n=e}while(null!==n);0===Ol&&(Ol=5)}function ks(e,n,t){var a=yn,o=Cl.transition;try{Cl.transition=null,yn=1,function(e,n,t,a){do{Ss()}while(null!==$l);if(6&Rl)throw Error(r(327));t=e.finishedWork;var o=e.finishedLanes;if(null===t)return null;if(e.finishedWork=null,e.finishedLanes=0,t===e.current)throw Error(r(177));e.callbackNode=null,e.callbackPriority=0;var c=t.lanes|t.childLanes;if(function(e,n){var t=e.pendingLanes&~n;e.pendingLanes=n,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=n,e.mutableReadLanes&=n,e.entangledLanes&=n,n=e.entanglements;var a=e.eventTimes;for(e=e.expirationTimes;0<t;){var o=31-cn(t),r=1<<o;n[o]=0,a[o]=-1,e[o]=-1,t&=~r}}(e,c),e===Ll&&(Il=Ll=null,Ml=0),!(2064&t.subtreeFlags)&&!(2064&t.flags)||Kl||(Kl=!0,Ls(nn,function(){return Ss(),null})),c=!!(15990&t.flags),15990&t.subtreeFlags||c){c=Cl.transition,Cl.transition=null;var i=yn;yn=1;var l=Rl;Rl|=4,wl.current=null,function(e,n){if(eo=Hn,fa(e=pa())){if("selectionStart"in e)var t={start:e.selectionStart,end:e.selectionEnd};else e:{var a=(t=(t=e.ownerDocument)&&t.defaultView||window).getSelection&&t.getSelection();if(a&&0!==a.rangeCount){t=a.anchorNode;var o=a.anchorOffset,c=a.focusNode;a=a.focusOffset;try{t.nodeType,c.nodeType}catch(e){t=null;break e}var i=0,l=-1,s=-1,u=0,d=0,p=e,f=null;n:for(;;){for(var m;p!==t||0!==o&&3!==p.nodeType||(l=i+o),p!==c||0!==a&&3!==p.nodeType||(s=i+a),3===p.nodeType&&(i+=p.nodeValue.length),null!==(m=p.firstChild);)f=p,p=m;for(;;){if(p===e)break n;if(f===t&&++u===o&&(l=i),f===c&&++d===a&&(s=i),null!==(m=p.nextSibling))break;f=(p=f).parentNode}p=m}t=-1===l||-1===s?null:{start:l,end:s}}else t=null}t=t||{start:0,end:0}}else t=null;for(no={focusedElem:e,selectionRange:t},Hn=!1,Qi=n;null!==Qi;)if(e=(n=Qi).child,1028&n.subtreeFlags&&null!==e)e.return=n,Qi=e;else for(;null!==Qi;){n=Qi;try{var _=n.alternate;if(1024&n.flags)switch(n.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==_){var g=_.memoizedProps,h=_.memoizedState,v=n.stateNode,b=v.getSnapshotBeforeUpdate(n.elementType===n.type?g:ti(n.type,g),h);v.__reactInternalSnapshotBeforeUpdate=b}break;case 3:var y=n.stateNode.containerInfo;1===y.nodeType?y.textContent="":9===y.nodeType&&y.documentElement&&y.removeChild(y.documentElement);break;default:throw Error(r(163))}}catch(e){Es(n,n.return,e)}if(null!==(e=n.sibling)){e.return=n.return,Qi=e;break}Qi=n.return}_=nl,nl=!1}(e,t),gl(t,e),ma(no),Hn=!!eo,no=eo=null,e.current=t,vl(t,e,o),Xe(),Rl=l,yn=i,Cl.transition=c}else e.current=t;if(Kl&&(Kl=!1,$l=e,Yl=o),0===(c=e.pendingLanes)&&(jl=null),function(e){if(rn&&"function"==typeof rn.onCommitFiberRoot)try{rn.onCommitFiberRoot(on,e,void 0,!(128&~e.current.flags))}catch(e){}}(t.stateNode),as(e,Ze()),null!==n)for(a=e.onRecoverableError,t=0;t<n.length;t++)a((o=n[t]).value,{componentStack:o.stack,digest:o.digest});if(Vl)throw Vl=!1,e=Hl,Hl=null,e;!!(1&Yl)&&0!==e.tag&&Ss(),1&(c=e.pendingLanes)?e===Zl?Xl++:(Xl=0,Zl=e):Xl=0,Wo()}(e,n,t,a)}finally{Cl.transition=o,yn=a}return null}function Ss(){if(null!==$l){var e=kn(Yl),n=Cl.transition,t=yn;try{if(Cl.transition=null,yn=16>e?16:e,null===$l)var a=!1;else{if(e=$l,$l=null,Yl=0,6&Rl)throw Error(r(331));var o=Rl;for(Rl|=4,Qi=e.current;null!==Qi;){var c=Qi,i=c.child;if(16&Qi.flags){var l=c.deletions;if(null!==l){for(var s=0;s<l.length;s++){var u=l[s];for(Qi=u;null!==Qi;){var d=Qi;switch(d.tag){case 0:case 11:case 15:tl(8,d,c)}var p=d.child;if(null!==p)p.return=d,Qi=p;else for(;null!==Qi;){var f=(d=Qi).sibling,m=d.return;if(rl(d),d===u){Qi=null;break}if(null!==f){f.return=m,Qi=f;break}Qi=m}}}var _=c.alternate;if(null!==_){var g=_.child;if(null!==g){_.child=null;do{var h=g.sibling;g.sibling=null,g=h}while(null!==g)}}Qi=c}}if(2064&c.subtreeFlags&&null!==i)i.return=c,Qi=i;else e:for(;null!==Qi;){if(2048&(c=Qi).flags)switch(c.tag){case 0:case 11:case 15:tl(9,c,c.return)}var v=c.sibling;if(null!==v){v.return=c.return,Qi=v;break e}Qi=c.return}}var b=e.current;for(Qi=b;null!==Qi;){var y=(i=Qi).child;if(2064&i.subtreeFlags&&null!==y)y.return=i,Qi=y;else e:for(i=b;null!==Qi;){if(2048&(l=Qi).flags)try{switch(l.tag){case 0:case 11:case 15:al(9,l)}}catch(e){Es(l,l.return,e)}if(l===i){Qi=null;break e}var k=l.sibling;if(null!==k){k.return=l.return,Qi=k;break e}Qi=l.return}}if(Rl=o,Wo(),rn&&"function"==typeof rn.onPostCommitFiberRoot)try{rn.onPostCommitFiberRoot(on,e)}catch(e){}a=!0}return a}finally{yn=t,Cl.transition=n}}return!1}function xs(e,n,t){e=Gr(e,n=fi(0,n=si(t,n),1),1),n=es(),null!==e&&(vn(e,1,n),as(e,n))}function Es(e,n,t){if(3===e.tag)xs(e,e,t);else for(;null!==n;){if(3===n.tag){xs(n,e,t);break}if(1===n.tag){var a=n.stateNode;if("function"==typeof n.type.getDerivedStateFromError||"function"==typeof a.componentDidCatch&&(null===jl||!jl.has(a))){n=Gr(n,e=mi(n,e=si(t,e),1),1),e=es(),null!==n&&(vn(n,1,e),as(n,e));break}}n=n.return}}function Ps(e,n,t){var a=e.pingCache;null!==a&&a.delete(n),n=es(),e.pingedLanes|=e.suspendedLanes&t,Ll===e&&(Ml&t)===t&&(4===Ol||3===Ol&&(130023424&Ml)===Ml&&500>Ze()-ql?ps(e,0):Fl|=t),as(e,n)}function ws(e,n){0===n&&(1&e.mode?(n=dn,!(130023424&(dn<<=1))&&(dn=4194304)):n=1);var t=es();null!==(e=Tr(e,n))&&(vn(e,n,t),as(e,t))}function Cs(e){var n=e.memoizedState,t=0;null!==n&&(t=n.retryLane),ws(e,t)}function Rs(e,n){var t=0;switch(e.tag){case 13:var a=e.stateNode,o=e.memoizedState;null!==o&&(t=o.retryLane);break;case 19:a=e.stateNode;break;default:throw Error(r(314))}null!==a&&a.delete(n),ws(e,t)}function Ls(e,n){return Ke(e,n)}function Is(e,n,t,a){this.tag=e,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=n,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ms(e,n,t,a){return new Is(e,n,t,a)}function Ds(e){return!(!(e=e.prototype)||!e.isReactComponent)}function As(e,n){var t=e.alternate;return null===t?((t=Ms(e.tag,n,e.key,e.mode)).elementType=e.elementType,t.type=e.type,t.stateNode=e.stateNode,t.alternate=e,e.alternate=t):(t.pendingProps=n,t.type=e.type,t.flags=0,t.subtreeFlags=0,t.deletions=null),t.flags=14680064&e.flags,t.childLanes=e.childLanes,t.lanes=e.lanes,t.child=e.child,t.memoizedProps=e.memoizedProps,t.memoizedState=e.memoizedState,t.updateQueue=e.updateQueue,n=e.dependencies,t.dependencies=null===n?null:{lanes:n.lanes,firstContext:n.firstContext},t.sibling=e.sibling,t.index=e.index,t.ref=e.ref,t}function Os(e,n,t,a,o,c){var i=2;if(a=e,"function"==typeof e)Ds(e)&&(i=1);else if("string"==typeof e)i=5;else e:switch(e){case x:return Ts(t.children,o,c,n);case E:i=8,o|=8;break;case P:return(e=Ms(12,t,n,2|o)).elementType=P,e.lanes=c,e;case L:return(e=Ms(13,t,n,o)).elementType=L,e.lanes=c,e;case I:return(e=Ms(19,t,n,o)).elementType=I,e.lanes=c,e;case A:return Bs(t,o,c,n);default:if("object"==typeof e&&null!==e)switch(e.$$typeof){case w:i=10;break e;case C:i=9;break e;case R:i=11;break e;case M:i=14;break e;case D:i=16,a=null;break e}throw Error(r(130,null==e?e:typeof e,""))}return(n=Ms(i,t,n,o)).elementType=e,n.type=a,n.lanes=c,n}function Ts(e,n,t,a){return(e=Ms(7,e,a,n)).lanes=t,e}function Bs(e,n,t,a){return(e=Ms(22,e,a,n)).elementType=A,e.lanes=t,e.stateNode={isHidden:!1},e}function zs(e,n,t){return(e=Ms(6,e,null,n)).lanes=t,e}function Fs(e,n,t){return(n=Ms(4,null!==e.children?e.children:[],e.key,n)).lanes=t,n.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},n}function Ns(e,n,t,a,o){this.tag=n,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=hn(0),this.expirationTimes=hn(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=hn(0),this.identifierPrefix=a,this.onRecoverableError=o,this.mutableSourceEagerHydrationData=null}function Gs(e,n,t,a,o,r,c,i,l){return e=new Ns(e,n,t,i,l),1===n?(n=1,!0===r&&(n|=8)):n=0,r=Ms(3,null,null,n),e.current=r,r.stateNode=e,r.memoizedState={element:a,isDehydrated:t,cache:null,transitions:null,pendingSuspenseBoundaries:null},zr(r),e}function qs(e){if(!e)return Ro;e:{if(Ue(e=e._reactInternals)!==e||1!==e.tag)throw Error(r(170));var n=e;do{switch(n.tag){case 3:n=n.stateNode.context;break e;case 1:if(Ao(n.type)){n=n.stateNode.__reactInternalMemoizedMergedChildContext;break e}}n=n.return}while(null!==n);throw Error(r(171))}if(1===e.tag){var t=e.type;if(Ao(t))return Bo(e,t,n)}return n}function Us(e,n,t,a,o,r,c,i,l){return(e=Gs(t,a,!0,e,0,r,0,i,l)).context=qs(null),t=e.current,(r=Nr(a=es(),o=ns(t))).callback=null!=n?n:null,Gr(t,r,o),e.current.lanes=o,vn(e,o,a),as(e,a),e}function Ws(e,n,t,a){var o=n.current,r=es(),c=ns(o);return t=qs(t),null===n.context?n.context=t:n.pendingContext=t,(n=Nr(r,c)).payload={element:e},null!==(a=void 0===a?null:a)&&(n.callback=a),null!==(e=Gr(o,n,c))&&(ts(e,o,c,r),qr(e,o,c)),c}function Vs(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Hs(e,n){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var t=e.retryLane;e.retryLane=0!==t&&t<n?t:n}}function js(e,n){Hs(e,n),(e=e.alternate)&&Hs(e,n)}xl=function(e,n,t){if(null!==e)if(e.memoizedProps!==n.pendingProps||Io.current)bi=!0;else{if(0===(e.lanes&t)&&!(128&n.flags))return bi=!1,function(e,n,t){switch(n.tag){case 3:Li(n),mr();break;case 5:Qr(n);break;case 1:Ao(n.type)&&zo(n);break;case 4:Xr(n,n.stateNode.containerInfo);break;case 10:var a=n.type._context,o=n.memoizedProps.value;Co(xr,a._currentValue),a._currentValue=o;break;case 13:if(null!==(a=n.memoizedState))return null!==a.dehydrated?(Co(ec,1&ec.current),n.flags|=128,null):0!==(t&n.child.childLanes)?zi(e,n,t):(Co(ec,1&ec.current),null!==(e=Vi(e,n,t))?e.sibling:null);Co(ec,1&ec.current);break;case 19:if(a=0!==(t&n.childLanes),128&e.flags){if(a)return Ui(e,n,t);n.flags|=128}if(null!==(o=n.memoizedState)&&(o.rendering=null,o.tail=null,o.lastEffect=null),Co(ec,ec.current),a)break;return null;case 22:case 23:return n.lanes=0,Ei(e,n,t)}return Vi(e,n,t)}(e,n,t);bi=!!(131072&e.flags)}else bi=!1,rr&&1048576&n.flags&&er(n,Ko,n.index);switch(n.lanes=0,n.tag){case 2:var a=n.type;Wi(e,n),e=n.pendingProps;var o=Do(n,Lo.current);Ir(n,t),o=gc(null,n,a,e,o,t);var c=hc();return n.flags|=1,"object"==typeof o&&null!==o&&"function"==typeof o.render&&void 0===o.$$typeof?(n.tag=1,n.memoizedState=null,n.updateQueue=null,Ao(a)?(c=!0,zo(n)):c=!1,n.memoizedState=null!==o.state&&void 0!==o.state?o.state:null,zr(n),o.updater=oi,n.stateNode=o,o._reactInternals=n,li(n,a,e,t),n=Ri(null,n,a,!0,c,t)):(n.tag=0,rr&&c&&nr(n),yi(null,n,o,t),n=n.child),n;case 16:a=n.elementType;e:{switch(Wi(e,n),e=n.pendingProps,a=(o=a._init)(a._payload),n.type=a,o=n.tag=function(e){if("function"==typeof e)return Ds(e)?1:0;if(null!=e){if((e=e.$$typeof)===R)return 11;if(e===M)return 14}return 2}(a),e=ti(a,e),o){case 0:n=wi(null,n,a,e,t);break e;case 1:n=Ci(null,n,a,e,t);break e;case 11:n=ki(null,n,a,e,t);break e;case 14:n=Si(null,n,a,ti(a.type,e),t);break e}throw Error(r(306,a,""))}return n;case 0:return a=n.type,o=n.pendingProps,wi(e,n,a,o=n.elementType===a?o:ti(a,o),t);case 1:return a=n.type,o=n.pendingProps,Ci(e,n,a,o=n.elementType===a?o:ti(a,o),t);case 3:e:{if(Li(n),null===e)throw Error(r(387));a=n.pendingProps,o=(c=n.memoizedState).element,Fr(e,n),Wr(n,a,null,t);var i=n.memoizedState;if(a=i.element,c.isDehydrated){if(c={element:a,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},n.updateQueue.baseState=c,n.memoizedState=c,256&n.flags){n=Ii(e,n,a,t,o=si(Error(r(423)),n));break e}if(a!==o){n=Ii(e,n,a,t,o=si(Error(r(424)),n));break e}for(or=so(n.stateNode.containerInfo.firstChild),ar=n,rr=!0,cr=null,t=Sr(n,null,a,t),n.child=t;t;)t.flags=-3&t.flags|4096,t=t.sibling}else{if(mr(),a===o){n=Vi(e,n,t);break e}yi(e,n,a,t)}n=n.child}return n;case 5:return Qr(n),null===e&&ur(n),a=n.type,o=n.pendingProps,c=null!==e?e.memoizedProps:null,i=o.children,to(a,o)?i=null:null!==c&&to(a,c)&&(n.flags|=32),Pi(e,n),yi(e,n,i,t),n.child;case 6:return null===e&&ur(n),null;case 13:return zi(e,n,t);case 4:return Xr(n,n.stateNode.containerInfo),a=n.pendingProps,null===e?n.child=kr(n,null,a,t):yi(e,n,a,t),n.child;case 11:return a=n.type,o=n.pendingProps,ki(e,n,a,o=n.elementType===a?o:ti(a,o),t);case 7:return yi(e,n,n.pendingProps,t),n.child;case 8:case 12:return yi(e,n,n.pendingProps.children,t),n.child;case 10:e:{if(a=n.type._context,o=n.pendingProps,c=n.memoizedProps,i=o.value,Co(xr,a._currentValue),a._currentValue=i,null!==c)if(ia(c.value,i)){if(c.children===o.children&&!Io.current){n=Vi(e,n,t);break e}}else for(null!==(c=n.child)&&(c.return=n);null!==c;){var l=c.dependencies;if(null!==l){i=c.child;for(var s=l.firstContext;null!==s;){if(s.context===a){if(1===c.tag){(s=Nr(-1,t&-t)).tag=2;var u=c.updateQueue;if(null!==u){var d=(u=u.shared).pending;null===d?s.next=s:(s.next=d.next,d.next=s),u.pending=s}}c.lanes|=t,null!==(s=c.alternate)&&(s.lanes|=t),Lr(c.return,t,n),l.lanes|=t;break}s=s.next}}else if(10===c.tag)i=c.type===n.type?null:c.child;else if(18===c.tag){if(null===(i=c.return))throw Error(r(341));i.lanes|=t,null!==(l=i.alternate)&&(l.lanes|=t),Lr(i,t,n),i=c.sibling}else i=c.child;if(null!==i)i.return=c;else for(i=c;null!==i;){if(i===n){i=null;break}if(null!==(c=i.sibling)){c.return=i.return,i=c;break}i=i.return}c=i}yi(e,n,o.children,t),n=n.child}return n;case 9:return o=n.type,a=n.pendingProps.children,Ir(n,t),a=a(o=Mr(o)),n.flags|=1,yi(e,n,a,t),n.child;case 14:return o=ti(a=n.type,n.pendingProps),Si(e,n,a,o=ti(a.type,o),t);case 15:return xi(e,n,n.type,n.pendingProps,t);case 17:return a=n.type,o=n.pendingProps,o=n.elementType===a?o:ti(a,o),Wi(e,n),n.tag=1,Ao(a)?(e=!0,zo(n)):e=!1,Ir(n,t),ci(n,a,o),li(n,a,o,t),Ri(null,n,a,!0,e,t);case 19:return Ui(e,n,t);case 22:return Ei(e,n,t)}throw Error(r(156,n.tag))};var Ks="function"==typeof reportError?reportError:function(e){console.error(e)};function $s(e){this._internalRoot=e}function Ys(e){this._internalRoot=e}function Xs(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Zs(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Qs(){}function Js(e,n,t,a,o){var r=t._reactRootContainer;if(r){var c=r;if("function"==typeof o){var i=o;o=function(){var e=Vs(c);i.call(e)}}Ws(n,c,e,o)}else c=function(e,n,t,a,o){if(o){if("function"==typeof a){var r=a;a=function(){var e=Vs(c);r.call(e)}}var c=Us(n,a,e,0,null,!1,0,"",Qs);return e._reactRootContainer=c,e[_o]=c.current,Ua(8===e.nodeType?e.parentNode:e),us(),c}for(;o=e.lastChild;)e.removeChild(o);if("function"==typeof a){var i=a;a=function(){var e=Vs(l);i.call(e)}}var l=Gs(e,0,!1,null,0,!1,0,"",Qs);return e._reactRootContainer=l,e[_o]=l.current,Ua(8===e.nodeType?e.parentNode:e),us(function(){Ws(n,l,t,a)}),l}(t,n,e,o,a);return Vs(c)}Ys.prototype.render=$s.prototype.render=function(e){var n=this._internalRoot;if(null===n)throw Error(r(409));Ws(e,n,null,null)},Ys.prototype.unmount=$s.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var n=e.containerInfo;us(function(){Ws(null,e,null,null)}),n[_o]=null}},Ys.prototype.unstable_scheduleHydration=function(e){if(e){var n=Pn();e={blockedOn:null,target:e,priority:n};for(var t=0;t<On.length&&0!==n&&n<On[t].priority;t++);On.splice(t,0,e),0===t&&Fn(e)}},Sn=function(e){switch(e.tag){case 3:var n=e.stateNode;if(n.current.memoizedState.isDehydrated){var t=pn(n.pendingLanes);0!==t&&(bn(n,1|t),as(n,Ze()),!(6&Rl)&&(Ul=Ze()+500,Wo()))}break;case 13:us(function(){var n=Tr(e,1);if(null!==n){var t=es();ts(n,e,1,t)}}),js(e,1)}},xn=function(e){if(13===e.tag){var n=Tr(e,134217728);null!==n&&ts(n,e,134217728,es()),js(e,134217728)}},En=function(e){if(13===e.tag){var n=ns(e),t=Tr(e,n);null!==t&&ts(t,e,n,es()),js(e,n)}},Pn=function(){return yn},wn=function(e,n){var t=yn;try{return yn=e,n()}finally{yn=t}},Se=function(e,n,t){switch(n){case"input":if(Q(e,t),n=t.name,"radio"===t.type&&null!=n){for(t=e;t.parentNode;)t=t.parentNode;for(t=t.querySelectorAll("input[name="+JSON.stringify(""+n)+'][type="radio"]'),n=0;n<t.length;n++){var a=t[n];if(a!==e&&a.form===e.form){var o=So(a);if(!o)throw Error(r(90));K(a),Q(a,o)}}}break;case"textarea":re(e,t);break;case"select":null!=(n=t.value)&&te(e,!!t.multiple,n,!1)}},Re=ss,Le=us;var eu={usingClientEntryPoint:!1,Events:[yo,ko,So,we,Ce,ss]},nu={findFiberByHostInstance:bo,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},tu={bundleType:nu.bundleType,version:nu.version,rendererPackageName:nu.rendererPackageName,rendererConfig:nu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:y.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=He(e))?null:e.stateNode},findFiberByHostInstance:nu.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var au=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!au.isDisabled&&au.supportsFiber)try{on=au.inject(tu),rn=au}catch(ue){}}n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=eu,n.createPortal=function(e,n){var t=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Xs(n))throw Error(r(200));return function(e,n,t){var a=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:S,key:null==a?null:""+a,children:e,containerInfo:n,implementation:t}}(e,n,null,t)},n.createRoot=function(e,n){if(!Xs(e))throw Error(r(299));var t=!1,a="",o=Ks;return null!=n&&(!0===n.unstable_strictMode&&(t=!0),void 0!==n.identifierPrefix&&(a=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),n=Gs(e,1,!1,null,0,t,0,a,o),e[_o]=n.current,Ua(8===e.nodeType?e.parentNode:e),new $s(n)},n.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var n=e._reactInternals;if(void 0===n){if("function"==typeof e.render)throw Error(r(188));throw e=Object.keys(e).join(","),Error(r(268,e))}return null===(e=He(n))?null:e.stateNode},n.flushSync=function(e){return us(e)},n.hydrate=function(e,n,t){if(!Zs(n))throw Error(r(200));return Js(null,e,n,!0,t)},n.hydrateRoot=function(e,n,t){if(!Xs(e))throw Error(r(405));var a=null!=t&&t.hydratedSources||null,o=!1,c="",i=Ks;if(null!=t&&(!0===t.unstable_strictMode&&(o=!0),void 0!==t.identifierPrefix&&(c=t.identifierPrefix),void 0!==t.onRecoverableError&&(i=t.onRecoverableError)),n=Us(n,null,e,1,null!=t?t:null,o,0,c,i),e[_o]=n.current,Ua(e),a)for(e=0;e<a.length;e++)o=(o=(t=a[e])._getVersion)(t._source),null==n.mutableSourceEagerHydrationData?n.mutableSourceEagerHydrationData=[t,o]:n.mutableSourceEagerHydrationData.push(t,o);return new Ys(n)},n.render=function(e,n,t){if(!Zs(n))throw Error(r(200));return Js(null,e,n,!1,t)},n.unmountComponentAtNode=function(e){if(!Zs(e))throw Error(r(40));return!!e._reactRootContainer&&(us(function(){Js(null,null,e,!1,function(){e._reactRootContainer=null,e[_o]=null})}),!0)},n.unstable_batchedUpdates=ss,n.unstable_renderSubtreeIntoContainer=function(e,n,t,a){if(!Zs(t))throw Error(r(200));if(null==e||void 0===e._reactInternals)throw Error(r(38));return Js(e,n,t,!1,a)},n.version="18.3.1-next-f1338f8080-20240426"},601:e=>{e.exports=function(e){return e[1]}},659:e=>{var n={};e.exports=function(e,t){var a=function(e){if(void 0===n[e]){var t=document.querySelector(e);if(window.HTMLIFrameElement&&t instanceof window.HTMLIFrameElement)try{t=t.contentDocument.head}catch(e){t=null}n[e]=t}return n[e]}(e);if(!a)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");a.appendChild(t)}},825:e=>{e.exports=function(e){if("undefined"==typeof document)return{update:function(){},remove:function(){}};var n=e.insertStyleElement(e);return{update:function(t){!function(e,n,t){var a="";t.supports&&(a+="@supports (".concat(t.supports,") {")),t.media&&(a+="@media ".concat(t.media," {"));var o=void 0!==t.layer;o&&(a+="@layer".concat(t.layer.length>0?" ".concat(t.layer):""," {")),a+=t.css,o&&(a+="}"),t.media&&(a+="}"),t.supports&&(a+="}");var r=t.sourceMap;r&&"undefined"!=typeof btoa&&(a+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r))))," */")),n.styleTagTransform(a,e,n.options)}(n,e,t)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(n)}}}},961:(e,n,t)=>{!function e(){if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(e){console.error(e)}}(),e.exports=t(551)},982:(e,n,t)=>{e.exports=t(463)}},n={};function t(a){var o=n[a];if(void 0!==o)return o.exports;var r=n[a]={id:a,exports:{}};return e[a](r,r.exports,t),r.exports}t.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return t.d(n,{a:n}),n},t.d=(e,n)=>{for(var a in n)t.o(n,a)&&!t.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:n[a]})},t.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),t.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),(()=>{var e;t.g.importScripts&&(e=t.g.location+"");var n=t.g.document;if(!e&&n&&(n.currentScript&&"SCRIPT"===n.currentScript.tagName.toUpperCase()&&(e=n.currentScript.src),!e)){var a=n.getElementsByTagName("script");if(a.length)for(var o=a.length-1;o>-1&&(!e||!/^http(s?):/.test(e));)e=a[o--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/^blob:/,"").replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),t.p=e})(),t.nc=void 0;var a=t(540),o=t(338),r=t(72),c=t.n(r),i=t(825),l=t.n(i),s=t(659),u=t.n(s),d=t(56),p=t.n(d),f=t(159),m=t.n(f),_=t(113),g=t.n(_),h=t(249),v={};function b(e){return b="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},b(e)}function y(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function k(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?y(Object(t),!0).forEach(function(n){S(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):y(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function S(e,n,t){return(n=function(e){var n=function(e){if("object"!=b(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=b(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==b(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}v.styleTagTransform=g(),v.setAttributes=p(),v.insert=u().bind(null,"head"),v.domAPI=l(),v.insertStyleElement=m(),c()(h.A,v),h.A&&h.A.locals&&h.A.locals;var x={Noise:{label:"Noise Generator",desc:"Multi-type noise generator: white, pink, brown with gate control and morphing.",params:{type:"white",gain:.3,gate:1,morph:0},audioIn:[],audioOut:["out"],ctrlIn:["gain","gate","type","morph"],ctrlOut:[]},Wavetable:{label:"Oscillator",desc:"Full-featured wavetable oscillator with FM, custom waveform editor, morphing, and ADSR breakpoint control. 512-sample LUT for high quality.",params:{freq:440,gain:.25,gate:1,pitch_range:24,fm_amount:0,fm_tracking:!1,fm_ratio:1,fm_ratio_mode:"zones",show_fm_inputs:!1,wavetables:[],current_table:0,adsr_morph:!1,attack_table:0,decay_table:1,sustain_table:2,release_table:3,editor_settings:{table_size:512,draw_mode:"sine",current_editing:0}},audioIn:["fm"],audioOut:["L","R"],ctrlIn:["freq","gain","gate","morph","table_select","pitch_cv","fm_ratio_cv","fm_amount"],ctrlOut:[]},SamplePlayer:{label:"Sample Player",desc:"Plays audio samples with sustain looping. Supports both single-voice and 6-voice polyphonic PSRAM modes.",params:{sample_name:"",base_note:60,pitch:1,gain:.8,loop:!1,polyphonic:!1,fileMin:1,fileMax:32,adsr_pitch_range:2,adsr_pitch_center:0,start_pos:0,end_pos:1,crossfade_ms:10,voice_allocation:"round_robin",max_voices:6,auto_load_samples:!0,max_voice_time:10},audioIn:[],audioOut:["out"],ctrlIn:["gate","pitch","pitch_env","sample_select","gain","start_pos","end_pos"],ctrlOut:[]},DrumDesigner4:{label:"Drum Designer",desc:"4-voice percussion synthesizer with Karplus-Strong modeling. Each voice can be enabled/disabled for CPU optimization. Mix output or individual voice outputs for flexible routing. Auto-banking: Pot=volume, Button=gate, Button hold + Pot=pitch.",params:{bank:1,voice1_enabled:!0,voice2_enabled:!0,voice3_enabled:!0,voice4_enabled:!0,show_individual_outputs:!1,selected_voice:1,voice1_pitch:60,voice1_fine_tune:0,voice1_pitch_sweep_mode:"none",voice1_ks_mode:"tonal",voice1_ks_damping:.6,voice1_ks_stretch:1,voice1_ks_excitation_type:"noise",voice1_ks_brightness:.5,voice1_ks_position:.5,voice1_ks_level:.3,voice1_sine_level:.7,voice1_sine_enabled:!0,voice1_sine_pitch_amount:2,voice1_sine_pitch_decay:.08,voice1_body_enabled:!0,voice1_body_type:"wood",voice1_body_resonance:.5,voice1_body_size:.5,voice1_amp_attack:1,voice1_amp_decay:500,voice1_amp_sustain:0,voice1_amp_release:100,voice1_velocity_sensitivity:.7,voice1_output_gain:3,voice1_volume:.8,voice1_preset:"marimba",voice2_pitch:62,voice2_fine_tune:0,voice2_pitch_sweep_mode:"none",voice2_ks_mode:"percussive",voice2_ks_damping:.5,voice2_ks_stretch:1,voice2_ks_excitation_type:"noise",voice2_ks_brightness:.6,voice2_ks_position:.5,voice2_ks_level:.4,voice2_sine_level:.6,voice2_sine_enabled:!0,voice2_sine_pitch_amount:2,voice2_sine_pitch_decay:.08,voice2_body_enabled:!0,voice2_body_type:"wood",voice2_body_resonance:.5,voice2_body_size:.5,voice2_amp_attack:1,voice2_amp_decay:400,voice2_amp_sustain:0,voice2_amp_release:100,voice2_velocity_sensitivity:.7,voice2_output_gain:3,voice2_volume:.8,voice2_preset:"snare",voice3_pitch:67,voice3_fine_tune:0,voice3_pitch_sweep_mode:"none",voice3_ks_mode:"noise",voice3_ks_damping:.3,voice3_ks_stretch:1,voice3_ks_excitation_type:"filtered",voice3_ks_brightness:.8,voice3_ks_position:.5,voice3_ks_level:.7,voice3_sine_level:.3,voice3_sine_enabled:!1,voice3_sine_pitch_amount:2,voice3_sine_pitch_decay:.08,voice3_body_enabled:!1,voice3_body_type:"metal",voice3_body_resonance:.5,voice3_body_size:.5,voice3_amp_attack:1,voice3_amp_decay:150,voice3_amp_sustain:0,voice3_amp_release:50,voice3_velocity_sensitivity:.7,voice3_output_gain:2.5,voice3_volume:.8,voice3_preset:"hihat",voice4_pitch:65,voice4_fine_tune:0,voice4_pitch_sweep_mode:"none",voice4_ks_mode:"percussive",voice4_ks_damping:.4,voice4_ks_stretch:1.01,voice4_ks_excitation_type:"noise",voice4_ks_brightness:.7,voice4_ks_position:.5,voice4_ks_level:.5,voice4_sine_level:.5,voice4_sine_enabled:!0,voice4_sine_pitch_amount:2,voice4_sine_pitch_decay:.08,voice4_body_enabled:!0,voice4_body_type:"wood",voice4_body_resonance:.6,voice4_body_size:.4,voice4_amp_attack:1,voice4_amp_decay:300,voice4_amp_sustain:0,voice4_amp_release:80,voice4_velocity_sensitivity:.7,voice4_output_gain:3,voice4_volume:.8,voice4_preset:"tom"},audioIn:[],audioOut:["mixL","mixR","voice1_outL","voice1_outR","voice2_outL","voice2_outR","voice3_outL","voice3_outR","voice4_outL","voice4_outR"],ctrlIn:["gate1","gate2","gate3","gate4","pitch1","pitch2","pitch3","pitch4"],ctrlOut:[]}},E={Filter:{label:"Filter",desc:"SVF: lowpass/bandpass/highpass/notch.",params:{mode:"lowpass",cutoff_hz:1200,resonance:.2,lfo_min_hz:100,lfo_max_hz:4e3,map:{cutMin:60,cutMax:16e3,resMin:0,resMax:1}},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["cutoff_hz","resonance","mode"],ctrlOut:[]},Distortion:{label:"Distortion",desc:"Waveshaping distortion with pre/post filtering. Presets: Clean, Overdrive, Fuzz, Speaker, Bitcrush. CV preset switching for rhythmic effects.",params:{preset:"overdrive",drive:2.5,tone:2e3,tone_q:.7,mix:.8,bypassMode:"toggle",presetCrossfade:0},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["drive","tone","mix","bypass","preset_cv"],ctrlOut:[]},VCA:{label:"VCA",desc:"Voltage Controlled Amplifier (gain 0..1).",params:{gain:.4},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["gain"],ctrlOut:[]},Delay:{label:"Delay",desc:"Stereo delay with tempo sync, ping-pong, freeze, and pitch-shift.",params:{time_ms:380,feedback:.35,mix:.3,pingpong:0,freeze:0,pitch_shift:1,division:1},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["time_ms","feedback","mix","pingpong","freeze","pitch_shift","division","tempo_hz"],ctrlOut:[]},CleanReverb:{label:"Reverb",desc:"Schroeder reverb with quality presets. Standard: ~28KB (40ms tails), High: ~100KB (140ms tails), Ultra: ~426KB (594ms tails). Choose quality based on patch complexity. OPI PSRAM required for ESP32-S3-WROOM-1-N16R8.",params:{mix:.25,size:.5,damp:.4,quality:"ultra"},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["mix","size","damp"],ctrlOut:[]},AudioMath:{label:"Audio Math",desc:"Multi-function audio processor: AM (amplitude modulation), crossfade, ring modulation, and vocoder - mode selectable.",params:{mode:"am",blend:.5,sensitivity:1},audioIn:["inA","inB"],audioOut:["out"],ctrlIn:["blend","sensitivity","mode"],ctrlOut:["env_follow"]},Limiter:{label:"Limiter",desc:"Audio limiter prevents clipping. Threshold 0-1, ratio 1:1 to :1.",params:{threshold:.8,ratio:4,attack_ms:1,release_ms:10},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["threshold","ratio"],ctrlOut:[]},Panner:{label:"Stereo Panner",desc:"Constant-power pan; width 0..1.",params:{pan:.5,width:1},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["pan","width"],ctrlOut:[]},StereoMixer4:{label:"Stereo Mixer (4ch)",desc:"4 stereo channels with volume/pan. Hardware banking uses 2 banks: Bank 1 (volume/mute): Pots=volumes, Buttons=mutes. Bank 2 (pan/solo): Pots=pans, Encoder HOLD+Buttons=solo.",params:{g1:.35,g2:.35,g3:.35,g4:.35,master:1,pan1:.5,pan2:.5,pan3:.5,pan4:.5,start_bank:1,mute1:!1,mute2:!1,mute3:!1,mute4:!1,solo_channel:0},audioIn:["1L","1R","2L","2R","3L","3R","4L","4R"],audioOut:["outL","outR"],ctrlIn:["g1","g2","g3","g4","master","pan1","pan2","pan3","pan4"],ctrlOut:[]},Matrix2x2:{label:"Matrix Mixer 22",desc:"Feedback-capable: A/B inputs  A/B outputs via 22 matrix.",params:{aa:1,ab:0,ba:0,bb:1},audioIn:["inAL","inAR","inBL","inBR"],audioOut:["outAL","outAR","outBL","outBR"],ctrlIn:["aa","ab","ba","bb"],ctrlOut:[]},ChorusFlangeRing:{label:"Chorus/Flange/Ring",desc:"Mod delay or ring mod; mix/feedback.",params:{mode:"chorus",rate_hz:.5,depth_ms:3,delay_ms:8,feedback:.15,mix:.35,rm_hz:40},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["rate_hz","depth_ms","delay_ms","feedback","mix","rm_hz","mode"],ctrlOut:[]},GranularSynth:{label:"Granular Synth",desc:"Experimental granular synthesis with 4 grains, variable grain size (10-200ms), and advanced controls: randomization, freeze, reverse playback, and CV pitch. Lighter CPU than Dense for stacking. 8MB PSRAM enables larger buffers.",params:{grain_density:6,grain_size_ms:50,position:.5,position_spread:.2,pitch:0,pitch_spread:.1,dry_wet:1,freeze:0,randomize:0,reverse_prob:0,envelope:"hann"},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["grain_density","grain_size_ms","position","position_spread","pitch","pitch_spread","dry_wet","freeze","randomize","reverse"],ctrlOut:[]},GranularDense:{label:"Granular Dense",desc:"Dense granular synthesis with 20 concurrent 32ms grains. Alternating grains reversed, stereo spread, cloud panning. Supports 1-4 grouped pitch CV inputs with optional grouped panning. CPU: ~76% at max density (round-robin processing + envelope table lookup).",params:{grain_density:15,position:.5,position_spread:.3,pitch:0,pitch_spread:.1,envelope:"hann",dry_wet:1,freeze:0,stereo_width:.5,cloud_pan:.5,grouped_panning:0},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["grain_density","position","pitch","dry_wet","freeze","stereo_width","cloud_pan","pitch_cv_1","pitch_cv_2","pitch_cv_3","pitch_cv_4"],ctrlOut:[]},NoiseGate:{label:"Noise Gate",desc:"Gate with threshold and sidechain. Blocks audio below threshold, with gate output for triggering.",params:{threshold:.1,attack_ms:1,release_ms:50,ratio:10},audioIn:["inL","inR","sidechainL","sidechainR"],audioOut:["outL","outR"],ctrlIn:["threshold","attack_ms","release_ms"],ctrlOut:["gate"]},EQ8:{label:"8-Band EQ",desc:"Graphic EQ (8 peaking bands).",params:{b1:0,b2:0,b3:0,b4:0,b5:0,b6:0,b7:0,b8:0},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["b1","b2","b3","b4","b5","b6","b7","b8"],ctrlOut:[]},Resonance:{label:"Resonance",desc:"Resonant object exploration: impulse response capture, FFT analysis, auto-tuning to detected frequencies. Requires v2.0 hardware (contact mic, exciter, gyroscope).",params:{mode:"discovery",fftSize:8192,impulseLength:1e3,sweepDuration:1e4,sweepStart:20,sweepEnd:1e4,threshold:-60,maxPeaks:16,objectSlot:0,autoTune:!0,hapticEnable:!1,gyroSensitivity:1,hapticIntensity:.5},audioIn:["contactMic"],audioOut:["exciter"],ctrlIn:["trigger","mode_select","object_select","sensitivity","intensity"],ctrlOut:["freq1","freq2","freq3","freq4","freq5","freq6","freq7","freq8","analysis_complete","resonance_strength"]},Looper:{label:"Looper",desc:"Advanced looper with overdubbing, Frippertronics decay, reverse, and tape speed control. Up to 20s using PSRAM.",params:{mix:1,playback_gain:1,fade_ms:10,overdub_gain:.8},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["record","decay","reverse","speed"],ctrlOut:["position","length","state","led"]},AudioRecorder:{label:"Audio Recorder",desc:"Standalone recorder/player with dedicated bank. 4-button control: Record/Play-Pause/Prev/Next. 24-bit recording, file navigation, playback modes. USES 1 BANK.",params:{bank:1,file_prefix:"rec",current_file_index:1,max_duration_sec:60,bit_depth:24,input_gain:1,playback_volume:1,playback_mode:0,playback_speed:.5,recording:!1,playing:!1,sck:12,miso:11,mosi:10,cs:9},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:[],ctrlOut:[]},BPMLooper:{label:"BPM Looper",desc:"4-slot beat-synced looper with slice randomization and pitch control. USES 2 CONSECUTIVE BANKS (e.g., Banks 1-2). Turn encoder to switch modes. Bank 1: record/mix (red/green LEDs). Bank 2: randomization/pitch (blue/cyan/yellow LEDs). ~5.6MB PSRAM.",params:{start_bank:1,slot1_length:.25,slot2_length:.5,slot3_length:2,slot4_length:4,slot1_slices_per_beat:8,slot2_slices_per_beat:8,slot3_slices_per_beat:8,slot4_slices_per_beat:8,internal_bpm:120,use_external_clock:!1,mix:1,master_gain:1,slot1_state:"empty",slot2_state:"empty",slot3_state:"empty",slot4_state:"empty",slot1_oneshot:!1,slot2_oneshot:!1,slot3_oneshot:!1,slot4_oneshot:!1,slot1_randomization:0,slot2_randomization:0,slot3_randomization:0,slot4_randomization:0,slot1_pitch:1,slot2_pitch:1,slot3_pitch:1,slot4_pitch:1,show_trigger_inputs:!1},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["clock","slot1_trig","slot2_trig","slot3_trig","slot4_trig","slot1_pitch","slot2_pitch","slot3_pitch","slot4_pitch"],ctrlOut:[]}},P={LineIn:{label:"Stereo In",desc:"PCM1802 ADC stereo line input with gain control. Uses GPIO16 MCLK (required). MCP23017 GPB2/GPB3=LOW enables line input.",params:{pin_din:8,pin_mclk:16,gain:2,dc_block:!0,rate:44100},audioIn:[],audioOut:["L","R"],ctrlIn:["gain"],ctrlOut:[]},Piezo:{label:"Piezo In",desc:"Contact mic input (PCM1802 left channel, mono to stereo). Uses GPIO16 MCLK. Higher gain range for piezo sensitivity (4x-64x).",params:{pin_din:8,pin_mclk:16,gain:4,dc_block:!0,rate:44100},audioIn:[],audioOut:["L","R"],ctrlIn:["gain"],ctrlOut:[]},Coil:{label:"Coil In",desc:"Coil pickup input (PCM1802 right channel, mono to stereo, 65Hz HPF). Uses GPIO16 MCLK. Higher gain for weak coil output.",params:{pin_din:8,pin_mclk:16,gain:48,dc_block:!0,hpf_cutoff:65,rate:44100},audioIn:[],audioOut:["L","R"],ctrlIn:["gain"],ctrlOut:[]},I2SOut:{label:"Stereo Out",desc:"IS DAC output (stereo)",params:{pin_bck:15,pin_lrck:17,pin_data:18,rate:44100},audioIn:["L","R"],audioOut:[],ctrlIn:[],ctrlOut:[]},Exciter:{label:"Exciter Out",desc:"PAM8302 amplifier enable for exciter speaker (left output channel). Enables/disables amp via MCP23017 GPB6.",params:{enabled:!0},audioIn:[],audioOut:[],ctrlIn:[],ctrlOut:[]},SDPlayer:{label:"SD Player",desc:"Streams 16-bit WAV (44.1k) from /sd (SPI).",params:{sck:41,miso:14,mosi:45,cs:16,mount:"/sd",fileMin:1,fileMax:32,loop:!0,gain:.8},audioIn:[],audioOut:["L","R"],ctrlIn:["trig","stop","gain","file_index"],ctrlOut:[]}},w={ADSR:{label:"ADSR",desc:"Advanced envelope generator with ADSR and freeform modes, looping, and timescale control.",params:{attack_ms:50,decay_ms:200,sustain:.7,release_ms:300,loop_mode:"oneshot",timescale:1,trigger_mode:"gate",breakpoints:[{time:0,level:0,curve:.5},{time:.1,level:1,curve:.3},{time:.3,level:.7,curve:.7},{time:.8,level:.7,curve:.5},{time:1,level:0,curve:.8}]},audioIn:[],audioOut:[],ctrlIn:["gate","trigger","attack_ms","decay_ms","sustain","release_ms","timescale"],ctrlOut:["env"]},LFO:{label:"LFO",desc:"Low Frequency Oscillator with clock sync and configurable rate range.",params:{rate_hz:1,rate_min_hz:.01,rate_max_hz:40,wave:"sine",sync_to_clock:!1,clock_div:4,phase:0,depth:1,offset:0},audioIn:[],audioOut:[],ctrlIn:["rate_hz","wave","depth","offset","clock"],ctrlOut:["out"]},Scale:{label:"Scale",desc:"Quantise control  musical scale/tuning with CV control of scale and tuning.",params:{tuning:"12-TET",scale:"major",root_note:"C",octave_range:2,base_octave:4,snap_amount:1},audioIn:[],audioOut:[],ctrlIn:["in","tuning_cv","scale_cv"],ctrlOut:["out"]},Automation:{label:"Automation",desc:"Records and loops control automation. Long-press encoder button (>1s) to record pot/button movements. Dynamically expands inputs - connect to add more ports.",params:{buffer_size:1e3,recording:!1,playing:!1,loop:!0,num_inputs:4},audioIn:[],audioOut:[],ctrlIn:["in_1","in_2","in_3","in_4","in_5","in_6","in_7","in_8","record_trigger","mode_select","clock"],ctrlOut:["out_1","out_2","out_3","out_4","out_5","out_6","out_7","out_8"]},Modulation:{label:"Modulation (4LFO)",desc:"4 LFOs; map rates or keep static.",params:{rate1_hz:1,rate2_hz:.5,rate3_hz:2,rate4_hz:4,rate1_min_hz:.01,rate1_max_hz:20,rate2_min_hz:.01,rate2_max_hz:20,rate3_min_hz:.01,rate3_max_hz:20,rate4_min_hz:.01,rate4_max_hz:20},audioIn:[],audioOut:[],ctrlIn:["rate1","rate2","rate3","rate4"],ctrlOut:["lfo1","lfo2","lfo3","lfo4"]},Clock:{label:"Clock (8-out)",desc:"8-output clock divider/multiplier like Pamela's NEW Workout. Algorithmic sequencing.",params:{bpm:120,swing:0,follow_midi:!0,bpm_min:30,bpm_max:600,output_select:1,division_select:1,running:!0,bank:0,use_outputs_5_8:!1,show_advanced_outputs:!1,rate1:1,rate2:.5,rate3:.25,rate4:.125,rate5:2,rate6:4,rate7:8,rate8:16,euclid1:1,euclid2:1,euclid3:1,euclid4:1,euclid5:1,euclid6:1,euclid7:1,euclid8:1,gate_mode1:!0,gate_mode2:!0,gate_mode3:!0,gate_mode4:!0,gate_mode5:!1,gate_mode6:!1,gate_mode7:!1,gate_mode8:!1,prob1:1,prob2:1,prob3:1,prob4:1,prob5:1,prob6:1,prob7:1,prob8:1},audioIn:[],audioOut:[],ctrlIn:["bpm_input","output_select","division_select","start_stop"],ctrlOut:["out1","out2","out3","out4","out5","out6","out7","out8","master_phase","master_pulse"]},HarmonicSequencer:{label:"Harmonic Sequencer",desc:"4-step hardware sequencer with banking integration and melodic patterns.",params:{start_bank:1,running:!1,current_step:0,loop_start:0,loop_end:3,loop_active:!1,bpm:120,clock_div:4,swing:0,gate_length:.7,steps:[{pitch:0,duration:1,muted:!1,active:!0,pattern:"octave",interval:12,probability:1,patternProbability:1,chordIntervals:[0,12],chordDiatonic:!0},{pitch:.25,duration:1,muted:!1,active:!0,pattern:"up_down",interval:3,probability:1,patternProbability:1,chordIntervals:[0,4,7],chordDiatonic:!0},{pitch:.5,duration:1,muted:!1,active:!0,pattern:"chord",interval:4,probability:1,patternProbability:1,chordIntervals:[0,4,7,11],chordDiatonic:!0},{pitch:.75,duration:1,muted:!1,active:!0,pattern:"static",interval:1,probability:1,patternProbability:1,chordIntervals:[0,7],chordDiatonic:!1}],hardware_pots:[1,2,3,4],hardware_btns:[1,2,3,4],scale_connected:!1,scale_root:"C",scale_type:"major",octave_center:4,show_individual_outputs:!1,sum_output_enabled:!0,individual_outputs_enabled:!1,playback_mode:"iteration",harmonic_linking:!1,harmonic_follow_steps:[-1,-1,-1,-1],harmonic_intervals:[7,7,7,7],pattern_enabled:!1},audioIn:[],audioOut:[],ctrlIn:["clock","start_stop","gate","swing","gate_length","bpm","clock_div"],ctrlOut:["pitch_sum","pitch_hz","gate_sum","pitch_step1","pitch_step1_hz","gate_step1","pitch_step2","pitch_step2_hz","gate_step2","pitch_step3","pitch_step3_hz","gate_step3","pitch_step4","pitch_step4_hz","gate_step4","current_step_cv","current_bank_cv","running","loop_active"]},GateGen:{label:"Gate Generator",desc:"Clock-triggered gate with built-in Sample & Hold and optional gate input for manual control.",params:{gate_length:.8,retrigger:!0,self_clock_bpm:120,use_self_clock:!0,probability:1,sh_enabled:!0,gate_control:!1,bpm_min:40,bpm_max:180,led_flash_ms:0},audioIn:[],audioOut:[],ctrlIn:["clock","gate_input","gate_length","self_clock_bpm","probability","sh_input"],ctrlOut:["gate","sh_output","rate"]},Invert:{label:"Invert",desc:"Inverts control signals (1-x). Useful for inverting gates, envelopes, LFOs, etc.",params:{offset:0,scale:1},audioIn:[],audioOut:[],ctrlIn:["in","offset","scale"],ctrlOut:["out"]}},C={Pot:{label:"Pot",desc:"Analog pot (0..1). Banked; smoothing kills jitter.",params:{pin:7,bank:1,index:1,locked:!1,smooth:.2,avgN:4,debug:!1},audioIn:[],audioOut:[],ctrlIn:[],ctrlOut:["value"]},LEDButton:{label:"Button",desc:"Momentary + LED. Debounced, banked.",params:{pin:0,ledPin:6,bank:1,index:1,locked:!1,debug:!1,mode:"latching",toggleValues:[100,50],sampleHold:!1},audioIn:[],audioOut:[],ctrlIn:["led","sampleIn"],ctrlOut:["press","gate","value","sampleOut"]},GateIn:{label:"Gate In",desc:"External gate/trigger input via LTV816 optoisolator. Select Gate In 1 or 2.",params:{index:1,debounce_ms:5,mode:"trigger",locked:!1},audioIn:[],audioOut:[],ctrlIn:[],ctrlOut:["gate","trigger"]},MIDIIn:{label:"MIDI In",desc:"UART MIDI input via TLP2361 optocoupler. Outputs: note (0-1 CV), gate, velocity (0-1).",params:{channel:0},audioIn:[],audioOut:[],ctrlIn:[],ctrlOut:["note","gate","velocity"]},MIDIOut:{label:"MIDI Out",desc:"UART MIDI output. Note and multiple CC outputs with dynamic port expansion (like Automation module). TX=GPIO43.",params:{channel:1,num_cc:1,cc_numbers:[1,2,3,4,5,6,7,8]},audioIn:[],audioOut:[],ctrlIn:["note","gate","velocity","cc_1","cc_2","cc_3","cc_4","cc_5","cc_6","cc_7","cc_8"],ctrlOut:[]},USBMIDIIn:{label:"USB MIDI In",desc:"USB MIDI input (class-compliant, GPIO19/20). Outputs: note (0-1 CV), gate, velocity. Low latency ~1-3ms. Channel 1-16 or 0 for omni.",params:{channel:1},audioIn:[],audioOut:[],ctrlIn:[],ctrlOut:["note","gate","velocity"]},USBMIDIOut:{label:"USB MIDI Out",desc:"USB MIDI output with multi-channel routing. Each note/CC output can target different MIDI channels. Dynamically expands ports like Automation module.",params:{num_outputs:1,ch_1:1,ch_2:2,ch_3:3,ch_4:4,ch_5:5,ch_6:6,ch_7:7,ch_8:8,cc_1:1,cc_2:2,cc_3:3,cc_4:4,cc_5:5,cc_6:6,cc_7:7,cc_8:8},audioIn:[],audioOut:[],ctrlIn:["note_1","gate_1","velocity_1","cc_1","note_2","gate_2","velocity_2","cc_2","note_3","gate_3","velocity_3","cc_3","note_4","gate_4","velocity_4","cc_4","note_5","gate_5","velocity_5","cc_5","note_6","gate_6","velocity_6","cc_6","note_7","gate_7","velocity_7","cc_7","note_8","gate_8","velocity_8","cc_8"],ctrlOut:[]}},R={Panner:E.Panner,StereoMixer4:E.StereoMixer4,Matrix2x2:E.Matrix2x2},L={GranularSynth:E.GranularSynth,GranularDense:E.GranularDense,Looper:E.Looper,BPMLooper:E.BPMLooper,AudioRecorder:E.AudioRecorder},I={Clock:w.Clock,HarmonicSequencer:w.HarmonicSequencer,GateGen:w.GateGen},M={Filter:E.Filter,Distortion:E.Distortion,VCA:E.VCA,Delay:E.Delay,CleanReverb:E.CleanReverb,AudioMath:E.AudioMath,Limiter:E.Limiter,ChorusFlangeRing:E.ChorusFlangeRing,NoiseGate:E.NoiseGate,EQ8:E.EQ8,Resonance:E.Resonance},D=k(k(k({},x),E),P),A=k(k(k({},D),w),C),O={EXAMPLES:[{name:"Audio Recorder Patch",description:"LineIn  AudioRecorder  I2SOut with recording/playback controls",patch:{version:"1.0",modules:[{id:"LineIn1",type:"LineIn",x:100,y:200,params:{pin_din:8,pin_mclk:16,gain:2,dc_block:!0,rate:44100}},{id:"AudioRecorder1",type:"AudioRecorder",x:350,y:200,params:{bank:1,file_prefix:"rec",current_file_index:1,max_duration_sec:60,bit_depth:24,input_gain:1,playback_volume:1,playback_mode:0,playback_speed:.5,recording:!1,playing:!1,sck:12,miso:11,mosi:10,cs:9}},{id:"I2SOut1",type:"I2SOut",x:600,y:200,params:{pin_bck:15,pin_lrck:17,pin_data:18,rate:44100}}],connections:[{from:{id:"LineIn1:L",port:"L",kind:"audio"},to:{id:"AudioRecorder1:inL",port:"inL",kind:"audio"}},{from:{id:"LineIn1:R",port:"R",kind:"audio"},to:{id:"AudioRecorder1:inR",port:"inR",kind:"audio"}},{from:{id:"AudioRecorder1:outL",port:"outL",kind:"audio"},to:{id:"I2SOut1:L",port:"L",kind:"audio"}},{from:{id:"AudioRecorder1:outR",port:"outR",kind:"audio"},to:{id:"I2SOut1:R",port:"R",kind:"audio"}}]}},{name:"FM Synthesis",description:"Two oscillators with FM modulation, ratio control, and LFO depth modulation. Pot1=FM ratio, Pot2=Freq, Pot3=LFO rate, Pot4=LFO depth",patch:{version:"1.0",modules:[{id:"Wavetable1",type:"Wavetable",x:100,y:150,params:{freq:220,gain:.25,gate:1,pitch_range:24,fm_amount:0,fm_tracking:!0,fm_ratio:1,fm_ratio_mode:"zones",wavetables:[],current_table:0,adsr_morph:!1,attack_table:0,decay_table:1,sustain_table:2,release_table:3,editor_settings:{table_size:512,draw_mode:"sine",current_editing:0}}},{id:"Wavetable2",type:"Wavetable",x:350,y:150,params:{freq:220,gain:.25,gate:1,pitch_range:24,fm_amount:.5,fm_tracking:!1,fm_ratio:1,fm_ratio_mode:"zones",wavetables:[],current_table:0,adsr_morph:!1,attack_table:0,decay_table:1,sustain_table:2,release_table:3,editor_settings:{table_size:512,draw_mode:"sine",current_editing:0}}},{id:"I2SOut1",type:"I2SOut",x:600,y:150,params:{pin_bck:15,pin_lrck:17,pin_data:18,rate:44100}},{id:"LFO1",type:"LFO",x:200,y:300,params:{rate_hz:1,rate_min_hz:.1,rate_max_hz:10,wave:"sine",depth:1,offset:0}},{id:"Pot1",type:"Pot",x:50,y:450,params:{pin:4,index:1,bank:1,smooth:.1}},{id:"Pot2",type:"Pot",x:200,y:450,params:{pin:5,index:2,bank:1,smooth:.1}},{id:"Pot3",type:"Pot",x:350,y:450,params:{pin:6,index:3,bank:1,smooth:.1}},{id:"Pot4",type:"Pot",x:500,y:450,params:{pin:7,index:4,bank:1,smooth:.1}}],connections:[{from:{id:"Wavetable1:R",port:"R",kind:"audio"},to:{id:"Wavetable2:fm",port:"fm",kind:"audio"}},{from:{id:"Wavetable2:L",port:"L",kind:"audio"},to:{id:"I2SOut1:L",port:"L",kind:"audio"}},{from:{id:"Wavetable2:R",port:"R",kind:"audio"},to:{id:"I2SOut1:R",port:"R",kind:"audio"}},{from:{id:"Pot1:value",port:"value",kind:"ctrl"},to:{id:"Wavetable1:fm_ratio_cv",port:"fm_ratio_cv",kind:"ctrl"}},{from:{id:"Pot2:value",port:"value",kind:"ctrl"},to:{id:"Wavetable2:freq",port:"freq",kind:"ctrl"}},{from:{id:"Pot3:value",port:"value",kind:"ctrl"},to:{id:"LFO1:rate_hz",port:"rate_hz",kind:"ctrl"}},{from:{id:"LFO1:out",port:"out",kind:"ctrl"},to:{id:"Wavetable2:fm_amount",port:"fm_amount",kind:"ctrl"}},{from:{id:"Pot4:value",port:"value",kind:"ctrl"},to:{id:"LFO1:depth",port:"depth",kind:"ctrl"}}]}},{name:"MicroLooper",description:"Simple 4-slot BPM looper - Stereo In  BPM Looper  Stereo Out",patch:{version:"1.0",modules:[{id:"LineIn1",type:"LineIn",x:100,y:250,params:{pin_din:8,pin_mclk:16,gain:2,dc_block:!0,rate:44100}},{id:"BPMLooper1",type:"BPMLooper",x:400,y:250,params:{start_bank:1,slot1_length:.25,slot2_length:.5,slot3_length:2,slot4_length:4,slot1_slices_per_beat:8,slot2_slices_per_beat:8,slot3_slices_per_beat:8,slot4_slices_per_beat:8,internal_bpm:120,use_external_clock:!1,mix:1,master_gain:1}},{id:"I2SOut1",type:"I2SOut",x:700,y:250,params:{pin_bclk:15,pin_lrck:17,pin_data:18,master_gain:1,rate:44100}}],connections:[{from:{id:"LineIn1:L",port:"L",kind:"audio"},to:{id:"BPMLooper1:inL",port:"inL",kind:"audio"}},{from:{id:"LineIn1:R",port:"R",kind:"audio"},to:{id:"BPMLooper1:inR",port:"inR",kind:"audio"}},{from:{id:"BPMLooper1:outL",port:"outL",kind:"audio"},to:{id:"I2SOut1:L",port:"L",kind:"audio"}},{from:{id:"BPMLooper1:outR",port:"outR",kind:"audio"},to:{id:"I2SOut1:R",port:"R",kind:"audio"}}]}}],AUDIO_SOURCES:Object.keys(x),MIXERS:Object.keys(R),AUDIO_PROCESSORS:Object.keys(M),GRANULAR_LOOPING:Object.keys(L),SEQUENCERS:Object.keys(I),AUDIO_IO:Object.keys(P),CTRL:Object.keys(w),HW:Object.keys(C)},T=["I2SOut"],B=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(!A[e])throw new Error("Unknown module type: ".concat(e));if(!function(e,n){return!T.includes(e)||!n.some(function(n){return n.type===e})}(e,a))throw new Error("Only one ".concat(e," module allowed"));var o=JSON.parse(JSON.stringify(A[e].params)),r=F(e,a),c=null!==n&&null!==t?{x:n,y:t}:function(e,n){var t=A[e];if(!t)return{x:100,y:100};var a,o,r=140,c=0===t.audioIn.length&&t.audioOut.length>0,i=t.audioIn.length>0&&0===t.audioOut.length,l=t.audioIn.length>0&&t.audioOut.length>0,s=t.ctrlOut.length>0&&0===t.audioOut.length,u="Pot"===e||"LEDButton"===e||"Encoder"===e||"MIDIIn"===e,d=n.filter(function(e){var n=A[e.type];return n&&0===n.audioIn.length&&n.audioOut.length>0}).length,p=n.filter(function(e){var n=A[e.type];return n&&n.audioIn.length>0&&n.audioOut.length>0}).length,f=n.filter(function(e){var n=A[e.type];return n&&n.audioIn.length>0&&0===n.audioOut.length}).length,m=n.filter(function(e){var n=A[e.type];return n&&n.ctrlOut.length>0&&0===n.audioOut.length}).length,_=n.filter(function(e){return"Pot"===e.type||"LEDButton"===e.type||"Encoder"===e.type||"MIDIIn"===e.type}).length;if(u){console.log("Positioning hardware ".concat(e,", existing hardware count: ").concat(_)),console.log("Existing nodes:",n.map(function(e){return"".concat(e.type,"(").concat(e.x,",").concat(e.y,")")}));for(var g=!1,h=function(){var t=b[v];if(!n.some(function(e){return Math.abs(e.x-t.x)<80&&Math.abs(e.y-t.y)<80}))return a=t.x,o=t.y,g=!0,console.log("Hardware positioning: ".concat(e," found open spot at (").concat(a,", ").concat(o,")")),1},v=0,b=[{x:50,y:200},{x:50,y:300},{x:150,y:50},{x:400,y:50},{x:450,y:100},{x:600,y:100},{x:700,y:100},{x:450,y:300},{x:600,y:300},{x:150,y:400},{x:350,y:400},{x:550,y:400}];v<b.length&&!h();v++);g||(a=800+_%3*150,o=100+120*Math.floor(_/3),console.log("Hardware positioning: ".concat(e," using fallback at (").concat(a,", ").concat(o,")")))}else c?(a=100,o=80+d*r):l?(a=540,o=80+p*r):i?(a=980,o=80+f*r):s?(a=320,o=80+m*r):(a=760,o=80+n.length*r);return{x:a,y:o}}(e,a);if("Pot"===e||"LEDButton"===e){var i=a.filter(function(n){return n.type===e}),l=z(i,e,a);o.index=l.index,o.bank=l.bank}if("HarmonicSequencer"===e){var s=a.find(function(e){return"HarmonicSequencer"===e.type});if(s){var u,d=(null===(u=s.params)||void 0===u?void 0:u.start_bank)||1;o.start_bank=d<6?d+1:1}else o.start_bank=q(o.step_count||4,a)}if("BPMLooper"===e){var p=a.find(function(e){return"BPMLooper"===e.type});if(p){var f,m=(null===(f=p.params)||void 0===f?void 0:f.start_bank)||1;o.start_bank=m+2<=5?m+2:1}else o.start_bank=U(a)}if("StereoMixer4"===e){var _=a.find(function(e){return"StereoMixer4"===e.type});if(_){var g,h=(null===(g=_.params)||void 0===g?void 0:g.start_bank)||1;o.start_bank=h<6?h+1:1}else o.start_bank=W(a)}if("Clock"===e){var v=a.find(function(e){return"Clock"===e.type});if(v){var b,y,k=((null===(b=v.params)||void 0===b?void 0:b.bank)||1)+((null===(y=v.params)||void 0===y?void 0:y.use_outputs_5_8)?2:1);o.bank=k<=(o.use_outputs_5_8?5:6)?k:1}else o.bank=V(a,o.use_outputs_5_8||!1)}return{id:r,type:e,x:c.x,y:c.y,params:o}},z=function(e,n,t){for(var a=t.some(function(e){return"HarmonicSequencer"===e.type})?2:1,o={},r=1;r<=4;r++)o[r]=[];var c=new Set;if(e.forEach(function(e){var n,t,a,r=(null===(n=e.params)||void 0===n?void 0:n.index)||1,i=(null===(t=e.params)||void 0===t?void 0:t.bank)||1,l=(null===(a=e.params)||void 0===a?void 0:a.locked)||!1;r>=1&&r<=4&&(l?c.add(r):o[r].push(i))}),e.length>=24)throw new Error("Cannot create more ".concat(n," modules. Hardware limit reached: ").concat(24," virtual ").concat(n,"s maximum (").concat(4," physical  ").concat(6," banks)"));for(var i=a;i<=6;i++)for(var l=1;l<=4;l++)if(!c.has(l)&&!o[l].includes(i))return{index:l,bank:i};throw new Error("Internal error: No available hardware slot found for ".concat(n))},F=function(e,n){var t=n.filter(function(n){return n.type===e}).reduce(function(n,t){var a=t.id.match(new RegExp("^".concat(e,"(\\d+)$"))),o=a?parseInt(a[1]):0;return Math.max(n,o)},0);return"".concat(e).concat(t+1)},N=function(e){var n,t,a,o=A[e.type];if(!o)return{left:[],right:[]};var r=o.audioIn,c=o.audioOut,i=o.ctrlIn,l=o.ctrlOut;if("Clock"===e.type){var s,u,d=(null===(s=e.params)||void 0===s?void 0:s.use_outputs_5_8)||!1,p=(null===(u=e.params)||void 0===u?void 0:u.show_advanced_outputs)||!1;l=l.filter(function(e){return"out1"===e||"out2"===e||"out3"===e||"out4"===e||("out5"===e||"out6"===e||"out7"===e||"out8"===e?d:"master_phase"!==e&&"master_pulse"!==e||p)})}if("HarmonicSequencer"!==e.type||null!==(n=e.params)&&void 0!==n&&n.show_individual_outputs||(l=l.filter(function(e){return"pitch_sum"===e||"pitch_hz"===e||"gate_sum"===e||"current_step"===e||"current_bank"===e})),"DrumDesigner4"!==e.type||null!==(t=e.params)&&void 0!==t&&t.show_individual_outputs||(c=c.filter(function(e){return"mixL"===e||"mixR"===e})),"BPMLooper"!==e.type||null!==(a=e.params)&&void 0!==a&&a.show_trigger_inputs||(i=i.filter(function(e){return"clock"===e})),"Automation"===e.type){var f,m=(null===(f=e.params)||void 0===f?void 0:f.num_inputs)||1;i=i.filter(function(e,n){return"record_trigger"===e||parseInt(e.split("_")[1])<=m}),l=l.filter(function(e){return parseInt(e.split("_")[1])<=m})}if("MIDIOut"===e.type){var _,g=(null===(_=e.params)||void 0===_?void 0:_.num_cc)||1;i=i.filter(function(e){return"note"===e||"gate"===e||"velocity"===e||!e.startsWith("cc_")||parseInt(e.split("_")[1])<=g})}if("USBMIDIOut"===e.type){var h,v=(null===(h=e.params)||void 0===h?void 0:h.num_outputs)||1;i=i.filter(function(e){var n=e.match(/^(note|gate|velocity|cc)_(\d+)$/);return!!n&&parseInt(n[2])<=v})}var b=Math.max(80,20*Math.max(r.length+i.length,c.length+l.length)+40),y=[],k=[],S=e.y+25+10,x=e.y+25+10;r.forEach(function(n){y.push({kind:"audio",side:"left",id:"".concat(e.id,":").concat(n),port:n,x:e.x,y:S}),S+=18}),i.forEach(function(n){y.push({kind:"ctrl",side:"left",id:"".concat(e.id,":").concat(n),port:n,x:e.x,y:S}),S+=18});var E=e.x+140;return c.forEach(function(n){k.push({kind:"audio",side:"right",id:"".concat(e.id,":").concat(n),port:n,x:E,y:x}),x+=18}),l.forEach(function(n){k.push({kind:"ctrl",side:"right",id:"".concat(e.id,":").concat(n),port:n,x:E,y:x}),x+=18}),{left:y,right:k,width:140,height:b,head:25}},G=function(e,n,t){for(var a=n,o=[],r=function(e){var n=t.filter(function(n){var t;return("Pot"===n.type||"LEDButton"===n.type)&&((null===(t=n.params)||void 0===t?void 0:t.bank)||1)===e});n.length>0&&o.push({bank:e,modules:n})},c=n;c<=a;c++)r(c);return{banksRequired:1,endBank:a,conflicts:o,isValid:a<=6&&0===o.length}},q=function(e,n){for(var t=1;t<=6;t++)if(G(0,t,n).isValid)return t;return 1},U=function(e){for(var n,t,a,o=e.find(function(e){return"HarmonicSequencer"===e.type}),r=(null==o||null===(n=o.params)||void 0===n?void 0:n.start_bank)||null,c=e.find(function(e){return"BPMLooper"===e.type}),i=(null==c||null===(t=c.params)||void 0===t?void 0:t.start_bank)||null,l=i?i+1:null,s=function(n){var t=n+1,a=!1;!r||r!==n&&r!==t||(a=!0),i&&l&&(n>=i&&n<=l||t>=i&&t<=l)&&(a=!0);var o=e.some(function(e){var a,o,r;return!("Pot"!==e.type&&"LEDButton"!==e.type||null!==(a=e.params)&&void 0!==a&&a.locked||((null===(o=e.params)||void 0===o?void 0:o.bank)||1)!==n&&((null===(r=e.params)||void 0===r?void 0:r.bank)||1)!==t)});return a||o?0:{v:n}},u=1;u<=5;u++)if(0!==(a=s(u))&&a)return a.v;return 3},W=function(e){for(var n,t,a,o=e.find(function(e){return"HarmonicSequencer"===e.type}),r=(null==o||null===(n=o.params)||void 0===n?void 0:n.start_bank)||null,c=e.find(function(e){return"BPMLooper"===e.type}),i=(null==c||null===(t=c.params)||void 0===t?void 0:t.start_bank)||null,l=i?i+1:null,s=e.find(function(e){return"StereoMixer4"===e.type}),u=(null==s||null===(a=s.params)||void 0===a?void 0:a.start_bank)||null,d=u?u+1:null,p=1;p<=5;p++){for(var f=!1,m=function(){var n=p+_;r&&r===n&&(f=!0),i&&l&&n>=i&&n<=l&&(f=!0),u&&d&&n>=u&&n<=d&&(f=!0),e.some(function(e){var t,a;return!("Pot"!==e.type&&"LEDButton"!==e.type||null!==(t=e.params)&&void 0!==t&&t.locked||((null===(a=e.params)||void 0===a?void 0:a.bank)||1)!==n)})&&(f=!0)},_=0;_<=1;_++)m();if(!f)return p}return 2},V=function(e,n){for(var t,a,o,r,c,i=e.find(function(e){return"HarmonicSequencer"===e.type}),l=(null==i||null===(t=i.params)||void 0===t?void 0:t.start_bank)||null,s=e.find(function(e){return"BPMLooper"===e.type}),u=(null==s||null===(a=s.params)||void 0===a?void 0:a.start_bank)||null,d=u?u+1:null,p=e.find(function(e){return"StereoMixer4"===e.type}),f=(null==p||null===(o=p.params)||void 0===o?void 0:o.start_bank)||null,m=f?f+1:null,_=e.find(function(e){return"Clock"===e.type}),g=(null==_||null===(r=_.params)||void 0===r?void 0:r.bank)||null,h=(null==_||null===(c=_.params)||void 0===c?void 0:c.use_outputs_5_8)||!1,v=g&&h?g+1:g,b=n?5:6,y=1;y<=b;y++){for(var k=!1,S=function(){var n=E[x];l&&l===n&&(k=!0),u&&d&&n>=u&&n<=d&&(k=!0),f&&m&&n>=f&&n<=m&&(k=!0),g&&v&&n>=g&&n<=v&&(k=!0),e.some(function(e){var t,a;return!("Pot"!==e.type&&"LEDButton"!==e.type||null!==(t=e.params)&&void 0!==t&&t.locked||((null===(a=e.params)||void 0===a?void 0:a.bank)||1)!==n)})&&(k=!0)},x=0,E=n?[y,y+1]:[y];x<E.length;x++)S();if(!k)return y}return 4},H={metadata:{label:"Looper",desc:"Advanced looper with overdubbing, Frippertronics decay, reverse, and tape speed control. Up to 20s using PSRAM.",params:{mix:1,playback_gain:1,fade_ms:10,overdub_gain:.8},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["record","decay","reverse","speed"],ctrlOut:["position","length","state","led"]},generateClass:function(e,n){return"\nclass Looper_".concat(e," {\nprivate:\n  static constexpr int MAX_LOOP_SAMPLES = ").concat(882e3,";\n  \n  // Simple looper state\n  float* bufferL = nullptr;\n  float* bufferR = nullptr;\n  int bufferSize = 0;        // Actual allocated buffer size \n  int length = 0;            // Recorded loop length\n  int writePos = 0;          // Current write position\n  float readPosFloat = 0.0f; // Current read position (float for smooth playback)\n  \n  enum State { EMPTY, RECORDING, PLAYING, OVERDUBBING, MUTED } state = EMPTY;\n\n  // Parameters\n  float mix = ").concat((n.mix||1).toFixed(1),"f;\n  float playbackGain = ").concat((n.playback_gain||2).toFixed(1),"f;\n  float overdubGain = ").concat((n.overdub_gain||.8).toFixed(1),'f;\n\n  // Control inputs\n  float recordButton = 0.0f;\n  float lastRecordButton = 0.0f;\n  float decayControl = 1.0f;      // 0.0-1.0: decay rate (1.0 = no decay, 0.0 = fast decay)\n  float reverseControl = 0.0f;    // 0.0 = forward, 1.0 = reverse\n  float speedControl = 0.5f;      // 0.0-1.0: maps to speed range (0.5 = 1.0x normal speed)\n\n  // Playback direction\n  float playbackDirection = 1.0f; // 1.0 = forward, -1.0 = reverse\n\n  // Button timing for long-press clear detection\n  unsigned long buttonPressTime = 0;\n  bool longPressHandled = false;\n  \npublic:\n  float outL = 0.0f;\n  float outR = 0.0f;\n  float positionOut = 0.0f;\n  float lengthOut = 0.0f;\n  float stateOut = 0.0f;\n  float ledOut = 0.0f;  // LED control output\n\n  void init() {\n    // Try to allocate PSRAM buffer\n    bufferL = (float*)ps_malloc(MAX_LOOP_SAMPLES * sizeof(float));\n    bufferR = (float*)ps_malloc(MAX_LOOP_SAMPLES * sizeof(float));\n    \n    if (!bufferL || !bufferR) {\n      Serial.println("Looper_').concat(e,': PSRAM allocation failed, using smaller SRAM fallback");\n      // Fall back to smaller SRAM buffer\n      if (bufferL) { free(bufferL); bufferL = nullptr; }\n      if (bufferR) { free(bufferR); bufferR = nullptr; }\n      \n      int fallbackSize = 44100; // 1 second\n      bufferL = (float*)malloc(fallbackSize * sizeof(float));\n      bufferR = (float*)malloc(fallbackSize * sizeof(float));\n      bufferSize = fallbackSize;\n    } else {\n      bufferSize = MAX_LOOP_SAMPLES;\n      Serial.printf("Looper_').concat(e,': Allocated %.1f seconds of PSRAM\\n", (float)bufferSize / 44100.0);\n    }\n    \n    // Clear buffers\n    if (bufferL && bufferR) {\n      memset(bufferL, 0, bufferSize * sizeof(float));\n      memset(bufferR, 0, bufferSize * sizeof(float));\n    }\n  }\n\n  void setControl(int index, float value) {\n    switch(index) {\n      case 0: // record button\n        recordButton = value;\n        break;\n      case 1: // decay control\n        decayControl = constrain(value, 0.0f, 1.0f);\n        break;\n      case 2: // reverse control\n        reverseControl = constrain(value, 0.0f, 1.0f);\n        break;\n      case 3: // speed control\n        speedControl = constrain(value, 0.0f, 1.0f);\n        break;\n    }\n  }\n\n  void process(float inL, float inR) {\n    // Simple tap-to-record/tap-to-play behavior\n    \n    // Debug button state periodically\n    static unsigned long lastDebug = 0;\n    static float lastRecordButtonDebug = -1;\n    if (recordButton != lastRecordButtonDebug || millis() - lastDebug > 2000) {\n      lastDebug = millis();\n      lastRecordButtonDebug = recordButton;\n      Serial.print("LOOPER DEBUG - recordButton: ");\n      Serial.print(recordButton);\n      Serial.print(", state: ");\n      Serial.println(state == EMPTY ? "EMPTY" : (state == RECORDING ? "RECORDING" : (state == PLAYING ? "PLAYING" : (state == OVERDUBBING ? "OVERDUBBING" : "MUTED"))));\n    }\n    \n    // Handle button press events - detect rising edge to prevent multiple triggers per buffer\n    bool buttonPressed = (recordButton > 0.5f && lastRecordButton <= 0.5f);  // Rising edge only\n    bool buttonReleased = (recordButton <= 0.5f && lastRecordButton > 0.5f); // Falling edge\n\n    // Track button press/release for long-press detection\n    if (buttonPressed) {\n      buttonPressTime = millis();\n      longPressHandled = false;\n      Serial.println("LOOPER: Button pressed");\n    }\n\n    // Long press detection (>1000ms) - Clear loop on RELEASE after long press\n    if (buttonReleased && !longPressHandled && (millis() - buttonPressTime > 1000)) {\n      Serial.println("LOOPER: Long press released - clearing loop");\n      state = EMPTY;\n      length = 0;\n      writePos = 0;\n      readPosFloat = 0.0f;\n      longPressHandled = true;\n    }\n\n    // Short press state machine - trigger on button PRESS (for tap-to-toggle)\n    // But check on RELEASE that it wasn\'t a long press\n    if (buttonReleased && (millis() - buttonPressTime <= 1000)) {\n      Serial.println("LOOPER: Short press detected");\n\n      // State machine: EMPTY  RECORDING  PLAYING  OVERDUBBING  PLAYING  MUTED  PLAYING\n      if (state == EMPTY) {\n        // Start recording\n        state = RECORDING;\n        writePos = 0;\n        length = 0;\n        Serial.println("LOOPER: Starting recording");\n      } else if (state == RECORDING) {\n        // Stop recording, start playing\n        state = PLAYING;\n        length = writePos;\n        readPosFloat = 0.0f;\n        Serial.printf("LOOPER: Stopping recording, recorded %d samples (%.1fs), starting playback\\n",\n                     length, (float)length / 44100.0);\n      } else if (state == PLAYING) {\n        // Enter overdub mode\n        state = OVERDUBBING;\n        writePos = (int)readPosFloat; // Sync write position to current playback position\n        Serial.println("LOOPER: Entering overdub mode");\n      } else if (state == OVERDUBBING) {\n        // Exit overdub, return to playing\n        state = PLAYING;\n        Serial.println("LOOPER: Exiting overdub mode, returning to playback");\n      } else if (state == MUTED) {\n        // Unmute playback\n        state = PLAYING;\n        readPosFloat = 0.0f; // Restart from beginning\n        Serial.println("LOOPER: Unmuting playback");\n      }\n    }\n\n    lastRecordButton = recordButton;\n\n    float wetL = 0.0f;\n    float wetR = 0.0f;\n\n    // Recording - auto-stop at buffer limit\n    if (state == RECORDING && bufferL && bufferR) {\n      if (writePos < bufferSize) {\n        bufferL[writePos] = inL;\n        bufferR[writePos] = inR;\n        writePos++;\n      } else {\n        // Buffer full - auto-stop and start playing\n        state = PLAYING;\n        length = writePos;\n        readPosFloat = 0.0f;\n        Serial.printf("LOOPER: Buffer full at %d samples (%.1fs), auto-stopping and starting playback\\n",\n                     length, (float)length / 44100.0);\n      }\n    }\n\n    // Overdubbing - add new audio to existing loop\n    if (state == OVERDUBBING && bufferL && bufferR && length > 0) {\n      // Sync write position to read position\n      writePos = (int)readPosFloat;\n\n      if (writePos < length) {\n        // Add incoming audio to buffer (overdub) with gain control\n        bufferL[writePos] += inL * overdubGain;\n        bufferR[writePos] += inR * overdubGain;\n      }\n    }\n    \n    // Calculate playback speed with octave detents\n    // Map speedControl (0.0-1.0) to speed range:\n    // 0.0 = 0.25x (-2 octaves), 0.25 = 0.5x (-1 octave), 0.5 = 1.0x (normal), 0.75 = 2.0x (+1 octave), 1.0 = 4.0x (+2 octaves)\n    float targetSpeed = 1.0f;\n    if (speedControl < 0.5f) {\n      // Range 0.0-0.5 maps to 0.25x-1.0x\n      targetSpeed = 0.25f + (speedControl * 2.0f) * 0.75f;\n    } else {\n      // Range 0.5-1.0 maps to 1.0x-4.0x\n      targetSpeed = 1.0f + ((speedControl - 0.5f) * 2.0f) * 3.0f;\n    }\n\n    // Apply detents (snap zones) around key ratios\n    const float detentStrength = 0.05f; // 5% snap zone\n    float detents[] = {0.25f, 0.5f, 1.0f, 2.0f, 4.0f};\n    for (int i = 0; i < 5; i++) {\n      if (fabs(targetSpeed - detents[i]) < detents[i] * detentStrength) {\n        targetSpeed = detents[i];\n        break;\n      }\n    }\n\n    // Determine playback direction\n    playbackDirection = (reverseControl > 0.5f) ? -1.0f : 1.0f;\n\n    // Playback with speed and direction control (PLAYING or OVERDUBBING)\n    if ((state == PLAYING || state == OVERDUBBING) && length > 0 && bufferL && bufferR) {\n      // Linear interpolation for smooth speed changes\n      int idx0 = (int)readPosFloat;\n      int idx1 = (idx0 + 1) % length;\n      float frac = readPosFloat - idx0;\n\n      // Ensure indices are within bounds\n      if (idx0 >= 0 && idx0 < length && idx1 >= 0 && idx1 < length) {\n        wetL = bufferL[idx0] * (1.0f - frac) + bufferL[idx1] * frac;\n        wetR = bufferR[idx0] * (1.0f - frac) + bufferR[idx1] * frac;\n      }\n\n      // Advance read position with speed and direction\n      readPosFloat += targetSpeed * playbackDirection;\n\n      // Handle looping with direction\n      if (readPosFloat >= length) {\n        readPosFloat = fmodf(readPosFloat, length); // Wrap to start\n\n        // Apply Frippertronics decay on loop wrap (forward direction)\n        if (playbackDirection > 0 && decayControl < 1.0f) {\n          // Map decayControl (0.0-1.0) to decay factor (0.8-1.0)\n          // 1.0 = no decay, 0.0 = heavy decay (20% fade per loop)\n          float decayFactor = 0.8f + (decayControl * 0.2f);\n          for (int i = 0; i < length; i++) {\n            bufferL[i] *= decayFactor;\n            bufferR[i] *= decayFactor;\n          }\n        }\n      } else if (readPosFloat < 0.0f) {\n        readPosFloat = length + fmodf(readPosFloat, length); // Wrap to end\n\n        // Apply decay on reverse loop wrap\n        if (playbackDirection < 0 && decayControl < 1.0f) {\n          float decayFactor = 0.8f + (decayControl * 0.2f);\n          for (int i = 0; i < length; i++) {\n            bufferL[i] *= decayFactor;\n            bufferR[i] *= decayFactor;\n          }\n        }\n      }\n    }\n    \n    // When muted, keep loop position frozen but don\'t output audio\n    if (state == MUTED && length > 0) {\n      wetL = 0.0f;\n      wetR = 0.0f;\n      // readPosFloat stays frozen at current position\n    }\n    \n    // Guitar pedal style mixing: dry signal always passes through + wet signal added with playback gain\n    // Use soft clipping (tanh) to prevent harsh digital clipping when overdubbing\n    float mixedL = inL + wetL * mix * playbackGain;\n    float mixedR = inR + wetR * mix * playbackGain;\n\n    // Soft saturation using tanh() - prevents clipping, adds warmth\n    outL = tanhf(mixedL * 0.9f);  // Scale down slightly before saturation\n    outR = tanhf(mixedR * 0.9f);\n    \n    // Update control outputs\n    positionOut = length > 0 ? readPosFloat / length : 0.0f;\n    lengthOut = (float)length / bufferSize;\n    stateOut = (state == RECORDING) ? 1.0f : ((state == PLAYING) ? 0.5f : ((state == MUTED) ? 0.25f : 0.0f));\n    \n    // LED control output (encoded state for NeoPixel rendering)\n    // 0.0 = EMPTY (pulsing red - ready to record)\n    // 1.0 = RECORDING (solid red)\n    // 2.0 = PLAYING (solid green - looping)\n    // 3.0 = MUTED (off/dim)\n    // 4.0 = OVERDUBBING (solid orange - layering audio)\n    if (state == EMPTY) {\n      ledOut = 0.0f;  // EMPTY = pulsing red\n    } else if (state == RECORDING) {\n      ledOut = 1.0f;  // RECORDING = solid red\n    } else if (state == PLAYING) {\n      ledOut = 2.0f;  // PLAYING = solid green\n    } else if (state == MUTED) {\n      ledOut = 3.0f;  // MUTED = off\n    } else if (state == OVERDUBBING) {\n      ledOut = 4.0f;  // OVERDUBBING = solid orange\n    }\n  }\n};\n')},generateIncludes:function(){return"#include <cstring>  // For memset\n#include <cmath>     // For tanhf (soft clipping)"}},j={metadata:{label:"BPM Looper",desc:"4-slot beat-synced looper with slice randomization and pitch control. 2-bank system: Bank 1 (record/mix), Bank 2 (randomization/pitch). CV inputs auto-detect mode. ~5.6MB PSRAM (4 slots  4 beats @ 120 BPM).",params:{start_bank:1,slot1_length:.25,slot2_length:.5,slot3_length:2,slot4_length:4,slot1_slices_per_beat:8,slot2_slices_per_beat:8,slot3_slices_per_beat:8,slot4_slices_per_beat:8,internal_bpm:120,use_external_clock:!1,mix:1,master_gain:1,slot1_state:0,slot2_state:0,slot3_state:0,slot4_state:0,slot1_oneshot:!1,slot2_oneshot:!1,slot3_oneshot:!1,slot4_oneshot:!1,slot1_randomization:0,slot2_randomization:0,slot3_randomization:0,slot4_randomization:0,slot1_pitch:1,slot2_pitch:1,slot3_pitch:1,slot4_pitch:1},audioIn:["inL","inR"],audioOut:["outL","outR"],ctrlIn:["clock","slot1_trig","slot2_trig","slot3_trig","slot4_trig","slot1_pitch","slot2_pitch","slot3_pitch","slot4_pitch"],ctrlOut:[]},generateClass:function(e,n){var t=n.internal_bpm||120,a=n.use_external_clock||!1,o=60/t*4,r=Math.ceil(44100*o),c=n.slot1_length||.25,i=n.slot2_length||.5,l=n.slot3_length||2,s=n.slot4_length||4,u=n.slot1_slices_per_beat||8,d=n.slot2_slices_per_beat||8,p=n.slot3_slices_per_beat||8,f=n.slot4_slices_per_beat||8,m=Math.max(Math.ceil(c*u),Math.ceil(i*d),Math.ceil(l*p),Math.ceil(s*f),128);return"\nclass BPMLooper_".concat(e," {\nprivate:\n  static constexpr int MAX_SAMPLES_PER_SLOT = ").concat(r,";\n  static constexpr int NUM_SLOTS = 4;\n\n  // PSRAM buffers for 4 slots\n  float* bufferL[NUM_SLOTS] = {nullptr, nullptr, nullptr, nullptr};\n  float* bufferR[NUM_SLOTS] = {nullptr, nullptr, nullptr, nullptr};\n\n  // Slot configuration (in beats)\n  float slotLengthBeats[NUM_SLOTS] = {").concat(c.toFixed(2),"f, ").concat(i.toFixed(2),"f, ").concat(l.toFixed(2),"f, ").concat(s.toFixed(2),"f};\n  int slotLengthSamples[NUM_SLOTS] = {0, 0, 0, 0};\n\n  // Slice randomization configuration\n  static constexpr int MAX_SLICES = ").concat(m,";\n  int slotSlicesPerBeat[NUM_SLOTS] = {").concat(u,", ").concat(d,", ").concat(p,", ").concat(f,"};\n  int slotNumSlices[NUM_SLOTS] = {0, 0, 0, 0}; // Calculated: slotLengthBeats * slicesPerBeat\n  uint8_t* slotShuffleMap[NUM_SLOTS] = {nullptr, nullptr, nullptr, nullptr}; // Dynamic shuffle maps\n  float lastRandomization[NUM_SLOTS] = {-1.0f, -1.0f, -1.0f, -1.0f}; // Track changes for regen\n\n  // Slot state\n  enum State { EMPTY, RECORDING, PLAYING, MUTED } slotState[NUM_SLOTS] = {EMPTY, EMPTY, EMPTY, EMPTY};\n  int writePos[NUM_SLOTS] = {0, 0, 0, 0};\n  float readPos[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};           // Main playback position (advances at 1.0x for time-locking)\n  float sliceReadPos[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};     // Position within current slice (advances at pitch speed)\n  int recordedLength[NUM_SLOTS] = {0, 0, 0, 0};\n  bool slotReversed[NUM_SLOTS] = {false, false, false, false};\n  float slotOffset[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f}; // Loop offset in samples\n  float slotPhase[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f}; // Per-slot phase (0-1) for LED pulse\n\n  // One-shot mode (plays loop once when triggered)\n  bool slotOneshot[NUM_SLOTS] = {false, false, false, false};\n  bool slotOneshotTriggered[NUM_SLOTS] = {false, false, false, false};\n\n  // Gate mode (CV trigger inputs control playback - HIGH=play, LOW=stop)\n  bool slotGateActive[NUM_SLOTS] = {false, false, false, false};\n  float lastTrigger[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n  unsigned long triggerHighStartTime[NUM_SLOTS] = {0, 0, 0, 0}; // Track how long trigger has been HIGH\n\n  // CV activity detection (detect if external CV is controlling this slot)\n  bool slotCvActive[NUM_SLOTS] = {false, false, false, false};\n  unsigned long lastCvActivityTime[NUM_SLOTS] = {0, 0, 0, 0};\n  static constexpr unsigned long CV_TIMEOUT_MS = 2000; // 2 seconds without CV = revert to button control\n  static constexpr unsigned long GATE_THRESHOLD_MS = 50; // If trigger HIGH >50ms, it's gate mode (not one-shot pulse)\n\n  // Clock/tempo\n  float internalBpm = ").concat(t.toFixed(1),"f;\n  float beatPhase = 0.0f; // 0.0-1.0 phase within current beat\n  float lastClockInput = 0.0f;\n  unsigned long lastClockTime = 0;\n  float externalBpm = ").concat(t.toFixed(1),"f;\n  bool useExternalClock = ").concat(a?"true":"false",";\n\n  // Button control\n  float buttonInputs[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n  float lastButtonInputs[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n  unsigned long buttonPressTime[NUM_SLOTS] = {0, 0, 0, 0}; // Track press duration\n  bool buttonLongHoldHandled[NUM_SLOTS] = {false, false, false, false}; // Prevent repeat clear\n  bool encoderButtonPressed = false; // For reverse toggle\n\n  // Bank 2 pot values (private - button state is public)\n  // Initialize to 0.0 (no randomization at startup)\n  float bank2PotValue[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n\n  // Parameters\n  float mix = ").concat((n.mix||1).toFixed(2),"f;\n  float masterGain = ").concat((n.master_gain||1).toFixed(2),'f;\n\n  // Control inputs\n  float clockInput = 0.0f;\n  float triggerInputs[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n  float pitchInputs[NUM_SLOTS] = {0.333f, 0.333f, 0.333f, 0.333f}; // 0.333 = 1.0x speed (0.5 + 0.333*1.5 = 1.0)\n\n  // Pot control (volumes or loop start when encoder held)\n  float slotVolume[NUM_SLOTS] = {1.0f, 1.0f, 1.0f, 1.0f}; // Volume per slot (0-1)\n\n  // Crossfade state for click-free loop transitions\n  static constexpr int CROSSFADE_SAMPLES = 64; // ~1.45ms at 44.1kHz (micro-fade)\n  float lastReadPos[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f}; // Track position for wrap detection\n\npublic:\n  float outL = 0.0f;\n  float outR = 0.0f;\n  float ledOutputs[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n\n  // Public access for LED control\n  float slotRandomization[NUM_SLOTS] = {0.0f, 0.0f, 0.0f, 0.0f};\n  float slotPitch[NUM_SLOTS] = {1.0f, 1.0f, 1.0f, 1.0f};\n  bool bank2ButtonPressed[NUM_SLOTS] = {false, false, false, false};\n\n  void init() {\n    // Calculate sample lengths for each slot based on BPM\n    float secondsPerBeat = 60.0f / internalBpm;\n    for (int s = 0; s < NUM_SLOTS; s++) {\n      slotLengthSamples[s] = (int)(slotLengthBeats[s] * secondsPerBeat * 44100.0f);\n\n      // Calculate number of slices for this slot\n      slotNumSlices[s] = max(1, (int)(slotLengthBeats[s] * slotSlicesPerBeat[s]));\n\n      // Allocate shuffle map\n      slotShuffleMap[s] = new uint8_t[slotNumSlices[s]];\n      if (slotShuffleMap[s]) {\n        // Initialize to sequential order\n        for (int i = 0; i < slotNumSlices[s]; i++) {\n          slotShuffleMap[s][i] = i;\n        }\n      }\n    }\n\n    // Allocate PSRAM buffers for all 4 slots\n    for (int s = 0; s < NUM_SLOTS; s++) {\n      bufferL[s] = (float*)ps_malloc(MAX_SAMPLES_PER_SLOT * sizeof(float));\n      bufferR[s] = (float*)ps_malloc(MAX_SAMPLES_PER_SLOT * sizeof(float));\n\n      if (!bufferL[s] || !bufferR[s]) {\n        Serial.printf("BPMLooper_').concat(e,': PSRAM allocation failed for slot %d\\n", s);\n      } else {\n        memset(bufferL[s], 0, MAX_SAMPLES_PER_SLOT * sizeof(float));\n        memset(bufferR[s], 0, MAX_SAMPLES_PER_SLOT * sizeof(float));\n        Serial.printf("BPMLooper_').concat(e,': Allocated slot %d (%.1f beats, %.2fs, %d samples, %d slices)\\n",\n                     s, slotLengthBeats[s], slotLengthBeats[s] * secondsPerBeat, slotLengthSamples[s], slotNumSlices[s]);\n      }\n    }\n\n    float totalMB = (4 * 2 * MAX_SAMPLES_PER_SLOT * sizeof(float)) / (1024.0f * 1024.0f);\n    float shuffleKB = (4 * MAX_SLICES) / 1024.0f;\n    Serial.printf("BPMLooper_').concat(e,': Total PSRAM allocated: %.2f MB + shuffle maps: %.2f KB\\n", totalMB, shuffleKB);\n  }\n\n  void setControl(int index, float value) {\n    if (index == 0) {\n      clockInput = value;\n    } else if (index >= 1 && index <= 4) {\n      // Trigger inputs (slot1_trig, slot2_trig, etc.)\n      triggerInputs[index - 1] = value;\n    } else if (index >= 5 && index <= 8) {\n      // Pitch inputs (slot1_pitch, slot2_pitch, etc.)\n      pitchInputs[index - 5] = constrain(value, 0.0f, 1.0f);\n    }\n  }\n\n  void setButtonState(int slotIndex, float buttonValue, bool encoderButton) {\n    if (slotIndex >= 0 && slotIndex < NUM_SLOTS) {\n      buttonInputs[slotIndex] = buttonValue;\n    }\n    encoderButtonPressed = encoderButton;\n  }\n\n  void setLoopOffset(int slotIndex, float offsetDelta) {\n    if (slotIndex >= 0 && slotIndex < NUM_SLOTS && recordedLength[slotIndex] > 0) {\n      slotOffset[slotIndex] += offsetDelta;\n      // Wrap offset to valid range\n      while (slotOffset[slotIndex] < 0) slotOffset[slotIndex] += recordedLength[slotIndex];\n      while (slotOffset[slotIndex] >= recordedLength[slotIndex]) slotOffset[slotIndex] -= recordedLength[slotIndex];\n    }\n  }\n\n  void setPotValue(int potIndex, float value) {\n    if (potIndex >= 0 && potIndex < NUM_SLOTS) {\n      if (encoderButtonPressed && recordedLength[potIndex] > 0) {\n        // Encoder held: Set loop start offset (0.0-1.0  0 to recordedLength)\n        slotOffset[potIndex] = value * recordedLength[potIndex];\n      } else {\n        // Normal mode: Set volume (0.0-1.0)\n        slotVolume[potIndex] = value;\n      }\n    }\n  }\n\n  // Bank 2 control methods\n  void setBank2PotValue(int slotIndex, float value) {\n    if (slotIndex >= 0 && slotIndex < NUM_SLOTS) {\n      bank2PotValue[slotIndex] = constrain(value, 0.0f, 1.0f);\n    }\n  }\n\n  void setBank2ButtonState(int slotIndex, bool pressed) {\n    if (slotIndex >= 0 && slotIndex < NUM_SLOTS) {\n      bank2ButtonPressed[slotIndex] = pressed;\n    }\n  }\n\n  // Update randomization and pitch from Bank 2 controls\n  void updateBank2Controls() {\n    for (int s = 0; s < NUM_SLOTS; s++) {\n      if (bank2ButtonPressed[s]) {\n        // Button held: Pot controls PITCH (chromatic 1 octave = 12 semitones)\n        // Map pot (0.0-1.0) to semitones (-12 to +12)\n        float semitones = (bank2PotValue[s] - 0.5f) * 24.0f;  // -12 to +12 semitones\n        // Convert semitones to pitch multiplier: pitch = 2^(semitones/12)\n        slotPitch[s] = powf(2.0f, semitones / 12.0f);  // Chromatic pitch control\n      } else {\n        // Button released: Pitch PERSISTS at last set value, pot now controls RANDOMIZATION\n        slotRandomization[s] = bank2PotValue[s];\n\n        // Regenerate shuffle map if randomization changed significantly\n        if (fabsf(slotRandomization[s] - lastRandomization[s]) > 0.05f) {\n          generateShuffleMap(s);\n          lastRandomization[s] = slotRandomization[s];\n        }\n      }\n    }\n  }\n\n  // Generate shuffle map with controlled randomization (Fisher-Yates shuffle)\n  void generateShuffleMap(int slotIndex) {\n    if (!slotShuffleMap[slotIndex] || slotNumSlices[slotIndex] <= 1) return;\n\n    int numSlices = slotNumSlices[slotIndex];\n    float randomAmt = slotRandomization[slotIndex];\n\n    // Start with sequential order\n    for (int i = 0; i < numSlices; i++) {\n      slotShuffleMap[slotIndex][i] = i;\n    }\n\n    if (randomAmt < 0.01f) return; // No shuffling needed\n\n    // Fisher-Yates shuffle with probability based on randomization amount\n    for (int i = numSlices - 1; i > 0; i--) {\n      // Probability increases with randomAmt (0% = no swaps, 100% = all swaps)\n      float swapChance = (float)random(1000) / 1000.0f;\n      if (swapChance < randomAmt) {\n        int j = random(i + 1);\n        // Swap slices i and j\n        uint8_t temp = slotShuffleMap[slotIndex][i];\n        slotShuffleMap[slotIndex][i] = slotShuffleMap[slotIndex][j];\n        slotShuffleMap[slotIndex][j] = temp;\n      }\n    }\n\n    Serial.printf("BPMLooper_').concat(e,': Slot %d shuffle regenerated (%.0f%% random)\\n", slotIndex, randomAmt * 100.0f);\n  }\n\n  void process(float inL, float inR) {\n    // Update Bank 2 controls (randomization/pitch)\n    updateBank2Controls();\n\n    // Update clock/tempo\n    updateClock();\n\n    // Process button events for each slot\n    unsigned long now = millis();\n    for (int s = 0; s < NUM_SLOTS; s++) {\n      // Check if CV is actively controlling this slot\n      bool cvControlling = slotCvActive[s];\n\n      bool buttonHeld = (buttonInputs[s] > 0.5f);\n      bool buttonPressed = (buttonHeld && lastButtonInputs[s] <= 0.5f); // Rising edge\n      bool buttonReleased = (!buttonHeld && lastButtonInputs[s] > 0.5f); // Falling edge\n\n      // Only process button input if CV is NOT actively controlling this slot\n      if (!cvControlling) {\n        // Track button press time\n        if (buttonPressed) {\n          buttonPressTime[s] = now;\n          buttonLongHoldHandled[s] = false;\n        }\n\n        // Long hold detection (1500ms) - clear/delete slot\n        if (buttonHeld && !buttonLongHoldHandled[s]) {\n          unsigned long holdDuration = now - buttonPressTime[s];\n          if (holdDuration > 1500) {\n            clearSlot(s);\n            buttonLongHoldHandled[s] = true; // Prevent repeat clear\n          }\n        }\n\n        // Normal button press handling (on release, if not long-held)\n        if (buttonReleased && !buttonLongHoldHandled[s]) {\n          if (encoderButtonPressed && slotState[s] == PLAYING) {\n            // Encoder + button = reverse toggle\n            slotReversed[s] = !slotReversed[s];\n            Serial.printf("BPMLooper_').concat(e,': Slot %d reverse = %s\\n", s, slotReversed[s] ? "true" : "false");\n          } else {\n            // Normal button press: state machine\n            handleSlotButton(s);\n          }\n        }\n      }\n\n      lastButtonInputs[s] = buttonInputs[s];\n    }\n\n    // Mix all slots\n    float mixL = 0.0f;\n    float mixR = 0.0f;\n\n    for (int s = 0; s < NUM_SLOTS; s++) {\n      float slotL = 0.0f;\n      float slotR = 0.0f;\n\n      processSlot(s, inL, inR, slotL, slotR);\n\n      mixL += slotL;\n      mixR += slotR;\n    }\n\n    // Soft clipping function (tanh approximation)\n    auto softClip = [](float x) -> float {\n      float absX = fabsf(x);\n      if (absX <= 1.0f) return x;\n      if (absX >= 2.0f) return (x > 0.0f) ? 1.0f : -1.0f;\n      float x2 = x * x;\n      return x * (27.0f + x2) / (27.0f + 9.0f * x2);\n    };\n\n    // Seamless looper mixing - NO DUCKING:\n    // Both input and loops stay at full volume during recording and playback\n    // Soft clipping prevents harsh distortion if levels exceed headroom\n\n    float inputGain = 1.0f;\n    float loopGain = mix * masterGain;\n\n    float mixedL = (inL * inputGain) + (mixL * loopGain);\n    float mixedR = (inR * inputGain) + (mixR * loopGain);\n\n    outL = softClip(mixedL);\n    outR = softClip(mixedR);\n  }\n\nprivate:\n  void updateClock() {\n    if (useExternalClock) {\n      // External clock input (rising edge detection)\n      if (clockInput > 0.5f && lastClockInput <= 0.5f) {\n        unsigned long now = millis();\n        if (lastClockTime > 0) {\n          float intervalMs = now - lastClockTime;\n          externalBpm = 60000.0f / intervalMs;\n          externalBpm = constrain(externalBpm, 40.0f, 300.0f);\n        }\n        lastClockTime = now;\n        beatPhase = 0.0f; // Reset phase on clock pulse\n      }\n      lastClockInput = clockInput;\n\n      // Advance phase based on external BPM\n      float samplesPerBeat = (60.0f / externalBpm) * 44100.0f;\n      beatPhase += 1.0f / samplesPerBeat;\n      if (beatPhase >= 1.0f) beatPhase -= 1.0f;\n    } else {\n      // Internal clock\n      float samplesPerBeat = (60.0f / internalBpm) * 44100.0f;\n      beatPhase += 1.0f / samplesPerBeat;\n      if (beatPhase >= 1.0f) beatPhase -= 1.0f;\n    }\n  }\n\n  void handleSlotButton(int s) {\n    switch (slotState[s]) {\n      case EMPTY:\n        // Start recording on next beat\n        startRecording(s);\n        break;\n      case RECORDING:\n        // Stop recording, start playing\n        stopRecording(s);\n        break;\n      case PLAYING:\n        // Mute\n        slotState[s] = MUTED;\n        Serial.printf("BPMLooper_').concat(e,': Slot %d muted\\n", s);\n        break;\n      case MUTED:\n        // Unmute\n        slotState[s] = PLAYING;\n        readPos[s] = 0.0f;\n        Serial.printf("BPMLooper_').concat(e,': Slot %d unmuted\\n", s);\n        break;\n    }\n  }\n\n  void startRecording(int s) {\n    slotState[s] = RECORDING;\n    writePos[s] = 0;\n    recordedLength[s] = 0;\n    slotOffset[s] = 0.0f;\n    Serial.printf("BPMLooper_').concat(e,': Slot %d recording started\\n", s);\n  }\n\n  void stopRecording(int s) {\n    slotState[s] = PLAYING;\n    recordedLength[s] = writePos[s];\n    readPos[s] = 0.0f;\n    Serial.printf("BPMLooper_').concat(e,': Slot %d recorded %d samples (%.2fs)\\n",\n                 s, recordedLength[s], (float)recordedLength[s] / 44100.0f);\n  }\n\n  void clearSlot(int s) {\n    slotState[s] = EMPTY;\n    writePos[s] = 0;\n    readPos[s] = 0.0f;\n    recordedLength[s] = 0;\n    slotOffset[s] = 0.0f;\n    slotReversed[s] = false;\n    slotOneshot[s] = false;\n    slotOneshotTriggered[s] = false;\n    slotPhase[s] = 0.0f;\n    slotVolume[s] = 1.0f; // Reset volume to full\n\n    // Reset Bank 2 parameters (pitch and randomization)\n    slotPitch[s] = 1.0f;           // Reset pitch to 1.0x (no pitch shift)\n    slotRandomization[s] = 0.0f;   // Reset randomization to 0%\n    bank2PotValue[s] = 0.0f;       // Reset pot to 0 (no randomization)\n    lastRandomization[s] = -1.0f;  // Force shuffle regen on next use\n\n    // Reset shuffle map to sequential\n    if (slotShuffleMap[s]) {\n      for (int i = 0; i < slotNumSlices[s]; i++) {\n        slotShuffleMap[s][i] = i;\n      }\n    }\n\n    // Clear buffer memory\n    if (bufferL[s]) memset(bufferL[s], 0, MAX_SAMPLES_PER_SLOT * sizeof(float));\n    if (bufferR[s]) memset(bufferR[s], 0, MAX_SAMPLES_PER_SLOT * sizeof(float));\n    Serial.printf("BPMLooper_').concat(e,": Slot %d cleared (Bank 2 params reset)\\n\", s);\n  }\n\n  void processSlot(int s, float inL, float inR, float &outL, float &outR) {\n    if (!bufferL[s] || !bufferR[s]) return;\n\n    unsigned long now = millis();\n    bool triggerHigh = (triggerInputs[s] > 0.5f);\n    bool triggerRisingEdge = (triggerHigh && lastTrigger[s] <= 0.5f);\n    bool triggerFallingEdge = (!triggerHigh && lastTrigger[s] > 0.5f);\n\n    // CV activity detection: Any edge or level change = CV is active\n    if (triggerRisingEdge || triggerFallingEdge) {\n      slotCvActive[s] = true;\n      lastCvActivityTime[s] = now;\n    }\n\n    // CV timeout: If no CV activity for CV_TIMEOUT_MS, revert to button control\n    if (slotCvActive[s] && (now - lastCvActivityTime[s] > CV_TIMEOUT_MS)) {\n      slotCvActive[s] = false;\n      slotGateActive[s] = false;\n      slotOneshot[s] = false;\n      slotOneshotTriggered[s] = false;\n    }\n\n    // Process CV trigger input (only if CV is active)\n    if (slotCvActive[s] && recordedLength[s] > 0) {\n      // Track rising edge timing\n      if (triggerRisingEdge) {\n        triggerHighStartTime[s] = now;\n      }\n\n      // Auto-detect mode: Gate vs One-shot\n      // If trigger stays HIGH for >GATE_THRESHOLD_MS, it's gate mode\n      // If trigger pulses briefly, it's one-shot mode\n      if (triggerHigh) {\n        unsigned long highDuration = now - triggerHighStartTime[s];\n\n        if (highDuration > GATE_THRESHOLD_MS) {\n          // Gate mode: HIGH = play\n          if (!slotGateActive[s]) {\n            slotGateActive[s] = true;\n            readPos[s] = 0.0f;\n            Serial.printf(\"BPMLooper_").concat(e,': Slot %d gate mode activated\\n", s);\n          }\n        } else if (triggerRisingEdge) {\n          // One-shot mode: Rising edge triggers playback\n          slotOneshot[s] = true;\n          slotOneshotTriggered[s] = true;\n          readPos[s] = 0.0f;\n          Serial.printf("BPMLooper_').concat(e,': Slot %d one-shot triggered\\n", s);\n        }\n      } else {\n        // Trigger LOW\n        if (slotGateActive[s]) {\n          // Gate mode: LOW = stop\n          slotGateActive[s] = false;\n          Serial.printf("BPMLooper_').concat(e,": Slot %d gate stopped\\n\", s);\n        }\n      }\n    }\n\n    lastTrigger[s] = triggerInputs[s];\n\n    // Recording\n    if (slotState[s] == RECORDING) {\n      if (writePos[s] < slotLengthSamples[s] && writePos[s] < MAX_SAMPLES_PER_SLOT) {\n        bufferL[s][writePos[s]] = inL;\n        bufferR[s][writePos[s]] = inR;\n        writePos[s]++;\n      } else {\n        // Recording complete at configured length\n        stopRecording(s);\n      }\n    }\n\n    // Playback (includes normal PLAYING state, one-shot mode, and gate mode)\n    if ((slotState[s] == PLAYING || slotOneshot[s] || slotGateActive[s]) && recordedLength[s] > 0) {\n      // Calculate playback speed:\n      // Priority: slotPitch (from Bank 2) overrides pitchInputs (CV)\n      // If slotPitch != 1.0, use it; otherwise use CV pitch\n      float speed;\n      if (fabsf(slotPitch[s] - 1.0f) > 0.01f) {\n        // Using Bank 2 pitch control\n        speed = slotPitch[s];\n      } else {\n        // Using CV pitch input (map 0.0-1.0 to 0.5x-2.0x)\n        speed = 0.5f + pitchInputs[s] * 1.5f;\n      }\n\n      // Apply direction\n      float direction = slotReversed[s] ? -1.0f : 1.0f;\n\n      // TIME-LOCKED GRANULAR PLAYBACK:\n      // Main readPos advances at 1.0x (time-locked to beat grid)\n      // sliceReadPos advances at pitch speed within each slice\n\n      // Calculate slice parameters\n      int sliceLength = recordedLength[s] / slotNumSlices[s];\n      int currentLogicalSlice = ((int)readPos[s] / sliceLength) % slotNumSlices[s];\n      int currentSliceStart = currentLogicalSlice * sliceLength;\n\n      // Apply slice randomization if enabled\n      int physicalSlice = currentLogicalSlice;\n      if (slotRandomization[s] > 0.01f && slotShuffleMap[s] && slotNumSlices[s] > 1) {\n        // Map to physical slice via shuffle map\n        physicalSlice = slotShuffleMap[s][currentLogicalSlice];\n      }\n      int physicalSliceStart = physicalSlice * sliceLength;\n\n      // Advance slice-local read position at pitched speed\n      sliceReadPos[s] += speed * direction;\n\n      // Wrap within slice boundaries (creates granular effect)\n      // Pitched up (2x): wraps/repeats content within the slice (plays slice twice)\n      // Pitched down (0.5x): gets cut off mid-content when next slice starts\n      while (sliceReadPos[s] >= sliceLength) {\n        sliceReadPos[s] -= sliceLength; // Wrap to slice start\n      }\n      while (sliceReadPos[s] < 0) {\n        sliceReadPos[s] += sliceLength; // Wrap to slice end\n      }\n\n      // Calculate final buffer read position\n      float bufferReadPos = physicalSliceStart + sliceReadPos[s];\n\n      // Apply offset\n      float readPosWithOffset = bufferReadPos + slotOffset[s];\n      while (readPosWithOffset >= recordedLength[s]) readPosWithOffset -= recordedLength[s];\n      while (readPosWithOffset < 0) readPosWithOffset += recordedLength[s];\n\n      // Crossfade detection: check if we're near loop boundary\n      // Apply micro-fade in last and first CROSSFADE_SAMPLES of loop to eliminate clicks\n      float crossfadeGain = 1.0f;\n      float distanceToEnd = recordedLength[s] - readPosWithOffset;\n      float distanceFromStart = readPosWithOffset;\n\n      if (distanceToEnd < CROSSFADE_SAMPLES && direction > 0) {\n        // Approaching end (forward playback) - fade out\n        crossfadeGain = distanceToEnd / (float)CROSSFADE_SAMPLES;\n      } else if (distanceFromStart < CROSSFADE_SAMPLES && direction > 0) {\n        // Just wrapped (forward playback) - fade in\n        crossfadeGain = distanceFromStart / (float)CROSSFADE_SAMPLES;\n      } else if (distanceFromStart < CROSSFADE_SAMPLES && direction < 0) {\n        // Approaching start (reverse playback) - fade out\n        crossfadeGain = distanceFromStart / (float)CROSSFADE_SAMPLES;\n      } else if (distanceToEnd < CROSSFADE_SAMPLES && direction < 0) {\n        // Just wrapped (reverse playback) - fade in\n        crossfadeGain = distanceToEnd / (float)CROSSFADE_SAMPLES;\n      }\n\n      // Linear interpolation\n      int idx0 = (int)readPosWithOffset;\n      int idx1 = (idx0 + 1) % recordedLength[s];\n      float frac = readPosWithOffset - idx0;\n\n      if (idx0 >= 0 && idx0 < recordedLength[s] && idx1 >= 0 && idx1 < recordedLength[s]) {\n        outL = (bufferL[s][idx0] * (1.0f - frac) + bufferL[s][idx1] * frac) * slotVolume[s] * crossfadeGain;\n        outR = (bufferR[s][idx0] * (1.0f - frac) + bufferR[s][idx1] * frac) * slotVolume[s] * crossfadeGain;\n      }\n\n      // Store previous position for wrap detection and slice boundary detection\n      int prevLogicalSlice = ((int)lastReadPos[s] / sliceLength) % slotNumSlices[s];\n      lastReadPos[s] = readPos[s];\n\n      // TIME-LOCKED: Advance main readPos at 1.0x speed (locked to beat grid)\n      readPos[s] += 1.0f * direction;\n\n      // Detect slice boundary crossing - reset sliceReadPos when entering new slice\n      int newLogicalSlice = ((int)readPos[s] / sliceLength) % slotNumSlices[s];\n      if (newLogicalSlice != prevLogicalSlice) {\n        sliceReadPos[s] = 0.0f; // Reset slice-local position at slice boundaries\n      }\n\n      // Update per-slot phase for LED pulse (based on slot's BEAT LENGTH, not loop position)\n      // Phase advances at normal playback rate (1.0x speed) regardless of pitch CV\n      // This keeps LED pulse synced to beat interval even when pitch is modulated\n      float phaseIncrement = 1.0f / (float)slotLengthSamples[s];\n      slotPhase[s] += phaseIncrement;\n\n      // Wrap phase at 1.0 (one beat cycle)\n      if (slotPhase[s] >= 1.0f) slotPhase[s] -= 1.0f;\n\n      // Handle looping\n      if (slotOneshot[s]) {\n        // One-shot mode: stop at end\n        if ((direction > 0 && readPos[s] >= recordedLength[s]) ||\n            (direction < 0 && readPos[s] < 0)) {\n          slotOneshot[s] = false;\n          slotOneshotTriggered[s] = false;\n          readPos[s] = 0.0f;\n          sliceReadPos[s] = 0.0f; // Reset slice position too\n          outL = 0.0f;\n          outR = 0.0f;\n        }\n      } else {\n        // Loop mode\n        if (readPos[s] >= recordedLength[s]) {\n          readPos[s] = fmodf(readPos[s], recordedLength[s]);\n          sliceReadPos[s] = 0.0f; // Reset on loop wrap\n        } else if (readPos[s] < 0) {\n          readPos[s] = recordedLength[s] + fmodf(readPos[s], recordedLength[s]);\n          sliceReadPos[s] = 0.0f; // Reset on loop wrap\n        }\n      }\n    }\n\n    // Phase tracking for recording and empty states\n    if (slotState[s] == RECORDING && slotLengthSamples[s] > 0) {\n      // Phase tracks recording progress\n      slotPhase[s] = (float)writePos[s] / (float)slotLengthSamples[s];\n    } else if (slotState[s] == EMPTY && slotLengthSamples[s] > 0) {\n      // Phase advances at beat rate even when empty (for per-slot arm pulsing)\n      float phaseIncrement = 1.0f / (float)slotLengthSamples[s];\n      slotPhase[s] += phaseIncrement;\n      if (slotPhase[s] >= 1.0f) slotPhase[s] -= 1.0f;\n    }\n\n    // Calculate LED output (state-based with slot-specific beat sync)\n    float led = 0.0f;\n    if (slotState[s] == EMPTY) {\n      // EMPTY state: Pulsing at slot's beat rate (ready to record)\n      // Each slot pulses according to its configured beat interval\n      float pulse = (sinf(slotPhase[s] * 3.14159f * 2.0f) + 1.0f) * 0.5f; // 0.0-1.0 sine wave\n      led = -pulse; // Negative = red pulsing in NeoPixel code\n    } else if (slotState[s] == RECORDING) {\n      led = -1.0f; // Negative = solid red\n    } else if (slotState[s] == PLAYING || slotOneshot[s] || slotGateActive[s]) {\n      // PLAYING state (including one-shot and gate modes): Green with beat pulse\n      // Each slot pulses according to its own loop length\n      float brightness = 200.0f - (slotPhase[s] * 50.0f); // 200 at loop start  150 at loop end\n      led = brightness / 255.0f; // Normalize to 0.0-1.0 (positive = green)\n    } else if (slotState[s] == MUTED) {\n      led = 0.0f; // Off\n    }\n    ledOutputs[s] = led;\n  }\n};\n")},generateIncludes:function(){return"#include <cstring>  // For memset\n#include <cmath>     // For fmodf, powf"}},K={I2S_BCLK:15,I2S_LRCK:17,I2S_DATA:18,I2C_SDA:1,I2C_SCL:2,ANALOG_PINS:[4,5,6,7],ENCODER_A:21,ENCODER_B:47,ENCODER_BTN:48,NEOPIXEL_PIN:46,NEOPIXEL_COUNT:8,NEOPIXEL_MAP:{BTN:[3,2,1,0],POT:[7,6,5,4]},BANK_COLORS:[{r:0,g:255,b:0},{r:255,g:0,b:0},{r:0,g:0,b:255},{r:255,g:128,b:0},{r:0,g:255,b:255},{r:255,g:255,b:255}],AUTOMATION_RECORD_COLOR:{r:255,g:0,b:0},NEOPIXEL_BRIGHTNESS:50,GATE_IN_PINS:[42,41],GATE_OUT_PINS:[40,39],SD_CS:14,SD_MOSI:10,SD_MISO:11,SD_SCK:9,MIDI_RX:44,MIDI_TX:43,USB_DM:19,USB_DP:20,SAMPLE_RATE:44100,BUFFER_SIZE:256},$={BUTTONS:[2,1,0,3],MIDI_OUT_LED:4,MIDI_IN_LED:5,GATE_LEDS:[7,6],GATE_LEDS_B:[8,9]};function Y(e){return Y="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Y(e)}function X(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}function Z(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,Q(a.key),a)}}function Q(e){var n=function(e){if("object"!=Y(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=Y(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==Y(n)?n:n+""}var J=function(){return e=function e(n,t){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.modules=n,this.connections=t},n=[{key:"resolveAudioChain",value:function(){var e=this,n=this.modules.find(function(e){return"I2SOut"===e.type}),t=[];return n&&(t=this.traceBackToSource(n,"audio")),this.connections.filter(function(e){return"audio"===e.kind}).forEach(function(n){var a=n.from.id.split(":")[0],o=e.modules.find(function(e){return e.id===a});o&&!t.some(function(e){return e.id===o.id})&&t.push(o)}),this.sortByFPUSafety(t)}},{key:"sortByFPUSafety",value:function(e){var n=this,t={Sample:1,Oscillator:2,Wavetable:3,Noise:10,NoiseGenerator:10,VCA:20,Distortion:25,CleanReverb:26,Filter:30,Delay:35,StereoMixer4:40,I2SOut:100},a=new Map;return e.forEach(function(e){var t;if("Wavetable"===e.type&&null!==(t=e.params)&&void 0!==t&&t.fm_tracking){var o=n.connections.find(function(n){var t,a,o=null!==(t=n.from)&&void 0!==t&&t.id?n.from.id.split(":")[0]:n.from,r=null!==(a=n.to)&&void 0!==a&&a.id?n.to.id.split(":")[1]:n.toPort;return o===e.id&&"fm"===r});if(o){var r,c=null!==(r=o.to)&&void 0!==r&&r.id?o.to.id.split(":")[0]:o.to;a.set(e.id,c)}}}),e.sort(function(e,n){var o=t[e.type]||50,r=t[n.type]||50;return a.has(e.id)&&a.get(e.id)===n.id?1:a.has(n.id)&&a.get(n.id)===e.id?-1:o-r})}},{key:"traceBackToSource",value:function(e,n){var t=this,a=[e],o=new Set([e.id]);return this.connections.filter(function(t){var a,o;if(t.to&&"string"==typeof t.to)a=t.to,o=t.toPort;else{if(!t.to||!t.to.id)return!1;a=t.to.id.split(":")[0],o=t.to.id.split(":")[1]}var r="audio"===t.type||["L","R","inL","inR","outL","outR","fm","pitch_cv"].includes(o)||o.includes("L")||o.includes("R");return a===e.id&&("audio"===n&&r||"control"===n&&!r)}).forEach(function(e){var r;if(e.from&&"string"==typeof e.from)r=e.from;else{if(!e.from||!e.from.id)return;r=e.from.id.split(":")[0]}var c=t.modules.find(function(e){return e.id===r});if(c&&!o.has(c.id)){var i=t.traceBackToSource(c,n);a.unshift.apply(a,function(e){return function(e){if(Array.isArray(e))return X(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,n){if(e){if("string"==typeof e)return X(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?X(e,n):void 0}}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}(i)),i.forEach(function(e){return o.add(e.id)})}}),a}},{key:"findConnectionsToModule",value:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return this.connections.filter(function(t){var a,o;if(t.to&&"string"==typeof t.to)a=t.to,o=t.toPort;else{if(!t.to||!t.to.id)return!1;a=t.to.id.split(":")[0],o=t.to.id.split(":")[1]}if(a!==e)return!1;if(n){var r="audio"===t.type||["L","R","inL","inR","outL","outR","fm","pitch_cv"].includes(o)||o.includes("L")||o.includes("R");return"audio"===n&&r||"control"===n&&!r}return!0})}},{key:"findConnectionsFromModule",value:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return this.connections.filter(function(t){var a,o;if(t.from&&"string"==typeof t.from)a=t.from,o=t.fromPort;else{if(!t.from||!t.from.id)return!1;a=t.from.id.split(":")[0],o=t.from.id.split(":")[1]}if(a!==e)return!1;if(n){var r="audio"===t.type||["L","R","inL","inR","outL","outR","fm","pitch_cv"].includes(o)||o.includes("L")||o.includes("R");return"audio"===n&&r||"control"===n&&!r}return!0})}}],n&&Z(e.prototype,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function ee(e){return ee="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},ee(e)}function ne(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,te(a.key),a)}}function te(e){var n=function(e){if("object"!=ee(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=ee(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==ee(n)?n:n+""}var ae=function(){return e=function e(){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e)},n=[{key:"getAnalogPin",value:function(e){return K.ANALOG_PINS[e%K.ANALOG_PINS.length]}},{key:"getGateOutPin",value:function(e){return K.GATE_OUT_PINS[e%K.GATE_OUT_PINS.length]}},{key:"getGateInPin",value:function(e){return K.GATE_IN_PINS[e%K.GATE_IN_PINS.length]}},{key:"getMCPButtonPin",value:function(e){return $.BUTTONS[e%$.BUTTONS.length]}},{key:"getMCPButtonLEDPin",value:function(e){return this.getNeoPixelIndex("button",e)}},{key:"getMCPGateLEDPin",value:function(e){return e<2?$.GATE_LEDS[e]:$.GATE_LEDS_B[e-2]}},{key:"getMCPMIDIInLEDPin",value:function(){return $.MIDI_IN_LED}},{key:"getMCPMIDIOutLEDPin",value:function(){return $.MIDI_OUT_LED}},{key:"getNeoPixelPin",value:function(){return K.NEOPIXEL_PIN}},{key:"getNeoPixelIndex",value:function(e,n){return"button"===e?K.NEOPIXEL_MAP.BTN[n%4]:"pot"===e?K.NEOPIXEL_MAP.POT[n%4]:0}},{key:"getEncoderPins",value:function(){return{A:K.ENCODER_A,B:K.ENCODER_B,BTN:K.ENCODER_BTN}}},{key:"getI2SPins",value:function(){return{BCLK:K.I2S_BCLK,LRCK:K.I2S_LRCK,DATA:K.I2S_DATA}}},{key:"getSDPins",value:function(){return{CS:K.SD_CS,MOSI:K.SD_MOSI,MISO:K.SD_MISO,SCK:K.SD_SCK}}},{key:"getI2CPins",value:function(){return{SDA:K.I2C_SDA,SCL:K.I2C_SCL}}},{key:"getMIDILEDPins",value:function(){return{IN:$.MIDI_IN_LED,OUT:$.MIDI_OUT_LED}}}],null&&ne(e.prototype,null),n&&ne(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function oe(e){return oe="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},oe(e)}function re(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,ce(a.key),a)}}function ce(e){var n=function(e){if("object"!=oe(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=oe(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==oe(n)?n:n+""}var ie=function(){return e=function e(){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e)},n=[{key:"generateIncludes",value:function(){var e=new Set;return e.add("#include <Wire.h>"),e.add("#include <driver/i2s.h>"),e.add("#include <Adafruit_MCP23X17.h>"),e.add("#include <Adafruit_NeoPixel.h>"),e.add("#include <time.h>"),e.add("#include <sys/time.h>"),e.add("#include <SD.h>"),e.add("#include <FS.h>"),e.add("#include <SPI.h>"),Array.from(e)}},{key:"generateI2SSetup",value:function(){return"\n// I2S Audio Output Configuration (PCM5102A DAC)\ni2s_config_t i2s_config = {\n    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX),\n    .sample_rate = ".concat(K.SAMPLE_RATE,",\n    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,\n    .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\n    .communication_format = I2S_COMM_FORMAT_I2S,\n    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n    .dma_buf_count = 8,\n    .dma_buf_len = ").concat(K.BUFFER_SIZE,",\n    .use_apll = false,\n    .tx_desc_auto_clear = true,\n    .fixed_mclk = 0\n};\n\ni2s_pin_config_t pin_config = {\n    .bck_io_num = ").concat(K.I2S_BCLK,",      // BCK (Bit Clock)\n    .ws_io_num = ").concat(K.I2S_LRCK,",       // LRCK/WS (Word Select)\n    .data_out_num = ").concat(K.I2S_DATA,",    // DIN (Audio Data)\n    .data_in_num = I2S_PIN_NO_CHANGE\n};\n\n// Initialize I2S\ni2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);\ni2s_set_pin(I2S_NUM_0, &pin_config);\ni2s_zero_dma_buffer(I2S_NUM_0);\n")}},{key:"generateMCP23017Setup",value:function(){return'\n// Initialize MCP23017 I/O expander\nif (!mcp.begin_I2C(0x20)) {\n    Serial.println("Error initializing MCP23017");\n    while (1);\n}\n\n// Configure MCP23017 pins (GPA0-3: buttons, GPA4-5: gate in, GPA6-7: button LEDs)\nmcp.pinMode(0, INPUT_PULLUP);  // Button 1\nmcp.pinMode(1, INPUT_PULLUP);  // Button 2\nmcp.pinMode(2, INPUT_PULLUP);  // Button 3\nmcp.pinMode(3, INPUT_PULLUP);  // Button 4\nmcp.pinMode(4, INPUT_PULLUP);  // Gate IN 1\nmcp.pinMode(5, INPUT_PULLUP);  // Gate IN 2\nmcp.pinMode(6, OUTPUT);        // Button 1 LED\nmcp.pinMode(7, OUTPUT);        // Button 2 LED\n\n// Configure Port B (GPB0-1: button LEDs 3-4, GPB2-5: gate LEDs)\nmcp.pinMode(8, OUTPUT);        // Button 3 LED\nmcp.pinMode(9, OUTPUT);        // Button 4 LED\nmcp.pinMode(10, OUTPUT);       // Gate 1 LED\nmcp.pinMode(11, OUTPUT);       // Gate 2 LED\nmcp.pinMode(12, OUTPUT);       // Gate 3 LED\nmcp.pinMode(13, OUTPUT);       // Gate 4 LED\n'}},{key:"generateNeoPixelSetup",value:function(){return"\n// Initialize NeoPixel LEDs\nneoPixels.begin();\nneoPixels.setBrightness(".concat(K.NEOPIXEL_BRIGHTNESS,');\nneoPixels.clear();\nneoPixels.show();\nSerial.println("NeoPixels initialized (8 LEDs, GPIO46)");\n')}},{key:"generateGlobalVariables",value:function(){return"\n// Global audio buffers\nint16_t audioBufferL[".concat(K.BUFFER_SIZE,"];\nint16_t audioBufferR[").concat(K.BUFFER_SIZE,"];\nfloat tempBufferL[").concat(K.BUFFER_SIZE,"];\nfloat tempBufferR[").concat(K.BUFFER_SIZE,"];\n\n// I/O expansion\nAdafruit_MCP23X17 mcp;\n\n// NeoPixel LEDs (WS2812B x8)\nAdafruit_NeoPixel neoPixels(").concat(K.NEOPIXEL_COUNT,", ").concat(K.NEOPIXEL_PIN,", NEO_GRB + NEO_KHZ800);\nuint8_t currentBank = 0; // Current bank (0-5 for 6 banks)\n\n// Timing\nunsigned long lastMillis = 0;\nunsigned long mcpReadTime = 0;\nconst unsigned long MCP_READ_INTERVAL = 20; // Read MCP every 20ms\nunsigned long neoPixelUpdateTime = 0;\nconst unsigned long NEOPIXEL_UPDATE_INTERVAL = 100; // Update NeoPixels every 100ms\n")}},{key:"generateNeoPixelUpdateCode",value:function(){var e=K.BANK_COLORS.map(function(e,n){return"  {".concat(e.r,", ").concat(e.g,", ").concat(e.b,"}").concat(n<K.BANK_COLORS.length-1?",":" "," // Bank ").concat(n+1)}).join("\n");return K.AUTOMATION_RECORD_COLOR,"\n// Bank colors (RGB)\nstruct BankColor {\n  uint8_t r, g, b;\n};\n\nconst BankColor bankColors[6] = {\n".concat(e,"\n};\n\nvoid updateNeoPixels() {\n  // Get current bank color\n  BankColor color = bankColors[currentBank % 6];\n\n  // Update button LEDs (indices ").concat(K.NEOPIXEL_MAP.BTN.join(", "),")\n  for (int i = 0; i < 4; i++) {\n    uint8_t ledIndex = 0;\n    switch(i) {\n      case 0: ledIndex = ").concat(K.NEOPIXEL_MAP.BTN[0],"; break;\n      case 1: ledIndex = ").concat(K.NEOPIXEL_MAP.BTN[1],"; break;\n      case 2: ledIndex = ").concat(K.NEOPIXEL_MAP.BTN[2],"; break;\n      case 3: ledIndex = ").concat(K.NEOPIXEL_MAP.BTN[3],"; break;\n    }\n\n    // Check if button is held for automation record (override with red)\n    // Button gates are stored in btn1_gate through btn4_gate (1-indexed)\n    bool isRecording = false;\n\n    // AUTOMATION_RECORD_CHECK_PLACEHOLDER will be replaced by actual automation checks\n    // Format: isRecording = isRecording || (btn1_gate && automation1_record_trigger);\n    // AUTOMATION_RECORD_CHECK_PLACEHOLDER\n\n    if (isRecording) {\n      // Override with red for automation record\n      neoPixels.setPixelColor(ledIndex, neoPixels.Color(").concat(K.AUTOMATION_RECORD_COLOR.r,", ").concat(K.AUTOMATION_RECORD_COLOR.g,", ").concat(K.AUTOMATION_RECORD_COLOR.b,"));\n    } else {\n      // Use bank color\n      neoPixels.setPixelColor(ledIndex, neoPixels.Color(color.r, color.g, color.b));\n    }\n  }\n\n  // Update pot LEDs (indices ").concat(K.NEOPIXEL_MAP.POT.join(", "),")\n  for (int i = 0; i < 4; i++) {\n    uint8_t ledIndex = 0;\n    switch(i) {\n      case 0: ledIndex = ").concat(K.NEOPIXEL_MAP.POT[0],"; break;\n      case 1: ledIndex = ").concat(K.NEOPIXEL_MAP.POT[1],"; break;\n      case 2: ledIndex = ").concat(K.NEOPIXEL_MAP.POT[2],"; break;\n      case 3: ledIndex = ").concat(K.NEOPIXEL_MAP.POT[3],"; break;\n    }\n    neoPixels.setPixelColor(ledIndex, neoPixels.Color(color.r, color.g, color.b));\n  }\n\n  neoPixels.show();\n}\n")}},{key:"generateMainLoop",value:function(){return"\nvoid loop() {\n    // Audio processing happens here\n    processAudioBuffer();\n\n    // Control rate updates (every 20ms to avoid I2C interference)\n    if (millis() - mcpReadTime > MCP_READ_INTERVAL) {\n        mcpReadTime = millis();\n        readControls();\n    }\n\n    // Update NeoPixels (every 100ms)\n    if (millis() - neoPixelUpdateTime > NEOPIXEL_UPDATE_INTERVAL) {\n        neoPixelUpdateTime = millis();\n        updateNeoPixels();\n    }\n}\n"}}],null&&re(e.prototype,null),n&&re(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function le(e){return le="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},le(e)}function se(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,r,c,i=[],l=!0,s=!1;try{if(r=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=r.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(c=t.return(),Object(c)!==c))return}finally{if(s)throw o}}return i}}(e,n)||function(e,n){if(e){if("string"==typeof e)return ue(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?ue(e,n):void 0}}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function ue(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}function de(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,pe(a.key),a)}}function pe(e){var n=function(e){if("object"!=le(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=le(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==le(n)?n:n+""}var fe=function(){return e=function e(n){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.connectionResolver=n},(n=[{key:"getPotReference",value:function(e,n){var t=e.params.index||1;return"pot".concat(t,"_value")}},{key:"generateBankAwareAssignment",value:function(e,n){if(!e||"Pot"!==e.type)return"        // WARNING: Invalid pot reference\n";var t=e.params.bank||1;return e.params.locked?"        ".concat(n,"\n"):"        if (currentBank == ".concat(t,") {\n            ").concat(n,"\n        }\n")}},{key:"getOscWaveTypeIndex",value:function(e){if("number"==typeof e)return e;if("string"!=typeof e)return 0;switch(e.toLowerCase()){case"sine":default:return 0;case"triangle":case"tri":return 1;case"sawtooth":case"saw":return 2;case"square":return 3}}},{key:"getNoiseTypeIndex",value:function(e){if("number"==typeof e)return e;if("string"!=typeof e)return 0;switch(e.toLowerCase()){case"white":default:return 0;case"pink":return 1;case"brown":case"brownian":return 2}}},{key:"getAudioMathModeIndex",value:function(e){if("number"==typeof e)return e;if("string"!=typeof e)return 0;switch(e.toLowerCase()){case"am":case"amplitude_modulation":default:return 0;case"crossfade":case"cross":return 1;case"ring":case"ring_modulation":return 2;case"vocoder":return 3}}},{key:"generateIncludes",value:function(e){var n=[];switch(e){case"Oscillator":case"Wavetable":case"Filter":case"GranularSynth":case"KickDrum":case"SnareDrum":case"Percussion":n.push("#include <math.h>"),n.push("#include <SD.h>"),n.push("#include <FS.h>"),n.push("#include <freertos/FreeRTOS.h>"),n.push("#include <freertos/task.h>"),n.push("#include <freertos/semphr.h>");break;case"Noise":case"CleanReverb":case"AudioMath":case"Panner":case"ChorusFlangeRing":case"Limiter":case"NoiseGate":case"EQ8":case"Wavetable":case"GranularDense":case"SamplePlayer":n.push("#include <math.h>");break;case"Resonance":n.push("#include <math.h>"),n.push("#include <esp_dsp.h>"),n.push("#include <Wire.h>"),n.push("#include <SD.h>"),n.push("#include <freertos/FreeRTOS.h>"),n.push("#include <freertos/task.h>")}return n}},{key:"generateModuleClasses",value:function(){return'\n// WAV File Header Structure\nstruct WAVHeader {\n    char riff[4];           // "RIFF"\n    uint32_t fileSize;      // File size minus 8 bytes\n    char wave[4];           // "WAVE"\n    char fmt[4];            // "fmt "\n    uint32_t fmtSize;       // Format chunk size\n    uint16_t audioFormat;   // Audio format (1 = PCM)\n    uint16_t numChannels;   // Number of channels\n    uint32_t sampleRate;    // Sample rate\n    uint32_t byteRate;      // Byte rate\n    uint16_t blockAlign;    // Block alignment\n    uint16_t bitsPerSample; // Bits per sample\n    char data[4];           // "data"\n    uint32_t dataSize;      // Data size\n};\n\n#define CHUNK_SIZE 4096  // Buffer size in bytes (1024 samples * 2 channels * 2 bytes)\n#define CHUNK_SAMPLES (CHUNK_SIZE / 4) // 1024 samples for stereo 16-bit\n\nclass MinimalWAVPlayer {\nprivate:\n    File wavFile;\n    WAVHeader header;\n\n    // Double buffering for seamless playback\n    int16_t* bufferA;\n    int16_t* bufferB;\n    int16_t* playingBuffer;       // Currently being played\n    int16_t* loadingBuffer;       // Currently being loaded\n    bool bufferAReady;\n    bool bufferBReady;\n\n    // Playback state\n    int playPosition;\n    int bufferPosition;\n    bool isPlaying;\n    float playbackSpeed;\n    float startPosition;\n    float endPosition;\n\n    // Background loading\n    SemaphoreHandle_t bufferMutex;\n    TaskHandle_t loadingTask;\n\npublic:\n    MinimalWAVPlayer();\n    bool loadFile(const String& filename);\n    void play();\n    void stop();\n    bool playing();\n    void setPlaybackSpeed(float speed);\n    void setStartPosition(float pos);\n    void setEndPosition(float pos);\n    int16_t getNextSample();\n\n    ~MinimalWAVPlayer() {\n        stop();\n        if (bufferA) free(bufferA);\n        if (bufferB) free(bufferB);\n        if (bufferMutex) vSemaphoreDelete(bufferMutex);\n    }\n};\n'}},{key:"generateGlobalVariables",value:function(e,n,t){switch(e.type){case"Oscillator":return"\n// ".concat(t.label," ").concat(n,"\nfloat osc").concat(n,"_phase = 0.0;\nfloat osc").concat(n,"_freq = ").concat(e.params.freq||440,";\nfloat osc").concat(n,"_gate = ").concat(e.params.gate||1,";\nint osc").concat(n,"_waveform = ").concat(this.getOscWaveTypeIndex(e.params.waveform),"; // 0=sine, 1=triangle, 2=saw, 3=square\nfloat osc").concat(n,"_morph = ").concat(e.params.morph||0,"; // Wave morphing parameter (0-1)\nfloat osc").concat(n,"_fm_amount = ").concat(e.params.fm_amount||0,"; // FM amount (0-1)\nfloat osc").concat(n,"_pitch_amount = ").concat(e.params.pitch_amount||e.params.pitch_range||24,"; // Pitch CV amount in semitones (+24=upward sweep, -24=downward kick drop)\nfloat osc").concat(n,"_pitch_smooth = 0.5; // Smoothed pitch CV to prevent artifacts (0-1)\nfloat osc").concat(n,"_outputL = 0.0;\nfloat osc").concat(n,"_outputR = 0.0;\nfloat osc").concat(n,"_amplitude = ").concat(e.params.amplitude||.8,";\nint osc").concat(n,"_debug_counter = 0;\n");case"Filter":return"\n// ".concat(t.label," ").concat(n,"\nfloat filter").concat(n,"_cutoff = ").concat(e.params.cutoff_hz||2e3,";\nfloat filter").concat(n,"_resonance = ").concat(e.params.resonance||.3,";\nfloat filter").concat(n,"_lfo_min_hz = ").concat(e.params.lfo_min_hz||100,";\nfloat filter").concat(n,"_lfo_max_hz = ").concat(e.params.lfo_max_hz||4e3,";\nfloat filter").concat(n,"_y1 = 0.0; // Left channel state\nfloat filter").concat(n,"_y2 = 0.0; // Right channel state\nfloat filter").concat(n,"_inputL = 0.0;\nfloat filter").concat(n,"_inputR = 0.0;\nfloat filter").concat(n,"_outputL = 0.0;\nfloat filter").concat(n,"_outputR = 0.0;\n");case"Distortion":return this.generateDistortionVariables(e,n,t);case"VCA":return"\n// ".concat(t.label," ").concat(n,"\nfloat vca").concat(n,"_gain = ").concat(e.params.gain||1,";\nfloat vca").concat(n,"_inputL = 0.0;\nfloat vca").concat(n,"_inputR = 0.0;\nfloat vca").concat(n,"_outputL = 0.0;\nfloat vca").concat(n,"_outputR = 0.0;\nfloat vca").concat(n,"_lastGain = 0.0; // For gain smoothing to prevent clicking\n");case"Noise":return"\n// ".concat(t.label," ").concat(n," - Multi-type Noise Generator\nint noise").concat(n,"_type = ").concat(this.getNoiseTypeIndex(e.params.type),"; // 0=white, 1=pink, 2=brown\nfloat noise").concat(n,"_gain = ").concat(e.params.gain||.3,";\nfloat noise").concat(n,"_gate = ").concat(e.params.gate||1,";\nfloat noise").concat(n,"_morph = ").concat(e.params.morph||0,"; // Morphing between noise types\nfloat noise").concat(n,"_output = 0.0;\n// Pink noise filter state (for pink noise generation)\nfloat noise").concat(n,"_pink_b0 = 0.0, noise").concat(n,"_pink_b1 = 0.0, noise").concat(n,"_pink_b2 = 0.0;\nfloat noise").concat(n,"_pink_b3 = 0.0, noise").concat(n,"_pink_b4 = 0.0, noise").concat(n,"_pink_b5 = 0.0, noise").concat(n,"_pink_b6 = 0.0;\n// Brown noise filter state\nfloat noise").concat(n,"_brown_last = 0.0;\n// LCG seed for deterministic noise generation (avoids ESP32 random() interference)\nuint32_t noise").concat(n,"_lcg_seed = ").concat(12345+7*n,"; // Different seed per instance\nint noise").concat(n,"_debug_counter = 0;\n");case"CleanReverb":var a,o,r,c=e.params.quality||"ultra";switch(c){case"standard":a={comb1:1051,comb2:1297,comb3:1531,comb4:1723,ap1:347,ap2:113,predelay:882},o="~28KB",r="Standard quality (40ms max decay)";break;case"high":a={comb1:3500,comb2:4300,comb3:5100,comb4:5700,ap1:1150,ap2:375,predelay:2940},o="~100KB",r="High quality (140ms max decay)";break;default:a={comb1:16e3,comb2:19700,comb3:23300,comb4:26200,ap1:2800,ap2:900,predelay:17640},o="~426KB",r="Ultra quality (594ms max decay)"}return"\n// ".concat(t.label," ").concat(n," - Schroeder Reverb (").concat(r,')\n// Quality preset: "').concat(c,'" (').concat(o," PSRAM per instance)\n// Comb filter delay sizes for 44.1kHz sample rate\n#define CLEANREVERB").concat(n,"_COMB1_SIZE ").concat(a.comb1,"   // ~").concat(Math.round(a.comb1/44.1),"ms\n#define CLEANREVERB").concat(n,"_COMB2_SIZE ").concat(a.comb2,"   // ~").concat(Math.round(a.comb2/44.1),"ms\n#define CLEANREVERB").concat(n,"_COMB3_SIZE ").concat(a.comb3,"   // ~").concat(Math.round(a.comb3/44.1),"ms\n#define CLEANREVERB").concat(n,"_COMB4_SIZE ").concat(a.comb4,"   // ~").concat(Math.round(a.comb4/44.1),"ms\n\n// Allpass filter delay sizes\n#define CLEANREVERB").concat(n,"_AP1_SIZE ").concat(a.ap1,"      // ~").concat(Math.round(a.ap1/44.1),"ms\n#define CLEANREVERB").concat(n,"_AP2_SIZE ").concat(a.ap2,"       // ~").concat(Math.round(a.ap2/44.1),"ms\n\n// Predelay for early reflections\n#define CLEANREVERB").concat(n,"_PREDELAY_SIZE ").concat(a.predelay," // ~").concat(Math.round(a.predelay/44.1),"ms\n\n// Delay line arrays (allocated dynamically from PSRAM at runtime)\n// Using pointers + ps_malloc() to explicitly allocate from PSRAM\nfloat* cleanreverb").concat(n,"_comb1 = nullptr;\nfloat* cleanreverb").concat(n,"_comb2 = nullptr;\nfloat* cleanreverb").concat(n,"_comb3 = nullptr;\nfloat* cleanreverb").concat(n,"_comb4 = nullptr;\n\nfloat* cleanreverb").concat(n,"_ap1 = nullptr;\nfloat* cleanreverb").concat(n,"_ap2 = nullptr;\n\n// Per-comb LPF states (damping inside feedback path) - small, can stay in DRAM\nfloat cleanreverb").concat(n,"_comb1_lpf = 0.0f;\nfloat cleanreverb").concat(n,"_comb2_lpf = 0.0f;\nfloat cleanreverb").concat(n,"_comb3_lpf = 0.0f;\nfloat cleanreverb").concat(n,"_comb4_lpf = 0.0f;\n\n// Predelay buffer (allocated dynamically from PSRAM at runtime)\nfloat* cleanreverb").concat(n,"_predelay = nullptr;\nint cleanreverb").concat(n,"_predelay_pos = 0;\n\n// Position counters\nint cleanreverb").concat(n,"_comb1_pos = 0, cleanreverb").concat(n,"_comb2_pos = 0;\nint cleanreverb").concat(n,"_comb3_pos = 0, cleanreverb").concat(n,"_comb4_pos = 0;\nint cleanreverb").concat(n,"_ap1_pos = 0, cleanreverb").concat(n,"_ap2_pos = 0;\n\n// Parameters\nfloat cleanreverb").concat(n,"_mix = ").concat(e.params.mix||.4,";\nfloat cleanreverb").concat(n,"_size = ").concat(e.params.size||.6,";\nfloat cleanreverb").concat(n,"_damp = ").concat(e.params.damp||.3,";\n\n// Smoothed params to avoid zippering\nfloat cleanreverb").concat(n,"_mix_z = cleanreverb").concat(n,"_mix;\nfloat cleanreverb").concat(n,"_size_z = cleanreverb").concat(n,"_size;\nfloat cleanreverb").concat(n,"_damp_z = cleanreverb").concat(n,"_damp;\n\n// Input variables (standard connection system)\nfloat cleanreverb").concat(n,"_inputL = 0.0;\nfloat cleanreverb").concat(n,"_inputR = 0.0;\n\n// Output\nfloat cleanreverb").concat(n,"_outputL = 0.0;\nfloat cleanreverb").concat(n,"_outputR = 0.0;\n\n// Allocate and initialize delay buffers from PSRAM (critical for ESP32-S3)\nvoid initCleanReverb").concat(n,'() {\n    Serial.println("Allocating CleanReverb').concat(n,' buffers from PSRAM...");\n\n    // Allocate buffers from PSRAM using ps_malloc (PSRAM-specific allocator)\n    cleanreverb').concat(n,"_comb1 = (float*)ps_malloc(CLEANREVERB").concat(n,"_COMB1_SIZE * sizeof(float));\n    cleanreverb").concat(n,"_comb2 = (float*)ps_malloc(CLEANREVERB").concat(n,"_COMB2_SIZE * sizeof(float));\n    cleanreverb").concat(n,"_comb3 = (float*)ps_malloc(CLEANREVERB").concat(n,"_COMB3_SIZE * sizeof(float));\n    cleanreverb").concat(n,"_comb4 = (float*)ps_malloc(CLEANREVERB").concat(n,"_COMB4_SIZE * sizeof(float));\n    cleanreverb").concat(n,"_ap1 = (float*)ps_malloc(CLEANREVERB").concat(n,"_AP1_SIZE * sizeof(float));\n    cleanreverb").concat(n,"_ap2 = (float*)ps_malloc(CLEANREVERB").concat(n,"_AP2_SIZE * sizeof(float));\n    cleanreverb").concat(n,"_predelay = (float*)ps_malloc(CLEANREVERB").concat(n,"_PREDELAY_SIZE * sizeof(float));\n\n    // Check allocation success\n    if (!cleanreverb").concat(n,"_comb1 || !cleanreverb").concat(n,"_comb2 || !cleanreverb").concat(n,"_comb3 ||\n        !cleanreverb").concat(n,"_comb4 || !cleanreverb").concat(n,"_ap1 || !cleanreverb").concat(n,"_ap2 ||\n        !cleanreverb").concat(n,'_predelay) {\n        Serial.println("ERROR: Failed to allocate CleanReverb').concat(n,' buffers from PSRAM!");\n        Serial.printf("Free PSRAM: %d bytes\\n", ESP.getFreePsram());\n        while(1); // Halt - cannot continue without reverb buffers\n    }\n\n    Serial.printf("CleanReverb').concat(n," allocated ").concat(o,' from PSRAM\\n");\n    Serial.printf("Free PSRAM remaining: %d bytes\\n", ESP.getFreePsram());\n\n    // Zero-initialize all buffers\n    memset(cleanreverb').concat(n,"_comb1, 0, CLEANREVERB").concat(n,"_COMB1_SIZE * sizeof(float));\n    memset(cleanreverb").concat(n,"_comb2, 0, CLEANREVERB").concat(n,"_COMB2_SIZE * sizeof(float));\n    memset(cleanreverb").concat(n,"_comb3, 0, CLEANREVERB").concat(n,"_COMB3_SIZE * sizeof(float));\n    memset(cleanreverb").concat(n,"_comb4, 0, CLEANREVERB").concat(n,"_COMB4_SIZE * sizeof(float));\n    memset(cleanreverb").concat(n,"_ap1, 0, CLEANREVERB").concat(n,"_AP1_SIZE * sizeof(float));\n    memset(cleanreverb").concat(n,"_ap2, 0, CLEANREVERB").concat(n,"_AP2_SIZE * sizeof(float));\n    memset(cleanreverb").concat(n,"_predelay, 0, CLEANREVERB").concat(n,"_PREDELAY_SIZE * sizeof(float));\n\n    // Initialize LPF states and parameters\n    cleanreverb").concat(n,"_comb1_lpf = cleanreverb").concat(n,"_comb2_lpf = 0.0f;\n    cleanreverb").concat(n,"_comb3_lpf = cleanreverb").concat(n,"_comb4_lpf = 0.0f;\n    cleanreverb").concat(n,"_predelay_pos = 0;\n    cleanreverb").concat(n,"_mix_z = cleanreverb").concat(n,"_mix;\n    cleanreverb").concat(n,"_size_z = cleanreverb").concat(n,"_size;\n    cleanreverb").concat(n,"_damp_z = cleanreverb").concat(n,"_damp;\n}\n");case"GranularSynth":return"\n// ".concat(t.label," ").concat(n," - Granular Synthesis Engine (PSRAM)\nint granular").concat(n,"_buffer_size; // Set dynamically based on available memory\nfloat* granular").concat(n,"_buffer_L; // PSRAM allocation\nfloat* granular").concat(n,"_buffer_R; // PSRAM allocation\nint granular").concat(n,"_write_pos = 0;\nfloat granular").concat(n,"_grain_density = ").concat(e.params.grain_density||8,";\nfloat granular").concat(n,"_grain_size_ms = ").concat(e.params.grain_size_ms||50,";\nfloat granular").concat(n,"_position = ").concat(e.params.position||.5,";\nfloat granular").concat(n,"_position_spread = ").concat(e.params.position_spread||.2,";\nfloat granular").concat(n,"_pitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(n,"_pitch_spread = ").concat(e.params.pitch_spread||.1,";\nfloat granular").concat(n,"_dry_wet = ").concat(e.params.dry_wet||1,";\nfloat granular").concat(n,"_outputL = 0.0;\nfloat granular").concat(n,"_outputR = 0.0;\n\n// 4 concurrent grain players for richer textures\nstruct Grain").concat(n," {\n    bool active;\n    float position;\n    float pitch_ratio;\n    float amplitude;\n    int samples_remaining;\n    int grain_size_samples;\n} granular").concat(n,"_grains[4];\n\nunsigned long granular").concat(n,"_last_grain_trigger = 0;\nfloat granular").concat(n,"_grain_interval_ms = 125.0; // 8 grains/sec default\n");case"KickDrum":return"\n// ".concat(t.label," ").concat(n," - Multi-Layer Drum Synthesizer (Sample + Oscillator + Noise)\n\n// Sample layer (integrated from Sample Player)\nMinimalWAVPlayer kick").concat(n,"_player;\nfloat kick").concat(n,"_sample_gain = ").concat(e.params.sample_gain||1,";\nfloat kick").concat(n,"_sample_pitch = ").concat(e.params.sample_pitch||1,";\nbool kick").concat(n,"_sample_loop = ").concat(e.params.sample_loop||!1,";\nint kick").concat(n,"_currentFile = ").concat(e.params.sample_file||1,";\nString kick").concat(n,'_currentFileName = "";\nfloat kick').concat(n,"_sample_outputL = 0.0;\nfloat kick").concat(n,"_sample_outputR = 0.0;\nint kick").concat(n,"_lastLoadedFile = -1;\n\n// Oscillator layer (existing implementation)\nfloat kick").concat(n,"_osc_phase = 0.0;\nfloat kick").concat(n,"_osc_freq = ").concat(e.params.osc_frequency||e.params.osc_freq||60,";\nfloat kick").concat(n,"_osc_level = ").concat(e.params.osc_level||.7,";\nfloat kick").concat(n,"_osc_distortion = ").concat(e.params.osc_distortion||0,";\nfloat kick").concat(n,"_osc_pitch_env = 0.0;\nfloat kick").concat(n,"_osc_pitch_amount = ").concat(e.params.osc_pitch_amount||1,";\n// Pitch envelope ADSR parameters\nfloat kick").concat(n,"_pitch_env_attack = ").concat((e.params.pitch_env_attack_ms||3)/1e3,";\nfloat kick").concat(n,"_pitch_env_decay = ").concat((e.params.pitch_env_decay_ms||80)/1e3,";\nfloat kick").concat(n,"_pitch_env_sustain = ").concat(e.params.pitch_env_sustain||0,";\nfloat kick").concat(n,"_pitch_env_release = ").concat((e.params.pitch_env_release_ms||20)/1e3,";\nfloat kick").concat(n,"_pitch_env_amount = ").concat(e.params.pitch_env_amount||2,";\nint kick").concat(n,"_pitch_env_stage = 0;\nfloat kick").concat(n,"_pitch_env_time = 0.0;\nbool kick").concat(n,"_osc_mute = ").concat(e.params.osc_mute||!1,";\n// Oscillator amplitude envelope\nfloat kick").concat(n,"_osc_amp_env = 0.0;\nfloat kick").concat(n,"_osc_amp_attack = ").concat((e.params.osc_amp_attack_ms||1)/1e3,";\nfloat kick").concat(n,"_osc_amp_decay = ").concat((e.params.osc_amp_decay_ms||150)/1e3,";\nfloat kick").concat(n,"_osc_amp_sustain = ").concat(e.params.osc_amp_sustain||.1,";\nfloat kick").concat(n,"_osc_amp_release = ").concat((e.params.osc_amp_release_ms||200)/1e3,";\nint kick").concat(n,"_osc_amp_stage = 0;\nfloat kick").concat(n,"_osc_amp_time = 0.0;\nfloat kick").concat(n,"_osc_outputL = 0.0;\nfloat kick").concat(n,"_osc_outputR = 0.0;\n\n// Noise layer (FPU-safe implementation)\nint kick").concat(n,"_noise_type = ").concat(e.params.noise_type||0,"; // 0=white, 1=pink, 2=brown\nfloat kick").concat(n,"_noise_gain = ").concat(e.params.noise_gain||.3,";\nfloat kick").concat(n,"_noise_morph = ").concat(e.params.noise_morph||0,";\nfloat kick").concat(n,"_noise_outputL = 0.0;\nfloat kick").concat(n,"_noise_outputR = 0.0;\n// Noise envelope\nfloat kick").concat(n,"_noise_amp_env = 0.0;\nfloat kick").concat(n,"_noise_amp_attack = ").concat((e.params.noise_amp_attack_ms||5)/1e3,";\nfloat kick").concat(n,"_noise_amp_decay = ").concat((e.params.noise_amp_decay_ms||80)/1e3,";\nfloat kick").concat(n,"_noise_amp_sustain = ").concat(e.params.noise_amp_sustain||0,";\nfloat kick").concat(n,"_noise_amp_release = ").concat((e.params.noise_amp_release_ms||50)/1e3,";\nint kick").concat(n,"_noise_amp_stage = 0;\nfloat kick").concat(n,"_noise_amp_time = 0.0;\n// Noise filtering state variables\nfloat kick").concat(n,"_noise_pink_b0 = 0.0, kick").concat(n,"_noise_pink_b1 = 0.0, kick").concat(n,"_noise_pink_b2 = 0.0;\nfloat kick").concat(n,"_noise_pink_b3 = 0.0, kick").concat(n,"_noise_pink_b4 = 0.0, kick").concat(n,"_noise_pink_b5 = 0.0, kick").concat(n,"_noise_pink_b6 = 0.0;\nfloat kick").concat(n,"_noise_brown_last = 0.0;\nuint32_t kick").concat(n,"_noise_lcg_seed = ").concat(12345+13*n,"; // Unique seed per instance\n\n// Master output and control\nfloat kick").concat(n,"_outputL = 0.0;\nfloat kick").concat(n,"_outputR = 0.0;\nbool kick").concat(n,"_triggered = false;\n");case"SnareDrum":return"\n// ".concat(t.label," ").concat(n," - Layered Snare Drum Synthesizer\n// Oscillator layer parameters\nfloat snare").concat(n,"_osc_freq = ").concat(e.params.osc_freq||200,";\nfloat snare").concat(n,"_osc_level = ").concat(e.params.osc_level||.4,";\nfloat snare").concat(n,"_osc_phase = 0.0;\n\n// Noise layer parameters\nfloat snare").concat(n,"_noise_level = ").concat(e.params.noise_level||.6,";\nint snare").concat(n,"_noise_type = ").concat(this.getNoiseTypeIndex(e.params.noise_type)||0,"; // 0=white\nfloat snare").concat(n,"_noise_state = 0.0; // Pink/brown filter state\n\n// Sample layer parameters (optional)\nfloat snare").concat(n,"_sample_level = ").concat(e.params.sample_level||0,";\n\n// Amplitude envelope (main drum envelope)\nfloat snare").concat(n,"_amp_attack = ").concat((e.params.amp_attack_ms||1)/1e3,";\nfloat snare").concat(n,"_amp_decay = ").concat((e.params.amp_decay_ms||120)/1e3,";\nfloat snare").concat(n,"_amp_sustain = ").concat(e.params.amp_sustain||0,";\nfloat snare").concat(n,"_amp_release = ").concat((e.params.amp_release_ms||150)/1e3,";\nfloat snare").concat(n,"_amp_env = 0.0;\nint snare").concat(n,"_amp_stage = 0; // 0=idle, 1=attack, 2=decay, 3=sustain, 4=release\nfloat snare").concat(n,"_amp_time = 0.0;\n\n// Pitch envelope (for pitch sweep effect)\nfloat snare").concat(n,"_pitch_attack = ").concat((e.params.pitch_attack_ms||.5)/1e3,";\nfloat snare").concat(n,"_pitch_decay = ").concat((e.params.pitch_decay_ms||30)/1e3,";\nfloat snare").concat(n,"_pitch_sustain = ").concat(e.params.pitch_sustain||0,";\nfloat snare").concat(n,"_pitch_release = ").concat((e.params.pitch_release_ms||50)/1e3,";\nfloat snare").concat(n,"_pitch_env = 0.0;\nfloat snare").concat(n,"_pitch_env_amount = ").concat(e.params.pitch_env_amount||.5,"; // Pitch bend in octaves\nint snare").concat(n,"_pitch_stage = 0;\nfloat snare").concat(n,"_pitch_time = 0.0;\n\n// Noise envelope (separate envelope for noise component)\nfloat snare").concat(n,"_noise_attack = ").concat((e.params.noise_attack_ms||2)/1e3,";\nfloat snare").concat(n,"_noise_decay = ").concat((e.params.noise_decay_ms||100)/1e3,";\nfloat snare").concat(n,"_noise_sustain = ").concat(e.params.noise_sustain||.1,";\nfloat snare").concat(n,"_noise_release = ").concat((e.params.noise_release_ms||200)/1e3,";\nfloat snare").concat(n,"_noise_env = 0.0;\nint snare").concat(n,"_noise_stage = 0;\nfloat snare").concat(n,"_noise_time = 0.0;\n\n// Output and control\nfloat snare").concat(n,"_outputL = 0.0;\nfloat snare").concat(n,"_outputR = 0.0;\nbool snare").concat(n,"_triggered = false;\n");case"AudioMath":return"\n// ".concat(t.label," ").concat(n," - Multi-Function Audio Processor\nint audioMath").concat(n,"_mode = ").concat(this.getAudioMathModeIndex(e.params.mode||"am"),"; // 0=am, 1=crossfade, 2=ring, 3=vocoder\nfloat audioMath").concat(n,"_amount = ").concat(e.params.amount||.5,"; // Mix/modulation amount\nfloat audioMath").concat(n,"_offset = ").concat(e.params.offset||0,"; // DC offset for modulation\nfloat audioMath").concat(n,"_inputA = 0.0; // First audio input\nfloat audioMath").concat(n,"_inputB = 0.0; // Second audio input\nfloat audioMath").concat(n,"_modInput = 0.0; // Modulation control input\nfloat audioMath").concat(n,"_output = 0.0; // Audio output\n\n// Vocoder-specific variables (simplified implementation)\nfloat audioMath").concat(n,"_vocoder_env = 0.0; // Envelope follower for carrier\nfloat audioMath").concat(n,"_vocoder_attack = 0.01; // Envelope attack time\nfloat audioMath").concat(n,"_vocoder_release = 0.1; // Envelope release time\n");case"Panner":return"\n// ".concat(t.label," ").concat(n," - Stereo Panner with Width Control\nfloat panner").concat(n,"_pan = ").concat(e.params.pan||.5,"; // Pan position (0.0=left, 0.5=center, 1.0=right)\nfloat panner").concat(n,"_width = ").concat(e.params.width||1,"; // Stereo width (0.0=mono, 1.0=full stereo)\nfloat panner").concat(n,"_inputL = 0.0; // Left audio input\nfloat panner").concat(n,"_inputR = 0.0; // Right audio input\nfloat panner").concat(n,"_outputL = 0.0; // Left audio output\nfloat panner").concat(n,"_outputR = 0.0; // Right audio output\n");case"StereoMixer4":return"\n// ".concat(t.label," ").concat(n," - 4-Channel Stereo Mixer\n// Channel 1\nfloat stereoMixer4_").concat(n,"_input1L = 0.0;\nfloat stereoMixer4_").concat(n,"_input1R = 0.0;\nfloat stereoMixer4_").concat(n,"_gain1 = ").concat(e.params.g1||.8,";\n\n// Channel 2\nfloat stereoMixer4_").concat(n,"_input2L = 0.0;\nfloat stereoMixer4_").concat(n,"_input2R = 0.0;\nfloat stereoMixer4_").concat(n,"_gain2 = ").concat(e.params.g2||.8,";\n\n// Channel 3\nfloat stereoMixer4_").concat(n,"_input3L = 0.0;\nfloat stereoMixer4_").concat(n,"_input3R = 0.0;\nfloat stereoMixer4_").concat(n,"_gain3 = ").concat(e.params.g3||.8,";\n\n// Channel 4\nfloat stereoMixer4_").concat(n,"_input4L = 0.0;\nfloat stereoMixer4_").concat(n,"_input4R = 0.0;\nfloat stereoMixer4_").concat(n,"_gain4 = ").concat(e.params.g4||.8,";\n\n// Master output\nfloat stereoMixer4_").concat(n,"_master = ").concat(e.params.master||1,";\nfloat stereoMixer4_").concat(n,"_outputL = 0.0;\nfloat stereoMixer4_").concat(n,"_outputR = 0.0;\n\n// Banking controls (Banks ").concat(e.params.start_bank||2," and ").concat((e.params.start_bank||2)+1,")\n// Bank 1: Volume/Mute\nfloat stereoMixer4_").concat(n,"_smoothed_pot[4] = {").concat(e.params.g1||.35,", ").concat(e.params.g2||.35,", ").concat(e.params.g3||.35,", ").concat(e.params.g4||.35,"};\nfloat stereoMixer4_").concat(n,"_pot_smooth_factor = 0.95; // Pot smoothing (higher = more smoothing)\nbool stereoMixer4_").concat(n,"_mute[4] = {").concat(e.params.mute1?"true":"false",", ").concat(e.params.mute2?"true":"false",", ").concat(e.params.mute3?"true":"false",", ").concat(e.params.mute4?"true":"false","};\nbool stereoMixer4_").concat(n,"_btn_last[4] = {false, false, false, false}; // Button state for debouncing\n\n// Soft takeover for volume (Bank 1)\nfloat stereoMixer4_").concat(n,"_vol_physical[4] = {").concat(e.params.g1||.35,", ").concat(e.params.g2||.35,", ").concat(e.params.g3||.35,", ").concat(e.params.g4||.35,"};\nfloat stereoMixer4_").concat(n,"_vol_target[4] = {").concat(e.params.g1||.35,", ").concat(e.params.g2||.35,", ").concat(e.params.g3||.35,", ").concat(e.params.g4||.35,"};\nfloat stereoMixer4_").concat(n,"_vol_saved[4] = {").concat(e.params.g1||.35,", ").concat(e.params.g2||.35,", ").concat(e.params.g3||.35,", ").concat(e.params.g4||.35,"}; // Per-bank value storage\nbool stereoMixer4_").concat(n,"_vol_taken_over[4] = {false, false, false, false}; // Start as NOT taken over (require soft takeover)\n\n// Bank 2: Pan/Solo\nfloat stereoMixer4_").concat(n,"_pan[4] = {").concat(e.params.pan1||.5,", ").concat(e.params.pan2||.5,", ").concat(e.params.pan3||.5,", ").concat(e.params.pan4||.5,"}; // 0.0=left, 0.5=center, 1.0=right\nfloat stereoMixer4_").concat(n,"_smoothed_pan[4] = {").concat(e.params.pan1||.5,", ").concat(e.params.pan2||.5,", ").concat(e.params.pan3||.5,", ").concat(e.params.pan4||.5,"};\nint stereoMixer4_").concat(n,"_solo_channel = ").concat(e.params.solo_channel||0,"; // 0 = none, 1-4 = channel soloed\n\n// Soft takeover for pan (Bank 2)\nfloat stereoMixer4_").concat(n,"_pan_physical[4] = {").concat(e.params.pan1||.5,", ").concat(e.params.pan2||.5,", ").concat(e.params.pan3||.5,", ").concat(e.params.pan4||.5,"};\nfloat stereoMixer4_").concat(n,"_pan_target[4] = {").concat(e.params.pan1||.5,", ").concat(e.params.pan2||.5,", ").concat(e.params.pan3||.5,", ").concat(e.params.pan4||.5,"};\nfloat stereoMixer4_").concat(n,"_pan_saved[4] = {").concat(e.params.pan1||.5,", ").concat(e.params.pan2||.5,", ").concat(e.params.pan3||.5,", ").concat(e.params.pan4||.5,"}; // Per-bank value storage\nbool stereoMixer4_").concat(n,"_pan_taken_over[4] = {false, false, false, false}; // Start as NOT taken over (require soft takeover)\n\n// Bank tracking\nint stereoMixer4_").concat(n,"_last_bank = -1; // Track which mixer bank was last active (-1 = none, 0 = vol bank, 1 = pan bank)\n\n// Pre-calculated pan coefficients (updated at control rate, used at audio rate)\nfloat stereoMixer4_").concat(n,"_panL[4] = {0.707, 0.707, 0.707, 0.707}; // Left channel gains\nfloat stereoMixer4_").concat(n,"_panR[4] = {0.707, 0.707, 0.707, 0.707}; // Right channel gains\n");case"Matrix2x2":return"\n// ".concat(t.label," ").concat(n," - 2x2 Audio Matrix Mixer with Feedback\n// Input A (stereo)\nfloat matrix").concat(n,"_inputAL = 0.0;\nfloat matrix").concat(n,"_inputAR = 0.0;\n\n// Input B (stereo)\nfloat matrix").concat(n,"_inputBL = 0.0;\nfloat matrix").concat(n,"_inputBR = 0.0;\n\n// Matrix coefficients (control the routing)\nfloat matrix").concat(n,"_aa = ").concat(e.params.aa||1,"; // Input A  Output A gain\nfloat matrix").concat(n,"_ab = ").concat(e.params.ab||0,"; // Input A  Output B gain\nfloat matrix").concat(n,"_ba = ").concat(e.params.ba||0,"; // Input B  Output A gain\nfloat matrix").concat(n,"_bb = ").concat(e.params.bb||1,"; // Input B  Output B gain\n\n// Output A (stereo)\nfloat matrix").concat(n,"_outputAL = 0.0;\nfloat matrix").concat(n,"_outputAR = 0.0;\n\n// Output B (stereo)\nfloat matrix").concat(n,"_outputBL = 0.0;\nfloat matrix").concat(n,"_outputBR = 0.0;\n");case"Delay":var i=Math.round(44.1*(e.params.time_ms||380)*1.5);return"\n// ".concat(t.label," ").concat(n,"\n#define DELAY").concat(n,"_BUFFER_SIZE ").concat(i,"\nfloat* delay").concat(n,"_bufferL; // PSRAM allocation\nfloat* delay").concat(n,"_bufferR; // PSRAM allocation\nint delay").concat(n,"_writePos = 0;\nfloat delay").concat(n,"_readPosFloat = 0.0; // For pitch shifting\nfloat delay").concat(n,"_time_ms = ").concat(e.params.time_ms||380,";\nfloat delay").concat(n,"_feedback = ").concat(e.params.feedback||.35,";\nfloat delay").concat(n,"_mix = ").concat(e.params.mix||.3,";\nfloat delay").concat(n,"_pingpong = ").concat(e.params.pingpong||0,";\nfloat delay").concat(n,"_freeze = ").concat(e.params.freeze||0,";\nfloat delay").concat(n,"_pitch_shift = ").concat(e.params.pitch_shift||1,";\nfloat delay").concat(n,"_division = ").concat(e.params.division||1,";\nfloat delay").concat(n,"_tempo_hz = 0.0; // Set by tempo sync connection\nfloat delay").concat(n,"_outputL = 0.0;\nfloat delay").concat(n,"_outputR = 0.0;\nfloat delay").concat(n,"_inputL = 0.0;\nfloat delay").concat(n,"_inputR = 0.0;\n\n// Feedback damping filters for stability and warmth\nfloat delay").concat(n,"_feedback_lpf_L = 0.0f;\nfloat delay").concat(n,"_feedback_lpf_R = 0.0f;\n");case"I2SOut":return"\n// ".concat(t.label," ").concat(n," - I2S Audio Output\nfloat i2sout").concat(n,"_inputL = 0.0;\nfloat i2sout").concat(n,"_inputR = 0.0;\nfloat i2sout").concat(n,"_volume = ").concat(e.params.volume||.8,";\nint i2sout").concat(n,"_debug_counter = 0;\n");case"LineIn":return"\n// ".concat(t.label," ").concat(n," - PCM1802 ADC Stereo Line Input\nfloat linein").concat(n,"_outputL = 0.0;\nfloat linein").concat(n,"_outputR = 0.0;\nfloat linein").concat(n,"_gain = ").concat(e.params.gain||2,";\n").concat(e.params.dc_block?"\n// DC blocking filter state (HPF ~3.5Hz at 44.1kHz)\nfloat linein".concat(n,"_dc_x_prev_L = 0.0f;\nfloat linein").concat(n,"_dc_y_prev_L = 0.0f;\nfloat linein").concat(n,"_dc_x_prev_R = 0.0f;\nfloat linein").concat(n,"_dc_y_prev_R = 0.0f;\nconst float linein").concat(n,"_dc_coeff = 0.995f;"):"","\n");case"AudioRecorder":var l=e.params.bank||1,s=e.params.max_duration_sec||60;return Math.floor(44100*s),"\n// AudioRecorder ".concat(n," - Standalone Recorder/Player with Banking\n// USES BANK ").concat(l," - Buttons: Record/Play-Pause, Pots: Input Gain/Volume\n\n// Banking\nconst int rec").concat(n,"_bank = ").concat(l,";\n\n// Recording state - Async SD write with ring buffer\nFile rec").concat(n,"_recFile;\nbool rec").concat(n,"_recording = false;\nbool rec").concat(n,"_finalizePending = false;  // True when waiting for SD writer to finish\nint rec").concat(n,"_currentFileIndex = 1;      // Next file to record to\nint rec").concat(n,"_lastRecordedFileIndex = 0; // Last file that was recorded (0 = none yet)\nuint32_t rec").concat(n,"_samplesRecorded = 0;\n\n// Ring buffer for async SD writing (glitch-free recording)\n#define REC").concat(n,"_BLOCK_SIZE 4092      // 4092 bytes = 682 samples exactly (MUST match PLAY_BLOCK_SIZE for alignment!)\n#define REC").concat(n,"_BLOCK_COUNT 128      // 128 blocks = ~512KB ring buffer (~2 seconds @ 44.1kHz stereo 24-bit)\nuint8_t* rec").concat(n,"_ringBuffer = nullptr;  // Allocated in PSRAM\nvolatile size_t rec").concat(n,"_writeIdx = 0;   // Audio thread writes here\nvolatile size_t rec").concat(n,"_readIdx = 0;    // SD task reads here\nvolatile size_t rec").concat(n,"_buffered = 0;   // Number of filled blocks\nSemaphoreHandle_t rec").concat(n,"_bufferMutex = nullptr;\nTaskHandle_t rec").concat(n,"_sdWriterTask = nullptr;\n\n// Current block being filled (audio thread local)\nuint8_t rec").concat(n,"_currentBlock[REC").concat(n,"_BLOCK_SIZE];\nsize_t rec").concat(n,"_currentBlockPos = 0;\n\n// Playback state - Async SD read with ring buffer (streaming playback)\nFile rec").concat(n,"_playFile;\nbool rec").concat(n,"_playing = false;\nbool rec").concat(n,"_paused = false;\nuint32_t rec").concat(n,"_totalSamples = 0;        // Total samples in file\nuint32_t rec").concat(n,"_samplesPlayed = 0;       // Samples played so far (can increment or decrement based on speed/direction)\nuint8_t rec").concat(n,"_channels = 2;             // 1=mono, 2=stereo\nbool rec").concat(n,"_playReverse = false;         // True when playing backwards (reverse mode or ping-pong reverse phase)\nfloat rec").concat(n,"_sampleAccumulator = 0.0f;   // Fractional sample counter for variable speed playback\n\n// Ring buffer for async SD reading (glitch-free streaming playback)\n#define PLAY").concat(n,"_BLOCK_SIZE 4092          // 4092 bytes = 682 samples exactly (4092  6 = 682, perfect alignment!)\n#define PLAY").concat(n,"_BLOCK_COUNT 64           // 64 blocks = ~256KB ring buffer (~1.4s @ 44.1kHz)\nuint8_t* play").concat(n,"_ringBuffer = nullptr;   // Allocated in PSRAM\nvolatile size_t play").concat(n,"_writeIdx = 0;    // SD reader task writes here\nvolatile size_t play").concat(n,"_readIdx = 0;     // Audio thread reads here\nvolatile size_t play").concat(n,"_buffered = 0;    // Number of filled blocks\nvolatile bool play").concat(n,"_eofReached = false; // SD reader hit end of file\nSemaphoreHandle_t play").concat(n,"_bufferMutex = nullptr;\nTaskHandle_t play").concat(n,"_sdReaderTask = nullptr;\n\n// Current block being read (audio thread local)\nuint8_t play").concat(n,"_currentBlock[PLAY").concat(n,"_BLOCK_SIZE];\nsize_t play").concat(n,"_currentBlockPos = 0;\nsize_t play").concat(n,"_currentBlockSize = 0;  // Actual size of current block (may be < BLOCK_SIZE at EOF)\n\n// Button state (banking system)\nbool rec").concat(n,"_btn1_state = false;  // Record button\nbool rec").concat(n,"_btn2_state = false;  // Play/Pause button\nbool rec").concat(n,"_btn3_state = false;  // Previous track / Rewind button\nbool rec").concat(n,"_btn4_state = false;  // Next track / Fast forward button\nbool rec").concat(n,"_btn1_last = false;\nbool rec").concat(n,"_btn2_last = false;\nbool rec").concat(n,"_btn3_last = false;\nbool rec").concat(n,"_btn4_last = false;\n\n// Long press detection (500ms threshold)\nunsigned long rec").concat(n,"_btn3_pressStart = 0;\nunsigned long rec").concat(n,"_btn4_pressStart = 0;\nconst unsigned long rec").concat(n,"_longPressThreshold = 500;  // 500ms for long press\nbool rec").concat(n,"_btn3_longHandled = false;\nbool rec").concat(n,"_btn4_longHandled = false;\n\n// Pot values\nfloat rec").concat(n,"_inputGain = 1.0f;  // Start at unity gain until pot is read\nfloat rec").concat(n,"_playbackVol = 1.0f;\nint rec").concat(n,"_playMode = 0;        // 0=normal, 1=loop, 2=reverse, 3=ping-pong\nfloat rec").concat(n,"_playSpeed = 1.0f;  // Playback speed (0.25x to 2.0x)\n\n// Cached file existence (avoid SD.exists() in audio thread)\nbool rec").concat(n,"_fileAvailable = false;\n\n// Hardware read throttling (prevent MCP23017 I2C blocking audio)\nint rec").concat(n,"_hwReadCounter = 0;\nconst int rec").concat(n,"_hwReadInterval = 4;  // Read hardware every 4 buffers = 1024 samples (~23ms @ 44.1kHz)\n\n// Button debounce (prevent double-triggering from bounce/timing races)\nbool rec").concat(n,"_armedForEdge = true;  // Must release button before next toggle allowed\nunsigned long rec").concat(n,"_lastToggleMs = 0;\nconst unsigned long rec").concat(n,"_toggleDebounceMs = 100;  // 100ms minimum between toggles\n\n// LED state (for feedback)\nfloat rec").concat(n,"_led1 = 0.0;  // Record LED\nfloat rec").concat(n,"_led2 = 0.0;  // Play LED\n\n// Output\nfloat rec").concat(n,"_outputL = 0.0;\nfloat rec").concat(n,"_outputR = 0.0;\n");case"ChorusFlangeRing":return"\n// ".concat(t.label," ").concat(n," - Modulation Effects (Chorus/Flange/Ring)\nint cfr").concat(n,"_mode = ").concat(e.params.mode||0,"; // 0=chorus, 1=flange, 2=ring\nfloat cfr").concat(n,"_depth = ").concat(e.params.depth||.5,";\nfloat cfr").concat(n,"_rate = ").concat(e.params.rate||1,";\nfloat cfr").concat(n,"_feedback = ").concat(e.params.feedback||.3,";\nfloat cfr").concat(n,"_mix = ").concat(e.params.mix||.5,";\nfloat cfr").concat(n,"_phase = 0.0;\nfloat cfr").concat(n,"_outputL = 0.0;\nfloat cfr").concat(n,"_outputR = 0.0;\n// Simple delay buffer for chorus/flange\n#define CFR").concat(n,"_BUFFER_SIZE 2048\nfloat cfr").concat(n,"_buffer[CFR").concat(n,"_BUFFER_SIZE];\nint cfr").concat(n,"_writePos = 0;\n");case"Limiter":return"\n// ".concat(t.label," ").concat(n," - Audio Limiter\nfloat limiter").concat(n,"_threshold = ").concat(e.params.threshold||.8,";\nfloat limiter").concat(n,"_ratio = ").concat(e.params.ratio||10,";\nfloat limiter").concat(n,"_attack = ").concat(e.params.attack_ms||1," / 1000.0;\nfloat limiter").concat(n,"_release = ").concat(e.params.release_ms||100," / 1000.0;\nfloat limiter").concat(n,"_makeup = ").concat(e.params.makeup||1,";\nfloat limiter").concat(n,"_envelope = 0.0;\nfloat limiter").concat(n,"_outputL = 0.0;\nfloat limiter").concat(n,"_outputR = 0.0;\n");case"NoiseGate":return"\n// ".concat(t.label," ").concat(n," - Noise Gate\nfloat noiseGate").concat(n,"_threshold = ").concat(e.params.threshold||.1,";\nfloat noiseGate").concat(n,"_attack = ").concat(e.params.attack_ms||1," / 1000.0;\nfloat noiseGate").concat(n,"_release = ").concat(e.params.release_ms||50," / 1000.0;\nfloat noiseGate").concat(n,"_ratio = ").concat(e.params.ratio||100,";\nfloat noiseGate").concat(n,"_envelope = 0.0;\nbool noiseGate").concat(n,"_gateOpen = false;\nfloat noiseGate").concat(n,"_outputL = 0.0;\nfloat noiseGate").concat(n,"_outputR = 0.0;\n");case"EQ8":return"\n// ".concat(t.label," ").concat(n," - 8-Band Graphic EQ\nfloat eq").concat(n,"_b1 = ").concat(e.params.b1||0,"; // 60Hz\nfloat eq").concat(n,"_b2 = ").concat(e.params.b2||0,"; // 170Hz\nfloat eq").concat(n,"_b3 = ").concat(e.params.b3||0,"; // 350Hz\nfloat eq").concat(n,"_b4 = ").concat(e.params.b4||0,"; // 1kHz\nfloat eq").concat(n,"_b5 = ").concat(e.params.b5||0,"; // 3kHz\nfloat eq").concat(n,"_b6 = ").concat(e.params.b6||0,"; // 6kHz\nfloat eq").concat(n,"_b7 = ").concat(e.params.b7||0,"; // 12kHz\nfloat eq").concat(n,"_b8 = ").concat(e.params.b8||0,"; // 14kHz\nfloat eq").concat(n,"_outputL = 0.0;\nfloat eq").concat(n,"_outputR = 0.0;\n// Filter state variables for each band\nfloat eq").concat(n,"_state[8][4] = {{0}}; // [band][state] for biquad filters\n");case"Resonance":return"\n// ".concat(t.label," ").concat(n," - Resonant Object Exploration System\n// Mode: 0=discovery, 1=performance, 2=exploration\nint resonance").concat(n,"_mode = ").concat("discovery"===e.params.mode?0:"performance"===e.params.mode?1:2,";\nint resonance").concat(n,"_fftSize = ").concat(e.params.fftSize||8192,";\nfloat resonance").concat(n,"_impulseLength = ").concat(e.params.impulseLength||1e3,"; // ms\nfloat resonance").concat(n,"_sweepDuration = ").concat(e.params.sweepDuration||1e4,"; // ms\nfloat resonance").concat(n,"_sweepStart = ").concat(e.params.sweepStart||20,"; // Hz\nfloat resonance").concat(n,"_sweepEnd = ").concat(e.params.sweepEnd||1e4,"; // Hz\nfloat resonance").concat(n,"_threshold = ").concat(e.params.threshold||-60,"; // dB\nint resonance").concat(n,"_maxPeaks = ").concat(e.params.maxPeaks||16,";\nint resonance").concat(n,"_objectSlot = ").concat(e.params.objectSlot||0,"; // 0-39\nbool resonance").concat(n,"_autoTune = ").concat(e.params.autoTune?"true":"false",";\nbool resonance").concat(n,"_hapticEnable = ").concat(e.params.hapticEnable?"true":"false",";\nfloat resonance").concat(n,"_gyroSensitivity = ").concat(e.params.gyroSensitivity||1,";\nfloat resonance").concat(n,"_hapticIntensity = ").concat(e.params.hapticIntensity||.5,";\n\n// Control inputs\nfloat resonance").concat(n,"_trigger = 0.0;\nfloat resonance").concat(n,"_mode_select = 0.0;\nfloat resonance").concat(n,"_object_select = 0.0;\nfloat resonance").concat(n,"_sensitivity = ").concat(e.params.gyroSensitivity||1,";\nfloat resonance").concat(n,"_intensity = ").concat(e.params.hapticIntensity||.5,";\n\n// Audio I/O\nfloat resonance").concat(n,"_contactMicInput = 0.0;\nfloat resonance").concat(n,"_exciterOutput = 0.0;\n\n// Control outputs (detected resonant frequencies)\nfloat resonance").concat(n,"_freq1 = 0.0;\nfloat resonance").concat(n,"_freq2 = 0.0;\nfloat resonance").concat(n,"_freq3 = 0.0;\nfloat resonance").concat(n,"_freq4 = 0.0;\nfloat resonance").concat(n,"_freq5 = 0.0;\nfloat resonance").concat(n,"_freq6 = 0.0;\nfloat resonance").concat(n,"_freq7 = 0.0;\nfloat resonance").concat(n,"_freq8 = 0.0;\nfloat resonance").concat(n,"_analysis_complete = 0.0;\nfloat resonance").concat(n,"_resonance_strength = 0.0;\n\n// FFT buffers (allocated in PSRAM)\nfloat* resonance").concat(n,"_fft_input = nullptr;\nfloat* resonance").concat(n,"_fft_output = nullptr;\nfloat* resonance").concat(n,"_window = nullptr;\n\n// State variables\nbool resonance").concat(n,"_analyzing = false;\nunsigned long resonance").concat(n,"_sweepStartTime = 0;\nfloat resonance").concat(n,"_currentSweepFreq = ").concat(e.params.sweepStart||20,";\nfloat resonance").concat(n,"_sweepPhase = 0.0;\n\n// FreeRTOS task handle for FFT analysis on Core 0\nTaskHandle_t resonance").concat(n,"_fftTask = nullptr;\nSemaphoreHandle_t resonance").concat(n,"_fftMutex = nullptr;\n\n// Detected resonant peaks storage\nstruct ResonantPeak {\n    float frequency;\n    float magnitude;\n    float q_factor;\n};\nResonantPeak resonance").concat(n,"_peaks[16] = {{0}};\nint resonance").concat(n,"_peakCount = 0;\n\n// Object library (40 slots in SPIFFS/SD)\nString resonance").concat(n,'_objectLibraryPath = "/resonance/objects/";\n');case"Percussion":return"\n// ".concat(t.label," ").concat(n," - Chromatic Percussion with Triple ADSR\nfloat perc").concat(n,"_freq = ").concat(e.params.freq||440,";\nfloat perc").concat(n,"_gain = ").concat(e.params.gain||.8,";\nfloat perc").concat(n,"_decay = ").concat(e.params.decay||.5,";\nfloat perc").concat(n,"_brightness = ").concat(e.params.brightness||.3,";\nfloat perc").concat(n,"_metallic = ").concat(e.params.metallic||0,";\n// Triple ADSR envelopes\nfloat perc").concat(n,"_env1 = 0.0, perc").concat(n,"_env2 = 0.0, perc").concat(n,"_env3 = 0.0;\nint perc").concat(n,"_stage1 = 0, perc").concat(n,"_stage2 = 0, perc").concat(n,"_stage3 = 0;\nfloat perc").concat(n,"_time1 = 0.0, perc").concat(n,"_time2 = 0.0, perc").concat(n,"_time3 = 0.0;\nbool perc").concat(n,"_triggered = false;\nfloat perc").concat(n,"_outputL = 0.0;\nfloat perc").concat(n,"_outputR = 0.0;\n");case"Wavetable":return this.generateWavetableVariables(e,n,t);case"GranularDense":return"\n// ".concat(t.label," ").concat(n," - Dense Granular Synthesis with 20 Grains\nint granular").concat(n,"_buffer_size; // Set dynamically based on available memory\nfloat* granular").concat(n,"_buffer_L; // PSRAM allocation\nfloat* granular").concat(n,"_buffer_R; // PSRAM allocation\nint granular").concat(n,"_write_pos = 0;\nfloat granular").concat(n,"_grain_density = ").concat(e.params.grain_density||15,";\nfloat granular").concat(n,"_position = ").concat(e.params.position||.5,";\nfloat granular").concat(n,"_position_spread = ").concat(e.params.position_spread||.3,";\nfloat granular").concat(n,"_pitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(n,"_pitch_spread = ").concat(e.params.pitch_spread||.1,";\nfloat granular").concat(n,"_dry_wet = ").concat(e.params.dry_wet||1,";\nfloat granular").concat(n,"_freeze = ").concat(e.params.freeze||0,";\nfloat granular").concat(n,"_stereo_width = ").concat(e.params.stereo_width||.5,";\nfloat granular").concat(n,"_cloud_pan = ").concat(e.params.cloud_pan||.5,";\nfloat granular").concat(n,"_grouped_panning = ").concat(e.params.grouped_panning||0,";\n\n// Dense grain structure - 20 concurrent 32ms grains with stereo panning\nstruct DenseGrain").concat(n," {\n    bool active;\n    float position;\n    float pitch_ratio;\n    float envelope_pos;\n    float envelope_inc;\n    int samples_remaining;\n    float pan;  // Stereo pan position (0=left, 1=right)\n};\n\n// Pre-calculated Hann window envelope (256 entries) for fast grain shaping\n// Replaces expensive cos() calculation with table lookup (~15% CPU reduction)\nconst float granular").concat(n,"_envelopeTable[256] = {\n    0.0000, 0.0015, 0.0061, 0.0138, 0.0245, 0.0381, 0.0548, 0.0743,\n    0.0968, 0.1221, 0.1502, 0.1810, 0.2145, 0.2506, 0.2891, 0.3301,\n    0.3735, 0.4191, 0.4669, 0.5168, 0.5688, 0.6226, 0.6782, 0.7355,\n    0.7944, 0.8549, 0.9168, 0.9799, 1.0000, 0.9799, 0.9168, 0.8549,\n    0.7944, 0.7355, 0.6782, 0.6226, 0.5688, 0.5168, 0.4669, 0.4191,\n    0.3735, 0.3301, 0.2891, 0.2506, 0.2145, 0.1810, 0.1502, 0.1221,\n    0.0968, 0.0743, 0.0548, 0.0381, 0.0245, 0.0138, 0.0061, 0.0015,\n    0.0000, 0.0015, 0.0061, 0.0138, 0.0245, 0.0381, 0.0548, 0.0743,\n    0.0968, 0.1221, 0.1502, 0.1810, 0.2145, 0.2506, 0.2891, 0.3301,\n    0.3735, 0.4191, 0.4669, 0.5168, 0.5688, 0.6226, 0.6782, 0.7355,\n    0.7944, 0.8549, 0.9168, 0.9799, 1.0000, 0.9799, 0.9168, 0.8549,\n    0.7944, 0.7355, 0.6782, 0.6226, 0.5688, 0.5168, 0.4669, 0.4191,\n    0.3735, 0.3301, 0.2891, 0.2506, 0.2145, 0.1810, 0.1502, 0.1221,\n    0.0968, 0.0743, 0.0548, 0.0381, 0.0245, 0.0138, 0.0061, 0.0015,\n    0.0000, 0.0015, 0.0061, 0.0138, 0.0245, 0.0381, 0.0548, 0.0743,\n    0.0968, 0.1221, 0.1502, 0.1810, 0.2145, 0.2506, 0.2891, 0.3301,\n    0.3735, 0.4191, 0.4669, 0.5168, 0.5688, 0.6226, 0.6782, 0.7355,\n    0.7944, 0.8549, 0.9168, 0.9799, 1.0000, 0.9799, 0.9168, 0.8549,\n    0.7944, 0.7355, 0.6782, 0.6226, 0.5688, 0.5168, 0.4669, 0.4191,\n    0.3735, 0.3301, 0.2891, 0.2506, 0.2145, 0.1810, 0.1502, 0.1221,\n    0.0968, 0.0743, 0.0548, 0.0381, 0.0245, 0.0138, 0.0061, 0.0015,\n    0.0000, 0.0015, 0.0061, 0.0138, 0.0245, 0.0381, 0.0548, 0.0743,\n    0.0968, 0.1221, 0.1502, 0.1810, 0.2145, 0.2506, 0.2891, 0.3301,\n    0.3735, 0.4191, 0.4669, 0.5168, 0.5688, 0.6226, 0.6782, 0.7355,\n    0.7944, 0.8549, 0.9168, 0.9799, 1.0000, 0.9799, 0.9168, 0.8549,\n    0.7944, 0.7355, 0.6782, 0.6226, 0.5688, 0.5168, 0.4669, 0.4191,\n    0.3735, 0.3301, 0.2891, 0.2506, 0.2145, 0.1810, 0.1502, 0.1221,\n    0.0968, 0.0743, 0.0548, 0.0381, 0.0245, 0.0138, 0.0061, 0.0015,\n    0.0000, 0.0015, 0.0061, 0.0138, 0.0245, 0.0381, 0.0548, 0.0743,\n    0.0968, 0.1221, 0.1502, 0.1810, 0.2145, 0.2506, 0.2891, 0.3301,\n    0.3735, 0.4191, 0.4669, 0.5168, 0.5688, 0.6226, 0.6782, 0.7355,\n    0.7944, 0.8549, 0.9168, 0.9799, 1.0000, 0.9799, 0.9168, 0.8549\n};\n\nDenseGrain").concat(n," granular").concat(n,"_grains[20]; // 20 concurrent grains\nfloat granular").concat(n,"_outputL = 0.0;\nfloat granular").concat(n,"_outputR = 0.0;\nint granular").concat(n,"_samples_since_grain = 0;\nbool granular").concat(n,"_process_even = true; // Round-robin: alternate processing even/odd grains\n\n// Runtime variables for control and audio processing\nfloat granular").concat(n,"_inputL = 0.0;\nfloat granular").concat(n,"_inputR = 0.0;\nfloat granular").concat(n,"_currentDensity = ").concat(e.params.grain_density||15,";\nfloat granular").concat(n,"_currentPosition = ").concat(e.params.position||.5,";\nfloat granular").concat(n,"_currentPitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(n,"_currentDryWet = ").concat(e.params.dry_wet||1,";\nfloat granular").concat(n,"_currentFreeze = ").concat(e.params.freeze||0,";\nfloat granular").concat(n,"_currentStereoWidth = ").concat(e.params.stereo_width||.5,";\nfloat granular").concat(n,"_currentCloudPan = ").concat(e.params.cloud_pan||.5,";\nfloat granular").concat(n,"_currentPitchCV1 = 0.0;\nfloat granular").concat(n,"_currentPitchCV2 = 0.0;\nfloat granular").concat(n,"_currentPitchCV3 = 0.0;\nfloat granular").concat(n,"_currentPitchCV4 = 0.0;\n");case"SamplePlayer":return e.params.polyphonic?"\n// ".concat(t.label," ").concat(n," - Polyphonic Sample Player with PSRAM (6 voices)\n#define SP").concat(n,"_VOICES 6\n#define SP").concat(n,"_BUFFER_SIZE 1572864  // 1.5MB PSRAM buffer per voice\n\nstruct SampleVoice").concat(n," {\n    int16_t* psramData;              // PSRAM sample data\n    uint32_t sampleLength;           // Length in samples\n    uint32_t playPosition;           // Current play position\n    float pitch;                     // Playback speed multiplier\n    float gain;                      // Voice gain\n    bool active;                     // Voice active state\n    int midiNote;                    // MIDI note for this voice\n    unsigned long noteOnTime;        // Note on timestamp\n    bool gateOpen;                   // Gate state\n    float fractionalPos;             // Fractional position for pitch control\n};\n\nSampleVoice").concat(n," sp").concat(n,"_voices[SP").concat(n,"_VOICES];\nint sp").concat(n,"_nextVoice = 0;        // Round-robin voice allocation\nint sp").concat(n,"_currentSample = ").concat(e.params.fileMin||1,";  // Current sample number\nfloat sp").concat(n,"_masterGain = ").concat(e.params.gain||.8,";\nfloat sp").concat(n,"_outputL = 0.0;\nfloat sp").concat(n,"_outputR = 0.0;\n\n// Sample metadata\nString sp").concat(n,'_currentFile = "";\nbool sp').concat(n,"_samplesLoaded = false;\nint sp").concat(n,"_sampleCount = 0;\n\n// Polyphonic control\nint sp").concat(n,"_baseNote = ").concat(e.params.base_note||60,"; // Middle C\nfloat sp").concat(n,"_adsrPitchRange = ").concat(e.params.adsr_pitch_range||2,";\nfloat sp").concat(n,"_adsrPitchCenter = ").concat(e.params.adsr_pitch_center||0,";\n"):"\n// ".concat(t.label," ").concat(n," - Single-Voice Sample Player (legacy mode)\nMinimalWAVPlayer sp").concat(n,"_player;\nfloat sp").concat(n,"_gain = ").concat(e.params.gain||.8,";\nfloat sp").concat(n,"_pitch = ").concat(e.params.pitch||1,";\nbool sp").concat(n,"_loop = ").concat(e.params.loop||!1,";\nbool sp").concat(n,"_playing = false;\nint sp").concat(n,"_currentFile = ").concat(e.params.fileMin||1,";\nint sp").concat(n,"_sampleCount = 0;\nString sp").concat(n,'_currentFileName = "";\nfloat sp').concat(n,"_triggerThreshold = 0.5;\nbool sp").concat(n,"_lastTrigger = false;\nfloat sp").concat(n,"_outputL = 0.0;\nfloat sp").concat(n,"_outputR = 0.0;\nint sp").concat(n,"_lastLoadedFile = -1;\n\n// File transfer variables\nbool fileTransferActive").concat(n," = false;\nString transferFilename").concat(n,' = "";\nFile transferFile').concat(n,";\nuint32_t expectedFileSize").concat(n," = 0;\nuint32_t receivedBytes").concat(n," = 0;\n\n// Ring buffer for file transfers\nuint8_t* ringBuffer").concat(n," = NULL;\nvolatile int ringWritePos").concat(n," = 0;\nvolatile int ringReadPos").concat(n," = 0;\nvolatile int ringBufferCount").concat(n," = 0;\nconst int ringBufferSize").concat(n," = 65536;\nportMUX_TYPE ringBufferMux").concat(n," = portMUX_INITIALIZER_UNLOCKED;\n");default:return""}}},{key:"generateOscillatorProcessingCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"freq"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"morph"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"fm"===n.to.port}),i=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"wave"===n.to.port}),l=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch_cv"===n.to.port}),s="osc".concat(n,"_gate"),u="osc".concat(n,"_freq"),d="osc".concat(n,"_morph"),p="0.0",f="osc".concat(n,"_waveform"),m="0.5";if(a){var _=a.from.id.split(":")[0],g=this.connectionResolver.modules.find(function(e){return e.id===_});if(g){var h,v=(null===(h=_.match(/\d+$/))||void 0===h?void 0:h[0])||"1";s="ADSR"===g.type?"(adsr".concat(v,"_output > 0.1)"):"osc".concat(n,"_gate")}}if(o){var b=o.from.id.split(":")[0],y=this.connectionResolver.modules.find(function(e){return e.id===b});if(y){var k,S="Pot"===y.type?y.params.index:(null===(k=b.match(/\d+$/))||void 0===k?void 0:k[0])||"1";switch(y.type){case"Scale":u="scale".concat(S,"_output");break;case"Pot":var x=y.params.index||1;u="(pot".concat(x,"_value * 2000.0 + 20.0)");break;case"LFO":u="lfo".concat(S,"_output");break;case"ADSR":u="(adsr".concat(S,"_output * 1000.0 + ").concat(e.params.freq||440,")")}}}if(r){var E=r.from.id.split(":")[0],P=this.connectionResolver.modules.find(function(e){return e.id===E});if(P){var w,C=(null===(w=E.match(/\d+$/))||void 0===w?void 0:w[0])||"1";switch(P.type){case"LFO":d="lfo".concat(C,"_output");break;case"Pot":var R=P.params.index||1;d="pot".concat(R,"_value");break;case"ADSR":d="adsr".concat(C,"_output")}}}if(c){var L=c.from.id.split(":")[0],I=this.connectionResolver.modules.find(function(e){return e.id===L});if(I){var M,D=(null===(M=L.match(/\d+$/))||void 0===M?void 0:M[0])||"1";switch(I.type){case"Oscillator":p="osc".concat(D,"_outputL");break;case"LFO":p="lfo".concat(D,"_output");break;case"ADSR":p="adsr".concat(D,"_output");break;case"Pot":var A=I.params.index||1;p="pot".concat(A,"_value")}}}if(i){var O=i.from.id.split(":")[0],T=this.connectionResolver.modules.find(function(e){return e.id===O});if(T){var B,z=(null===(B=O.match(/\d+$/))||void 0===B?void 0:B[0])||"1";switch(T.type){case"Pot":var F=T.params.index||1;f="(int)(pot".concat(F,"_value * 3.99)");break;case"LFO":f="(int)(abs(lfo".concat(z,"_output) * 3.99)")}}}if(l){var N=l.from.id.split(":")[0],G=this.connectionResolver.modules.find(function(e){return e.id===N});if(G){var q,U=(null===(q=N.match(/\d+$/))||void 0===q?void 0:q[0])||"1";switch(G.type){case"ADSR":m="adsr".concat(U,"_output");break;case"LFO":m="lfo".concat(U,"_output");break;case"Pot":var W=G.params.index||1;m="pot".concat(W,"_value")}}}return"\n        // Oscillator ".concat(n," processing\n        // DEBUG: Gate source = ").concat(s,", connection from ").concat(a?a.from.id:"none","\n        if (").concat(s," > 0.1) {\n            float freq = ").concat(u,";\n            float morph = constrain(").concat(d,", 0.0, 1.0);\n            float fm_input = ").concat(p,";\n\n            // Exponential pitch CV modulation (semitones, like KickDrum pitch envelope)\n            // pitch_amount: +24 = upward sweep, -24 = downward kick pitch drop\n            float pitch_cv = ").concat(m,";\n\n            // Smooth pitch CV to prevent artifacts from rapid ADSR changes\n            // One-pole lowpass: coefficient 0.3 = gentle smoothing without losing responsiveness\n            osc").concat(n,"_pitch_smooth = osc").concat(n,"_pitch_smooth * 0.7 + pitch_cv * 0.3;\n\n            float pitch_offset_semitones = (osc").concat(n,"_pitch_smooth - 0.5) * osc").concat(n,"_pitch_amount;\n            float pitch_multiplier = pow(2.0, pitch_offset_semitones / 12.0);\n            freq = freq * pitch_multiplier;\n\n            // FM synthesis: modulate frequency with FM input and amount\n            float fm_freq_offset = fm_input * osc").concat(n,"_fm_amount * freq; // FM amount as ratio of base frequency\n            float effective_freq = freq + fm_freq_offset;\n\n            // Constrain to reasonable frequency range\n            effective_freq = constrain(effective_freq, 1.0, 20000.0);\n\n            osc").concat(n,"_phase += (2.0 * M_PI * effective_freq) / 44100.0;\n            if (osc").concat(n,"_phase >= 2.0 * M_PI) {\n                osc").concat(n,"_phase -= 2.0 * M_PI;\n            }\n\n            float sample = 0.0;\n\n            // Dynamic wave selection with morphing - only compute needed waveforms (CPU optimization)\n            int current_wave = ").concat(f,";\n            current_wave = constrain(current_wave, 0, 3); // Ensure valid range\n\n            if (current_wave == 0) {\n                // Sine base - morph towards triangle\n                float sine_wave = sin(osc").concat(n,"_phase);\n                if (morph > 0.001) {\n                    float triangle_wave = (2.0 / M_PI) * asin(sine_wave); // Reuse sine_wave to avoid double sin()\n                    sample = sine_wave * (1.0 - morph) + triangle_wave * morph;\n                } else {\n                    sample = sine_wave; // Pure sine - skip expensive asin()\n                }\n            } else if (current_wave == 1) {\n                // Triangle base - morph towards saw\n                float triangle_wave = (2.0 / M_PI) * asin(sin(osc").concat(n,"_phase));\n                if (morph > 0.001) {\n                    float saw_wave = (2.0 / M_PI) * (osc").concat(n,"_phase - M_PI);\n                    sample = triangle_wave * (1.0 - morph) + saw_wave * morph;\n                } else {\n                    sample = triangle_wave; // Pure triangle\n                }\n            } else if (current_wave == 2) {\n                // Saw base - morph towards square\n                float saw_wave = (2.0 / M_PI) * (osc").concat(n,"_phase - M_PI);\n                if (morph > 0.001) {\n                    float square_wave = (osc").concat(n,"_phase < M_PI) ? 1.0 : -1.0;\n                    sample = saw_wave * (1.0 - morph) + square_wave * morph;\n                } else {\n                    sample = saw_wave; // Pure saw\n                }\n            } else if (current_wave == 3) {\n                // Square base - morph towards sine (wrap around)\n                float square_wave = (osc").concat(n,"_phase < M_PI) ? 1.0 : -1.0;\n                if (morph > 0.001) {\n                    float sine_wave = sin(osc").concat(n,"_phase);\n                    sample = square_wave * (1.0 - morph) + sine_wave * morph;\n                } else {\n                    sample = square_wave; // Pure square - skip expensive sin()\n                }\n            }\n\n            osc").concat(n,"_outputL = sample * osc").concat(n,"_amplitude;\n            osc").concat(n,"_outputR = osc").concat(n,"_outputL;\n\n            // DEBUG: Print oscillator output every 500ms\n            static unsigned long oscDebugTime_").concat(n," = 0;\n            if (millis() - oscDebugTime_").concat(n," > 500) {\n                oscDebugTime_").concat(n,' = millis();\n                Serial.print("Osc').concat(n,' - freq=");\n                Serial.print(osc').concat(n,'_freq);\n                Serial.print(", gate=");\n                Serial.print(osc').concat(n,'_gate);\n                Serial.print(", amp=");\n                Serial.print(osc').concat(n,'_amplitude);\n                Serial.print(", out=");\n                Serial.println(osc').concat(n,"_outputL);\n            }\n        } else {\n            osc").concat(n,"_outputL = 0.0;\n            osc").concat(n,"_outputR = 0.0;\n        }\n")}},{key:"generateFilterCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"cutoff_hz"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"resonance"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&("inL"===n.to.port||"in"===n.to.port)}),c="filter".concat(n,"_cutoff"),i="filter".concat(n,"_resonance");if(a){var l=a.from.id.split(":")[0],s=this.connectionResolver.modules.find(function(e){return e.id===l});if(s){var u,d=(null===(u=l.match(/\d+$/))||void 0===u?void 0:u[0])||"1";switch(s.type){case"ADSR":c="(filter".concat(n,"_cutoff * adsr").concat(d,"_output)");break;case"LFO":c="(filter".concat(n,"_lfo_min_hz + lfo").concat(d,"_output * (filter").concat(n,"_lfo_max_hz - filter").concat(n,"_lfo_min_hz))");break;case"Pot":c="(filter".concat(n,"_lfo_min_hz + pot").concat(d,"_value * (filter").concat(n,"_lfo_max_hz - filter").concat(n,"_lfo_min_hz))")}}}if(o){var p=o.from.id.split(":")[0],f=this.connectionResolver.modules.find(function(e){return e.id===p});if(f){var m,_=(null===(m=p.match(/\d+$/))||void 0===m?void 0:m[0])||"1";switch(f.type){case"Pot":i="pot".concat(_,"_value");break;case"LFO":i="lfo".concat(_,"_output");break;case"ADSR":i="adsr".concat(_,"_output")}}}if(r){var g=r.from.id.split(":")[0],h=this.connectionResolver.modules.find(function(e){return e.id===g});if(h){var v,b=(null===(v=g.match(/\d+$/))||void 0===v?void 0:v[0])||"1";switch(h.type){case"Oscillator":"osc".concat(b,"_outputL");break;case"VCA":"vca".concat(b,"_outputL");break;case"Filter":"filter".concat(b,"_outputL");break;case"Noise":"noise".concat(b,"_output");break;case"AudioMath":"audioMath".concat(b,"_output");break;case"Delay":"delay".concat(b,"_outputL");break;case"CleanReverb":"cleanreverb".concat(b,"_outputL");break;case"Panner":"panner".concat(b,"_outputL");break;case"StereoMixer4":"stereoMixer4_".concat(b,"_outputL");break;case"Matrix2x2":"matrix".concat(b,"_outputL")}}}return"\n        // Filter ".concat(n," processing\n        {\n            float cutoff = constrain(").concat(c,", 20.0, 20000.0); // Constrain cutoff frequency\n            float resonance = constrain(").concat(i,", 0.0, 1.0); // Constrain resonance\n            float inputL = filter").concat(n,"_inputL;\n            float inputR = filter").concat(n,"_inputR;\n\n            // One-pole coefficient for filtering\n            float alpha = 2.0 * M_PI * cutoff / 44100.0;\n            alpha = constrain(alpha, 0.001, 0.99); // Keep well below Nyquist\n\n            // Process left channel\n            filter").concat(n,"_y1 = filter").concat(n,"_y1 + alpha * (inputL - filter").concat(n,"_y1);\n\n            // Process right channel\n            filter").concat(n,"_y2 = filter").concat(n,"_y2 + alpha * (inputR - filter").concat(n,'_y2);\n\n            // Generate different filter outputs based on mode\n            float outputL, outputR;\n            if (strcmp("').concat(e.params.mode,'", "lowpass") == 0) {\n                // LOWPASS: Use filtered signal directly\n                outputL = filter').concat(n,"_y1;\n                outputR = filter").concat(n,'_y2;\n            } else if (strcmp("').concat(e.params.mode,'", "highpass") == 0) {\n                // HIGHPASS: Input minus lowpass = highpass\n                outputL = inputL - filter').concat(n,"_y1;\n                outputR = inputR - filter").concat(n,'_y2;\n            } else if (strcmp("').concat(e.params.mode,'", "bandpass") == 0) {\n                // BANDPASS: Difference between input and lowpass, scaled by resonance\n                float diffL = inputL - filter').concat(n,"_y1;\n                float diffR = inputR - filter").concat(n,"_y2;\n                outputL = diffL * (0.5f + resonance * 0.5f); // Resonance boosts bandpass\n                outputR = diffR * (0.5f + resonance * 0.5f);\n            } else { // notch\n                // NOTCH: Input minus bandpass = notch (removes frequencies around cutoff)\n                float diffL = inputL - filter").concat(n,"_y1;\n                float diffR = inputR - filter").concat(n,"_y2;\n                float bandpassL = diffL * (0.5f + resonance * 0.5f);\n                float bandpassR = diffR * (0.5f + resonance * 0.5f);\n                outputL = inputL - bandpassL;\n                outputR = inputR - bandpassR;\n            }\n\n            // Prevent denormals\n            if (fabsf(outputL) < 1e-10f) outputL = 0.0f;\n            if (fabsf(outputR) < 1e-10f) outputR = 0.0f;\n\n            filter").concat(n,"_outputL = outputL;\n            filter").concat(n,"_outputR = outputR;\n        }\n")}},{key:"generateDistortionCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"drive"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"tone"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"mix"===n.to.port}),c="dist".concat(n,"_drive"),i="dist".concat(n,"_tone"),l="dist".concat(n,"_mix");if(a){var s=a.from.id.split(":")[0],u=this.connectionResolver.modules.find(function(e){return e.id===s});if(u){var d,p=(null===(d=s.match(/\d+$/))||void 0===d?void 0:d[0])||"1";switch(u.type){case"Pot":var f=u.params.index||p;c="(pot".concat(f,"_value * 10.0)");break;case"LFO":c="(lfo".concat(p,"_output * 10.0)")}}}if(o){var m=o.from.id.split(":")[0],_=this.connectionResolver.modules.find(function(e){return e.id===m});if(_){var g,h=(null===(g=m.match(/\d+$/))||void 0===g?void 0:g[0])||"1";switch(_.type){case"Pot":var v=_.params.index||h;i="(500.0 + pot".concat(v,"_value * 7500.0)");break;case"LFO":i="(500.0 + lfo".concat(h,"_output * 7500.0)")}}}if(r){var b=r.from.id.split(":")[0],y=this.connectionResolver.modules.find(function(e){return e.id===b});if(y){var k,S=(null===(k=b.match(/\d+$/))||void 0===k?void 0:k[0])||"1";switch(y.type){case"Pot":var x=y.params.index||S;l="pot".concat(x,"_value");break;case"LFO":l="lfo".concat(S,"_output")}}}var E=e.params.bypassMode||"toggle";return"\n        // Distortion ".concat(n," processing - CPU cost: ~20 units\n        {\n            float inputL = dist").concat(n,"_inputL;\n            float inputR = dist").concat(n,"_inputR;\n\n            // Handle bypass control (").concat(E," mode)\n            bool bypassTrigger = (dist").concat(n,"_bypass > 0.5);\n            ").concat("toggle"===E?"\n            // Toggle mode: button press switches bypass on/off\n            if (bypassTrigger && !dist".concat(n,"_lastBypassTrigger) {\n                dist").concat(n,"_bypassState = !dist").concat(n,"_bypassState;  // Toggle on rising edge\n            }\n            dist").concat(n,"_lastBypassTrigger = bypassTrigger;\n            bool isBypassed = dist").concat(n,"_bypassState;\n            "):"\n            // Gate mode: bypassed only while button is held\n            bool isBypassed = bypassTrigger;\n            ","\n\n            if (isBypassed) {\n                // Bypass: pass audio through unprocessed\n                dist").concat(n,"_outputL = inputL;\n                dist").concat(n,"_outputR = inputR;\n            } else {\n                // Active: process distortion\n                float drive = constrain(").concat(c,", 0.1, 10.0);\n                float tone_freq = constrain(").concat(i,", 500.0, 8000.0);\n                float mix = constrain(").concat(l,", 0.0, 1.0);\n\n                // Save dry signal for blending\n                float dryL = inputL;\n                float dryR = inputR;\n\n                // Apply drive (pre-gain)\n                float wetL = inputL * drive;\n                float wetR = inputR * drive;\n\n                // CV-controlled preset selection (for rhythmic preset switching)\n                // Map 0-1 CV to preset index 0-5\n                int presetIdx = constrain((int)(dist").concat(n,"_preset_cv * 5.999), 0, 5);\n\n                // Select active waveshaping table based on CV\n                const float* activeTable = nullptr;\n                switch(presetIdx) {\n                    case 0: activeTable = dist").concat(n,"_table_clean; break;\n                    case 1: activeTable = dist").concat(n,"_table_overdrive; break;\n                    case 2: activeTable = dist").concat(n,"_table_fuzz; break;\n                    case 3: activeTable = dist").concat(n,"_table_speaker; break;\n                    case 4: activeTable = dist").concat(n,"_table_bitcrush; break;\n                    case 5: activeTable = dist").concat(n,"_table_saturatorlive; break;\n                    default: activeTable = dist").concat(n,"_table_overdrive; break;\n                }\n\n                // Waveshaping lookup with linear interpolation\n                // Map -drive..+drive to 0..255 table index\n                float indexL = constrain((wetL + drive) / (2.0 * drive), 0.0, 0.9999) * 256.0;\n                float indexR = constrain((wetR + drive) / (2.0 * drive), 0.0, 0.9999) * 256.0;\n\n                int idxL = (int)indexL;\n                int idxR = (int)indexR;\n                float fracL = indexL - idxL;\n                float fracR = indexR - idxR;\n\n                // Apply waveshaping with selected preset table\n                wetL = activeTable[idxL] * (1.0 - fracL) + activeTable[idxL + 1] * fracL;\n                wetR = activeTable[idxR] * (1.0 - fracR) + activeTable[idxR + 1] * fracR;\n\n                // Optional crossfade between presets (for smooth transitions)\n                if (dist").concat(n,"_presetCrossfade > 0.0 && presetIdx < 5) {\n                    // Crossfade with next preset\n                    const float* nextTable = nullptr;\n                    switch(presetIdx + 1) {\n                        case 1: nextTable = dist").concat(n,"_table_overdrive; break;\n                        case 2: nextTable = dist").concat(n,"_table_fuzz; break;\n                        case 3: nextTable = dist").concat(n,"_table_speaker; break;\n                        case 4: nextTable = dist").concat(n,"_table_bitcrush; break;\n                        case 5: nextTable = dist").concat(n,"_table_saturatorlive; break;\n                        default: nextTable = dist").concat(n,"_table_overdrive; break;\n                    }\n\n                    float nextWetL = nextTable[idxL] * (1.0 - fracL) + nextTable[idxL + 1] * fracL;\n                    float nextWetR = nextTable[idxR] * (1.0 - fracR) + nextTable[idxR + 1] * fracR;\n\n                    // Crossfade amount determined by preset_cv fractional part\n                    float cvFrac = (dist").concat(n,"_preset_cv * 5.999) - presetIdx;\n                    float blend = cvFrac * dist").concat(n,"_presetCrossfade;\n\n                    wetL = wetL * (1.0 - blend) + nextWetL * blend;\n                    wetR = wetR * (1.0 - blend) + nextWetR * blend;\n                }\n\n                // Post-filter (tone control) - simple one-pole lowpass\n                float alpha = 2.0 * M_PI * tone_freq / 44100.0;\n                alpha = constrain(alpha, 0.001, 0.99);\n\n                dist").concat(n,"_filterL = dist").concat(n,"_filterL + alpha * (wetL - dist").concat(n,"_filterL);\n                dist").concat(n,"_filterR = dist").concat(n,"_filterR + alpha * (wetR - dist").concat(n,"_filterR);\n\n                wetL = dist").concat(n,"_filterL;\n                wetR = dist").concat(n,"_filterR;\n\n                // Dry/wet mix\n                dist").concat(n,"_outputL = dryL * (1.0 - mix) + wetL * mix;\n                dist").concat(n,"_outputR = dryR * (1.0 - mix) + wetR * mix;\n\n                // Prevent denormals\n                if (fabsf(dist").concat(n,"_outputL) < 1e-10f) dist").concat(n,"_outputL = 0.0f;\n                if (fabsf(dist").concat(n,"_outputR) < 1e-10f) dist").concat(n,"_outputR = 0.0f;\n            }\n        }\n")}},{key:"generateDistortionVariables",value:function(e,n,t){var a=function(e){for(var n=[],t=0;t<257;t++){var a=t/256*2-1,o=0;switch(e){case"clean":o=a/(1+.3*Math.abs(a));break;case"overdrive":o=Math.abs(a)<.33?2*a:Math.abs(a)<.67?(3-Math.pow(2-3*Math.abs(a),2))/3*Math.sign(a):Math.sign(a);break;case"fuzz":o=a>.4?.8:a<-.5?-1:1.5*a,o=Math.max(-1,Math.min(1,o));break;case"speaker":o=2/(1+Math.exp(-2.5*a))-1;break;case"bitcrush":o=Math.round(8*a)/8,o=Math.max(-1,Math.min(1,o));break;case"saturatorlive":o=[-.5,-.485011,-.470211,-.455768,-.44181,-.428413,-.415592,-.403298,-.391425,-.379822,-.368306,-.356685,-.344776,-.332427,-.319533,-.30605,-.292008,-.277512,-.262746,-.24796,-.233464,-.219603,-.206738,-.195211,-.185318,-.177271,-.171167,-.166964,-.164459,-.16329,-.162946,-.162797,-.16215,-.16031,-.156661,-.150747,-.14235,-.131551,-.118765,-.10475,-.090565,-.077504,-.066979,-.060387,-.05896,-.063616,-.074827,-.092535,-.116102,-.144337,-.175575,-.207814,-.238899,-.266735,-.289493,-.305807,-.314911,-.31673,-.311878,-.30159,-.287577,-.271825,-.256365,-.243043,-.233302,-.22803,-.227474,-.231236,-.238352,-.247446,-.256933,-.26525,-.271078,-.273524,-.272247,-.267498,-.260081,-.251229,-.242417,-.235149,-.230725,-.230052,-.233502,-.240853,-.251316,-.263649,-.276342,-.287843,-.296795,-.302252,-.303831,-.301792,-.297011,-.290866,-.285038,-.28126,-.281052,-.285472,-.294933,-.309108,-.326945,-.346798,-.366647,-.384398,-.398201,-.40676,-.40957,-.407054,-.400564,-.392246,-.384772,-.380967,-.383379,-.393858,-.413175,-.440766,-.474627,-.511389,-.546569,-.574987,-.591303,-.590604,-.568986,-.524057,-.45529,-.364195,-.254262,-.130705,0,.130705,.254262,.364195,.45529,.524057,.568986,.590604,.591303,.574987,.546569,.511389,.474627,.440766,.413175,.393858,.383379,.380967,.384772,.392246,.400564,.407054,.40957,.40676,.398201,.384398,.366647,.346798,.326945,.309108,.294933,.285472,.281052,.28126,.285038,.290866,.297011,.301792,.303831,.302252,.296795,.287843,.276342,.263649,.251316,.240853,.233502,.230052,.230725,.235149,.242417,.251229,.260081,.267498,.272247,.273524,.271078,.26525,.256933,.247446,.238352,.231236,.227474,.22803,.233302,.243043,.256365,.271825,.287577,.30159,.311878,.31673,.314911,.305807,.289493,.266735,.238899,.207814,.175575,.144337,.116102,.092535,.074827,.063616,.05896,.060387,.066979,.077504,.090565,.10475,.118765,.131551,.14235,.150747,.156661,.16031,.16215,.162797,.162946,.16329,.164459,.166964,.171167,.177271,.185318,.195211,.206738,.219603,.233464,.24796,.262746,.277512,.292008,.30605,.319533,.332427,.344776,.356685,.368306,.379822,.391425,.403298,.415592,.428413,.44181,.455768,.470211,.485011,.5][t];break;default:o=a}n.push(o.toFixed(6))}return n.join(", ")};return"\n// ".concat(t.label," ").concat(n," - Waveshaping Distortion with CV Preset Switching\n// All preset waveshaping tables (6KB total, 0.04% of ESP32-S3 16MB flash)\nconst float dist").concat(n,"_table_clean[257] = {").concat(a("clean"),"};\nconst float dist").concat(n,"_table_overdrive[257] = {").concat(a("overdrive"),"};\nconst float dist").concat(n,"_table_fuzz[257] = {").concat(a("fuzz"),"};\nconst float dist").concat(n,"_table_speaker[257] = {").concat(a("speaker"),"};\nconst float dist").concat(n,"_table_bitcrush[257] = {").concat(a("bitcrush"),"};\nconst float dist").concat(n,"_table_saturatorlive[257] = {").concat(a("saturatorlive"),"};\n\n// Filter state for tone control\nfloat dist").concat(n,"_filterL = 0.0;\nfloat dist").concat(n,"_filterR = 0.0;\n\n// I/O variables\nfloat dist").concat(n,"_inputL = 0.0;\nfloat dist").concat(n,"_inputR = 0.0;\nfloat dist").concat(n,"_outputL = 0.0;\nfloat dist").concat(n,"_outputR = 0.0;\n\n// Bypass control\nfloat dist").concat(n,"_bypass = 0.0;  // Control input (0 = active, 1 = bypassed)\nbool dist").concat(n,"_bypassState = false;  // Toggle state\nbool dist").concat(n,"_lastBypassTrigger = false;  // For toggle detection\n\n// Preset CV control\nfloat dist").concat(n,"_preset_cv = 0.0;  // 0-1 CV input for preset selection (0=clean ... 1=saturatorlive)\nint dist").concat(n,"_currentPreset = ").concat(["clean","overdrive","fuzz","speaker","bitcrush","saturatorlive"].indexOf(e.params.preset||"overdrive"),";  // Current preset index (0-5)\nfloat dist").concat(n,"_presetCrossfade = ").concat(e.params.presetCrossfade||0,";  // Crossfade amount (0=instant, 1=full blend)\n\n// Parameters\nfloat dist").concat(n,"_drive = ").concat(e.params.drive||2.5,";\nfloat dist").concat(n,"_tone = ").concat(e.params.tone||2e3,";\nfloat dist").concat(n,"_mix = ").concat(e.params.mix||.8,";\n")}},{key:"generateVCACode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gain"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&("inL"===n.to.port||"in"===n.to.port)}),r="vca".concat(n,"_gain"),c="0.0";if(a){var i=a.from.id.split(":")[0],l=this.connectionResolver.modules.find(function(e){return e.id===i});if(l){var s,u=(null===(s=i.match(/\d+$/))||void 0===s?void 0:s[0])||"1";switch(l.type){case"ADSR":r="adsr".concat(u,"_output");break;case"Pot":var d=l.params.index||u;r="pot".concat(d,"_value");break;case"LFO":r="lfo".concat(u,"_output");break;case"Scale":r="scale".concat(u,"_output");break;case"Modulation":r="modulation".concat(u,"_output");break;default:r="1.0"}}}if(o){var p=o.from.id.split(":")[0],f=this.connectionResolver.modules.find(function(e){return e.id===p});if(f){var m,_=(null===(m=p.match(/\d+$/))||void 0===m?void 0:m[0])||"1";switch(f.type){case"Oscillator":c="osc".concat(_,"_outputL");break;case"Filter":c="filter".concat(_,"_outputL");break;case"VCA":c="vca".concat(_,"_outputL");break;case"AudioMath":c="audioMath".concat(_,"_outputL");break;case"Noise":c="noise".concat(_,"_output");break;case"Delay":c="delay".concat(_,"_outputL");break;case"CleanReverb":c="cleanreverb".concat(_,"_outputL");break;case"Panner":c="panner".concat(_,"_outputL");break;case"StereoMixer4":c="stereoMixer4_".concat(_,"_outputL");break;case"Matrix2x2":c="matrix2x2_".concat(_,"_outputL");break;case"SamplePlayer":c="samplePlayer".concat(_,"_outputL");break;case"KickDrum":c="kickDrum".concat(_,"_output");break;case"SnareDrum":c="snareDrum".concat(_,"_output");break;case"Wavetable":c="wavetable".concat(_,"_outputL");break;case"GranularDense":c="granularDense".concat(_,"_outputL");break;case"ChorusFlangeRing":c="chorusFlangeRing".concat(_,"_outputL");break;case"Limiter":c="limiter".concat(_,"_outputL");break;case"NoiseGate":c="noiseGate".concat(_,"_outputL");break;case"EQ8":c="eq8_".concat(_,"_outputL");break;case"Percussion":c="percussion".concat(_,"_output");break;default:c="0.0"}}}return"\n        // VCA ".concat(n," processing\n        {\n            float gain = ").concat(a?"".concat(r," * vca").concat(n,"_gain"):r,";\n            // CRITICAL FIX: Read from input variables set by connection system\n            // OLD BROKEN: float inputL = ").concat(c,"; // Bypassed connections!\n            float inputL = vca").concat(n,"_inputL;\n            float inputR = vca").concat(n,"_inputR;\n\n            // Smooth gain changes to prevent clicking (10% per sample smoothing)\n            vca").concat(n,"_lastGain = vca").concat(n,"_lastGain * 0.9 + gain * 0.1;\n\n            vca").concat(n,"_outputL = inputL * vca").concat(n,"_lastGain;\n            vca").concat(n,"_outputR = inputR * vca").concat(n,"_lastGain;\n        }\n")}},{key:"generateI2SOutCode",value:function(e,n,t){var a=t.find(function(n){return n.to===e.id&&("L"===n.toPort||"inL"===n.toPort)}),o=t.find(function(n){return n.to===e.id&&("R"===n.toPort||"inR"===n.toPort)}),r="0.0",c="0.0";if(a){var i=a.from,l=this.connectionResolver.modules.find(function(e){return e.id===i});if(l){var s,u=(null===(s=i.match(/\d+$/))||void 0===s?void 0:s[0])||"1";switch(l.type){case"VCA":r="vca".concat(u,"_outputL");break;case"Filter":r="filter".concat(u,"_outputL");break;case"Oscillator":r="osc".concat(u,"_outputL");break;case"Delay":r="delay".concat(u,"_outputL");break;case"AudioMath":r="audioMath".concat(u,"_outputL");break;case"Noise":r="noise".concat(u,"_output");break;case"Panner":r="panner".concat(u,"_outputL");break;case"StereoMixer4":r="stereoMixer4_".concat(u,"_outputL");break;case"Matrix2x2":r="matrix2x2_".concat(u,"_outputL");break;case"SamplePlayer":r="samplePlayer".concat(u,"_outputL");break;case"KickDrum":r="kickDrum".concat(u,"_output");break;case"SnareDrum":r="snareDrum".concat(u,"_output");break;case"Wavetable":r="wavetable".concat(u,"_outputL");break;case"GranularDense":r="granular".concat(u,"_outputL");break;case"ChorusFlangeRing":r="chorusFlangeRing".concat(u,"_outputL");break;case"Limiter":r="limiter".concat(u,"_outputL");break;case"NoiseGate":r="noiseGate".concat(u,"_outputL");break;case"EQ8":r="eq8_".concat(u,"_outputL");break;case"Percussion":r="percussion".concat(u,"_output");break;default:r="0.0"}}}if(o){var d=o.from,p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"VCA":c="vca".concat(m,"_outputR");break;case"Filter":c="filter".concat(m,"_outputR");break;case"Oscillator":c="osc".concat(m,"_outputR");break;case"Delay":c="delay".concat(m,"_outputR");break;case"AudioMath":c="audioMath".concat(m,"_outputR");break;case"Noise":c="noise".concat(m,"_output");break;case"CleanReverb":c="cleanreverb".concat(m,"_outputR");break;case"Panner":c="panner".concat(m,"_outputR");break;case"StereoMixer4":c="stereoMixer4_".concat(m,"_outputR");break;case"Matrix2x2":c="matrix2x2_".concat(m,"_outputR");break;case"SamplePlayer":c="samplePlayer".concat(m,"_outputR");break;case"KickDrum":c="kickDrum".concat(m,"_output");break;case"SnareDrum":c="snareDrum".concat(m,"_output");break;case"Wavetable":c="wavetable".concat(m,"_outputR");break;case"GranularDense":c="granular".concat(m,"_outputR");break;case"ChorusFlangeRing":c="chorusFlangeRing".concat(m,"_outputR");break;case"Limiter":c="limiter".concat(m,"_outputR");break;case"NoiseGate":c="noiseGate".concat(m,"_outputR");break;case"EQ8":c="eq8_".concat(m,"_outputR");break;case"Percussion":c="percussion".concat(m,"_output");break;default:c="0.0"}}}return"\n        // I2S Output ".concat(n," - Send to DAC\n        {\n            float inputL = ").concat(r,";\n            float inputR = ").concat(c,";\n\n            i2sout").concat(n,"_inputL = inputL * i2sout").concat(n,"_volume;\n            i2sout").concat(n,"_inputR = inputR * i2sout").concat(n,"_volume;\n\n            // DEBUG: Print I2S input signals every 500ms\n            static unsigned long i2sDebugTime_").concat(n," = 0;\n            if (i == 0 && millis() - i2sDebugTime_").concat(n," > 500) { // Only print once per buffer\n                i2sDebugTime_").concat(n,' = millis();\n                Serial.print("I2S').concat(n,' - inputL=");\n                Serial.print(inputL);\n                Serial.print(", inputR=");\n                Serial.print(inputR);\n                Serial.print(", vol=");\n                Serial.print(i2sout').concat(n,'_volume);\n                Serial.print(", outL=");\n                Serial.println(i2sout').concat(n,"_inputL);\n            }\n\n            // Convert to 16-bit signed integers and add to main audio buffers\n            leftBuffer[i] = i2sout").concat(n,"_inputL;\n            rightBuffer[i] = i2sout").concat(n,"_inputR;\n        }\n")}},{key:"generateWavetableCode",value:function(e,n,t){t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"freq"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"morph"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"table_select"===n.to.port});var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"fm"===n.to.port});return"\n        // Wavetable ".concat(n," processing\n        {\n            // Control processing\n            ").concat(this.generateWavetableControlProcessing(e,n,t),"\n\n            // Audio generation\n            if (wt").concat(n,"_gate > 0.5) {\n                // FM synthesis: modulate frequency with audio-rate input\n                float wt").concat(n,"_fm_input = 0.0;\n                ").concat(a?this.generateWavetableFMConnection(a,n):"","\n\n                // FM ratio mapping with musical detent zones (applied to fm_amount)\n                float cv = wt").concat(n,"_fm_ratio_cv;\n                float computed_ratio;\n                if (cv < 0.1) {\n                    computed_ratio = 0.5; // 1:2 (octave below)\n                } else if (cv < 0.15) {\n                    computed_ratio = 0.5 + (cv - 0.1) * 3.34; // Smooth to 0.667\n                } else if (cv < 0.25) {\n                    computed_ratio = 0.667; // 2:3 (perfect fifth down)\n                } else if (cv < 0.3) {\n                    computed_ratio = 0.667 + (cv - 0.25) * 6.66; // Smooth to 1.0\n                } else if (cv < 0.4) {\n                    computed_ratio = 1.0; // 1:1 (unison)\n                } else if (cv < 0.45) {\n                    computed_ratio = 1.0 + (cv - 0.4) * 10.0; // Smooth to 1.5\n                } else if (cv < 0.55) {\n                    computed_ratio = 1.5; // 3:2 (perfect fifth)\n                } else if (cv < 0.6) {\n                    computed_ratio = 1.5 + (cv - 0.55) * 10.0; // Smooth to 2.0\n                } else if (cv < 0.7) {\n                    computed_ratio = 2.0; // 2:1 (octave)\n                } else if (cv < 0.75) {\n                    computed_ratio = 2.0 + (cv - 0.7) * 20.0; // Smooth to 3.0\n                } else if (cv < 0.85) {\n                    computed_ratio = 3.0; // 3:1\n                } else if (cv < 0.9) {\n                    computed_ratio = 3.0 + (cv - 0.85) * 20.0; // Smooth to 4.0\n                } else {\n                    computed_ratio = 4.0; // 4:1 (two octaves)\n                }\n\n                // FM modulation (classic FM: fm_amount controls depth, ratio controls frequency)\n                float fm_freq_offset = wt").concat(n,"_fm_input * wt").concat(n,"_fm_amount * wt").concat(n,"_freq;\n                float effective_freq = wt").concat(n,"_freq + fm_freq_offset;\n                effective_freq = constrain(effective_freq, 1.0, 20000.0);\n\n                // Phase increment calculation with FM\n                float phaseIncrement = (effective_freq * WT").concat(n,"_TABLE_SIZE) / SAMPLE_RATE;\n                wt").concat(n,"_phase += phaseIncrement;\n\n                // Keep phase in range [0, TABLE_SIZE) - OPTIMIZED: Single if instead of while loop\n                if (wt").concat(n,"_phase >= WT").concat(n,"_TABLE_SIZE) {\n                    wt").concat(n,"_phase -= WT").concat(n,"_TABLE_SIZE;\n                }\n\n                // Linear interpolation for smooth playback\n                int index1 = (int)wt").concat(n,"_phase;\n                int index2 = (index1 + 1) % WT").concat(n,"_TABLE_SIZE;\n                float frac = wt").concat(n,"_phase - index1;\n\n                // Select wavetable based on current table or morphing\n                float* currentTable;\n                float sample = 0.0;\n\n                if (wt").concat(n,"_morph <= 0.0) {\n                    // Use table 0\n                    currentTable = wt").concat(n,"_table0;\n                    sample = currentTable[index1] * (1.0 - frac) + currentTable[index2] * frac;\n                } else if (wt").concat(n,"_morph < 1.0) {\n                    // Morph between table 0 and table 1\n                    float sample0 = wt").concat(n,"_table0[index1] * (1.0 - frac) + wt").concat(n,"_table0[index2] * frac;\n                    float sample1 = wt").concat(n,"_table1[index1] * (1.0 - frac) + wt").concat(n,"_table1[index2] * frac;\n                    sample = sample0 * (1.0 - wt").concat(n,"_morph) + sample1 * wt").concat(n,"_morph;\n                } else if (wt").concat(n,"_morph < 2.0) {\n                    // Morph between table 1 and table 2\n                    float morphFrac = wt").concat(n,"_morph - 1.0;\n                    float sample1 = wt").concat(n,"_table1[index1] * (1.0 - frac) + wt").concat(n,"_table1[index2] * frac;\n                    float sample2 = wt").concat(n,"_table2[index1] * (1.0 - frac) + wt").concat(n,"_table2[index2] * frac;\n                    sample = sample1 * (1.0 - morphFrac) + sample2 * morphFrac;\n                } else {\n                    // Morph between table 2 and table 3\n                    float morphFrac = constrain(wt").concat(n,"_morph - 2.0, 0.0, 1.0);\n                    float sample2 = wt").concat(n,"_table2[index1] * (1.0 - frac) + wt").concat(n,"_table2[index2] * frac;\n                    float sample3 = wt").concat(n,"_table3[index1] * (1.0 - frac) + wt").concat(n,"_table3[index2] * frac;\n                    sample = sample2 * (1.0 - morphFrac) + sample3 * morphFrac;\n                }\n\n                // Apply gain\n                wt").concat(n,"_outputL = sample * wt").concat(n,"_gain;\n                wt").concat(n,"_outputR = wt").concat(n,"_outputL; // Mono for now\n            } else {\n                wt").concat(n,"_outputL = 0.0;\n                wt").concat(n,"_outputR = 0.0;\n            }\n        }\n")}},{key:"generateGranularCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"grain_density"===n.to.port}),c=(t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"grain_size_ms"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"position"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"dry_wet"===n.to.port}),"0.0"),i="0.0",l="granular".concat(n,"_grain_density"),s="granular".concat(n,"_grain_size_ms"),u="granular".concat(n,"_position"),d="granular".concat(n,"_pitch"),p="granular".concat(n,"_dry_wet");if(a){var f=a.from.id.split(":")[0],m=this.connectionResolver.modules.find(function(e){return e.id===f});if(m){var _,g=(null===(_=f.match(/\d+$/))||void 0===_?void 0:_[0])||"1";switch(m.type){case"Oscillator":c="osc".concat(g,"_outputL");break;case"VCA":c="vca".concat(g,"_outputL")}}}if(o){var h=o.from.id.split(":")[0],v=this.connectionResolver.modules.find(function(e){return e.id===h});if(v){var b,y=(null===(b=h.match(/\d+$/))||void 0===b?void 0:b[0])||"1";switch(v.type){case"Oscillator":i="osc".concat(y,"_outputR");break;case"VCA":i="vca".concat(y,"_outputR")}}}if(r){var k=r.from.id.split(":")[0],S=this.connectionResolver.modules.find(function(e){return e.id===k});if(S){var x,E=(null===(x=k.match(/\d+$/))||void 0===x?void 0:x[0])||"1";"Pot"===S.type&&(l="(pot".concat(E,"_value * 32.0 + 0.5)"))}}return"\n        // GranularSynth ".concat(n," processing\n        {\n            float inputL = ").concat(c,";\n            float inputR = ").concat(i,";\n            float density = ").concat(l,";\n            float grain_size = ").concat(s,";\n            float position = ").concat(u,";\n            float pitch = ").concat(d,";\n            float dry_wet = ").concat(p,";\n\n            // Write input to circular buffer\n            granular").concat(n,"_buffer_L[granular").concat(n,"_write_pos] = inputL;\n            granular").concat(n,"_buffer_R[granular").concat(n,"_write_pos] = inputR;\n            granular").concat(n,"_write_pos = (granular").concat(n,"_write_pos + 1) % granular").concat(n,"_buffer_size;\n\n            // Update grain interval based on density\n            granular").concat(n,"_grain_interval_ms = 1000.0 / density;\n\n            // Trigger new grains based on density\n            unsigned long currentTime = millis();\n            if (currentTime - granular").concat(n,"_last_grain_trigger >= granular").concat(n,"_grain_interval_ms) {\n                // Find inactive grain slot\n                for (int g = 0; g < 4; g++) {\n                    if (!granular").concat(n,"_grains[g].active) {\n                        // Activate new grain\n                        granular").concat(n,"_grains[g].active = true;\n                        granular").concat(n,"_grains[g].position = position + ((random(-100, 100) / 100.0) * granular").concat(n,"_position_spread);\n                        granular").concat(n,"_grains[g].pitch_ratio = 1.0 + pitch + ((random(-100, 100) / 100.0) * granular").concat(n,"_pitch_spread);\n                        granular").concat(n,"_grains[g].amplitude = 0.25; // 1/4 volume per grain for 4 concurrent grains\n                        granular").concat(n,"_grains[g].grain_size_samples = (int)(grain_size * 44.1); // ms to samples\n                        granular").concat(n,"_grains[g].samples_remaining = granular").concat(n,"_grains[g].grain_size_samples;\n                        break;\n                    }\n                }\n                granular").concat(n,"_last_grain_trigger = currentTime;\n            }\n\n            // Process all active grains\n            float outputL = 0.0;\n            float outputR = 0.0;\n\n            for (int g = 0; g < 4; g++) {\n                if (granular").concat(n,"_grains[g].active) {\n                    // Calculate buffer position for this grain\n                    float bufferPos = granular").concat(n,"_grains[g].position * granular").concat(n,"_buffer_size;\n                    int pos = (int)bufferPos % granular").concat(n,"_buffer_size;\n\n                    // Apply envelope (simple triangular)\n                    float envelope = 1.0;\n                    float progress = (float)(granular").concat(n,"_grains[g].grain_size_samples - granular").concat(n,"_grains[g].samples_remaining) / granular").concat(n,"_grains[g].grain_size_samples;\n                    if (progress < 0.5) {\n                        envelope = progress * 2.0; // Attack\n                    } else {\n                        envelope = 2.0 - (progress * 2.0); // Release\n                    }\n\n                    // Read from buffer and apply grain\n                    outputL += granular").concat(n,"_buffer_L[pos] * granular").concat(n,"_grains[g].amplitude * envelope;\n                    outputR += granular").concat(n,"_buffer_R[pos] * granular").concat(n,"_grains[g].amplitude * envelope;\n\n                    // Update grain state\n                    granular").concat(n,"_grains[g].samples_remaining--;\n                    if (granular").concat(n,"_grains[g].samples_remaining <= 0) {\n                        granular").concat(n,"_grains[g].active = false;\n                    }\n\n                    // Update position based on pitch\n                    granular").concat(n,"_grains[g].position += granular").concat(n,"_grains[g].pitch_ratio / granular").concat(n,"_buffer_size;\n                    if (granular").concat(n,"_grains[g].position >= 1.0) {\n                        granular").concat(n,"_grains[g].position -= 1.0;\n                    }\n                }\n            }\n\n            // Mix dry and processed signals\n            granular").concat(n,"_outputL = (inputL * (1.0 - dry_wet)) + (outputL * dry_wet);\n            granular").concat(n,"_outputR = (inputR * (1.0 - dry_wet)) + (outputR * dry_wet);\n        }\n")}},{key:"generateKickDrumCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"trigger"===n.to.port}),o="false";if(a){var r=a.from.id.split(":")[0],c=this.connectionResolver.modules.find(function(e){return e.id===r});if(c){var i,l=(null===(i=r.match(/\d+$/))||void 0===i?void 0:i[0])||"1";switch(c.type){case"LEDButton":var s=c.params.index||1;o="btn".concat(s,"_pressed");break;case"Clock":o="clock".concat(l,"_output")}}}return"\n        // KickDrum ".concat(n," - Multi-Layer Drum Synthesizer (Sample + Oscillator + Noise)\n        {\n            bool trigger = ").concat(o,";\n\n            // Trigger all layers on rising edge\n            static bool kick").concat(n,"_lastTrigger = false;\n            if (trigger && !kick").concat(n,"_lastTrigger) {\n                // Sample layer trigger\n                if (kick").concat(n,"_lastLoadedFile != kick").concat(n,'_currentFile) {\n                    String filename = "/kick0" + String(kick').concat(n,'_currentFile) + ".wav";\n                    if (SD.exists(filename)) {\n                        kick').concat(n,"_player.loadFile(filename);\n                        kick").concat(n,"_lastLoadedFile = kick").concat(n,"_currentFile;\n                        kick").concat(n,"_currentFileName = filename;\n                    }\n                }\n                kick").concat(n,"_player.setPlaybackSpeed(kick").concat(n,"_sample_pitch);\n                kick").concat(n,"_player.play();\n\n                // Oscillator layer trigger\n                kick").concat(n,"_osc_amp_stage = 1; // Start attack\n                kick").concat(n,"_osc_amp_time = 0.0;\n\n                // Pitch envelope trigger\n                kick").concat(n,"_pitch_env_stage = 1; // Start attack\n                kick").concat(n,"_pitch_env_time = 0.0;\n                kick").concat(n,"_osc_pitch_env = 0.0; // Start at zero, build up to amount\n\n                // Noise layer trigger\n                kick").concat(n,"_noise_amp_stage = 1; // Start noise attack\n                kick").concat(n,"_noise_amp_time = 0.0;\n\n                kick").concat(n,"_triggered = true;\n            }\n            kick").concat(n,"_lastTrigger = trigger;\n\n            // === SAMPLE LAYER PROCESSING ===\n            if (kick").concat(n,"_player.playing()) {\n                int16_t sample = kick").concat(n,"_player.getNextSample();\n                float sampleFloat = (float)sample / 32767.0f;\n                kick").concat(n,"_sample_outputL = sampleFloat * kick").concat(n,"_sample_gain;\n                kick").concat(n,"_sample_outputR = kick").concat(n,"_sample_outputL;\n            } else {\n                kick").concat(n,"_sample_outputL = 0.0;\n                kick").concat(n,"_sample_outputR = 0.0;\n            }\n\n            // === OSCILLATOR LAYER PROCESSING ===\n            kick").concat(n,"_osc_outputL = 0.0;\n            kick").concat(n,"_osc_outputR = 0.0;\n\n            if (kick").concat(n,"_osc_amp_stage > 0) {\n                float sampleTime = 1.0 / SAMPLE_RATE;\n                kick").concat(n,"_osc_amp_time += sampleTime;\n\n                // Oscillator amplitude envelope\n                switch (kick").concat(n,"_osc_amp_stage) {\n                    case 1: // Attack\n                        if (kick").concat(n,"_osc_amp_time >= kick").concat(n,"_osc_amp_attack) {\n                            kick").concat(n,"_osc_amp_stage = 2;\n                            kick").concat(n,"_osc_amp_time = 0.0;\n                            kick").concat(n,"_osc_amp_env = 1.0;\n                        } else {\n                            kick").concat(n,"_osc_amp_env = kick").concat(n,"_osc_amp_time / kick").concat(n,"_osc_amp_attack;\n                        }\n                        break;\n\n                    case 2: // Decay\n                        if (kick").concat(n,"_osc_amp_time >= kick").concat(n,"_osc_amp_decay) {\n                            kick").concat(n,"_osc_amp_stage = 3;\n                            kick").concat(n,"_osc_amp_time = 0.0;\n                        } else {\n                            float progress = kick").concat(n,"_osc_amp_time / kick").concat(n,"_osc_amp_decay;\n                            kick").concat(n,"_osc_amp_env = 1.0 - progress * (1.0 - kick").concat(n,"_osc_amp_sustain);\n                        }\n                        break;\n\n                    case 3: // Sustain\n                        kick").concat(n,"_osc_amp_env = kick").concat(n,"_osc_amp_sustain;\n                        if (!trigger) {\n                            kick").concat(n,"_osc_amp_stage = 4; // Release\n                            kick").concat(n,"_osc_amp_time = 0.0;\n                        }\n                        break;\n\n                    case 4: // Release\n                        if (kick").concat(n,"_osc_amp_time >= kick").concat(n,"_osc_amp_release) {\n                            kick").concat(n,"_osc_amp_stage = 0; // Idle\n                            kick").concat(n,"_osc_amp_env = 0.0;\n                        } else {\n                            float progress = kick").concat(n,"_osc_amp_time / kick").concat(n,"_osc_amp_release;\n                            kick").concat(n,"_osc_amp_env = kick").concat(n,"_osc_amp_sustain * (1.0 - progress);\n                        }\n                        break;\n                }\n\n                // Pitch envelope ADSR processing\n                if (kick").concat(n,"_pitch_env_stage > 0) {\n                    kick").concat(n,"_pitch_env_time += sampleTime;\n\n                    switch (kick").concat(n,"_pitch_env_stage) {\n                        case 1: // Attack\n                            if (kick").concat(n,"_pitch_env_time >= kick").concat(n,"_pitch_env_attack) {\n                                kick").concat(n,"_pitch_env_stage = 2;\n                                kick").concat(n,"_pitch_env_time = 0.0;\n                                kick").concat(n,"_osc_pitch_env = kick").concat(n,"_pitch_env_amount;\n                            } else {\n                                kick").concat(n,"_osc_pitch_env = (kick").concat(n,"_pitch_env_time / kick").concat(n,"_pitch_env_attack) * kick").concat(n,"_pitch_env_amount;\n                            }\n                            break;\n\n                        case 2: // Decay\n                            if (kick").concat(n,"_pitch_env_time >= kick").concat(n,"_pitch_env_decay) {\n                                kick").concat(n,"_pitch_env_stage = 3;\n                                kick").concat(n,"_pitch_env_time = 0.0;\n                                kick").concat(n,"_osc_pitch_env = kick").concat(n,"_pitch_env_amount * kick").concat(n,"_pitch_env_sustain;\n                            } else {\n                                float progress = kick").concat(n,"_pitch_env_time / kick").concat(n,"_pitch_env_decay;\n                                kick").concat(n,"_osc_pitch_env = kick").concat(n,"_pitch_env_amount * (1.0 - progress * (1.0 - kick").concat(n,"_pitch_env_sustain));\n                            }\n                            break;\n\n                        case 3: // Sustain\n                            kick").concat(n,"_osc_pitch_env = kick").concat(n,"_pitch_env_amount * kick").concat(n,"_pitch_env_sustain;\n                            if (!trigger) {\n                                kick").concat(n,"_pitch_env_stage = 4; // Release\n                                kick").concat(n,"_pitch_env_time = 0.0;\n                            }\n                            break;\n\n                        case 4: // Release\n                            if (kick").concat(n,"_pitch_env_time >= kick").concat(n,"_pitch_env_release) {\n                                kick").concat(n,"_pitch_env_stage = 0; // Idle\n                                kick").concat(n,"_osc_pitch_env = 0.0;\n                            } else {\n                                float progress = kick").concat(n,"_pitch_env_time / kick").concat(n,"_pitch_env_release;\n                                kick").concat(n,"_osc_pitch_env = (kick").concat(n,"_pitch_env_amount * kick").concat(n,"_pitch_env_sustain) * (1.0 - progress);\n                            }\n                            break;\n                    }\n                }\n\n                // Generate oscillator with pitch modulation\n                if (!kick").concat(n,"_osc_mute && kick").concat(n,"_osc_amp_env > 0.001) {\n                    float pitchMod = pow(2.0, kick").concat(n,"_osc_pitch_env);\n                    float oscFreq = kick").concat(n,"_osc_freq * pitchMod;\n                    kick").concat(n,"_osc_phase += 2.0 * PI * oscFreq / SAMPLE_RATE;\n                    if (kick").concat(n,"_osc_phase >= 2.0 * PI) kick").concat(n,"_osc_phase -= 2.0 * PI;\n\n                    float osc_sample = sin(kick").concat(n,"_osc_phase);\n\n                    // Apply distortion if enabled\n                    if (kick").concat(n,"_osc_distortion > 0.0) {\n                        float drive = 1.0 + kick").concat(n,"_osc_distortion; // 1-11 range\n                        osc_sample *= drive;\n                        osc_sample = tanh(osc_sample); // Soft saturation\n                    }\n\n                    osc_sample *= kick").concat(n,"_osc_level * kick").concat(n,"_osc_amp_env;\n                    kick").concat(n,"_osc_outputL = osc_sample;\n                    kick").concat(n,"_osc_outputR = osc_sample;\n                } else if (kick").concat(n,"_osc_amp_stage == 0) {\n                    // Reset phase when envelope is idle to prevent artifacts on retrigger\n                    kick").concat(n,"_osc_phase = 0.0;\n                }\n            }\n\n            // === NOISE LAYER PROCESSING ===\n            kick").concat(n,"_noise_outputL = 0.0;\n            kick").concat(n,"_noise_outputR = 0.0;\n\n            if (kick").concat(n,"_noise_amp_stage > 0) {\n                float sampleTime = 1.0 / SAMPLE_RATE;\n                kick").concat(n,"_noise_amp_time += sampleTime;\n\n                // Noise amplitude envelope\n                switch (kick").concat(n,"_noise_amp_stage) {\n                    case 1: // Attack\n                        if (kick").concat(n,"_noise_amp_time >= kick").concat(n,"_noise_amp_attack) {\n                            kick").concat(n,"_noise_amp_stage = 2;\n                            kick").concat(n,"_noise_amp_time = 0.0;\n                            kick").concat(n,"_noise_amp_env = 1.0;\n                        } else {\n                            kick").concat(n,"_noise_amp_env = kick").concat(n,"_noise_amp_time / kick").concat(n,"_noise_amp_attack;\n                        }\n                        break;\n\n                    case 2: // Decay\n                        if (kick").concat(n,"_noise_amp_time >= kick").concat(n,"_noise_amp_decay) {\n                            kick").concat(n,"_noise_amp_stage = 3;\n                            kick").concat(n,"_noise_amp_time = 0.0;\n                        } else {\n                            float progress = kick").concat(n,"_noise_amp_time / kick").concat(n,"_noise_amp_decay;\n                            kick").concat(n,"_noise_amp_env = 1.0 - progress * (1.0 - kick").concat(n,"_noise_amp_sustain);\n                        }\n                        break;\n\n                    case 3: // Sustain\n                        kick").concat(n,"_noise_amp_env = kick").concat(n,"_noise_amp_sustain;\n                        if (!trigger) {\n                            kick").concat(n,"_noise_amp_stage = 4; // Release\n                            kick").concat(n,"_noise_amp_time = 0.0;\n                        }\n                        break;\n\n                    case 4: // Release\n                        if (kick").concat(n,"_noise_amp_time >= kick").concat(n,"_noise_amp_release) {\n                            kick").concat(n,"_noise_amp_stage = 0; // Idle\n                            kick").concat(n,"_noise_amp_env = 0.0;\n                        } else {\n                            float progress = kick").concat(n,"_noise_amp_time / kick").concat(n,"_noise_amp_release;\n                            kick").concat(n,"_noise_amp_env = kick").concat(n,"_noise_amp_sustain * (1.0 - progress);\n                        }\n                        break;\n                }\n\n                // Generate noise with FPU-safe implementation\n                if (kick").concat(n,"_noise_amp_env > 0.001) {\n                    float white_noise = 0.0;\n                    float pink_noise = 0.0;\n                    float brown_noise = 0.0;\n\n                    // FPU-safe LCG noise generation (isolated from oscillator)\n                    uint32_t temp_seed = kick").concat(n,"_noise_lcg_seed;\n                    temp_seed = (temp_seed * 1103515245U + 12345U) & 0x7FFFFFFFU;\n                    kick").concat(n,"_noise_lcg_seed = temp_seed;\n                    int32_t noise_int = (int32_t)(temp_seed & 0xFFFF) - 32768;\n                    white_noise = (float)noise_int * (1.0f / 32768.0f);\n\n                    // Simple noise approximations (FPU-safe for now)\n                    pink_noise = white_noise * 0.5; // Scaled approximation\n                    brown_noise = white_noise * 0.3; // Scaled approximation\n\n                    // Mix noise types based on current type and morph\n                    float noise_output = 0.0;\n                    if (kick").concat(n,"_noise_type == 0) {\n                        // White noise base - morph towards pink\n                        noise_output = white_noise * (1.0 - kick").concat(n,"_noise_morph) + pink_noise * kick").concat(n,"_noise_morph;\n                    } else if (kick").concat(n,"_noise_type == 1) {\n                        // Pink noise base - morph towards brown\n                        noise_output = pink_noise * (1.0 - kick").concat(n,"_noise_morph) + brown_noise * kick").concat(n,"_noise_morph;\n                    } else if (kick").concat(n,"_noise_type == 2) {\n                        // Brown noise base - morph towards white\n                        noise_output = brown_noise * (1.0 - kick").concat(n,"_noise_morph) + white_noise * kick").concat(n,"_noise_morph;\n                    }\n\n                    float final_noise = noise_output * kick").concat(n,"_noise_gain * kick").concat(n,"_noise_amp_env;\n                    kick").concat(n,"_noise_outputL = final_noise;\n                    kick").concat(n,"_noise_outputR = final_noise;\n                }\n            }\n\n            // === LAYER MIXING ===\n            // Mix all active layers to master output\n            kick").concat(n,"_outputL = kick").concat(n,"_sample_outputL + kick").concat(n,"_osc_outputL + kick").concat(n,"_noise_outputL;\n            kick").concat(n,"_outputR = kick").concat(n,"_sample_outputR + kick").concat(n,"_osc_outputR + kick").concat(n,"_noise_outputR;\n        }\n")}},{key:"generateDrumDesignerCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"velocity"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch"===n.to.port}),c=(t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"damping"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"body_resonance"===n.to.port}),"false"),i="ks".concat(n,"_velocityInput"),l="ks".concat(n,"_pitch"),s="ks".concat(n,"_damping"),u="ks".concat(n,"_bodyResonance");if(a){var d=a.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d}),f=a.from.port;if(p){var m,_=(null===(m=d.match(/\d+$/))||void 0===m?void 0:m[0])||"1";switch(p.type){case"LEDButton":var g=p.params.index||1;c="btn".concat(g,"_gate");break;case"MIDIIn":c="midi".concat(_,"_gate");break;case"GateGen":c="gate".concat(_,"_output");break;case"Clock":var h=f.replace("out","");c="clock".concat(_,"_out").concat(h)}}}if(o){var v=o.from.id.split(":")[0],b=this.connectionResolver.modules.find(function(e){return e.id===v});if(b){var y,k=(null===(y=v.match(/\d+$/))||void 0===y?void 0:y[0])||"1";"MIDIIn"===b.type&&(i="midi".concat(k,"_velocity"))}}if(r){var S=r.from.id.split(":")[0],x=this.connectionResolver.modules.find(function(e){return e.id===S}),E=r.from.port;if(console.log("DrumDesigner".concat(n," pitch connection: fromId=").concat(S,", fromModule=").concat(x?x.type:"NOT FOUND",", fromPort=").concat(E)),x){var P,w=(null===(P=S.match(/\d+$/))||void 0===P?void 0:P[0])||"1";switch(console.log("  Extracted fromIndex=".concat(w," from ").concat(S)),x.type){case"MIDIIn":l="midi".concat(w,"_note");break;case"LEDButton":var C=x.params.index||1;"sampleOut"===E&&(l="(btn".concat(C,"_sampleOut * 72.0 + 24.0)"));break;case"Pot":l="(pot".concat(w,"_value * 72.0 + 24.0)"),console.log("  Generated pitchSource: ".concat(l))}}}return"\n        // DrumDesigner ".concat(n," - Karplus-Strong Physical Modeling Synthesizer\n        {\n            // === CONTROL INPUT PROCESSING (100Hz control rate) ===\n            static unsigned long ks").concat(n,"_lastControlUpdate = 0;\n            if (currentTime - ks").concat(n,"_lastControlUpdate >= 10) { // 100Hz control rate\n                ks").concat(n,"_lastControlUpdate = currentTime;\n\n                ks").concat(n,"_velocityInput = ").concat(i,";\n                float currentPitch = ").concat(l,";\n                ks").concat(n,"_damping = ").concat(s,";\n                ks").concat(n,"_bodyResonance = ").concat(u,";\n\n                // Pre-calculate frequency from pitch at control rate (expensive powf!)\n                // frequency = 440 * 2^((note - 69) / 12)\n                float noteOffset = (currentPitch - 69.0f) + (ks").concat(n,"_fineTune / 100.0f);\n                ks").concat(n,"_currentFreq = 440.0f * powf(2.0f, noteOffset / 12.0f);\n\n                // Pre-calculate base sine frequency for sine oscillator\n                ks").concat(n,"_baseSineFreq = ks").concat(n,"_currentFreq;\n            }\n\n            // Gate input is audio-rate for accurate trigger timing\n            ks").concat(n,"_gateInput = ").concat(c,";\n\n            // === TRIGGER DETECTION ===\n            // Detect rising edge on gate input\n            bool trigger = (ks").concat(n,"_gateInput > 0.5f && !ks").concat(n,"_lastGate);\n            bool release = (ks").concat(n,"_gateInput < 0.5f && ks").concat(n,"_lastGate);\n\n            if (trigger) {\n                // Use pre-calculated frequency from control rate\n                ks").concat(n,"_delayLength = (int)(44100.0f / ks").concat(n,"_currentFreq);\n\n                // Clamp delay length to valid range\n                if (ks").concat(n,"_delayLength < 10) ks").concat(n,"_delayLength = 10;\n                if (ks").concat(n,"_delayLength > KS_MAX_DELAY_").concat(n,") ks").concat(n,"_delayLength = KS_MAX_DELAY_").concat(n,";\n\n                // Calculate pitch-dependent gain compensation for consistent amplitude\n                // Higher pitches (shorter delays) need more gain\n                // Reference pitch: MIDI 60 (C4, ~262Hz, delay ~168 samples)\n                float refDelayLength = 168.0f;\n                ks").concat(n,"_pitchGainComp = sqrtf((float)ks").concat(n,"_delayLength / refDelayLength);\n                // Clamp to prevent clipping on low pitches and excessive attenuation on high pitches\n                if (ks").concat(n,"_pitchGainComp > 1.5f) ks").concat(n,"_pitchGainComp = 1.5f;  // Max 1.5x gain\n                if (ks").concat(n,"_pitchGainComp < 0.7f) ks").concat(n,"_pitchGainComp = 0.7f;  // Min 0.7x gain\n\n                // Initialize delay line with excitation signal (FAST version using pre-generated noise)\n                // Fast copy from pre-generated noise buffer (100x faster than per-sample random())\n                memcpy(ks").concat(n,"_delayLine, ks").concat(n,"_noiseBuffer, ks").concat(n,"_delayLength * sizeof(float));\n\n                // Pitch-dependent excitation filtering for better bass response\n                // Low pitches (long delays) need heavily filtered excitation to emphasize fundamental\n                // High pitches (short delays) sound better with brighter excitation\n                float pitchFilterAmount = 0.0f;\n                if (ks").concat(n,"_delayLength > 512) {\n                    // Long delay (low pitch) - apply progressively more lowpass filtering\n                    // delayLength 512 (86 Hz) = no filter\n                    // delayLength 2048 (22 Hz) = heavy filter\n                    // delayLength 8192 (5 Hz) = very heavy filter\n                    pitchFilterAmount = (float)(ks").concat(n,"_delayLength - 512) / (float)(KS_MAX_DELAY_").concat(n," - 512);\n                    pitchFilterAmount = pitchFilterAmount * 0.9f; // Scale to 0.0-0.9 range\n                }\n\n                // Mode-dependent post-processing (optional filtering)\n                if (strcmp(ks").concat(n,'_mode, "tonal") == 0) {\n                    // TONAL MODE: Apply pitch-dependent filtering for bass response\n                    if (pitchFilterAmount > 0.01f) {\n                        // Low pitch detected - apply aggressive lowpass to excitation for bass emphasis\n                        // Multi-pass filtering for very low frequencies (each pass removes more highs)\n                        int numPasses = 1 + (int)(pitchFilterAmount * 3.0f); // 1-4 passes based on pitch\n                        float alpha = 0.1f + (pitchFilterAmount * 0.05f); // 0.1-0.15 (very aggressive lowpass)\n\n                        for (int pass = 0; pass < numPasses; pass++) {\n                            ks').concat(n,"_prevSample = 0.0f;\n                            for (int i = 0; i < ks").concat(n,"_delayLength; i++) {\n                                float excitation = ks").concat(n,"_delayLine[i];\n                                // Very aggressive lowpass (alpha 0.1 = 90% of previous sample)\n                                excitation = alpha * excitation + (1.0f - alpha) * ks").concat(n,"_prevSample;\n                                ks").concat(n,"_prevSample = excitation;\n                                ks").concat(n,"_delayLine[i] = excitation;\n                            }\n                        }\n\n                        // Compensate for energy loss from heavy filtering\n                        float gainBoost = 1.5f + (pitchFilterAmount * 2.0f); // 1.5x-3.5x gain for low freqs\n                        for (int i = 0; i < ks").concat(n,"_delayLength; i++) {\n                            ks").concat(n,"_delayLine[i] *= gainBoost;\n                        }\n                    }\n                    // High pitches use unfiltered noise for brightness\n\n                } else if (strcmp(ks").concat(n,'_mode, "percussive") == 0) {\n                    // PERCUSSIVE MODE: Apply brightness and position filtering for marimba-like sounds\n                    ks').concat(n,"_prevSample = 0.0f;\n                    for (int i = 0; i < ks").concat(n,"_delayLength; i++) {\n                        float excitation = ks").concat(n,"_delayLine[i];\n\n                        // Apply brightness filter (simple 1-pole lowpass)\n                        float alpha = ks").concat(n,"_brightness;\n                        excitation = alpha * excitation + (1.0f - alpha) * ks").concat(n,"_prevSample;\n                        ks").concat(n,"_prevSample = excitation;\n\n                        // Apply strike position (comb filtering effect)\n                        float positionPhase = (float)i / (float)ks").concat(n,"_delayLength;\n                        float positionMod = 1.0f - fabsf(positionPhase - ks").concat(n,"_position) * 0.5f;\n                        excitation *= positionMod;\n\n                        ks").concat(n,'_delayLine[i] = excitation;\n                    }\n\n                } else {  // "noise" mode\n                    // NOISE MODE: Heavy lowpass filtering for short, noisy hits\n                    ks').concat(n,"_prevSample = 0.0f;\n                    float alpha = 0.3f;\n                    for (int i = 0; i < ks").concat(n,"_delayLength; i++) {\n                        float excitation = ks").concat(n,"_delayLine[i];\n                        excitation = alpha * excitation + (1.0f - alpha) * ks").concat(n,"_prevSample;\n                        ks").concat(n,"_prevSample = excitation;\n                        ks").concat(n,"_delayLine[i] = excitation;\n                    }\n                }\n\n                // CRITICAL FIX: Set writePos to delayLength so readPos points to start of initialized data\n                // readPos = (writePos - delayLength + MAX) % MAX = (delayLength - delayLength + MAX) % MAX = 0\n                ks").concat(n,"_writePos = ks").concat(n,"_delayLength;\n\n                // Trigger amplitude envelope\n                ks").concat(n,"_ampStage = 1; // Attack\n                ks").concat(n,"_ampTime = 0.0f;\n                ks").concat(n,"_triggered = true;\n\n                // Initialize pitch sweep (sine or delay mode)\n                if (strcmp(ks").concat(n,'_pitchSweepMode, "sine") == 0) {\n                    // Sine oscillator pitch envelope (808 style)\n                    ks').concat(n,"_sinePitchStage = 1; // Attack (instant)\n                    ks").concat(n,"_sinePitchTime = 0.0f;\n                    ks").concat(n,"_sinePhase = 0.0f; // Reset phase for clean attack\n                } else if (strcmp(ks").concat(n,'_pitchSweepMode, "delay") == 0) {\n                    // K-S delay sweep (Boss delay feedback style)\n                    ks').concat(n,"_delayTarget = (float)ks").concat(n,"_delayLength;  // Store target delay\n                    ks").concat(n,"_delayCurrent = ks").concat(n,"_delayTarget * 0.1f; // Start at 10% (high pitch)\n                    ks").concat(n,"_delaySweepTime = 0.0f;\n                    ks").concat(n,"_delayLength = (int)ks").concat(n,"_delayCurrent;   // Use short delay initially\n                }\n            }\n\n            if (release && ks").concat(n,"_ampStage > 0 && ks").concat(n,"_ampStage < 4) {\n                // Gate released during attack/decay/sustain - enter release stage\n                ks").concat(n,"_ampStage = 4;\n                ks").concat(n,"_ampTime = 0.0f;\n            }\n\n            ks").concat(n,"_lastGate = (ks").concat(n,"_gateInput > 0.5f);\n\n            // Time step for all envelope/modulation calculations\n            const float dt = 1.0f / 44100.0f;\n\n            // === DELAY SWEEP (Boss delay pitch-drop effect) ===\n            if (strcmp(ks").concat(n,'_pitchSweepMode, "delay") == 0 && ks').concat(n,"_ampStage > 0) {\n                ks").concat(n,"_delaySweepTime += dt;\n\n                // Exponential sweep from short to long delay (high to low pitch)\n                if (ks").concat(n,"_delaySweepTime < ks").concat(n,"_sinePitchDecay) {\n                    float t = ks").concat(n,"_delaySweepTime / ks").concat(n,"_sinePitchDecay;\n                    float sweepEnv = 1.0f - expf(-4.0f * t);  // 0  1 exponential curve\n\n                    // Interpolate from 10% to 100% of target delay\n                    ks").concat(n,"_delayCurrent = (ks").concat(n,"_delayTarget * 0.1f) +\n                                             (sweepEnv * ks").concat(n,"_delayTarget * 0.9f);\n                    ks").concat(n,"_delayLength = (int)ks").concat(n,"_delayCurrent;\n\n                    // Clamp to valid range\n                    if (ks").concat(n,"_delayLength < 10) ks").concat(n,"_delayLength = 10;\n                    if (ks").concat(n,"_delayLength > KS_MAX_DELAY_").concat(n,") ks").concat(n,"_delayLength = KS_MAX_DELAY_").concat(n,";\n                } else {\n                    // Sweep complete - stay at target delay\n                    ks").concat(n,"_delayLength = (int)ks").concat(n,"_delayTarget;\n                }\n            }\n\n            // === KARPLUS-STRONG SYNTHESIS ===\n            float ksSample = 0.0f;\n\n            if (ks").concat(n,"_ampStage > 0) {\n                // Read from delay line (optimized wraparound, no modulo!)\n                int readPos = ks").concat(n,"_writePos - ks").concat(n,"_delayLength;\n                if (readPos < 0) readPos += KS_MAX_DELAY_").concat(n,";\n                float delaySample = ks").concat(n,"_delayLine[readPos];\n\n                // Mode-dependent damping filter\n                float filteredSample;\n\n                if (strcmp(ks").concat(n,'_mode, "tonal") == 0) {\n                    // TONAL MODE (Teensy-style): Fixed damping coefficient for guitar-like decay\n                    // 0.9973  (32686 + 32686) / 65536 from Teensy implementation\n                    // Creates very slow, tonal decay similar to acoustic guitar/bass\n                    float dampingCoeff = 0.9973f;\n                    filteredSample = dampingCoeff * delaySample + (1.0f - dampingCoeff) * ks').concat(n,"_prevSample;\n\n                } else if (strcmp(ks").concat(n,'_mode, "percussive") == 0) {\n                    // PERCUSSIVE MODE: Variable damping for marimba/xylophone-like sounds\n                    // Higher damping = faster decay, more high-frequency loss\n                    float dampingCoeff = 0.5f + (ks').concat(n,"_damping * 0.499f); // Range: 0.5 to 0.999\n                    filteredSample = dampingCoeff * delaySample + (1.0f - dampingCoeff) * ks").concat(n,'_prevSample;\n\n                } else {  // "noise" mode\n                    // NOISE MODE: Very short decay for drum hits / noise bursts\n                    float dampingCoeff = 0.3f + (ks').concat(n,"_damping * 0.3f);  // Range: 0.3 to 0.6 (fast decay)\n                    filteredSample = dampingCoeff * delaySample + (1.0f - dampingCoeff) * ks").concat(n,"_prevSample;\n                }\n\n                // Apply stretch/inharmonicity (slightly detunes overtones for bell-like sounds)\n                // stretch > 1.0 makes delay length frequency-dependent\n                float stretchedSample = filteredSample * ks").concat(n,"_stretch;\n\n                // Write back to delay line (feedback loop)\n                ks").concat(n,"_delayLine[ks").concat(n,"_writePos] = stretchedSample;\n                ks").concat(n,"_prevSample = filteredSample;\n\n                // Advance write position (optimized wraparound, no modulo!)\n                ks").concat(n,"_writePos++;\n                if (ks").concat(n,"_writePos >= KS_MAX_DELAY_").concat(n,") ks").concat(n,"_writePos = 0;\n\n                ksSample = filteredSample;\n            }\n\n            // === BODY CHARACTER (Simple lowpass filter) ===\n            // Replaces heavy comb filters with lightweight lowpass for warmth/character\n            // CPU cost: ~0.1% vs 211% for comb filters!\n            float bodySample = ksSample;\n\n            if (ks").concat(n,"_bodyEnabled && ks").concat(n,"_ampStage > 0) {\n                // Simple one-pole lowpass filter for body warmth\n                // Cutoff determined by body_size (smaller = darker/warmer sound)\n                float cutoffFactor = 0.3f + (ks").concat(n,"_bodySize * 0.6f);  // 0.3-0.9 range\n                float alpha = 1.0f - cutoffFactor;  // Filter coefficient\n\n                // Apply lowpass with resonance feedback\n                float filtered = ksSample * (1.0f - alpha) + ks").concat(n,"_bodyLpf * alpha;\n\n                // Add slight resonance boost (creates mild peak at cutoff)\n                if (ks").concat(n,"_bodyResonance > 0.01f) {\n                    float resonanceFeedback = filtered * ks").concat(n,"_bodyResonance * 0.3f;\n                    filtered += resonanceFeedback;\n                }\n\n                ks").concat(n,"_bodyLpf = filtered;\n                bodySample = filtered;\n            }\n\n            // Apply pitch-dependent gain compensation for consistent amplitude across tuning range\n            bodySample *= ks").concat(n,"_pitchGainComp;\n\n            // === AMPLITUDE ENVELOPE (ADSR) ===\n            switch (ks").concat(n,"_ampStage) {\n                case 1: // Attack\n                    ks").concat(n,"_ampTime += dt;\n                    if (ks").concat(n,"_ampAttack > 0.0001f) {\n                        ks").concat(n,"_ampEnv = ks").concat(n,"_ampTime / ks").concat(n,"_ampAttack;\n                        if (ks").concat(n,"_ampEnv >= 1.0f) {\n                            ks").concat(n,"_ampEnv = 1.0f;\n                            ks").concat(n,"_ampStage = 2; // Move to decay\n                            ks").concat(n,"_ampTime = 0.0f;\n                        }\n                    } else {\n                        ks").concat(n,"_ampEnv = 1.0f;\n                        ks").concat(n,"_ampStage = 2;\n                        ks").concat(n,"_ampTime = 0.0f;\n                    }\n                    break;\n\n                case 2: // Decay\n                    ks").concat(n,"_ampTime += dt;\n                    if (ks").concat(n,"_ampDecay > 0.0001f) {\n                        float decayProgress = ks").concat(n,"_ampTime / ks").concat(n,"_ampDecay;\n                        ks").concat(n,"_ampEnv = 1.0f - (decayProgress * (1.0f - ks").concat(n,"_ampSustain));\n                        if (decayProgress >= 1.0f) {\n                            ks").concat(n,"_ampEnv = ks").concat(n,"_ampSustain;\n                            ks").concat(n,"_ampStage = 3; // Move to sustain\n                        }\n                    } else {\n                        ks").concat(n,"_ampEnv = ks").concat(n,"_ampSustain;\n                        ks").concat(n,"_ampStage = 3;\n                    }\n                    break;\n\n                case 3: // Sustain\n                    ks").concat(n,"_ampEnv = ks").concat(n,"_ampSustain;\n                    // Stay in sustain until gate released\n                    break;\n\n                case 4: // Release\n                    ks").concat(n,"_ampTime += dt;\n                    if (ks").concat(n,"_ampRelease > 0.0001f) {\n                        float releaseProgress = ks").concat(n,"_ampTime / ks").concat(n,"_ampRelease;\n                        ks").concat(n,"_ampEnv = ks").concat(n,"_ampSustain * (1.0f - releaseProgress);\n                        if (releaseProgress >= 1.0f) {\n                            ks").concat(n,"_ampEnv = 0.0f;\n                            ks").concat(n,"_ampStage = 0; // Idle\n                        }\n                    } else {\n                        ks").concat(n,"_ampEnv = 0.0f;\n                        ks").concat(n,"_ampStage = 0;\n                    }\n                    break;\n\n                default: // Idle\n                    ks").concat(n,"_ampEnv = 0.0f;\n                    break;\n            }\n\n            // === SINE OSCILLATOR FOR DEEP BASS ===\n            float sineOut = 0.0f;\n            if (ks").concat(n,"_sineEnabled) {\n                bool usePitchSweep = (strcmp(ks").concat(n,'_pitchSweepMode, "sine") == 0);\n\n                // Pitch envelope processing (only in "sine" mode)\n                if (usePitchSweep) {\n                    if (ks').concat(n,"_sinePitchStage == 1) { // Attack (instant)\n                        ks").concat(n,"_sinePitchStage = 2;\n                        ks").concat(n,"_sinePitchTime = 0.0f;\n                        ks").concat(n,"_sinePitchEnv = 1.0f;\n                    } else if (ks").concat(n,"_sinePitchStage == 2) { // Decay\n                        ks").concat(n,"_sinePitchTime += dt;\n                        if (ks").concat(n,"_sinePitchTime >= ks").concat(n,"_sinePitchDecay) {\n                            ks").concat(n,"_sinePitchStage = 0;\n                            ks").concat(n,"_sinePitchEnv = 0.0f;\n                        } else {\n                            float t = ks").concat(n,"_sinePitchTime / ks").concat(n,"_sinePitchDecay;\n                            // Exponential decay for smooth, musical pitch sweeps (classic 808 kick)\n                            ks").concat(n,"_sinePitchEnv = expf(-4.0f * t);\n                        }\n                    }\n                }\n\n                // Generate sine wave\n                if (ks").concat(n,"_ampStage > 0) {\n                    // Use pre-calculated base frequency from control rate (avoids expensive powf!)\n                    float sineFreq = ks").concat(n,"_baseSineFreq;\n                    if (usePitchSweep) {\n                        float pitchMod = powf(2.0f, ks").concat(n,"_sinePitchEnv * ks").concat(n,"_sinePitchAmount);\n                        sineFreq = ks").concat(n,"_baseSineFreq * pitchMod;\n                    }\n\n                    // Phase accumulation\n                    ks").concat(n,"_sinePhase += 2.0f * PI * sineFreq / 44100.0f;\n                    if (ks").concat(n,"_sinePhase >= 2.0f * PI) ks").concat(n,"_sinePhase -= 2.0f * PI;\n\n                    // Generate sine wave (no level scaling here - applied in output mixing)\n                    sineOut = fastSin(ks").concat(n,"_sinePhase);  // Fast approximation (5-10x faster than sinf)\n                } else {\n                    // Reset phase when envelope is idle to prevent artifacts\n                    ks").concat(n,"_sinePhase = 0.0f;\n                }\n            }\n\n            // === OUTPUT MIXING ===\n            // Apply envelope, velocity sensitivity, and output gain\n            float velocityAmount = 1.0f - ks").concat(n,"_velocitySensitivity + (ks").concat(n,"_velocitySensitivity * ks").concat(n,"_velocityInput);\n            float finalGain = ks").concat(n,"_ampEnv * velocityAmount * ks").concat(n,"_outputGain;\n\n            // Apply individual level controls and mix\n            float ksSampleScaled = bodySample * ks").concat(n,"_ksLevel;       // K-S harmonics level\n            float sineSampleScaled = sineOut * ks").concat(n,"_sineLevel;      // Sine fundamental level\n            float mixedSample = ksSampleScaled + sineSampleScaled;\n\n            ks").concat(n,"_outputL = mixedSample * finalGain;\n            ks").concat(n,"_outputR = mixedSample * finalGain; // Mono for now\n        }\n")}},{key:"generateDrumDesigner4Code",value:function(e,n,t){for(var a=this,o=e.params.bank||1,r="\n        // DrumDesigner4 ".concat(n," - 4-voice percussion synthesizer\n        {\n            // Banking controls (Bank ").concat(o,"): Pot=volume, Button=gate, Button hold + Pot=pitch\n            // Read button states from MCP23017 (rate-limited to avoid I2S interference)\n            {\n                static unsigned long lastBtnRead_dd4").concat(n," = 0;\n                if (millis() - lastBtnRead_dd4").concat(n," > 20) { // Read every 20ms\n                    lastBtnRead_dd4").concat(n," = millis();\n                    uint16_t mcpInputs = mcp.readGPIOAB();\n                    btn1_state = !(mcpInputs & (1 << 2)); // GPA2 - active low (v1.0 mapping)\n                    btn2_state = !(mcpInputs & (1 << 1)); // GPA1 - active low\n                    btn3_state = !(mcpInputs & (1 << 0)); // GPA0 - active low\n                    btn4_state = !(mcpInputs & (1 << 3)); // GPA3 - active low\n                }\n            }\n\n            // Mix buffer for all enabled voices\n            float dd4").concat(n,"_mixL = 0.0f;\n            float dd4").concat(n,"_mixR = 0.0f;\n\n            // Read pots and update NeoPixels for Bank ").concat(o," (once per buffer)\n            if (currentBank == ").concat(o,") {\n                static unsigned long dd4").concat(n,"_lastPotRead = 0;\n                static bool dd4").concat(n,"_firstBankEntry = true;\n\n                if (millis() - dd4").concat(n,"_lastPotRead > 10) { // Read every 10ms\n                    dd4").concat(n,"_lastPotRead = millis();\n\n                    // Read pots (GPIO4-7)\n                    float pot_raw[4];\n                    pot_raw[0] = analogRead(4) / 4095.0;\n                    pot_raw[1] = analogRead(5) / 4095.0;\n                    pot_raw[2] = analogRead(6) / 4095.0;\n                    pot_raw[3] = analogRead(7) / 4095.0;\n\n                    // First time entering this bank - initialize to physical position immediately\n                    if (dd4").concat(n,"_firstBankEntry) {\n                        pot1_value = pot_raw[0];\n                        pot2_value = pot_raw[1];\n                        pot3_value = pot_raw[2];\n                        pot4_value = pot_raw[3];\n                        pot1_physical = pot_raw[0];\n                        pot2_physical = pot_raw[1];\n                        pot3_physical = pot_raw[2];\n                        pot4_physical = pot_raw[3];\n                        pot1_taken_over = true;\n                        pot2_taken_over = true;\n                        pot3_taken_over = true;\n                        pot4_taken_over = true;\n                        dd4").concat(n,"_firstBankEntry = false;\n                    } else {\n                        // Smooth physical readings\n                        const float smooth_factor = 0.8; // Heavy smoothing to reduce ESP32 ADC noise\n                        pot1_physical = pot1_physical * smooth_factor + pot_raw[0] * (1.0 - smooth_factor);\n                        pot2_physical = pot2_physical * smooth_factor + pot_raw[1] * (1.0 - smooth_factor);\n                        pot3_physical = pot3_physical * smooth_factor + pot_raw[2] * (1.0 - smooth_factor);\n                        pot4_physical = pot4_physical * smooth_factor + pot_raw[3] * (1.0 - smooth_factor);\n\n                        // Soft takeover: update value when physical pot crosses within threshold\n                        const float takeover_threshold = 0.03;\n                        if (pot1_taken_over || fabs(pot1_physical - pot1_value) < takeover_threshold) {\n                            pot1_value = pot1_physical;\n                            pot1_taken_over = true;\n                        }\n                        if (pot2_taken_over || fabs(pot2_physical - pot2_value) < takeover_threshold) {\n                            pot2_value = pot2_physical;\n                            pot2_taken_over = true;\n                        }\n                        if (pot3_taken_over || fabs(pot3_physical - pot3_value) < takeover_threshold) {\n                            pot3_value = pot3_physical;\n                            pot3_taken_over = true;\n                        }\n                        if (pot4_taken_over || fabs(pot4_physical - pot4_value) < takeover_threshold) {\n                            pot4_value = pot4_physical;\n                            pot4_taken_over = true;\n                        }\n                    }\n                }\n\n                // Update NeoPixel LEDs for buttons and pots (Bank ").concat(o,")\n                static unsigned long dd4").concat(n,"_lastLedUpdate = 0;\n                static uint8_t dd4").concat(n,"_lastPotBrightness[4] = {0, 0, 0, 0}; // Track last brightness for hysteresis\n                static bool dd4").concat(n,"_lastBtnState[4] = {false, false, false, false};\n\n                if (millis() - dd4").concat(n,"_lastLedUpdate > 100) { // Update every 100ms\n                    dd4").concat(n,"_lastLedUpdate = millis();\n\n                    bool buttonsChanged = false;\n                    bool potsChanged = false;\n\n                    // Check if button states changed\n                    if (btn1_state != dd4").concat(n,"_lastBtnState[0] || btn2_state != dd4").concat(n,"_lastBtnState[1] ||\n                        btn3_state != dd4").concat(n,"_lastBtnState[2] || btn4_state != dd4").concat(n,"_lastBtnState[3]) {\n                        buttonsChanged = true;\n                        dd4").concat(n,"_lastBtnState[0] = btn1_state;\n                        dd4").concat(n,"_lastBtnState[1] = btn2_state;\n                        dd4").concat(n,"_lastBtnState[2] = btn3_state;\n                        dd4").concat(n,"_lastBtnState[3] = btn4_state;\n                    }\n\n                    // Calculate pot brightness values with hysteresis (only update if changed by >10)\n                    uint8_t pot_brightness[4];\n                    pot_brightness[0] = (uint8_t)(pot1_value * 255);\n                    pot_brightness[1] = (uint8_t)(pot2_value * 255);\n                    pot_brightness[2] = (uint8_t)(pot3_value * 255);\n                    pot_brightness[3] = (uint8_t)(pot4_value * 255);\n\n                    for (int i = 0; i < 4; i++) {\n                        if (abs((int)pot_brightness[i] - (int)dd4").concat(n,"_lastPotBrightness[i]) > 10) {\n                            potsChanged = true;\n                            dd4").concat(n,"_lastPotBrightness[i] = pot_brightness[i];\n                        }\n                    }\n\n                    // Update button LEDs if button states changed\n                    if (buttonsChanged) {\n                        // Button LEDs (3,2,1,0) - white when pressed, off when not\n                        neoPixels.setPixelColor(3, btn1_state ? 255 : 0, btn1_state ? 255 : 0, btn1_state ? 255 : 0);\n                        neoPixels.setPixelColor(2, btn2_state ? 255 : 0, btn2_state ? 255 : 0, btn2_state ? 255 : 0);\n                        neoPixels.setPixelColor(1, btn3_state ? 255 : 0, btn3_state ? 255 : 0, btn3_state ? 255 : 0);\n                        neoPixels.setPixelColor(0, btn4_state ? 255 : 0, btn4_state ? 255 : 0, btn4_state ? 255 : 0);\n                    }\n\n                    // Update pot LEDs if pot values changed OR button states changed (color mode switch)\n                    if (potsChanged || buttonsChanged) {\n                        // Pot LEDs (7,6,5,4) - Bank color (green for bank 1)\n                        // When button held: Yellow (pitch control mode)\n                        // When button not held: Green (volume control mode)\n\n                        // Pot 1 LED (LED 7)\n                        if (btn1_state) {\n                            // Yellow (pitch mode) - brightness based on pot value\n                            neoPixels.setPixelColor(7, dd4").concat(n,"_lastPotBrightness[0], dd4").concat(n,"_lastPotBrightness[0], 0);\n                        } else {\n                            // Green (volume mode) - brightness based on pot value\n                            neoPixels.setPixelColor(7, 0, dd4").concat(n,"_lastPotBrightness[0], 0);\n                        }\n\n                        // Pot 2 LED (LED 6)\n                        if (btn2_state) {\n                            neoPixels.setPixelColor(6, dd4").concat(n,"_lastPotBrightness[1], dd4").concat(n,"_lastPotBrightness[1], 0);\n                        } else {\n                            neoPixels.setPixelColor(6, 0, dd4").concat(n,"_lastPotBrightness[1], 0);\n                        }\n\n                        // Pot 3 LED (LED 5)\n                        if (btn3_state) {\n                            neoPixels.setPixelColor(5, dd4").concat(n,"_lastPotBrightness[2], dd4").concat(n,"_lastPotBrightness[2], 0);\n                        } else {\n                            neoPixels.setPixelColor(5, 0, dd4").concat(n,"_lastPotBrightness[2], 0);\n                        }\n\n                        // Pot 4 LED (LED 4)\n                        if (btn4_state) {\n                            neoPixels.setPixelColor(4, dd4").concat(n,"_lastPotBrightness[3], dd4").concat(n,"_lastPotBrightness[3], 0);\n                        } else {\n                            neoPixels.setPixelColor(4, 0, dd4").concat(n,"_lastPotBrightness[3], 0);\n                        }\n                    }\n\n                    // Only call show() if something actually changed\n                    if (buttonsChanged || potsChanged) {\n                        neoPixels.show();\n                    }\n                }\n            }\n"),c=function(c){if(!1===e.params["voice".concat(c,"_enabled")])return r+="\n            // Voice ".concat(c,": DISABLED (no processing)\n            dd4").concat(n,"_v").concat(c,"_outL = 0.0f;\n            dd4").concat(n,"_v").concat(c,"_outR = 0.0f;\n"),1;var i=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&n.to.port==="gate".concat(c)}),l=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&n.to.port==="pitch".concat(c)}),s="false",u=!i;if(i){var d=i.from.id.split(":")[0],p=a.connectionResolver.modules.find(function(e){return e.id===d}),f=i.from.port;if(p){var m,_=(null===(m=d.match(/\d+$/))||void 0===m?void 0:m[0])||"1";switch(p.type){case"Clock":var g=f.replace("out","");s="clock".concat(_,"_out").concat(g);break;case"LEDButton":var h=p.params.index||1;s="btn".concat(h,"_gate");break;case"MIDIIn":s="midi".concat(_,"_gate");break;case"GateGen":s="gate".concat(_,"_output")}}}var v="dd4".concat(n,"_v").concat(c,"_pitch"),b=!l;if(l){var y=l.from.id.split(":")[0],k=a.connectionResolver.modules.find(function(e){return e.id===y});if(k){var S,x=(null===(S=y.match(/\d+$/))||void 0===S?void 0:S[0])||"1";switch(k.type){case"Pot":v="(pot".concat(x,"_value * 72.0 + 24.0)");break;case"MIDIIn":v="midi".concat(x,"_note")}}}r+="\n            // Voice ".concat(c,": ENABLED\n            {\n                // Control input processing (only when button NOT held, so banking pitch can take over)\n                ").concat(b?"\n                if (!btn".concat(c,"_state) {\n                "):"","\n                    static unsigned long dd4").concat(n,"_v").concat(c,"_lastControlUpdate = 0;\n                    if (currentTime - dd4").concat(n,"_v").concat(c,"_lastControlUpdate >= 10) {\n                        dd4").concat(n,"_v").concat(c,"_lastControlUpdate = currentTime;\n\n                        float currentPitch = ").concat(v,";\n                        float noteOffset = (currentPitch - 69.0f) + (dd4").concat(n,"_v").concat(c,"_fineTune / 100.0f);\n                        dd4").concat(n,"_v").concat(c,"_currentFreq = 440.0f * powf(2.0f, noteOffset / 12.0f);\n                        dd4").concat(n,"_v").concat(c,"_baseSineFreq = dd4").concat(n,"_v").concat(c,"_currentFreq;\n                    }\n                ").concat(b?"\n                }\n                ":"","\n\n                // Banking controls (Bank ").concat(o,")\n                ").concat(u||b?"\n                if (currentBank == ".concat(o,") {\n                    // Pot ").concat(c," = volume control\n                    dd4").concat(n,"_v").concat(c,"_volume = pot").concat(c,"_value;\n\n                    ").concat(u?"\n                    // Button ".concat(c," alone = one-shot trigger (not gate)\n                    if (!encoderBtn) {\n                        // Edge detection for one-shot triggering\n                        static bool btn").concat(c,"_lastState_dd4").concat(n," = false;\n                        bool btn").concat(c,"_edge = (btn").concat(c,"_state && !btn").concat(c,"_lastState_dd4").concat(n,");\n                        btn").concat(c,"_lastState_dd4").concat(n," = btn").concat(c,"_state;\n\n                        if (btn").concat(c,"_edge) {\n                            // Trigger on button press\n                            dd4").concat(n,"_v").concat(c,"_gateInput = 1.0f;\n                        } else if (dd4").concat(n,"_v").concat(c,"_ampStage == 0) {\n                            // Reset gate when envelope completes (allows retriggering)\n                            dd4").concat(n,"_v").concat(c,"_gateInput = 0.0f;\n                        }\n                    }\n                    "):"","\n\n                    ").concat(b?"\n                    // Button ".concat(c," hold + Pot ").concat(c," rotate = pitch control\n                    if (btn").concat(c,"_state) {\n                        // Button held - pot controls pitch (MIDI 24-96 range)\n                        float bankPitch = pot").concat(c,"_value * 72.0f + 24.0f;\n                        float noteOffset = (bankPitch - 69.0f) + (dd4").concat(n,"_v").concat(c,"_fineTune / 100.0f);\n                        dd4").concat(n,"_v").concat(c,"_currentFreq = 440.0f * powf(2.0f, noteOffset / 12.0f);\n                        dd4").concat(n,"_v").concat(c,"_baseSineFreq = dd4").concat(n,"_v").concat(c,"_currentFreq;\n                    }\n                    "):"","\n                }\n                "):"","\n\n                // Gate input\n                ").concat(u?"\n                // Using banking gate (set above in bank check)\n                ":"\n                dd4".concat(n,"_v").concat(c,"_gateInput = ").concat(s,"; // Canvas-connected gate\n                "),"\n\n                // Trigger detection\n                bool trigger = (dd4").concat(n,"_v").concat(c,"_gateInput > 0.5f && !dd4").concat(n,"_v").concat(c,"_lastGate);\n                bool release = (dd4").concat(n,"_v").concat(c,"_gateInput < 0.5f && dd4").concat(n,"_v").concat(c,"_lastGate);\n\n                if (trigger) {\n                    dd4").concat(n,"_v").concat(c,"_delayLength = (int)(44100.0f / dd4").concat(n,"_v").concat(c,"_currentFreq);\n                    if (dd4").concat(n,"_v").concat(c,"_delayLength < 10) dd4").concat(n,"_v").concat(c,"_delayLength = 10;\n                    if (dd4").concat(n,"_v").concat(c,"_delayLength > KS_MAX_DELAY_DD4").concat(n,"_V").concat(c,") dd4").concat(n,"_v").concat(c,"_delayLength = KS_MAX_DELAY_DD4").concat(n,"_V").concat(c,";\n\n                    // Initialize delay line with noise\n                    memcpy(dd4").concat(n,"_v").concat(c,"_delayLine, dd4").concat(n,"_v").concat(c,"_noiseBuffer, dd4").concat(n,"_v").concat(c,"_delayLength * sizeof(float));\n\n                    dd4").concat(n,"_v").concat(c,"_writePos = dd4").concat(n,"_v").concat(c,"_delayLength;\n                    dd4").concat(n,"_v").concat(c,"_ampStage = 1;\n                    dd4").concat(n,"_v").concat(c,"_ampTime = 0.0f;\n                    dd4").concat(n,"_v").concat(c,"_sinePhase = 0.0f;\n                }\n\n                // One-shot behavior: Don't force release on button release\n                // Envelope completes naturally through ADSR stages\n                // (Original gate-based release logic removed for drum one-shots)\n\n                dd4").concat(n,"_v").concat(c,"_lastGate = (dd4").concat(n,"_v").concat(c,"_gateInput > 0.5f);\n\n                const float dt = 1.0f / 44100.0f;\n\n                // Karplus-Strong synthesis\n                float ksSample = 0.0f;\n                if (dd4").concat(n,"_v").concat(c,"_ampStage > 0) {\n                    int readPos = dd4").concat(n,"_v").concat(c,"_writePos - dd4").concat(n,"_v").concat(c,"_delayLength;\n                    if (readPos < 0) readPos += KS_MAX_DELAY_DD4").concat(n,"_V").concat(c,";\n                    float delaySample = dd4").concat(n,"_v").concat(c,"_delayLine[readPos];\n\n                    // Simple damping filter\n                    float dampingCoeff = 0.5f + (dd4").concat(n,"_v").concat(c,"_damping * 0.499f);\n                    float filteredSample = dampingCoeff * delaySample + (1.0f - dampingCoeff) * dd4").concat(n,"_v").concat(c,"_prevSample;\n                    dd4").concat(n,"_v").concat(c,"_prevSample = filteredSample;\n\n                    ksSample = filteredSample;\n                    dd4").concat(n,"_v").concat(c,"_delayLine[dd4").concat(n,"_v").concat(c,"_writePos] = filteredSample;\n                    dd4").concat(n,"_v").concat(c,"_writePos++;\n                    if (dd4").concat(n,"_v").concat(c,"_writePos >= KS_MAX_DELAY_DD4").concat(n,"_V").concat(c,") dd4").concat(n,"_v").concat(c,"_writePos = 0;\n                }\n\n                // Sine oscillator\n                float sineOut = 0.0f;\n                if (dd4").concat(n,"_v").concat(c,"_sineEnabled && dd4").concat(n,"_v").concat(c,"_ampStage > 0) {\n                    sineOut = sinf(dd4").concat(n,"_v").concat(c,"_sinePhase * 2.0f * M_PI);\n                    float phaseInc = dd4").concat(n,"_v").concat(c,"_baseSineFreq / 44100.0f;\n                    dd4").concat(n,"_v").concat(c,"_sinePhase += phaseInc;\n                    if (dd4").concat(n,"_v").concat(c,"_sinePhase >= 1.0f) dd4").concat(n,"_v").concat(c,"_sinePhase -= 1.0f;\n                }\n\n                // Amplitude envelope (simplified ADSR)\n                float envOut = 0.0f;\n                dd4").concat(n,"_v").concat(c,"_ampTime += dt;\n\n                switch(dd4").concat(n,"_v").concat(c,"_ampStage) {\n                    case 1: // Attack\n                        if (dd4").concat(n,"_v").concat(c,"_ampTime >= dd4").concat(n,"_v").concat(c,"_attack) {\n                            envOut = 1.0f;\n                            dd4").concat(n,"_v").concat(c,"_ampStage = 2;\n                            dd4").concat(n,"_v").concat(c,"_ampTime = 0.0f;\n                        } else {\n                            envOut = dd4").concat(n,"_v").concat(c,"_ampTime / dd4").concat(n,"_v").concat(c,"_attack;\n                        }\n                        break;\n                    case 2: // Decay\n                        if (dd4").concat(n,"_v").concat(c,"_ampTime >= dd4").concat(n,"_v").concat(c,"_decay) {\n                            envOut = dd4").concat(n,"_v").concat(c,"_sustain;\n                            dd4").concat(n,"_v").concat(c,"_ampStage = 3;\n                        } else {\n                            float t = dd4").concat(n,"_v").concat(c,"_ampTime / dd4").concat(n,"_v").concat(c,"_decay;\n                            envOut = 1.0f - t * (1.0f - dd4").concat(n,"_v").concat(c,"_sustain);\n                        }\n                        break;\n                    case 3: // Sustain\n                        envOut = dd4").concat(n,"_v").concat(c,"_sustain;\n                        break;\n                    case 4: // Release\n                        if (dd4").concat(n,"_v").concat(c,"_ampTime >= dd4").concat(n,"_v").concat(c,"_release) {\n                            envOut = 0.0f;\n                            dd4").concat(n,"_v").concat(c,"_ampStage = 0;\n                        } else {\n                            float t = dd4").concat(n,"_v").concat(c,"_ampTime / dd4").concat(n,"_v").concat(c,"_release;\n                            envOut = dd4").concat(n,"_v").concat(c,"_sustain * (1.0f - t);\n                        }\n                        break;\n                    default:\n                        envOut = 0.0f;\n                        dd4").concat(n,"_v").concat(c,"_ampStage = 0;\n                        break;\n                }\n\n                // Mix K-S and sine, apply envelope, output gain, and volume\n                float mixedSample = (ksSample * dd4").concat(n,"_v").concat(c,"_ksLevel) + (sineOut * dd4").concat(n,"_v").concat(c,"_sineLevel);\n                float finalSample = mixedSample * envOut * dd4").concat(n,"_v").concat(c,"_outputGain * dd4").concat(n,"_v").concat(c,"_volume;\n\n                dd4").concat(n,"_v").concat(c,"_outL = finalSample;\n                dd4").concat(n,"_v").concat(c,"_outR = finalSample;\n\n                // Add to mix\n                dd4").concat(n,"_mixL += finalSample;\n                dd4").concat(n,"_mixR += finalSample;\n            }\n")},i=1;i<=4;i++)c(i);return r+="\n            // Output assignments\n            dd4".concat(n,"_outputMixL = dd4").concat(n,"_mixL;\n            dd4").concat(n,"_outputMixR = dd4").concat(n,"_mixR;\n        }\n")}},{key:"generateNoiseCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gain"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"morph"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"type"===n.to.port}),i="noise".concat(n,"_gate"),l="noise".concat(n,"_gain"),s="noise".concat(n,"_morph"),u="noise".concat(n,"_type");if(a){var d=a.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"LEDButton":var _=p.params.index||1;i="btn".concat(_,"_gate");break;case"ADSR":i="(adsr".concat(m,"_output > 0.1)")}}}if(o){var g=o.from.id.split(":")[0],h=this.connectionResolver.modules.find(function(e){return e.id===g});if(h){var v,b=(null===(v=g.match(/\d+$/))||void 0===v?void 0:v[0])||"1";switch(h.type){case"Pot":l=this.getPotReference(h,b);break;case"ADSR":l="adsr".concat(b,"_output")}}}if(r){var y=r.from.id.split(":")[0],k=this.connectionResolver.modules.find(function(e){return e.id===y});if(k){var S,x=(null===(S=y.match(/\d+$/))||void 0===S?void 0:S[0])||"1";switch(k.type){case"Pot":var E=k.params.index||1;s="pot".concat(E,"_value");break;case"LFO":s="lfo".concat(x,"_output")}}}if(c){var P,w=c.from.id.split(":")[0],C=this.connectionResolver.modules.find(function(e){return e.id===w});if(C&&(null===(P=w.match(/\d+$/))||void 0===P||P[0],"Pot"===C.type)){var R=C.params.index||1;u="(int)(pot".concat(R,"_value * 2.99)")}}return"\n        // Noise Generator ".concat(n," processing\n        {\n            float gate = ").concat(i," ? 1.0 : 0.0;\n            float gain = ").concat(l,";\n            float morph = constrain(").concat(s,", 0.0, 1.0);\n            int noiseType = ").concat(u,';\n            noiseType = constrain(noiseType, 0, 2); // Ensure valid range\n\n            // DEBUG: Noise generator gate\n            static unsigned long lastNoiseDebug = 0;\n            if (millis() - lastNoiseDebug > 500) {\n                lastNoiseDebug = millis();\n                Serial.print("DEBUG: Noise generator gate=");\n                Serial.print(gate);\n                Serial.print(", gain=");\n                Serial.print(gain);\n                Serial.print(", currentBank=");\n                Serial.println(currentBank);\n            }\n\n            if (gate > 0.1) {\n                float white_noise = 0.0;\n                float pink_noise = 0.0;\n                float brown_noise = 0.0;\n\n                // Generate white noise using isolated deterministic LCG (avoids ESP32 FPU interference)\n                // Use completely isolated integer math to avoid affecting oscillator FPU state\n                uint32_t temp_seed = noise').concat(n,"_lcg_seed;\n                temp_seed = (temp_seed * 1103515245U + 12345U) & 0x7FFFFFFFU;\n                noise").concat(n,"_lcg_seed = temp_seed;\n                // Convert to float using safe integer division to avoid FPU precision issues\n                int32_t noise_int = (int32_t)(temp_seed & 0xFFFF) - 32768;\n                white_noise = (float)noise_int * (1.0f / 32768.0f);\n\n                // TEMPORARY: White noise only until FPU interference resolved\n                // Complex filtering causes oscillator frequency modulation on ESP32\n                pink_noise = white_noise * 0.5; // Scaled white noise approximation\n                brown_noise = white_noise * 0.3; // Scaled white noise approximation\n\n                // Mix noise types based on current type and morph\n                float output = 0.0;\n                if (noiseType == 0) {\n                    // White noise base - morph towards pink\n                    output = white_noise * (1.0 - morph) + pink_noise * morph * 0.11;\n                } else if (noiseType == 1) {\n                    // Pink noise base - morph towards brown\n                    output = pink_noise * 0.11 * (1.0 - morph) + brown_noise * morph;\n                } else if (noiseType == 2) {\n                    // Brown noise base - morph towards white\n                    output = brown_noise * (1.0 - morph) + white_noise * morph;\n                }\n\n                noise").concat(n,"_output = output * gain;\n\n                // DEBUG: Print noise output every 500ms\n                static unsigned long noiseDebugTime_").concat(n," = 0;\n                if (millis() - noiseDebugTime_").concat(n," > 500) {\n                    noiseDebugTime_").concat(n,' = millis();\n                    Serial.print("Noise').concat(n,' - gate=");\n                    Serial.print(gate);\n                    Serial.print(", gain=");\n                    Serial.print(gain);\n                    Serial.print(", out=");\n                    Serial.println(noise').concat(n,"_output);\n                }\n            } else {\n                noise").concat(n,"_output = 0.0;\n            }\n        }\n")}},{key:"generateReverbCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"mix"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"size"===n.to.port}),i=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"damp"===n.to.port}),l="0.0",s="0.0",u="reverb".concat(n,"_mix"),d="reverb".concat(n,"_size"),p="reverb".concat(n,"_damp");if(a){var f=a.from.id.split(":")[0],m=this.connectionResolver.modules.find(function(e){return e.id===f});if(m){var _,g=(null===(_=f.match(/\d+$/))||void 0===_?void 0:_[0])||"1";switch(m.type){case"VCA":l="vca".concat(g,"_outputL");break;case"Oscillator":l="osc".concat(g,"_outputL");break;case"Filter":l="filter".concat(g,"_outputL");break;case"Delay":l="delay".concat(g,"_outputL");break;case"LineIn":l="linein".concat(g,"_outputL");break;case"CleanReverb":l="cleanreverb".concat(g,"_outputL");break;case"Reverb":l="reverb".concat(g,"_outputL")}}}if(o){var h=o.from.id.split(":")[0],v=this.connectionResolver.modules.find(function(e){return e.id===h});if(v){var b,y=(null===(b=h.match(/\d+$/))||void 0===b?void 0:b[0])||"1";switch(v.type){case"VCA":s="vca".concat(y,"_outputR");break;case"Oscillator":s="osc".concat(y,"_outputR");break;case"Filter":s="filter".concat(y,"_outputR");break;case"Delay":s="delay".concat(y,"_outputR");break;case"LineIn":s="linein".concat(y,"_outputR");break;case"CleanReverb":s="cleanreverb".concat(y,"_outputR");break;case"Reverb":s="reverb".concat(y,"_outputR")}}}if(r){var k=r.from.id.split(":")[0],S=this.connectionResolver.modules.find(function(e){return e.id===k});if(S){var x,E=(null===(x=k.match(/\d+$/))||void 0===x?void 0:x[0])||"1";switch(S.type){case"Pot":u="pot".concat(E,"_value");break;case"LFO":u="lfo".concat(E,"_output")}}}if(c){var P=c.from.id.split(":")[0],w=this.connectionResolver.modules.find(function(e){return e.id===P});if(w){var C,R=(null===(C=P.match(/\d+$/))||void 0===C?void 0:C[0])||"1";switch(w.type){case"Pot":d="pot".concat(R,"_value");break;case"LFO":d="lfo".concat(R,"_output")}}}if(i){var L=i.from.id.split(":")[0],I=this.connectionResolver.modules.find(function(e){return e.id===L});if(I){var M,D=(null===(M=L.match(/\d+$/))||void 0===M?void 0:M[0])||"1";switch(I.type){case"Pot":p="pot".concat(D,"_value");break;case"LFO":p="lfo".concat(D,"_output")}}}return"\n        // Reverb ".concat(n," processing - Clouds Reverb (Dattorro Algorithm)\n        {\n            float inputL = ").concat(l,";\n            float inputR = ").concat(s,";\n            float mix = constrain(").concat(u,", 0.0, 1.0);\n            float size = constrain(").concat(d,", 0.0, 1.0);\n            float damp = constrain(").concat(p,", 0.0, 1.0);\n\n            reverb").concat(n,"_inputL = inputL;\n            reverb").concat(n,"_inputR = inputR;\n\n            // Mono input sum for reverb tank\n            float input_mono = (inputL + inputR) * 0.5;\n\n            // Pre-delay\n            float predelayed = reverb").concat(n,"_predelay[reverb").concat(n,"_predelay_pos];\n            reverb").concat(n,"_predelay[reverb").concat(n,"_predelay_pos] = input_mono;\n            reverb").concat(n,"_predelay_pos = (reverb").concat(n,"_predelay_pos + 1) % REVERB").concat(n,"_PREDELAY_SIZE;\n\n            // Diffusion stage (4 all-pass filters in series)\n            float diffused = predelayed;\n\n            // All-pass 1 (Left tank input)\n            float ap1_delay = reverb").concat(n,"_ap1L[reverb").concat(n,"_ap1L_pos];\n            float ap1_out = -0.75 * diffused + ap1_delay;\n            reverb").concat(n,"_ap1L[reverb").concat(n,"_ap1L_pos] = diffused + 0.75 * ap1_out;\n            reverb").concat(n,"_ap1L_pos = (reverb").concat(n,"_ap1L_pos + 1) % REVERB").concat(n,"_AP1_SIZE;\n\n            // All-pass 2 (Left tank continued)\n            float ap2_delay = reverb").concat(n,"_ap2L[reverb").concat(n,"_ap2L_pos];\n            float ap2_out = -0.75 * ap1_out + ap2_delay;\n            reverb").concat(n,"_ap2L[reverb").concat(n,"_ap2L_pos] = ap1_out + 0.75 * ap2_out;\n            reverb").concat(n,"_ap2L_pos = (reverb").concat(n,"_ap2L_pos + 1) % REVERB").concat(n,"_AP2_SIZE;\n\n            // Split into left and right tanks\n            float tankL_input = ap2_out;\n            float tankR_input = ap2_out;\n\n            // Left tank processing\n            // Delay 1\n            float delay1_out = reverb").concat(n,"_delay1L[reverb").concat(n,"_delay1L_pos];\n            reverb").concat(n,"_delay1L[reverb").concat(n,"_delay1L_pos] = tankL_input;\n            reverb").concat(n,"_delay1L_pos = (reverb").concat(n,"_delay1L_pos + 1) % REVERB").concat(n,"_DELAY1_SIZE;\n\n            // Low-pass damping filter\n            reverb").concat(n,"_lpf_L = reverb").concat(n,"_lpf_L + damp * (delay1_out - reverb").concat(n,"_lpf_L);\n            delay1_out = reverb").concat(n,"_lpf_L;\n\n            // All-pass 3\n            float ap3_delay = reverb").concat(n,"_ap3R[reverb").concat(n,"_ap3R_pos];\n            float ap3_out = -0.5 * delay1_out + ap3_delay;\n            reverb").concat(n,"_ap3R[reverb").concat(n,"_ap3R_pos] = delay1_out + 0.5 * ap3_out;\n            reverb").concat(n,"_ap3R_pos = (reverb").concat(n,"_ap3R_pos + 1) % REVERB").concat(n,"_AP3_SIZE;\n\n            // Delay 2 (main left delay)\n            float delay2_out = reverb").concat(n,"_delay2L[reverb").concat(n,"_delay2L_pos];\n            reverb").concat(n,"_delay2L[reverb").concat(n,"_delay2L_pos] = ap3_out + reverb").concat(n,"_feedback * size * delay2_out;\n            reverb").concat(n,"_delay2L_pos = (reverb").concat(n,"_delay2L_pos + 1) % REVERB").concat(n,"_DELAY2_SIZE;\n\n            // Right tank processing (simplified for brevity)\n            // All-pass 4\n            float ap4_delay = reverb").concat(n,"_ap4R[reverb").concat(n,"_ap4R_pos];\n            float ap4_out = -0.5 * tankR_input + ap4_delay;\n            reverb").concat(n,"_ap4R[reverb").concat(n,"_ap4R_pos] = tankR_input + 0.5 * ap4_out;\n            reverb").concat(n,"_ap4R_pos = (reverb").concat(n,"_ap4R_pos + 1) % REVERB").concat(n,"_AP4_SIZE;\n\n            // Low-pass damping filter (right)\n            reverb").concat(n,"_lpf_R = reverb").concat(n,"_lpf_R + damp * (ap4_out - reverb").concat(n,"_lpf_R);\n            ap4_out = reverb").concat(n,"_lpf_R;\n\n            // Delay 3 (main right delay)\n            float delay3_out = reverb").concat(n,"_delay3R[reverb").concat(n,"_delay3R_pos];\n            reverb").concat(n,"_delay3R[reverb").concat(n,"_delay3R_pos] = ap4_out + reverb").concat(n,"_feedback * size * delay3_out;\n            reverb").concat(n,"_delay3R_pos = (reverb").concat(n,"_delay3R_pos + 1) % REVERB").concat(n,"_DELAY3_SIZE;\n\n            // Output taps from delay lines (multiple taps for fuller sound)\n            float outL = delay2_out * 0.6 + delay3_out * 0.3;\n            float outR = delay3_out * 0.6 + delay2_out * 0.3;\n\n            // Final output mixing\n            reverb").concat(n,"_outputL = inputL * (1.0 - mix) + outL * mix;\n            reverb").concat(n,"_outputR = inputR * (1.0 - mix) + outR * mix;\n        }\n")}},{key:"generateCleanReverbCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"mix"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"size"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"damp"===n.to.port}),c="cleanreverb".concat(n,"_mix"),i="cleanreverb".concat(n,"_size"),l="cleanreverb".concat(n,"_damp");if(a){var s=a.from.id.split(":")[0],u=this.connectionResolver.modules.find(function(e){return e.id===s});if(u){var d,p=(null===(d=s.match(/\d+$/))||void 0===d?void 0:d[0])||"1";switch(u.type){case"Pot":c="pot".concat(p,"_value");break;case"LFO":c="lfo".concat(p,"_output");break;default:c="".concat(u.type.toLowerCase()).concat(p,"_output")}}}if(o){var f=o.from.id.split(":")[0],m=this.connectionResolver.modules.find(function(e){return e.id===f});if(m){var _,g=(null===(_=f.match(/\d+$/))||void 0===_?void 0:_[0])||"1";switch(m.type){case"Pot":i="pot".concat(g,"_value");break;case"LFO":i="lfo".concat(g,"_output");break;default:i="".concat(m.type.toLowerCase()).concat(g,"_output")}}}if(r){var h=r.from.id.split(":")[0],v=this.connectionResolver.modules.find(function(e){return e.id===h});if(v){var b,y=(null===(b=h.match(/\d+$/))||void 0===b?void 0:b[0])||"1";switch(v.type){case"Pot":l="pot".concat(y,"_value");break;case"LFO":l="lfo".concat(y,"_output");break;default:l="".concat(v.type.toLowerCase()).concat(y,"_output")}}}return"\n        // CleanReverb ".concat(e.id," processing (Freeverb-style diffuse reverb)\n        {\n            // Inputs & raw params (from standard connection system)\n            float inL  = cleanreverb").concat(n,"_inputL;\n            float inR  = cleanreverb").concat(n,"_inputR;\n            float mix  = ").concat(c,";\n            float size = ").concat(i,";\n            float damp = ").concat(l,";\n\n            // Parameter smoothing (one-pole)\n            const float z = 0.0025f; // ~2.5 ms smoothing at 44.1kHz inside sample loop chunk\n            cleanreverb").concat(n,"_mix_z  += z * (mix  - cleanreverb").concat(n,"_mix_z);\n            cleanreverb").concat(n,"_size_z += z * (size - cleanreverb").concat(n,"_size_z);\n            cleanreverb").concat(n,"_damp_z += z * (damp - cleanreverb").concat(n,"_damp_z);\n            mix  = constrain(cleanreverb").concat(n,"_mix_z,  0.0f, 1.0f);\n            size = constrain(cleanreverb").concat(n,"_size_z, 0.0f, 1.0f);\n            damp = constrain(cleanreverb").concat(n,'_damp_z, 0.0f, 1.0f);\n\n            // Map "size" to feedback gain (higher = longer decay, smoother tail)\n            // Extended range: 0.7-0.88 gives classic reverb character with smooth decay\n            const float g = constrain(0.70f + 0.18f * size, 0.0f, 0.88f);\n\n            // Map "damp" to LPF coefficient (Freeverb-style damping)\n            // Higher damp => more filtering => darker tail\n            const float d = constrain(0.2f + 0.7f * (1.0f - damp), 0.05f, 0.95f);\n\n            // Gentle input limiter\n            inL = inL > 0.8f ? 0.8f : (inL < -0.8f ? -0.8f : inL);\n            inR = inR > 0.8f ? 0.8f : (inR < -0.8f ? -0.8f : inR);\n\n            // Mono feed to comb bank (classic Schroeder); stereo will be built later\n            float x = 0.5f * (inL + inR);\n\n            // Predelay (early reflections feel)\n            float pdTap = cleanreverb').concat(n,"_predelay[cleanreverb").concat(n,"_predelay_pos];\n            cleanreverb").concat(n,"_predelay[cleanreverb").concat(n,"_predelay_pos] = x;\n            if (++cleanreverb").concat(n,"_predelay_pos >= CLEANREVERB").concat(n,"_PREDELAY_SIZE) cleanreverb").concat(n,"_predelay_pos = 0;\n            x = pdTap;\n\n            // 4 parallel feedback combs with LPF *inside* the feedback loop (Freeverb style)\n            // comb1\n            float c1 = cleanreverb").concat(n,"_comb1[cleanreverb").concat(n,"_comb1_pos];\n            cleanreverb").concat(n,"_comb1_lpf = c1 * (1.0f - d) + cleanreverb").concat(n,"_comb1_lpf * d;\n            cleanreverb").concat(n,"_comb1[cleanreverb").concat(n,"_comb1_pos] = x + g * cleanreverb").concat(n,"_comb1_lpf;\n            if (++cleanreverb").concat(n,"_comb1_pos >= CLEANREVERB").concat(n,"_COMB1_SIZE) cleanreverb").concat(n,"_comb1_pos = 0;\n\n            // comb2\n            float c2 = cleanreverb").concat(n,"_comb2[cleanreverb").concat(n,"_comb2_pos];\n            cleanreverb").concat(n,"_comb2_lpf = c2 * (1.0f - d) + cleanreverb").concat(n,"_comb2_lpf * d;\n            cleanreverb").concat(n,"_comb2[cleanreverb").concat(n,"_comb2_pos] = x + g * cleanreverb").concat(n,"_comb2_lpf;\n            if (++cleanreverb").concat(n,"_comb2_pos >= CLEANREVERB").concat(n,"_COMB2_SIZE) cleanreverb").concat(n,"_comb2_pos = 0;\n\n            // comb3\n            float c3 = cleanreverb").concat(n,"_comb3[cleanreverb").concat(n,"_comb3_pos];\n            cleanreverb").concat(n,"_comb3_lpf = c3 * (1.0f - d) + cleanreverb").concat(n,"_comb3_lpf * d;\n            cleanreverb").concat(n,"_comb3[cleanreverb").concat(n,"_comb3_pos] = x + g * cleanreverb").concat(n,"_comb3_lpf;\n            if (++cleanreverb").concat(n,"_comb3_pos >= CLEANREVERB").concat(n,"_COMB3_SIZE) cleanreverb").concat(n,"_comb3_pos = 0;\n\n            // comb4\n            float c4 = cleanreverb").concat(n,"_comb4[cleanreverb").concat(n,"_comb4_pos];\n            cleanreverb").concat(n,"_comb4_lpf = c4 * (1.0f - d) + cleanreverb").concat(n,"_comb4_lpf * d;\n            cleanreverb").concat(n,"_comb4[cleanreverb").concat(n,"_comb4_pos] = x + g * cleanreverb").concat(n,"_comb4_lpf;\n            if (++cleanreverb").concat(n,"_comb4_pos >= CLEANREVERB").concat(n,"_COMB4_SIZE) cleanreverb").concat(n,"_comb4_pos = 0;\n\n            // Sum combs\n            float combSum = 0.25f * (c1 + c2 + c3 + c4);\n\n            // 2 serial allpasses for diffusion (critical for smooth reverb character)\n            // AP1\n            float ap1_delay = cleanreverb").concat(n,"_ap1[cleanreverb").concat(n,"_ap1_pos];\n            const float ap1_a = 0.5f;\n            float ap1_out = -ap1_a * combSum + ap1_delay;\n            cleanreverb").concat(n,"_ap1[cleanreverb").concat(n,"_ap1_pos] = combSum + ap1_a * ap1_out;\n            if (++cleanreverb").concat(n,"_ap1_pos >= CLEANREVERB").concat(n,"_AP1_SIZE) cleanreverb").concat(n,"_ap1_pos = 0;\n\n            // AP2\n            float ap2_delay = cleanreverb").concat(n,"_ap2[cleanreverb").concat(n,"_ap2_pos];\n            const float ap2_a = 0.5f;\n            float ap2_out = -ap2_a * ap1_out + ap2_delay;\n            cleanreverb").concat(n,"_ap2[cleanreverb").concat(n,"_ap2_pos] = ap1_out + ap2_a * ap2_out;\n            if (++cleanreverb").concat(n,"_ap2_pos >= CLEANREVERB").concat(n,"_AP2_SIZE) cleanreverb").concat(n,"_ap2_pos = 0;\n\n            // Stereo decorrelation: Use fully diffused allpass output for smooth character\n            // Mix different comb taps with the diffused signal for stereo width\n            float wetL = 0.6f * ap2_out + 0.2f * c1 + 0.2f * c3;\n            float wetR = 0.6f * ap2_out + 0.2f * c2 + 0.2f * c4;\n\n            // Scale down wet signal to prevent buildup (diffused signal is denser)\n            wetL *= 0.5f;\n            wetR *= 0.5f;\n\n            // Final mix (no additional clipping - rely on output limiter)\n            float outL = inL * (1.0f - mix) + wetL * mix;\n            float outR = inR * (1.0f - mix) + wetR * mix;\n\n            // Denormal guard\n            if (fabsf(outL) < 1e-12f) outL = 0.0f;\n            if (fabsf(outR) < 1e-12f) outR = 0.0f;\n\n            cleanreverb").concat(n,"_outputL = outL;\n            cleanreverb").concat(n,"_outputR = outR;\n        }\n")}},{key:"generateSnareDrumCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"trigger"===n.to.port}),o="false";if(a){var r=a.from.id.split(":")[0],c=this.connectionResolver.modules.find(function(e){return e.id===r});if(c){var i,l=(null===(i=r.match(/\d+$/))||void 0===i?void 0:i[0])||"1";switch(c.type){case"LEDButton":o="btn".concat(l,"_pressed");break;case"Clock":o="clock".concat(l,"_output");break;case"GateGen":o="gate".concat(l,"_output")}}}return"\n        // SnareDrum ".concat(n," processing - Layered Snare Drum Synthesizer\n        {\n            bool trigger = ").concat(o,";\n\n            // Trigger all envelopes on rising edge\n            static bool snare").concat(n,"_lastTrigger = false;\n            if (trigger && !snare").concat(n,"_lastTrigger) {\n                // Start all envelope stages\n                snare").concat(n,"_amp_stage = 1; // Attack\n                snare").concat(n,"_amp_time = 0.0;\n                snare").concat(n,"_pitch_stage = 1; // Attack\n                snare").concat(n,"_pitch_time = 0.0;\n                snare").concat(n,"_noise_stage = 1; // Attack\n                snare").concat(n,"_noise_time = 0.0;\n                snare").concat(n,"_triggered = true;\n            }\n            snare").concat(n,"_lastTrigger = trigger;\n\n            float sampleTime = 1.0 / 44100.0;\n\n            // Process amplitude envelope\n            if (snare").concat(n,"_amp_stage > 0) {\n                snare").concat(n,"_amp_time += sampleTime;\n\n                switch (snare").concat(n,"_amp_stage) {\n                    case 1: // Attack\n                        if (snare").concat(n,"_amp_time >= snare").concat(n,"_amp_attack) {\n                            snare").concat(n,"_amp_stage = 2;\n                            snare").concat(n,"_amp_time = 0.0;\n                            snare").concat(n,"_amp_env = 1.0;\n                        } else {\n                            snare").concat(n,"_amp_env = snare").concat(n,"_amp_time / snare").concat(n,"_amp_attack;\n                        }\n                        break;\n\n                    case 2: // Decay\n                        if (snare").concat(n,"_amp_time >= snare").concat(n,"_amp_decay) {\n                            snare").concat(n,"_amp_stage = 3;\n                            snare").concat(n,"_amp_time = 0.0;\n                        } else {\n                            float progress = snare").concat(n,"_amp_time / snare").concat(n,"_amp_decay;\n                            snare").concat(n,"_amp_env = 1.0 - progress * (1.0 - snare").concat(n,"_amp_sustain);\n                        }\n                        break;\n\n                    case 3: // Sustain\n                        snare").concat(n,"_amp_env = snare").concat(n,"_amp_sustain;\n                        if (!trigger) {\n                            snare").concat(n,"_amp_stage = 4; // Release\n                            snare").concat(n,"_amp_time = 0.0;\n                        }\n                        break;\n\n                    case 4: // Release\n                        if (snare").concat(n,"_amp_time >= snare").concat(n,"_amp_release) {\n                            snare").concat(n,"_amp_stage = 0; // Idle\n                            snare").concat(n,"_amp_env = 0.0;\n                        } else {\n                            float progress = snare").concat(n,"_amp_time / snare").concat(n,"_amp_release;\n                            snare").concat(n,"_amp_env = snare").concat(n,"_amp_sustain * (1.0 - progress);\n                        }\n                        break;\n                }\n            }\n\n            // Process pitch envelope\n            if (snare").concat(n,"_pitch_stage > 0) {\n                snare").concat(n,"_pitch_time += sampleTime;\n\n                switch (snare").concat(n,"_pitch_stage) {\n                    case 1: // Attack\n                        if (snare").concat(n,"_pitch_time >= snare").concat(n,"_pitch_attack) {\n                            snare").concat(n,"_pitch_stage = 2;\n                            snare").concat(n,"_pitch_time = 0.0;\n                            snare").concat(n,"_pitch_env = 1.0;\n                        } else {\n                            snare").concat(n,"_pitch_env = snare").concat(n,"_pitch_time / snare").concat(n,"_pitch_attack;\n                        }\n                        break;\n\n                    case 2: // Decay\n                        if (snare").concat(n,"_pitch_time >= snare").concat(n,"_pitch_decay) {\n                            snare").concat(n,"_pitch_stage = 0; // Skip sustain, go to idle\n                            snare").concat(n,"_pitch_env = 0.0;\n                        } else {\n                            float progress = snare").concat(n,"_pitch_time / snare").concat(n,"_pitch_decay;\n                            snare").concat(n,"_pitch_env = 1.0 - progress;\n                        }\n                        break;\n                }\n            }\n\n            // Process noise envelope\n            if (snare").concat(n,"_noise_stage > 0) {\n                snare").concat(n,"_noise_time += sampleTime;\n\n                switch (snare").concat(n,"_noise_stage) {\n                    case 1: // Attack\n                        if (snare").concat(n,"_noise_time >= snare").concat(n,"_noise_attack) {\n                            snare").concat(n,"_noise_stage = 2;\n                            snare").concat(n,"_noise_time = 0.0;\n                            snare").concat(n,"_noise_env = 1.0;\n                        } else {\n                            snare").concat(n,"_noise_env = snare").concat(n,"_noise_time / snare").concat(n,"_noise_attack;\n                        }\n                        break;\n\n                    case 2: // Decay\n                        if (snare").concat(n,"_noise_time >= snare").concat(n,"_noise_decay) {\n                            snare").concat(n,"_noise_stage = 3;\n                            snare").concat(n,"_noise_time = 0.0;\n                        } else {\n                            float progress = snare").concat(n,"_noise_time / snare").concat(n,"_noise_decay;\n                            snare").concat(n,"_noise_env = 1.0 - progress * (1.0 - snare").concat(n,"_noise_sustain);\n                        }\n                        break;\n\n                    case 3: // Sustain\n                        snare").concat(n,"_noise_env = snare").concat(n,"_noise_sustain;\n                        if (!trigger) {\n                            snare").concat(n,"_noise_stage = 4; // Release\n                            snare").concat(n,"_noise_time = 0.0;\n                        }\n                        break;\n\n                    case 4: // Release\n                        if (snare").concat(n,"_noise_time >= snare").concat(n,"_noise_release) {\n                            snare").concat(n,"_noise_stage = 0; // Idle\n                            snare").concat(n,"_noise_env = 0.0;\n                        } else {\n                            float progress = snare").concat(n,"_noise_time / snare").concat(n,"_noise_release;\n                            snare").concat(n,"_noise_env = snare").concat(n,"_noise_sustain * (1.0 - progress);\n                        }\n                        break;\n                }\n            }\n\n            // Generate sound sources\n            float osc_output = 0.0;\n            float noise_output = 0.0;\n\n            if (snare").concat(n,"_amp_env > 0.001) {\n                // Oscillator layer with pitch envelope\n                float pitch_mod = snare").concat(n,"_pitch_env * snare").concat(n,"_pitch_env_amount;\n                float effective_freq = snare").concat(n,"_osc_freq * pow(2.0, pitch_mod);\n\n                snare").concat(n,"_osc_phase += (2.0 * M_PI * effective_freq) / 44100.0;\n                if (snare").concat(n,"_osc_phase >= 2.0 * M_PI) {\n                    snare").concat(n,"_osc_phase -= 2.0 * M_PI;\n                }\n\n                osc_output = sin(snare").concat(n,"_osc_phase) * snare").concat(n,"_osc_level;\n\n                // Noise layer with separate envelope\n                if (snare").concat(n,"_noise_env > 0.001) {\n                    float white_noise = ((float)random(-32768, 32767)) / 32767.0;\n\n                    // Simple noise filtering based on type\n                    if (snare").concat(n,"_noise_type == 0) {\n                        // White noise (no filtering)\n                        noise_output = white_noise;\n                    } else {\n                        // Simple lowpass for pink/brown approximation\n                        snare").concat(n,"_noise_state = snare").concat(n,"_noise_state * 0.99 + white_noise * 0.01;\n                        noise_output = snare").concat(n,"_noise_state * 10.0; // Boost filtered noise\n                    }\n\n                    noise_output *= snare").concat(n,"_noise_level * snare").concat(n,"_noise_env;\n                }\n            }\n\n            // Mix all layers with amplitude envelope\n            float mixed_output = (osc_output + noise_output) * snare").concat(n,"_amp_env;\n\n            snare").concat(n,"_outputL = mixed_output;\n            snare").concat(n,"_outputR = mixed_output;\n        }\n")}},{key:"generateAudioMathCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inA"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inB"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"mod"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"amount"===n.to.port}),i="0.0",l="0.0",s="0.0",u="audioMath".concat(n,"_amount");if(a){var d=a.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"Oscillator":i="osc".concat(m,"_outputL");break;case"VCA":i="vca".concat(m,"_outputL");break;case"Filter":i="filter".concat(m,"_outputL");break;case"Noise":i="noise".concat(m,"_output")}}}if(o){var _=o.from.id.split(":")[0],g=this.connectionResolver.modules.find(function(e){return e.id===_});if(g){var h,v=(null===(h=_.match(/\d+$/))||void 0===h?void 0:h[0])||"1";switch(g.type){case"Oscillator":l="osc".concat(v,"_outputL");break;case"VCA":l="vca".concat(v,"_outputL");break;case"Filter":l="filter".concat(v,"_outputL");break;case"Noise":l="noise".concat(v,"_output")}}}if(r){var b=r.from.id.split(":")[0],y=this.connectionResolver.modules.find(function(e){return e.id===b});if(y){var k,S=(null===(k=b.match(/\d+$/))||void 0===k?void 0:k[0])||"1";switch(y.type){case"LFO":s="lfo".concat(S,"_output");break;case"ADSR":s="adsr".concat(S,"_output");break;case"Pot":s="pot".concat(S,"_value");break;case"Oscillator":s="osc".concat(S,"_outputL")}}}if(c){var x=c.from.id.split(":")[0],E=this.connectionResolver.modules.find(function(e){return e.id===x});if(E){var P,w=(null===(P=x.match(/\d+$/))||void 0===P?void 0:P[0])||"1";switch(E.type){case"Pot":u="pot".concat(w,"_value");break;case"LFO":u="lfo".concat(w,"_output");break;case"ADSR":u="adsr".concat(w,"_output")}}}return"\n        // AudioMath ".concat(n," processing\n        {\n            audioMath").concat(n,"_inputA = ").concat(i,";\n            audioMath").concat(n,"_inputB = ").concat(l,";\n            audioMath").concat(n,"_modInput = ").concat(s,";\n            float amount = ").concat(u,";\n            float offset = audioMath").concat(n,"_offset;\n\n            switch (audioMath").concat(n,"_mode) {\n                case 0: // Amplitude Modulation (AM)\n                    {\n                        float modulated_signal = audioMath").concat(n,"_modInput + offset;\n                        modulated_signal = constrain(modulated_signal, 0.0, 1.0);\n                        audioMath").concat(n,"_output = audioMath").concat(n,"_inputA * modulated_signal * amount +\n                                                   audioMath").concat(n,"_inputA * (1.0 - amount);\n                    }\n                    break;\n\n                case 1: // Crossfade\n                    {\n                        float mix = constrain(amount + audioMath").concat(n,"_modInput + offset, 0.0, 1.0);\n                        audioMath").concat(n,"_output = audioMath").concat(n,"_inputA * (1.0 - mix) +\n                                                   audioMath").concat(n,"_inputB * mix;\n                    }\n                    break;\n\n                case 2: // Ring Modulation\n                    {\n                        float modulated = audioMath").concat(n,"_inputA * (audioMath").concat(n,"_modInput + offset);\n                        audioMath").concat(n,"_output = modulated * amount +\n                                                   audioMath").concat(n,"_inputA * (1.0 - amount);\n                    }\n                    break;\n\n                case 3: // Vocoder (simplified envelope follower)\n                    {\n                        // Envelope follower on carrier signal (inputA)\n                        float carrier_env = fabs(audioMath").concat(n,"_inputA);\n                        if (carrier_env > audioMath").concat(n,"_vocoder_env) {\n                            audioMath").concat(n,"_vocoder_env += (carrier_env - audioMath").concat(n,"_vocoder_env) *\n                                                            audioMath").concat(n,"_vocoder_attack;\n                        } else {\n                            audioMath").concat(n,"_vocoder_env += (carrier_env - audioMath").concat(n,"_vocoder_env) *\n                                                            audioMath").concat(n,"_vocoder_release;\n                        }\n\n                        // Apply carrier envelope to modulator (inputB)\n                        audioMath").concat(n,"_output = audioMath").concat(n,"_inputB * audioMath").concat(n,"_vocoder_env * amount +\n                                                   audioMath").concat(n,"_inputB * (1.0 - amount);\n                    }\n                    break;\n\n                default:\n                    audioMath").concat(n,"_output = audioMath").concat(n,"_inputA; // Pass-through\n                    break;\n            }\n\n            // Apply final gain limiting\n            audioMath").concat(n,"_output = constrain(audioMath").concat(n,"_output, -1.0, 1.0);\n        }\n")}},{key:"generatePannerCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pan"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"width"===n.to.port}),i="0.0",l="0.0",s="panner".concat(n,"_pan"),u="panner".concat(n,"_width");if(a){var d=a.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"Oscillator":i="osc".concat(m,"_outputL");break;case"VCA":i="vca".concat(m,"_outputL");break;case"Filter":i="filter".concat(m,"_outputL");break;case"AudioMath":i="audioMath".concat(m,"_output");break;case"Noise":i="noise".concat(m,"_output")}}}if(o){var _=o.from.id.split(":")[0],g=this.connectionResolver.modules.find(function(e){return e.id===_});if(g){var h,v=(null===(h=_.match(/\d+$/))||void 0===h?void 0:h[0])||"1";switch(g.type){case"Oscillator":l="osc".concat(v,"_outputR");break;case"VCA":l="vca".concat(v,"_outputR");break;case"Filter":l="filter".concat(v,"_outputR");break;case"AudioMath":l="audioMath".concat(v,"_output");break;case"Noise":l="noise".concat(v,"_output")}}}if(r){var b=r.from.id.split(":")[0],y=this.connectionResolver.modules.find(function(e){return e.id===b});if(y){var k,S=(null===(k=b.match(/\d+$/))||void 0===k?void 0:k[0])||"1";switch(y.type){case"Pot":s="pot".concat(S,"_value");break;case"LFO":s="(lfo".concat(S,"_output * 0.5 + 0.5)");break;case"ADSR":s="adsr".concat(S,"_output")}}}if(c){var x=c.from.id.split(":")[0],E=this.connectionResolver.modules.find(function(e){return e.id===x});if(E){var P,w=(null===(P=x.match(/\d+$/))||void 0===P?void 0:P[0])||"1";switch(E.type){case"Pot":u="pot".concat(w,"_value");break;case"LFO":u="(lfo".concat(w,"_output * 0.5 + 0.5)");break;case"ADSR":u="adsr".concat(w,"_output")}}}return"\n        // Panner ".concat(n," processing\n        {\n            panner").concat(n,"_inputL = ").concat(i,";\n            panner").concat(n,"_inputR = ").concat(l,";\n            float pan = constrain(").concat(s,", 0.0, 1.0);\n            float width = constrain(").concat(u,", 0.0, 1.0);\n\n            // Convert stereo input to mid/side representation\n            float mid = (panner").concat(n,"_inputL + panner").concat(n,"_inputR) * 0.5;\n            float side = (panner").concat(n,"_inputL - panner").concat(n,"_inputR) * 0.5;\n\n            // Apply width control to side signal\n            side *= width;\n\n            // Convert back to left/right\n            float processedL = mid + side;\n            float processedR = mid - side;\n\n            // Apply constant-power panning\n            float pan_angle = pan * M_PI * 0.5; // 0 to PI/2\n            float left_gain = cos(pan_angle);   // 1.0 at left, 0.707 at center, 0.0 at right\n            float right_gain = sin(pan_angle);  // 0.0 at left, 0.707 at center, 1.0 at right\n\n            panner").concat(n,"_outputL = processedL * left_gain + processedR * left_gain;\n            panner").concat(n,"_outputR = processedL * right_gain + processedR * right_gain;\n\n            // Apply final output limiting\n            panner").concat(n,"_outputL = constrain(panner").concat(n,"_outputL, -1.0, 1.0);\n            panner").concat(n,"_outputR = constrain(panner").concat(n,"_outputR, -1.0, 1.0);\n        }\n")}},{key:"generateStereoMixer4Code",value:function(e,n,t){t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"1L"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"1R"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"2L"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"2R"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"3L"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"3R"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"4L"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"4R"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"g1"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"g2"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"g3"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"g4"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"master"===n.to.port});var a=e.params.start_bank||2;return"\n        // StereoMixer4 ".concat(n," processing (Banks ").concat(a," and ").concat(a+1,")\n        // Note: Inputs are assigned by CodeGenerator before this code runs\n        {\n            // Get gain controls (use hardware banking values set in updateControl)\n            float gain1 = stereoMixer4_").concat(n,"_gain1;\n            float gain2 = stereoMixer4_").concat(n,"_gain2;\n            float gain3 = stereoMixer4_").concat(n,"_gain3;\n            float gain4 = stereoMixer4_").concat(n,"_gain4;\n            float master = stereoMixer4_").concat(n,"_master;\n\n            // Apply mute/solo logic\n            // Solo mode: only when encoder held (detected by solo_channel != 0)\n            if (stereoMixer4_").concat(n,"_solo_channel != 0) {\n                // Solo mode: only play the solo channel\n                if (stereoMixer4_").concat(n,"_solo_channel != 1) gain1 = 0.0;\n                if (stereoMixer4_").concat(n,"_solo_channel != 2) gain2 = 0.0;\n                if (stereoMixer4_").concat(n,"_solo_channel != 3) gain3 = 0.0;\n                if (stereoMixer4_").concat(n,"_solo_channel != 4) gain4 = 0.0;\n            } else {\n                // Individual mute mode (Bank 1)\n                if (stereoMixer4_").concat(n,"_mute[0]) gain1 = 0.0;\n                if (stereoMixer4_").concat(n,"_mute[1]) gain2 = 0.0;\n                if (stereoMixer4_").concat(n,"_mute[2]) gain3 = 0.0;\n                if (stereoMixer4_").concat(n,"_mute[3]) gain4 = 0.0;\n            }\n\n            // Apply panning using pre-calculated coefficients (updated at control rate)\n            // Pan coefficients calculated in updateControl() to avoid expensive cos/sin in audio loop\n\n            // Mix all channels with panning\n            float mixedL = (stereoMixer4_").concat(n,"_input1L * stereoMixer4_").concat(n,"_panL[0] * gain1) +\n                           (stereoMixer4_").concat(n,"_input1R * stereoMixer4_").concat(n,"_panL[0] * gain1) +\n                           (stereoMixer4_").concat(n,"_input2L * stereoMixer4_").concat(n,"_panL[1] * gain2) +\n                           (stereoMixer4_").concat(n,"_input2R * stereoMixer4_").concat(n,"_panL[1] * gain2) +\n                           (stereoMixer4_").concat(n,"_input3L * stereoMixer4_").concat(n,"_panL[2] * gain3) +\n                           (stereoMixer4_").concat(n,"_input3R * stereoMixer4_").concat(n,"_panL[2] * gain3) +\n                           (stereoMixer4_").concat(n,"_input4L * stereoMixer4_").concat(n,"_panL[3] * gain4) +\n                           (stereoMixer4_").concat(n,"_input4R * stereoMixer4_").concat(n,"_panL[3] * gain4);\n\n            float mixedR = (stereoMixer4_").concat(n,"_input1L * stereoMixer4_").concat(n,"_panR[0] * gain1) +\n                           (stereoMixer4_").concat(n,"_input1R * stereoMixer4_").concat(n,"_panR[0] * gain1) +\n                           (stereoMixer4_").concat(n,"_input2L * stereoMixer4_").concat(n,"_panR[1] * gain2) +\n                           (stereoMixer4_").concat(n,"_input2R * stereoMixer4_").concat(n,"_panR[1] * gain2) +\n                           (stereoMixer4_").concat(n,"_input3L * stereoMixer4_").concat(n,"_panR[2] * gain3) +\n                           (stereoMixer4_").concat(n,"_input3R * stereoMixer4_").concat(n,"_panR[2] * gain3) +\n                           (stereoMixer4_").concat(n,"_input4L * stereoMixer4_").concat(n,"_panR[3] * gain4) +\n                           (stereoMixer4_").concat(n,"_input4R * stereoMixer4_").concat(n,"_panR[3] * gain4);\n\n            // Apply master gain and output limiting\n            stereoMixer4_").concat(n,"_outputL = constrain(mixedL * master, -1.0, 1.0);\n            stereoMixer4_").concat(n,"_outputR = constrain(mixedR * master, -1.0, 1.0);\n        }\n")}},{key:"generateMatrix2x2Code",value:function(e,n,t){var a=this,o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inAL"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inAR"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inBL"===n.to.port}),i=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inBR"===n.to.port}),l=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"aa"===n.to.port}),s=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"ab"===n.to.port}),u=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"ba"===n.to.port}),d=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"bb"===n.to.port}),p=function(e){var n;if(!e)return"0.0";var t=e.from.id.split(":")[0],o=a.connectionResolver.modules.find(function(e){return e.id===t});if(!o)return"0.0";var r=(null===(n=t.match(/\d+$/))||void 0===n?void 0:n[0])||"1",c=e.from.port;switch(o.type){case"Oscillator":return"osc".concat(r,"outR"===c?"_outputR":"_outputL");case"VCA":return"vca".concat(r,"outR"===c?"_outputR":"_outputL");case"Filter":return"filter".concat(r,"outR"===c?"_outputR":"_outputL");case"Panner":return"panner".concat(r,"outR"===c?"_outputR":"_outputL");case"StereoMixer4":return"stereoMixer4_".concat(r,"outR"===c?"_outputR":"_outputL");case"Matrix2x2":return"outAL"===c?"matrix".concat(r,"_outputAL"):"outAR"===c?"matrix".concat(r,"_outputAR"):"outBL"===c?"matrix".concat(r,"_outputBL"):"outBR"===c?"matrix".concat(r,"_outputBR"):"0.0";case"AudioMath":return"audioMath".concat(r,"_output");case"Noise":return"noise".concat(r,"_output");case"Delay":return"delay".concat(r,"outR"===c?"_outputR":"_outputL");default:return"0.0"}},f=function(e,n){var t;if(!e)return n;var o=e.from.id.split(":")[0],r=a.connectionResolver.modules.find(function(e){return e.id===o});if(!r)return n;var c=(null===(t=o.match(/\d+$/))||void 0===t?void 0:t[0])||"1";switch(r.type){case"Pot":return"(pot".concat(c,"_value * 2.0 - 1.0)");case"LFO":return"lfo".concat(c,"_output");case"ADSR":return"(adsr".concat(c,"_output * 2.0 - 1.0)");default:return n}};return"\n        // Matrix2x2 ".concat(n," processing - 2x2 Audio Router with Feedback\n        {\n            // Get input signals\n            matrix").concat(n,"_inputAL = ").concat(p(o),";\n            matrix").concat(n,"_inputAR = ").concat(p(r),";\n            matrix").concat(n,"_inputBL = ").concat(p(c),";\n            matrix").concat(n,"_inputBR = ").concat(p(i),";\n\n            // Get matrix coefficients (with external control)\n            float aa = ").concat(f(l,"matrix".concat(n,"_aa")),";\n            float ab = ").concat(f(s,"matrix".concat(n,"_ab")),";\n            float ba = ").concat(f(u,"matrix".concat(n,"_ba")),";\n            float bb = ").concat(f(d,"matrix".concat(n,"_bb")),";\n\n            // Constrain matrix gains to prevent runaway feedback\n            aa = constrain(aa, -2.0, 2.0);\n            ab = constrain(ab, -2.0, 2.0);\n            ba = constrain(ba, -2.0, 2.0);\n            bb = constrain(bb, -2.0, 2.0);\n\n            // Matrix multiplication:\n            // [outA] = [aa ab] * [inA]\n            // [outB]   [ba bb]   [inB]\n\n            // Left channel\n            matrix").concat(n,"_outputAL = (matrix").concat(n,"_inputAL * aa) + (matrix").concat(n,"_inputBL * ab);\n            matrix").concat(n,"_outputBL = (matrix").concat(n,"_inputAL * ba) + (matrix").concat(n,"_inputBL * bb);\n\n            // Right channel (same matrix applied to right signals)\n            matrix").concat(n,"_outputAR = (matrix").concat(n,"_inputAR * aa) + (matrix").concat(n,"_inputBR * ab);\n            matrix").concat(n,"_outputBR = (matrix").concat(n,"_inputAR * ba) + (matrix").concat(n,"_inputBR * bb);\n\n            // Apply output limiting to prevent clipping from feedback\n            matrix").concat(n,"_outputAL = constrain(matrix").concat(n,"_outputAL, -1.0, 1.0);\n            matrix").concat(n,"_outputAR = constrain(matrix").concat(n,"_outputAR, -1.0, 1.0);\n            matrix").concat(n,"_outputBL = constrain(matrix").concat(n,"_outputBL, -1.0, 1.0);\n            matrix").concat(n,"_outputBR = constrain(matrix").concat(n,"_outputBR, -1.0, 1.0);\n        }\n")}},{key:"generateChorusFlangeRingCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o="0.0";if(a){var r=a.from.id.split(":")[0];if(this.connectionResolver.modules.find(function(e){return e.id===r})){var c,i=(null===(c=r.match(/\d+$/))||void 0===c?void 0:c[0])||"1";o="osc".concat(i,"_outputL")}}return"\n        // ChorusFlangeRing ".concat(n," processing\n        {\n            float input = ").concat(o,";\n            cfr").concat(n,"_phase += cfr").concat(n,"_rate * 2.0 * M_PI / 44100.0;\n            if (cfr").concat(n,"_phase >= 2.0 * M_PI) cfr").concat(n,"_phase -= 2.0 * M_PI;\n\n            if (cfr").concat(n,"_mode == 2) { // Ring modulation\n                float modulated = input * sin(cfr").concat(n,"_phase) * cfr").concat(n,"_depth;\n                cfr").concat(n,"_outputL = input * (1.0 - cfr").concat(n,"_mix) + modulated * cfr").concat(n,"_mix;\n            } else { // Chorus/Flange (simplified)\n                cfr").concat(n,"_buffer[cfr").concat(n,"_writePos] = input;\n                cfr").concat(n,"_writePos = (cfr").concat(n,"_writePos + 1) % CFR").concat(n,"_BUFFER_SIZE;\n                int delayOffset = (int)(sin(cfr").concat(n,"_phase) * cfr").concat(n,"_depth * 100);\n                int readPos = (cfr").concat(n,"_writePos - 100 - delayOffset + CFR").concat(n,"_BUFFER_SIZE) % CFR").concat(n,"_BUFFER_SIZE;\n                float delayed = cfr").concat(n,"_buffer[readPos];\n                cfr").concat(n,"_outputL = input * (1.0 - cfr").concat(n,"_mix) + delayed * cfr").concat(n,"_mix;\n            }\n            cfr").concat(n,"_outputR = cfr").concat(n,"_outputL;\n        }\n")}},{key:"generateLimiterCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o="0.0";if(a){var r=a.from.id.split(":")[0];if(this.connectionResolver.modules.find(function(e){return e.id===r})){var c,i=(null===(c=r.match(/\d+$/))||void 0===c?void 0:c[0])||"1";o="osc".concat(i,"_outputL")}}return"\n        // Limiter ".concat(n," processing\n        {\n            float input = ").concat(o,";\n            float inputLevel = abs(input);\n            float targetGain = 1.0;\n\n            if (inputLevel > limiter").concat(n,"_threshold) {\n                targetGain = limiter").concat(n,"_threshold / inputLevel;\n            }\n\n            // Envelope following\n            float rate = (targetGain < limiter").concat(n,"_envelope) ? limiter").concat(n,"_attack : limiter").concat(n,"_release;\n            limiter").concat(n,"_envelope = limiter").concat(n,"_envelope * (1.0 - rate) + targetGain * rate;\n\n            float output = input * limiter").concat(n,"_envelope * limiter").concat(n,"_makeup;\n            limiter").concat(n,"_outputL = output;\n            limiter").concat(n,"_outputR = output;\n        }\n")}},{key:"generateEQ8Code",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o="0.0";if(a){var r=a.from.id.split(":")[0];if(this.connectionResolver.modules.find(function(e){return e.id===r})){var c,i=(null===(c=r.match(/\d+$/))||void 0===c?void 0:c[0])||"1";o="osc".concat(i,"_outputL")}}return"\n        // EQ8 ".concat(n," processing (simplified 8-band EQ)\n        {\n            float input = ").concat(o,";\n            float output = input; // Simplified - just pass through for now\n            // TODO: Implement proper 8-band EQ with biquad filters\n            eq").concat(n,"_outputL = output;\n            eq").concat(n,"_outputR = output;\n        }\n")}},{key:"generatePercussionCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"trig"===n.to.port}),o="false";if(a){var r=a.from.id.split(":")[0],c=this.connectionResolver.modules.find(function(e){return e.id===r});if(c){var i=c.params?c.params.index:0;"LEDButton"===c.type&&(o="btn".concat(i,"_pressed"))}}return"\n        // Percussion ".concat(n," processing\n        {\n            bool trigger = ").concat(o,";\n\n            if (trigger && !perc").concat(n,"_triggered) {\n                perc").concat(n,"_triggered = true;\n                // Reset all envelope stages\n                perc").concat(n,"_stage1 = 1; perc").concat(n,"_stage2 = 1; perc").concat(n,"_stage3 = 1;\n                perc").concat(n,"_time1 = 0.0; perc").concat(n,"_time2 = 0.0; perc").concat(n,"_time3 = 0.0;\n            } else if (!trigger) {\n                perc").concat(n,"_triggered = false;\n            }\n\n            // Simple percussion synthesis (metallic tone with decay)\n            float sampleTime = 1.0 / 44100.0;\n            float tone = sin(2.0 * M_PI * perc").concat(n,"_freq * perc").concat(n,"_time1) * perc").concat(n,"_env1;\n            tone += sin(2.0 * M_PI * perc").concat(n,"_freq * 2.1 * perc").concat(n,"_time2) * perc").concat(n,"_env2 * perc").concat(n,"_metallic;\n\n            // Update envelopes\n            if (perc").concat(n,"_stage1 == 1) {\n                perc").concat(n,"_time1 += sampleTime;\n                perc").concat(n,"_env1 = exp(-perc").concat(n,"_time1 / perc").concat(n,"_decay);\n                if (perc").concat(n,"_env1 < 0.001) perc").concat(n,"_stage1 = 0;\n            }\n\n            perc").concat(n,"_outputL = tone * perc").concat(n,"_gain;\n            perc").concat(n,"_outputR = perc").concat(n,"_outputL;\n        }\n")}},{key:"generateWavetableFMConnection",value:function(e,n){var t,a=e.from.id.split(":")[0],o=this.connectionResolver.modules.find(function(e){return e.id===a});if(!o)return"";var r=(null===(t=a.match(/\d+$/))||void 0===t?void 0:t[0])||"1";switch(o.type){case"Wavetable":return"wt".concat(n,"_fm_input = wt").concat(r,"_outputL; // FM from Wavetable ").concat(r);case"Oscillator":return"wt".concat(n,"_fm_input = osc").concat(r,"_outputL; // FM from Oscillator ").concat(r);case"VCA":return"wt".concat(n,"_fm_input = vca").concat(r,"_outputL; // FM from VCA ").concat(r);case"LFO":return"wt".concat(n,"_fm_input = lfo").concat(r,"_output; // FM from LFO ").concat(r);case"ADSR":return"wt".concat(n,"_fm_input = adsr").concat(r,"_output; // FM from ADSR ").concat(r);default:return""}}},{key:"generateWavetableControlProcessing",value:function(e,n,t){var a=this,o="\n            // Update control parameters\n            float wt".concat(n,"_currentFreq = wt").concat(n,"_freq;\n            float wt").concat(n,"_currentMorph = wt").concat(n,"_morph;\n            float wt").concat(n,"_currentGate = wt").concat(n,"_gate;\n            float wt").concat(n,"_currentPitchCv = 0.5; // Default = no modulation\n");t.forEach(function(t){var r,c;if(t.to.id.includes("".concat(e.id,":"))){var i=t.from.id.split(":")[0],l=a.connectionResolver.modules.find(function(e){return e.id===i});if(l){var s=(null===(r=l.params)||void 0===r?void 0:r.index)||(null===(c=i.match(/\d+$/))||void 0===c?void 0:c[0])||"1";switch(t.to.port){case"freq":switch(l.type){case"Pot":o+="\n            wt".concat(n,"_currentFreq = (pot").concat(s,"_value * 2000.0 + 20.0); // 20Hz to 2020Hz\n");break;case"Scale":o+="\n            wt".concat(n,"_currentFreq = scale").concat(s,"_output;\n");break;case"HarmonicSequencer":case"BankSequencer":var u=t.from.port;u&&u.includes("pitch_step")&&u.includes("_hz")&&(o+="\n            wt".concat(n,"_currentFreq = seq").concat(s,"_").concat(u,"; // ").concat(l.type," step frequency\n"));break;case"LFO":o+="\n            wt".concat(n,"_currentFreq = wt").concat(n,"_freq + (lfo").concat(s,"_output * 100.0); // 100Hz modulation\n");break;case"Automation":var d=t.from.port,p=d.replace("out_","output_");o+="\n            wt".concat(n,"_currentFreq = (automation").concat(s,"_").concat(p," * 2000.0 + 20.0); // Automation ").concat(s," ").concat(d,": 20Hz to 2020Hz\n")}break;case"gate":if("LEDButton"===l.type){var f=l.params.bank||1,m=l.params.locked||!1;o+=m?"\n            wt".concat(n,"_currentGate = btn").concat(s,"_gate ? 1.0 : 0.0; // Button").concat(s," (LOCKED)\n"):"\n            if (currentBank == ".concat(f,") { wt").concat(n,"_currentGate = btn").concat(s,"_gate ? 1.0 : 0.0; } // Button").concat(s," Bank ").concat(f,"\n")}else"ADSR"===l.type&&(o+="\n            wt".concat(n,"_currentGate = adsr").concat(s,"_output;\n"));break;case"morph":switch(l.type){case"Pot":o+="\n            wt".concat(n,"_currentMorph = pot").concat(s,"_value * 3.0; // 0-3 range for 4 tables\n");break;case"LFO":o+="\n            wt".concat(n,"_currentMorph = (lfo").concat(s,"_output + 1.0) * 1.5; // 0-3 range\n");break;case"ADSR":o+="\n            wt".concat(n,"_currentMorph = adsr").concat(s,"_output * 3.0; // 0-3 range\n")}break;case"pitch_cv":switch(l.type){case"ADSR":o+="\n            wt".concat(n,"_currentPitchCv = adsr").concat(s,"_output;\n");break;case"LFO":o+="\n            wt".concat(n,"_currentPitchCv = lfo").concat(s,"_output;\n");break;case"Pot":o+="\n            wt".concat(n,"_currentPitchCv = pot").concat(s,"_value;\n")}break;case"fm_ratio_cv":if("Pot"===l.type)o+="\n            wt".concat(n,"_fm_ratio_cv = pot").concat(s,"_value; // FM ratio CV from pot (0-1)\n");else if("Automation"===l.type){var _=t.from.port.replace("out_","output_");o+="\n            wt".concat(n,"_fm_ratio_cv = automation").concat(s,"_").concat(_,"; // FM ratio CV from Automation (0-1)\n")}break;case"fm_amount":if("Pot"===l.type)o+="\n            wt".concat(n,"_fm_amount = pot").concat(s,"_value; // FM amount from pot (0-1)\n");else if("LFO"===l.type)o+="\n            wt".concat(n,"_fm_amount = (lfo").concat(s,"_output + 1.0) * 0.5; // FM amount from LFO (0-1)\n");else if("ADSR"===l.type)o+="\n            wt".concat(n,"_fm_amount = adsr").concat(s,"_output; // FM amount from ADSR (0-1)\n");else if("Automation"===l.type){var g=t.from.port.replace("out_","output_");o+="\n            wt".concat(n,"_fm_amount = automation").concat(s,"_").concat(g,"; // FM amount from Automation (0-1)\n")}}}}});var r=t.find(function(n){var t=n.from.id.split(":")[0],a=n.to.id?n.to.id.split(":")[1]:n.to.port;return t===e.id&&"fm"===a});if(r&&!1!==e.params.fm_tracking){var c=r.to.id?r.to.id.split(":")[0]:r.to,i=this.connectionResolver.modules.find(function(e){return e.id===c});if(i&&"Wavetable"===i.type){var l,s=(null===(l=c.match(/\d+$/))||void 0===l?void 0:l[0])||"1",u=e.params.fm_ratio_mode||"zones";o+="\n            // FM Tracking: This modulator tracks Wavetable".concat(s,' frequency\n            // FM Ratio Mapping Mode: "').concat(u,'"\n'),o+="zones"===u?"\n            float cv = wt".concat(n,"_fm_ratio_cv;\n            float computed_ratio;\n\n            // Zone mapping: pure ratios get wider zones for easy tuning\n            if (cv < 0.1) {\n                computed_ratio = 0.5; // 1:2 (octave below) - zone\n            } else if (cv < 0.15) {\n                computed_ratio = 0.5 + (cv - 0.1) / 0.05 * (0.667 - 0.5); // Smooth transition\n            } else if (cv < 0.25) {\n                computed_ratio = 0.667; // 2:3 (perfect fifth down) - zone\n            } else if (cv < 0.3) {\n                computed_ratio = 0.667 + (cv - 0.25) / 0.05 * (1.0 - 0.667); // Smooth transition\n            } else if (cv < 0.4) {\n                computed_ratio = 1.0; // 1:1 (unison) - zone\n            } else if (cv < 0.45) {\n                computed_ratio = 1.0 + (cv - 0.4) / 0.05 * (1.5 - 1.0); // Smooth transition\n            } else if (cv < 0.55) {\n                computed_ratio = 1.5; // 3:2 (perfect fifth) - zone\n            } else if (cv < 0.6) {\n                computed_ratio = 1.5 + (cv - 0.55) / 0.05 * (2.0 - 1.5); // Smooth transition\n            } else if (cv < 0.7) {\n                computed_ratio = 2.0; // 2:1 (octave) - zone\n            } else if (cv < 0.75) {\n                computed_ratio = 2.0 + (cv - 0.7) / 0.05 * (3.0 - 2.0); // Smooth transition\n            } else if (cv < 0.85) {\n                computed_ratio = 3.0; // 3:1 - zone\n            } else if (cv < 0.9) {\n                computed_ratio = 3.0 + (cv - 0.85) / 0.05 * (4.0 - 3.0); // Smooth transition\n            } else {\n                computed_ratio = 4.0; // 4:1 (two octaves) - zone\n            }\n\n            float final_ratio = computed_ratio;\n            wt").concat(n,"_currentFreq = wt").concat(s,"_freq * final_ratio;\n"):"quantized"===u?"\n            float cv = wt".concat(n,"_fm_ratio_cv;\n            float ratios[] = {0.5, 0.667, 1.0, 1.5, 2.0, 3.0, 4.0};\n            int numRatios = 7;\n            float scaledCV = cv * 6.0; // Map 0-1 to 0-6 (ratio indices)\n            int idx = constrain((int)scaledCV, 0, numRatios - 1);\n            float computed_ratio = ratios[idx];\n\n            wt").concat(n,"_currentFreq = wt").concat(s,"_freq * computed_ratio;\n"):"\n            float cv = wt".concat(n,"_fm_ratio_cv;\n            float computed_ratio = 0.1 + cv * 7.9; // 0-1 CV maps to 0.1-8.0 ratio range\n\n            wt").concat(n,"_currentFreq = wt").concat(s,"_freq * computed_ratio;\n")}}return o+="\n            // Apply exponential pitch CV modulation (semitones, like Oscillator)\n            float pitch_offset_semitones = (wt".concat(n,"_currentPitchCv - 0.5) * wt").concat(n,"_pitch_amount;\n            float pitch_multiplier = pow(2.0, pitch_offset_semitones / 12.0);\n            wt").concat(n,"_freq = wt").concat(n,"_currentFreq * pitch_multiplier;\n\n            // Apply other control values\n            wt").concat(n,"_morph = wt").concat(n,"_currentMorph;\n            wt").concat(n,"_gate = wt").concat(n,"_currentGate;\n")}},{key:"generateGranularDenseCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port});return"\n        // Granular Dense ".concat(n," - 20 concurrent 32ms grains for rich textural synthesis\n        {\n            // Control processing\n            ").concat(this.generateGranularDenseControlProcessing(e,n,t),"\n\n            // Audio input processing\n            granular").concat(n,"_inputL = 0.0;\n            granular").concat(n,"_inputR = 0.0;\n\n            ").concat(a?this.generateGranularDenseInputConnection(a,n,"L"):"","\n            ").concat(o?this.generateGranularDenseInputConnection(o,n,"R"):"","\n\n            // Record input to buffer (if not frozen)\n            if (!granular").concat(n,"_currentFreeze) {\n                granular").concat(n,"_buffer_L[granular").concat(n,"_write_pos] = granular").concat(n,"_inputL;\n                granular").concat(n,"_buffer_R[granular").concat(n,"_write_pos] = granular").concat(n,"_inputR;\n                granular").concat(n,"_write_pos++;\n                if (granular").concat(n,"_write_pos >= granular").concat(n,"_buffer_size) {\n                    granular").concat(n,"_write_pos = 0;\n                }\n            }\n\n            // Grain triggering - rate-limited dense processing\n            float grainTriggerRate = constrain(granular").concat(n,"_currentDensity, 1.0, 20.0); // Max 20 grains/sec\n            int samplesBetweenGrains = (int)(SAMPLE_RATE / grainTriggerRate);\n            granular").concat(n,"_samples_since_grain++;\n\n            if (granular").concat(n,"_samples_since_grain >= samplesBetweenGrains) {\n                // Find inactive grain slot (memory-efficient)\n                int activeGrains = 0;\n                int availableSlot = -1;\n\n                for (int g = 0; g < 20; g++) {\n                    if (granular").concat(n,"_grains[g].active) {\n                        activeGrains++;\n                    } else if (availableSlot == -1) {\n                        availableSlot = g;\n                    }\n                }\n\n                // Limit to 18/20 grains max for stability\n                if (availableSlot != -1 && activeGrains < 18) {\n                    // Trigger new grain with constrained parameters\n                    granular").concat(n,"_grains[availableSlot].active = true;\n\n                    // Grain position with spread\n                    float basePosition = constrain(granular").concat(n,"_currentPosition, 0.1, 0.9);\n                    float spread = constrain(granular").concat(n,"_position_spread, 0.0, 0.3);\n                    float positionJitter = (random(0, 1000) / 1000.0 - 0.5) * spread;\n                    granular").concat(n,"_grains[availableSlot].position = constrain(basePosition + positionJitter, 0.0, 1.0);\n\n                    // Grain pitch with controlled spread\n                    float basePitchRatio = pow(2.0, constrain(granular").concat(n,"_currentPitch, -2.0, 2.0)); // 2 octaves max\n                    float pitchSpread = constrain(granular").concat(n,"_pitch_spread, 0.0, 0.3);\n                    float pitchJitter = (random(0, 1000) / 1000.0 - 0.5) * pitchSpread;\n                    granular").concat(n,"_grains[availableSlot].pitch_ratio = constrain(basePitchRatio + pitchJitter, 0.25, 4.0);\n\n                    // Fixed 32ms grain duration for dense texture\n                    int grainSamples = (int)(0.032 * SAMPLE_RATE); // 32ms grains\n                    granular").concat(n,"_grains[availableSlot].samples_remaining = grainSamples;\n                    granular").concat(n,"_grains[availableSlot].envelope_pos = 0.0;\n                    granular").concat(n,"_grains[availableSlot].envelope_inc = 1.0 / grainSamples;\n                }\n\n                granular").concat(n,"_samples_since_grain = 0;\n            }\n\n            // Process all active grains with efficient envelope\n            float outL = 0.0;\n            float outR = 0.0;\n\n            for (int g = 0; g < 20; g++) {\n                if (granular").concat(n,"_grains[g].active) {\n                    // Calculate buffer read position\n                    float bufferPos = granular").concat(n,"_grains[g].position * granular").concat(n,"_buffer_size;\n                    int readPos = (int)bufferPos;\n                    float frac = bufferPos - readPos;\n\n                    // Bounds checking\n                    if (readPos >= 0 && readPos < (granular").concat(n,"_buffer_size - 1)) {\n                        // Linear interpolation for smooth pitch shifting\n                        float sampleL = granular").concat(n,"_buffer_L[readPos] * (1.0 - frac) +\n                                       granular").concat(n,"_buffer_L[readPos + 1] * frac;\n                        float sampleR = granular").concat(n,"_buffer_R[readPos] * (1.0 - frac) +\n                                       granular").concat(n,"_buffer_R[readPos + 1] * frac;\n\n                        // Cosine envelope for smooth grains\n                        float envelope = 0.5 * (1.0 + cos(PI * (2.0 * granular").concat(n,"_grains[g].envelope_pos - 1.0)));\n                        envelope = constrain(envelope, 0.0, 1.0);\n\n                        // Scale output to prevent clipping with 20 grains\n                        float grainScale = 0.15; // Reduced amplitude per grain\n                        outL += sampleL * envelope * grainScale;\n                        outR += sampleR * envelope * grainScale;\n                    }\n\n                    // Update grain state\n                    granular").concat(n,"_grains[g].envelope_pos += granular").concat(n,"_grains[g].envelope_inc;\n                    granular").concat(n,"_grains[g].position += granular").concat(n,"_grains[g].pitch_ratio / granular").concat(n,"_buffer_size;\n                    granular").concat(n,"_grains[g].samples_remaining--;\n\n                    // Wrap position\n                    if (granular").concat(n,"_grains[g].position >= 1.0) {\n                        granular").concat(n,"_grains[g].position -= 1.0;\n                    }\n\n                    // Deactivate finished grains\n                    if (granular").concat(n,"_grains[g].samples_remaining <= 0) {\n                        granular").concat(n,"_grains[g].active = false;\n                    }\n                }\n            }\n\n            // Dry/wet mix with input\n            float dryGain = 1.0 - constrain(granular").concat(n,"_currentDryWet, 0.0, 1.0);\n            float wetGain = constrain(granular").concat(n,"_currentDryWet, 0.0, 1.0);\n\n            granular").concat(n,"_outputL = granular").concat(n,"_inputL * dryGain + outL * wetGain;\n            granular").concat(n,"_outputR = granular").concat(n,"_inputR * dryGain + outR * wetGain;\n        }\n")}},{key:"generateGranularDenseControlProcessing",value:function(e,n,t){var a=this,o="\n            // Update granular parameters from connections\n            float granular".concat(n,"_currentDensity = granular").concat(n,"_grain_density;\n            float granular").concat(n,"_currentPosition = granular").concat(n,"_position;\n            float granular").concat(n,"_currentPitch = granular").concat(n,"_pitch;\n            float granular").concat(n,"_currentDryWet = granular").concat(n,"_dry_wet;\n            bool granular").concat(n,"_currentFreeze = granular").concat(n,"_freeze;\n");return t.forEach(function(t){var r,c;if(t.to.id.includes("".concat(e.id,":"))){var i=t.from.id.split(":")[0],l=a.connectionResolver.modules.find(function(e){return e.id===i});if(l){var s=(null===(r=l.params)||void 0===r?void 0:r.index)||(null===(c=i.match(/\d+$/))||void 0===c?void 0:c[0])||"1";switch(t.to.port){case"density":switch(l.type){case"Pot":o+="\n            granular".concat(n,"_currentDensity = pot").concat(s,"_value * 20.0; // 0-20 grains/sec\n");break;case"LFO":o+="\n            granular".concat(n,"_currentDensity = granular").concat(n,"_grain_density + (lfo").concat(s,"_output * 10.0);\n")}break;case"position":switch(l.type){case"Pot":o+="\n            granular".concat(n,"_currentPosition = pot").concat(s,"_value; // 0-1 buffer position\n");break;case"LFO":o+="\n            granular".concat(n,"_currentPosition = constrain(granular").concat(n,"_position + (lfo").concat(s,"_output * 0.3), 0.0, 1.0);\n")}break;case"pitch":switch(l.type){case"Pot":o+="\n            granular".concat(n,"_currentPitch = (pot").concat(s,"_value - 0.5) * 4.0; // 2 octaves\n");break;case"ADSR":o+="\n            granular".concat(n,"_currentPitch = granular").concat(n,"_pitch + (adsr").concat(s,"_output * 2.0);\n")}break;case"dry_wet":"Pot"===l.type&&(o+="\n            granular".concat(n,"_currentDryWet = pot").concat(s,"_value; // 0=dry, 1=wet\n"));break;case"freeze":"LEDButton"===l.type&&(o+="\n            granular".concat(n,"_currentFreeze = btn").concat(s,"_pressed; // Freeze buffer\n"))}}}}),o+="\n            // Apply parameter constraints for stability\n            granular".concat(n,"_grain_density = constrain(granular").concat(n,"_currentDensity, 1.0, 20.0);\n            granular").concat(n,"_position = constrain(granular").concat(n,"_currentPosition, 0.0, 1.0);\n            granular").concat(n,"_pitch = constrain(granular").concat(n,"_currentPitch, -2.0, 2.0);\n            granular").concat(n,"_dry_wet = constrain(granular").concat(n,"_currentDryWet, 0.0, 1.0);\n            granular").concat(n,"_freeze = granular").concat(n,"_currentFreeze;\n")}},{key:"generateGranularDenseInputConnection",value:function(e,n,t){var a,o=e.from.id.split(":")[0],r=this.connectionResolver.modules.find(function(e){return e.id===o});if(!r)return"";var c=(null===(a=o.match(/\d+$/))||void 0===a?void 0:a[0])||"1";switch(r.type){case"Oscillator":return"granular".concat(n,"_input").concat(t," = osc").concat(c,"_output;");case"Filter":return"granular".concat(n,"_input").concat(t," = filter").concat(c,"_output").concat(t,";");case"VCA":return"granular".concat(n,"_input").concat(t," = vca").concat(c,"_output").concat(t,";");case"SamplePlayer":return"granular".concat(n,"_input").concat(t," = sdPlayer").concat(c,"_output").concat(t,";");default:return"// Unknown input type: ".concat(r.type)}}},{key:"generateSamplePlayerCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"trig"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch"===n.to.port}),r=(t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"sample_select"===n.to.port}),"false"),c="sp".concat(n,"_pitch"),i="sp".concat(n,"_currentFile");if(a){var l=a.from.id.split(":")[0],s=this.connectionResolver.modules.find(function(e){return e.id===l});if(s){var u=s.params?s.params.index:0;"LEDButton"===s.type&&(r="btn".concat(u,"_pressed"))}}if(o){var d=o.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"Scale":c="(scale".concat(m,"_output / 440.0)");break;case"ADSR":c="(sp".concat(n,"_pitch + adsr").concat(m,"_output * 0.5)");break;case"Pot":c="(pot".concat(m,"_value * 2.0 + 0.5)")}}}return e.params.polyphonic?"\n        // SamplePlayer ".concat(n," processing - Polyphonic Mode (6 voices)\n        {\n            bool trigger = ").concat(r,";\n            float pitchRatio = ").concat(c,";\n\n            // Voice allocation and triggering (simplified)\n            if (trigger) {\n                // Find available voice or steal oldest\n                int voiceToUse = sp").concat(n,"_nextVoice;\n                sp").concat(n,"_nextVoice = (sp").concat(n,"_nextVoice + 1) % SP").concat(n,"_VOICES;\n\n                // Initialize voice\n                sp").concat(n,"_voices[voiceToUse].active = true;\n                sp").concat(n,"_voices[voiceToUse].playPosition = 0;\n                sp").concat(n,"_voices[voiceToUse].pitch = pitchRatio;\n                sp").concat(n,"_voices[voiceToUse].fractionalPos = 0.0;\n            }\n\n            // Mix all active voices\n            float mixL = 0.0, mixR = 0.0;\n            for (int v = 0; v < SP").concat(n,"_VOICES; v++) {\n                if (sp").concat(n,"_voices[v].active && sp").concat(n,"_voices[v].psramData) {\n                    // Simple sample playback with pitch control\n                    uint32_t pos = (uint32_t)sp").concat(n,"_voices[v].fractionalPos;\n                    if (pos < sp").concat(n,"_voices[v].sampleLength) {\n                        float sample = (float)sp").concat(n,"_voices[v].psramData[pos] / 32767.0f;\n                        mixL += sample * sp").concat(n,"_voices[v].gain;\n                        mixR += sample * sp").concat(n,"_voices[v].gain;\n\n                        // Advance position with pitch control\n                        sp").concat(n,"_voices[v].fractionalPos += sp").concat(n,"_voices[v].pitch;\n                    } else {\n                        // Sample finished\n                        sp").concat(n,"_voices[v].active = false;\n                    }\n                }\n            }\n\n            sp").concat(n,"_outputL = mixL * sp").concat(n,"_masterGain;\n            sp").concat(n,"_outputR = mixR * sp").concat(n,"_masterGain;\n        }\n"):"\n        // SamplePlayer ".concat(n," processing - Single Voice Mode\n        {\n            // Control signal processing (from existing SampleModules)\n            bool currentTrigger = ").concat(r,";\n            float currentPitch = ").concat(c,";\n            int targetFile = ").concat(i,";\n\n            // Edge detection for trigger\n            if (currentTrigger && !sp").concat(n,"_lastTrigger) {\n                // Trigger detected - start playback\n                if (sp").concat(n,"_lastLoadedFile != -1) {\n                    sp").concat(n,"_player.play();\n                    sp").concat(n,"_playing = true;\n                }\n            }\n            sp").concat(n,"_lastTrigger = currentTrigger;\n\n            // Audio generation\n            if (sp").concat(n,"_playing) {\n                int16_t sampleL = sp").concat(n,"_player.getNextSample();\n                int16_t sampleR = sampleL; // Mono for now\n\n                sp").concat(n,"_outputL = (float)sampleL / 32767.0f * sp").concat(n,"_gain;\n                sp").concat(n,"_outputR = (float)sampleR / 32767.0f * sp").concat(n,"_gain;\n\n                sp").concat(n,"_playing = sp").concat(n,"_player.playing();\n            } else {\n                sp").concat(n,"_outputL = 0.0f;\n                sp").concat(n,"_outputR = 0.0f;\n            }\n\n            // Update pitch if changed\n            if (currentPitch != sp").concat(n,"_pitch) {\n                sp").concat(n,"_pitch = currentPitch;\n                sp").concat(n,"_player.setPlaybackSpeed(sp").concat(n,"_pitch);\n            }\n        }\n")}},{key:"generateProcessingCode",value:function(e,n,t){switch(e.type){case"Oscillator":return this.generateOscillatorProcessingCode(e,n,t);case"Wavetable":return this.generateWavetableCode(e,n,t);case"Noise":case"NoiseGenerator":return this.generateNoiseCode(e,n,t);case"VCA":return this.generateVCAProcessingCode(e,n,t);case"Filter":return this.generateFilterCode(e,n,t);case"Distortion":return this.generateDistortionCode(e,n,t);case"StereoMixer4":return this.generateStereoMixer4Code(e,n,t);case"I2SOut":case"PCM5102A Out":return this.generateI2SOutProcessingCode(e,n,t);case"LineIn":return this.generateLineInProcessingCode(e,n,t);case"AudioRecorder":return this.generateAudioRecorderCode(e,n,t);case"SamplePlayer":return this.generateSamplePlayerProcessingCode(e,n,t);case"CleanReverb":return this.generateCleanReverbCode(e,n,t);case"Delay":return this.generateDelayCode(e,n,t);case"GranularDense":return this.generateGranularDenseProcessingCode(e,n,t);case"GranularSynth":return this.generateGranularSynthProcessingCode(e,n,t);case"Resonance":return this.generateResonanceProcessingCode(e,n,t);case"DrumDesigner":return this.generateDrumDesignerCode(e,n,t);case"DrumDesigner4":return this.generateDrumDesigner4Code(e,n,t);default:return console.warn("No audio processing code generator for: ".concat(e.type)),null}}},{key:"generateNoiseProcessingCode",value:function(e,n,t){return"\n        // Noise Generator ".concat(n," processing\n        if (noise").concat(n,'_debug_counter % 1000 == 0) { // Every ~23ms at 44.1kHz\n            Serial.print("DEBUG: Noise generator').concat(n,' gate=");\n            Serial.print(noise').concat(n,'_gate);\n            Serial.print(", gain=");\n            Serial.print(noise').concat(n,'_gain);\n            Serial.print(", output=");\n            Serial.println(noise').concat(n,"_output);\n        }\n        noise").concat(n,"_debug_counter++;\n\n        float noise").concat(n,"_gateVal = noise").concat(n,"_gate;\n        if (noise").concat(n,"_gateVal > 0.1) {\n            // Generate white noise\n            float sample = ((float)random(-32768, 32768)) / 32768.0;\n            noise").concat(n,"_output = sample * noise").concat(n,"_gain;\n        } else {\n            noise").concat(n,"_output = 0.0;\n        }\n")}},{key:"generateVCAProcessingCode",value:function(e,n,t){return this.generateVCACode(e,n,t)}},{key:"generateFilterProcessingCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&("inL"===n.to.port||"input_left"===n.to.port)}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&("inR"===n.to.port||"input_right"===n.to.port)}),r="0.0",c="0.0";if(a){var i=a.from.id.split(":")[0],l=this.connectionResolver.modules.find(function(e){return e.id===i});if(l){var s,u=(null===(s=i.match(/\d+$/))||void 0===s?void 0:s[0])||"1";switch(l.type){case"Oscillator":r="osc".concat(u,"_output");break;case"CleanReverb":r="cleanreverb".concat(u,"_outputL");break;case"VCA":r="vca".concat(u,"_outputL");break;case"Noise":r="noise".concat(u,"_output");break;default:r="0.0"}}}if(o){var d=o.from.id.split(":")[0],p=this.connectionResolver.modules.find(function(e){return e.id===d});if(p){var f,m=(null===(f=d.match(/\d+$/))||void 0===f?void 0:f[0])||"1";switch(p.type){case"Oscillator":c="osc".concat(m,"_output");break;case"CleanReverb":c="cleanreverb".concat(m,"_outputR");break;case"VCA":c="vca".concat(m,"_outputR");break;case"Noise":c="noise".concat(m,"_output");break;default:c="0.0"}}}return"\n        // Filter ".concat(n," processing\n        filter").concat(n,"_inputL = ").concat(r,";\n        filter").concat(n,"_inputR = ").concat(c,";\n\n        // Simple low-pass filter implementation\n        float cutoffNorm = constrain(filter").concat(n,"_cutoff / 22050.0, 0.001, 0.99);\n        float alpha = sin(PI * cutoffNorm) / (1.0 + cos(PI * cutoffNorm));\n\n        // Apply filter to left channel\n        filter").concat(n,"_outputL = filter").concat(n,"_y1 + alpha * (filter").concat(n,"_inputL - filter").concat(n,"_y1);\n        filter").concat(n,"_y1 = filter").concat(n,"_outputL;\n\n        // Apply filter to right channel\n        filter").concat(n,"_outputR = filter").concat(n,"_y2 + alpha * (filter").concat(n,"_inputR - filter").concat(n,"_y2);\n        filter").concat(n,"_y2 = filter").concat(n,"_outputR;\n")}},{key:"generateStereoMixer4ProcessingCode",value:function(e,n,t){return"\n        // Stereo Mixer ".concat(n," processing\n        stereoMixer4_").concat(n,"_outputL = (stereoMixer4_").concat(n,"_input1L * stereoMixer4_").concat(n,"_gain1) +\n                                       (stereoMixer4_").concat(n,"_input2L * stereoMixer4_").concat(n,"_gain2) +\n                                       (stereoMixer4_").concat(n,"_input3L * stereoMixer4_").concat(n,"_gain3) +\n                                       (stereoMixer4_").concat(n,"_input4L * stereoMixer4_").concat(n,"_gain4);\n\n        stereoMixer4_").concat(n,"_outputR = (stereoMixer4_").concat(n,"_input1R * stereoMixer4_").concat(n,"_gain1) +\n                                       (stereoMixer4_").concat(n,"_input2R * stereoMixer4_").concat(n,"_gain2) +\n                                       (stereoMixer4_").concat(n,"_input3R * stereoMixer4_").concat(n,"_gain3) +\n                                       (stereoMixer4_").concat(n,"_input4R * stereoMixer4_").concat(n,"_gain4);\n")}},{key:"generateI2SOutProcessingCode",value:function(e,n,t){console.log("DEBUG I2S Processing - Module:",e.id,"Index:",n),console.log("DEBUG I2S Processing - Connections:",t.length);var a=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&("L"===a||"inL"===a)}),o=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&("R"===a||"inR"===a)});console.log("DEBUG I2S Processing - InputL Connection:",a),console.log("DEBUG I2S Processing - InputR Connection:",o);var r="0.0",c="0.0";if(a){for(var i,l,s=(null===(i=(l=a.from&&"string"==typeof a.from?a.from:a.from&&a.from.id?a.from.id.split(":")[0]:"unknown").match(/\d+$/))||void 0===i?void 0:i[0])||"1",u="Unknown",d=0,p=Object.entries({vca:"VCA",oscillator:"Wavetable",wavetable:"Wavetable",osc:"Oscillator",filter:"Filter",noise:"Noise",cleanreverb:"CleanReverb",reverb:"CleanReverb",delay:"Delay",stereomix:"StereoMixer4",panner:"Panner",matrix2x2:"Matrix2x2",granular:"GranularDense",linein:"LineIn",stereoin:"LineIn",audiorecorder:"AudioRecorder",rec:"AudioRecorder",drumdesigner:"DrumDesigner"});d<p.length;d++){var f=se(p[d],2),m=f[0],_=f[1];if(l.toLowerCase().startsWith(m)){u=_;break}}switch(console.log("DEBUG I2S Processing - FromModuleId:",l,"Type:",u,"Index:",s),u){case"StereoMixer4":r="stereoMixer4_".concat(s,"_outputL");break;case"Wavetable":r="wt".concat(s,"_outputL");break;case"Oscillator":r="osc".concat(s,"_outputL");break;case"VCA":r="vca".concat(s,"_outputL");break;case"Filter":r="filter".concat(s,"_outputL");break;case"Noise":r="noise".concat(s,"_output");break;case"CleanReverb":r="cleanreverb".concat(s,"_outputL");break;case"Delay":r="delay".concat(s,"_outputL");break;case"GranularDense":r="granular".concat(s,"_outputL");break;case"LineIn":r="linein".concat(s,"_outputL");break;case"AudioRecorder":r="rec".concat(s,"_outputL");break;case"DrumDesigner":r="dd4".concat(s,"_outputMixL");break;default:r="0.0"}}if(o){for(var g,h,v=(null===(g=(h=o.from&&"string"==typeof o.from?o.from:o.from&&o.from.id?o.from.id.split(":")[0]:"unknown").match(/\d+$/))||void 0===g?void 0:g[0])||"1",b="Unknown",y=0,k=Object.entries({vca:"VCA",oscillator:"Wavetable",wavetable:"Wavetable",osc:"Oscillator",filter:"Filter",noise:"Noise",cleanreverb:"CleanReverb",reverb:"CleanReverb",delay:"Delay",stereomix:"StereoMixer4",panner:"Panner",matrix2x2:"Matrix2x2",granular:"GranularDense",linein:"LineIn",stereoin:"LineIn",audiorecorder:"AudioRecorder",rec:"AudioRecorder",drumdesigner:"DrumDesigner"});y<k.length;y++){var S=se(k[y],2),x=S[0],E=S[1];if(h.toLowerCase().startsWith(x)){b=E;break}}switch(console.log("DEBUG I2S Processing - FromModuleId R:",h,"Type:",b,"Index:",v),b){case"StereoMixer4":c="stereoMixer4_".concat(v,"_outputR");break;case"Wavetable":c="wt".concat(v,"_outputR");break;case"Oscillator":c="osc".concat(v,"_outputR");break;case"VCA":c="vca".concat(v,"_outputR");break;case"Filter":c="filter".concat(v,"_outputR");break;case"Noise":c="noise".concat(v,"_output");break;case"CleanReverb":c="cleanreverb".concat(v,"_outputR");break;case"Delay":c="delay".concat(v,"_outputR");break;case"GranularDense":c="granular".concat(v,"_outputR");break;case"LineIn":c="linein".concat(v,"_outputR");break;case"AudioRecorder":c="rec".concat(v,"_outputR");break;case"DrumDesigner":c="dd4".concat(v,"_outputMixR");break;default:c="0.0"}}return console.log("DEBUG I2S Processing - Final Sources: L="+r+", R="+c),"\n        // I2S Output ".concat(n," processing - assign inputs then process (per sample)\n        i2sout").concat(n,"_inputL = ").concat(r,";\n        i2sout").concat(n,"_inputR = ").concat(c,";\n\n        // Debug output disabled for cleaner serial output\n\n        // Add connected signals to buffers (like working 1709Code)\n        leftBuffer[i] += i2sout").concat(n,"_inputL * i2sout").concat(n,"_volume;\n        rightBuffer[i] += i2sout").concat(n,"_inputR * i2sout").concat(n,"_volume;\n")}},{key:"generateLineInProcessingCode",value:function(e,n,t){var a=e.params.dc_block?"\n        // Apply DC blocking filter (HPF ~3.5Hz at 44.1kHz)\n        float linein".concat(n,"_dc_out_L = linein").concat(n,"_rawL - linein").concat(n,"_dc_x_prev_L + linein").concat(n,"_dc_coeff * linein").concat(n,"_dc_y_prev_L;\n        float linein").concat(n,"_dc_out_R = linein").concat(n,"_rawR - linein").concat(n,"_dc_x_prev_R + linein").concat(n,"_dc_coeff * linein").concat(n,"_dc_y_prev_R;\n        linein").concat(n,"_dc_x_prev_L = linein").concat(n,"_rawL;\n        linein").concat(n,"_dc_x_prev_R = linein").concat(n,"_rawR;\n        linein").concat(n,"_dc_y_prev_L = linein").concat(n,"_dc_out_L;\n        linein").concat(n,"_dc_y_prev_R = linein").concat(n,"_dc_out_R;\n        linein").concat(n,"_outputL = linein").concat(n,"_dc_out_L;\n        linein").concat(n,"_outputR = linein").concat(n,"_dc_out_R;"):"\n        linein".concat(n,"_outputL = linein").concat(n,"_rawL;\n        linein").concat(n,"_outputR = linein").concat(n,"_rawR;");return"\n        // Line In ".concat(n," processing\n        // Read from I2S input buffer (i2sInputBuffer) and apply gain\n        // Note: i2sInputBuffer is populated by i2s_read in the main audio processing function\n        int32_t linein").concat(n,"_sample_L = i2sInputBuffer[i * 2];\n        int32_t linein").concat(n,"_sample_R = i2sInputBuffer[i * 2 + 1];\n\n        // Convert 24-bit in 32-bit slot to float and apply gain\n        int32_t linein").concat(n,"_val24_L = (linein").concat(n,"_sample_L >> 8);  // 24-bit domain\n        int32_t linein").concat(n,"_val24_R = (linein").concat(n,"_sample_R >> 8);\n        float linein").concat(n,"_rawL = ((float)linein").concat(n,"_val24_L / 8388608.0f) * linein").concat(n,"_gain;\n        float linein").concat(n,"_rawR = ((float)linein").concat(n,"_val24_R / 8388608.0f) * linein").concat(n,"_gain;\n\n        // Clamp to valid range\n        if (linein").concat(n,"_rawL >  1.0f) linein").concat(n,"_rawL =  1.0f;\n        if (linein").concat(n,"_rawL < -1.0f) linein").concat(n,"_rawL = -1.0f;\n        if (linein").concat(n,"_rawR >  1.0f) linein").concat(n,"_rawR =  1.0f;\n        if (linein").concat(n,"_rawR < -1.0f) linein").concat(n,"_rawR = -1.0f;\n").concat(a,"\n")}},{key:"generateAudioRecorderCode",value:function(e,n,t){var a=e.params,o=(a.bank,a.max_duration_sec||60),r=Math.floor(44100*o),c=a.bit_depth||24,i=24===c?3:2,l=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),s=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port}),u="0.0f",d="0.0f";if(l){var p,f=(null===(p=l.from.id.split(":")[0].match(/\d+$/))||void 0===p?void 0:p[0])||"1";u="linein".concat(f,"_outputL")}if(s){var m,_=(null===(m=s.from.id.split(":")[0].match(/\d+$/))||void 0===m?void 0:m[0])||"1";d="linein".concat(_,"_outputR")}return"\n        // AudioRecorder ".concat(n," - With throttled hardware reads to prevent I2C audio dropouts\n        {\n            // THROTTLED HARDWARE READING - Only every 1024 samples (~23ms @ 44.1kHz)\n            // This prevents MCP23017 I2C reads from blocking audio processing\n            // Track total samples to increment counter once per buffer (always incrementing, not just when recording)\n            static uint32_t rec").concat(n,"_totalSampleCounter = 0;\n            rec").concat(n,"_totalSampleCounter++;\n\n            // Increment hardware read counter every 256 samples (once per buffer)\n            if (rec").concat(n,"_totalSampleCounter % 256 == 0) {\n                rec").concat(n,"_hwReadCounter++;\n            }\n\n            if (rec").concat(n,"_hwReadCounter >= rec").concat(n,"_hwReadInterval) {\n                rec").concat(n,'_hwReadCounter = 0;\n\n                // Debug: Print recording state at hardware read\n                static unsigned long lastStateDebug = 0;\n                if (millis() - lastStateDebug > 2000) {\n                    lastStateDebug = millis();\n                    Serial.printf("[REC%d] State: recording=%d, samples=%lu, armed=%d\\n",\n                                 ').concat(n,", rec").concat(n,"_recording, rec").concat(n,"_samplesRecorded, rec").concat(n,"_armedForEdge);\n                }\n\n                // Check if we need to finalize a recording (SD writer finished draining)\n                if (rec").concat(n,"_finalizePending && rec").concat(n,'_buffered == 0) {\n                    Serial.printf("[REC%d] SD writer finished, finalizing file...\\n", ').concat(n,");\n                    // Update WAV header with final size\n                    if (rec").concat(n,"_recFile) {\n                        uint32_t dataSize = rec").concat(n,"_samplesRecorded * 2 * ").concat(i,";\n                        uint32_t fileSize = dataSize + 36;\n                        rec").concat(n,"_recFile.seek(4);\n                        rec").concat(n,"_recFile.write((uint8_t*)&fileSize, 4);\n                        rec").concat(n,"_recFile.seek(40);\n                        rec").concat(n,"_recFile.write((uint8_t*)&dataSize, 4);\n                        rec").concat(n,'_recFile.close();\n                        Serial.printf("[REC%d] WAV header updated, file closed\\n", ').concat(n,");\n                        rec").concat(n,"_fileAvailable = true;  // File ready for playback\n\n                        // Increment file index for next recording (persistent auto-increment)\n                        rec").concat(n,'_currentFileIndex++;\n                        Serial.printf("[REC%d] Next recording will use: rec%03d.wav\\n", ').concat(n,", rec").concat(n,"_currentFileIndex);\n                    }\n                    rec").concat(n,"_finalizePending = false;\n                }\n\n                // Read buttons and pots only when in correct bank\n                if (currentBank == rec").concat(n,"_bank) {\n                    // Use global 'inputs' variable (batch read by updateHardware on Core 0)\n                    // Button mapping: Btn1=GPA2, Btn2=GPA1, Btn3=GPA0, Btn4=GPA3 - active low\n                    rec").concat(n,"_btn1_state = !(inputs & (1 << 2));  // Button 1 (GPA2) - Record\n                    rec").concat(n,"_btn2_state = !(inputs & (1 << 1));  // Button 2 (GPA1) - Play/Pause\n                    rec").concat(n,"_btn3_state = !(inputs & (1 << 0));  // Button 3 (GPA0) - Prev/Rewind\n                    rec").concat(n,"_btn4_state = !(inputs & (1 << 3));  // Button 4 (GPA3) - Next/FFwd\n\n                    float pot1_raw = analogRead(4) / 4095.0f;  // Pot 1 - Input Gain\n                    float pot2_raw = analogRead(5) / 4095.0f;  // Pot 2 - Playback Volume\n                    float pot3_raw = analogRead(6) / 4095.0f;  // Pot 3 - Play Mode (0-3)\n                    float pot4_raw = analogRead(7) / 4095.0f;  // Pot 4 - Play Speed (0.25x-2.0x)\n\n                    rec").concat(n,"_inputGain = pot1_raw * 4.0f;         // 0.0x-4.0x (attenuator: 0 = silent input)\n                    rec").concat(n,"_playbackVol = pot2_raw * 2.0f;       // 0.0x-2.0x\n                    rec").concat(n,"_playMode = (int)(pot3_raw * 3.999f); // 0-3 (normal, loop, reverse, ping-pong)\n\n                    // Speed control with octave detents (0.25x-2.0x)\n                    float rawSpeed = pot4_raw * 1.75f + 0.25f;\n                    // Octave detent zones (+/- 3% around each octave):\n                    // 0.25x (2 oct down) at pot=0%, 0.5x (1 oct down) at pot=14.3%, 1.0x (original) at pot=42.9%, 2.0x (1 oct up) at pot=100%\n                    const float detentWidth = 0.03f;  // 3% deadzone around each octave\n                    if (pot4_raw < 0.0f + detentWidth) {\n                        rec").concat(n,"_playSpeed = 0.25f;  // 2 octaves down detent\n                    } else if (fabs(pot4_raw - 0.143f) < detentWidth) {\n                        rec").concat(n,"_playSpeed = 0.5f;   // 1 octave down detent\n                    } else if (fabs(pot4_raw - 0.429f) < detentWidth) {\n                        rec").concat(n,"_playSpeed = 1.0f;   // Original pitch detent (center)\n                    } else if (pot4_raw > 1.0f - detentWidth) {\n                        rec").concat(n,"_playSpeed = 2.0f;   // 1 octave up detent\n                    } else {\n                        rec").concat(n,"_playSpeed = rawSpeed;  // Smooth interpolation between detents\n                    }\n                }\n\n                // BUTTON 1: Record Toggle with debounce (prevents double-trigger from bounce/timing races)\n                unsigned long nowMs = millis();\n                bool rising = rec").concat(n,"_btn1_state && !rec").concat(n,"_btn1_last;\n\n                if (rising && rec").concat(n,"_armedForEdge && (nowMs - rec").concat(n,"_lastToggleMs > rec").concat(n,"_toggleDebounceMs)) {\n                    rec").concat(n,"_lastToggleMs = nowMs;\n                    rec").concat(n,'_armedForEdge = false;  // Disarm until button released\n\n                    Serial.printf("[REC%d] TOGGLE at %lums (armed=%d, lastToggle=%lums ago, recording=%d)\\n",\n                                 ').concat(n,", nowMs, rec").concat(n,"_armedForEdge, nowMs - rec").concat(n,"_lastToggleMs, rec").concat(n,"_recording);\n\n                    if (!rec").concat(n,"_recording) {\n                        // START RECORDING (block if currently playing)\n                        if (rec").concat(n,'_playing) {\n                            Serial.printf("[REC%d] Cannot record while playing - stop playback first\\n", ').concat(n,');\n                        } else {\n                            Serial.printf("[REC%d] START recording\\n", ').concat(n,");\n\n                        // Remember which file we're recording to (for playback later)\n                        rec").concat(n,"_lastRecordedFileIndex = rec").concat(n,"_currentFileIndex;\n\n                        // Reset counters FIRST (before any file operations)\n                        rec").concat(n,"_samplesRecorded = 0;\n                        rec").concat(n,'_currentBlockPos = 0;\n                        Serial.printf("[REC%d] Counters reset: samples=%lu, blockPos=%d\\n", ').concat(n,", rec").concat(n,"_samplesRecorded, rec").concat(n,'_currentBlockPos);\n\n                        char filename[32];\n                        snprintf(filename, sizeof(filename), "/rec%03d.wav", rec').concat(n,"_currentFileIndex);\n                        // Delete existing file (FILE_WRITE appends, which corrupts WAV files)\n                        if (SD.exists(filename)) {\n                            SD.remove(filename);\n                        }\n                        rec").concat(n,"_recFile = SD.open(filename, FILE_WRITE);\n                        if (rec").concat(n,'_recFile) {\n                            Serial.printf("[REC%d] File opened: %s\\n", ').concat(n,", filename);\n                            // Write WAV header\n                            rec").concat(n,'_recFile.write((const uint8_t*)"RIFF", 4);\n                            uint32_t tempSize = 0;\n                            rec').concat(n,"_recFile.write((uint8_t*)&tempSize, 4);\n                            rec").concat(n,'_recFile.write((const uint8_t*)"WAVE", 4);\n                            rec').concat(n,'_recFile.write((const uint8_t*)"fmt ", 4);\n                            uint32_t fmtSize = 16;\n                            rec').concat(n,"_recFile.write((uint8_t*)&fmtSize, 4);\n                            uint16_t audioFormat = 1;\n                            rec").concat(n,"_recFile.write((uint8_t*)&audioFormat, 2);\n                            uint16_t numChannels = 2;\n                            rec").concat(n,"_recFile.write((uint8_t*)&numChannels, 2);\n                            uint32_t sampleRate = 44100;\n                            rec").concat(n,"_recFile.write((uint8_t*)&sampleRate, 4);\n                            uint32_t byteRate = 44100 * 2 * ").concat(i,";\n                            rec").concat(n,"_recFile.write((uint8_t*)&byteRate, 4);\n                            uint16_t blockAlign = 2 * ").concat(i,";\n                            rec").concat(n,"_recFile.write((uint8_t*)&blockAlign, 2);\n                            uint16_t bitsPerSample = ").concat(c,";\n                            rec").concat(n,"_recFile.write((uint8_t*)&bitsPerSample, 2);\n                            rec").concat(n,'_recFile.write((const uint8_t*)"data", 4);\n                            rec').concat(n,"_recFile.write((uint8_t*)&tempSize, 4);\n                            rec").concat(n,'_recording = true;\n                            Serial.printf("[REC%d] Recording flag set to TRUE\\n", ').concat(n,');\n                        } else {\n                            Serial.printf("[REC%d] ERROR: Failed to open file %s\\n", ').concat(n,', filename);\n                        }\n                        }  // Close "if (!playing)" block\n                    } else {\n                        // STOP RECORDING - Flush final partial block and wait for SD writer\n                        Serial.printf("[REC%d] STOP recording (%lu samples = %.2f seconds)\\n",\n                                     ').concat(n,", rec").concat(n,"_samplesRecorded, rec").concat(n,"_samplesRecorded / 44100.0f);\n\n                        rec").concat(n,"_recording = false;  // Stop accepting new samples\n\n                        // If we have a partial block, push it to ring buffer\n                        if (rec").concat(n,'_currentBlockPos > 0) {\n                            Serial.printf("[REC%d] Flushing partial block: %d bytes\\n", ').concat(n,", rec").concat(n,"_currentBlockPos);\n\n                            // Pad remainder with zeros\n                            memset(&rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos], 0,\n                                   REC").concat(n,"_BLOCK_SIZE - rec").concat(n,"_currentBlockPos);\n\n                            // Check if ring buffer has space (should always have space since we stopped recording)\n                            if (rec").concat(n,"_buffered < REC").concat(n,"_BLOCK_COUNT) {\n                                // Copy block to ring buffer\n                                memcpy(&rec").concat(n,"_ringBuffer[rec").concat(n,"_writeIdx * REC").concat(n,"_BLOCK_SIZE],\n                                       rec").concat(n,"_currentBlock, REC").concat(n,"_BLOCK_SIZE);\n\n                                // Update ring buffer pointers (blocking lock is OK here - we're not in audio loop)\n                                if (xSemaphoreTake(rec").concat(n,"_bufferMutex, portMAX_DELAY)) {\n                                    rec").concat(n,"_writeIdx = (rec").concat(n,"_writeIdx + 1) % REC").concat(n,"_BLOCK_COUNT;\n                                    rec").concat(n,"_buffered++;\n                                    xSemaphoreGive(rec").concat(n,'_bufferMutex);\n                                }\n                            } else {\n                                Serial.printf("[REC%d] ERROR: Ring buffer full during stop! Data loss!\\n", ').concat(n,");\n                            }\n                            rec").concat(n,"_currentBlockPos = 0;\n                        }\n\n                        // Mark for finalization (don't block audio thread!)\n                        rec").concat(n,'_finalizePending = true;\n                        Serial.printf("[REC%d] Recording stopped, waiting for SD writer to finish (%d blocks buffered)\\n",\n                                     ').concat(n,", rec").concat(n,'_buffered);\n                        Serial.printf("[REC%d] Recording flag cleared (manual stop)\\n", ').concat(n,");\n                    }\n                }\n\n                // Re-arm only after clean button release AND debounce period elapsed\n                if (!rec").concat(n,"_btn1_state && rec").concat(n,"_btn1_last && (nowMs - rec").concat(n,"_lastToggleMs > rec").concat(n,"_toggleDebounceMs)) {\n                    rec").concat(n,'_armedForEdge = true;\n                    Serial.printf("[REC%d] RE-ARMED (button released, %lums after last toggle)\\n", ').concat(n,", nowMs - rec").concat(n,"_lastToggleMs);\n                }\n\n                rec").concat(n,"_btn1_last = rec").concat(n,"_btn1_state;\n\n                // BUTTON 2: Play/Pause Toggle\n                if (rec").concat(n,"_btn2_state && !rec").concat(n,'_btn2_last) {\n                    Serial.printf("[REC%d] BUTTON 2 pressed (playing=%d)\\n", ').concat(n,", rec").concat(n,"_playing);\n                    if (!rec").concat(n,"_playing) {\n                        // START STREAMING PLAYBACK - Only if a file has been recorded\n                        if (rec").concat(n,'_lastRecordedFileIndex == 0) {\n                            Serial.printf("[PLAY%d] No file recorded yet\\n", ').concat(n,');\n                        } else {\n                            char filename[32];\n                            snprintf(filename, sizeof(filename), "/rec%03d.wav", rec').concat(n,'_lastRecordedFileIndex);\n                            Serial.printf("[PLAY%d] Starting streaming playback: %s\\n", ').concat(n,", filename);\n\n                        rec").concat(n,"_playFile = SD.open(filename, FILE_READ);\n                        if (rec").concat(n,'_playFile) {\n                            Serial.printf("[PLAY%d] File opened for streaming\\n", ').concat(n,");\n\n                            // Read WAV header\n                            rec").concat(n,"_playFile.seek(22);\n                            uint16_t channels;\n                            rec").concat(n,"_playFile.read((uint8_t*)&channels, 2);\n                            rec").concat(n,"_channels = channels;\n\n                            rec").concat(n,"_playFile.seek(40);\n                            uint32_t dataSize;\n                            rec").concat(n,"_playFile.read((uint8_t*)&dataSize, 4);\n                            rec").concat(n,"_totalSamples = dataSize / (").concat(i," * rec").concat(n,'_channels);\n\n                            Serial.printf("[PLAY%d] Channels: %d, Total samples: %lu (%.2f seconds)\\n",\n                                         ').concat(n,", rec").concat(n,"_channels, rec").concat(n,"_totalSamples,\n                                         rec").concat(n,"_totalSamples / 44100.0f);\n\n                            // Seek to audio data start (byte 44)\n                            rec").concat(n,"_playFile.seek(44);\n\n                            // Reset ring buffer indices and counters\n                            if (xSemaphoreTake(play").concat(n,"_bufferMutex, portMAX_DELAY)) {\n                                play").concat(n,"_writeIdx = 0;\n                                play").concat(n,"_readIdx = 0;\n                                play").concat(n,"_buffered = 0;\n                                play").concat(n,"_eofReached = false;\n                                xSemaphoreGive(play").concat(n,"_bufferMutex);\n                            }\n\n                            play").concat(n,"_currentBlockPos = 0;\n                            play").concat(n,"_currentBlockSize = 0;\n                            rec").concat(n,"_sampleAccumulator = 0.0f;  // Reset speed accumulator\n\n                            // Initialize playback position and direction based on mode\n                            if (rec").concat(n,"_playMode == 2) {\n                                // Reverse mode - start at end, play backwards\n                                rec").concat(n,"_samplesPlayed = rec").concat(n,"_totalSamples - 1;\n                                rec").concat(n,'_playReverse = true;\n                                Serial.printf("[PLAY%d] Starting in REVERSE mode from end\\n", ').concat(n,");\n                            } else {\n                                // Normal/Loop/Ping-pong - start at beginning, play forwards\n                                rec").concat(n,"_samplesPlayed = 0;\n                                rec").concat(n,"_playReverse = false;\n                            }\n\n                            // Initialize output to silence\n                            rec").concat(n,"_outputL = 0.0f;\n                            rec").concat(n,"_outputR = 0.0f;\n\n                            // Start playback (SD reader task will automatically fill ring buffer)\n                            rec").concat(n,"_playing = true;\n                            rec").concat(n,'_paused = false;\n                            Serial.printf("[PLAY%d] Streaming playback started! SD reader task will fill ring buffer.\\n", ').concat(n,');\n                        } else {\n                            Serial.printf("[PLAY%d] ERROR: Failed to open file for playback\\n", ').concat(n,');\n                        }\n                        }  // Close "if (fileAvailable)" block\n                    } else {\n                        // TOGGLE PAUSE\n                        rec').concat(n,"_paused = !rec").concat(n,"_paused;\n                    }\n                }\n                rec").concat(n,"_btn2_last = rec").concat(n,"_btn2_state;\n\n                // BUTTON 3: Previous Track (short press) / Rewind (long press)\n                if (rec").concat(n,"_btn3_state && !rec").concat(n,"_btn3_last) {\n                    // Button just pressed - start timer\n                    rec").concat(n,"_btn3_pressStart = nowMs;\n                    rec").concat(n,"_btn3_longHandled = false;\n                } else if (rec").concat(n,"_btn3_state && (nowMs - rec").concat(n,"_btn3_pressStart > rec").concat(n,"_longPressThreshold) && !rec").concat(n,"_btn3_longHandled) {\n                    // Long press - REWIND (seek backward during playback)\n                    if (rec").concat(n,"_playing && rec").concat(n,"_samplesPlayed > 44100) {  // Skip back 1 second\n                        rec").concat(n,'_samplesPlayed -= 44100;\n                        Serial.printf("[PLAY%d] REWIND: Seek to %.2f seconds\\n", ').concat(n,", rec").concat(n,"_samplesPlayed / 44100.0f);\n                        // Mark as handled to prevent repeat until button released\n                        rec").concat(n,"_btn3_longHandled = true;\n                    }\n                } else if (!rec").concat(n,"_btn3_state && rec").concat(n,"_btn3_last) {\n                    // Button released\n                    if (!rec").concat(n,"_btn3_longHandled && (nowMs - rec").concat(n,"_btn3_pressStart < rec").concat(n,"_longPressThreshold)) {\n                        // Short press - PREVIOUS TRACK\n                        if (rec").concat(n,"_lastRecordedFileIndex > 1) {\n                            rec").concat(n,'_lastRecordedFileIndex--;\n                            Serial.printf("[PLAY%d] Previous track: rec%03d.wav\\n", ').concat(n,", rec").concat(n,"_lastRecordedFileIndex);\n                            // If currently playing, restart with new file\n                            if (rec").concat(n,"_playing) {\n                                rec").concat(n,"_playing = false;\n                                rec").concat(n,"_playFile.close();\n                                // Trigger playback restart (simulate button 2 press)\n                                rec").concat(n,"_btn2_state = true;\n                                rec").concat(n,"_btn2_last = false;\n                            }\n                        }\n                    }\n                }\n                rec").concat(n,"_btn3_last = rec").concat(n,"_btn3_state;\n\n                // BUTTON 4: Next Track (short press) / Fast Forward (long press)\n                if (rec").concat(n,"_btn4_state && !rec").concat(n,"_btn4_last) {\n                    // Button just pressed - start timer\n                    rec").concat(n,"_btn4_pressStart = nowMs;\n                    rec").concat(n,"_btn4_longHandled = false;\n                } else if (rec").concat(n,"_btn4_state && (nowMs - rec").concat(n,"_btn4_pressStart > rec").concat(n,"_longPressThreshold) && !rec").concat(n,"_btn4_longHandled) {\n                    // Long press - FAST FORWARD (seek forward during playback)\n                    if (rec").concat(n,"_playing && rec").concat(n,"_samplesPlayed < rec").concat(n,"_totalSamples - 44100) {  // Skip forward 1 second\n                        rec").concat(n,'_samplesPlayed += 44100;\n                        Serial.printf("[PLAY%d] FAST FORWARD: Seek to %.2f seconds\\n", ').concat(n,", rec").concat(n,"_samplesPlayed / 44100.0f);\n                        // Mark as handled to prevent repeat until button released\n                        rec").concat(n,"_btn4_longHandled = true;\n                    }\n                } else if (!rec").concat(n,"_btn4_state && rec").concat(n,"_btn4_last) {\n                    // Button released\n                    if (!rec").concat(n,"_btn4_longHandled && (nowMs - rec").concat(n,"_btn4_pressStart < rec").concat(n,"_longPressThreshold)) {\n                        // Short press - NEXT TRACK\n                        if (rec").concat(n,"_lastRecordedFileIndex < rec").concat(n,"_currentFileIndex - 1) {\n                            rec").concat(n,'_lastRecordedFileIndex++;\n                            Serial.printf("[PLAY%d] Next track: rec%03d.wav\\n", ').concat(n,", rec").concat(n,"_lastRecordedFileIndex);\n                            // If currently playing, restart with new file\n                            if (rec").concat(n,"_playing) {\n                                rec").concat(n,"_playing = false;\n                                rec").concat(n,"_playFile.close();\n                                // Trigger playback restart (simulate button 2 press)\n                                rec").concat(n,"_btn2_state = true;\n                                rec").concat(n,"_btn2_last = false;\n                            }\n                        }\n                    }\n                }\n                rec").concat(n,"_btn4_last = rec").concat(n,"_btn4_state;\n\n                // LED FEEDBACK (updated every hardware read ~23ms, NOT per-sample for performance)\n                // LED1 (Record): Solid red when recording, OFF otherwise\n                // LED2 (Play): Solid green when playing, pulsing green when file ready, OFF otherwise\n                if (rec").concat(n,"_recording || rec").concat(n,"_finalizePending) {\n                    rec").concat(n,"_led1 = 1.0f;  // Solid red while recording or finalizing\n                    rec").concat(n,"_led2 = 0.0f;  // Play LED off while recording\n                } else if (rec").concat(n,"_playing) {\n                    rec").concat(n,"_led1 = 0.0f;  // Record LED off while playing\n                    if (rec").concat(n,"_paused) {\n                        rec").concat(n,"_led2 = (sin(millis() / 300.0f) + 1.0f) * 0.5f;  // Pulsing green while paused\n                    } else {\n                        rec").concat(n,"_led2 = 1.0f;  // Solid green while playing\n                    }\n                } else {\n                    // Idle state - pulsing red when armed for recording, pulsing green if file ready for playback\n                    rec").concat(n,"_led1 = (millis() % 1000 < 500) ? 1.0f : 0.0f;  // Pulsing red (armed for recording)\n                    if (rec").concat(n,"_lastRecordedFileIndex > 0) {\n                        rec").concat(n,"_led2 = (sin(millis() / 500.0f) + 1.0f) * 0.5f;  // Pulsing green (file ready)\n                    } else {\n                        rec").concat(n,"_led2 = 0.0f;  // Off if no file\n                    }\n                }\n            }\n\n            // GET INPUT AUDIO (every sample)\n            float inL = ").concat(u,";\n            float inR = ").concat(d,";\n            inL *= rec").concat(n,"_inputGain;\n            inR *= rec").concat(n,"_inputGain;\n\n            // RECORDING PROCESS - Write to ring buffer (async SD writes, glitch-free!)\n            if (rec").concat(n,"_recording) {\n                // Write sample to current block (audio thread local, no locks needed)\n                int32_t sampleL = (int32_t)(constrain(inL, -1.0f, 1.0f) * 8388607.0f);\n                int32_t sampleR = (int32_t)(constrain(inR, -1.0f, 1.0f) * 8388607.0f);\n                rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos++] = sampleL & 0xFF;\n                rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos++] = (sampleL >> 8) & 0xFF;\n                rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos++] = (sampleL >> 16) & 0xFF;\n                rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos++] = sampleR & 0xFF;\n                rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos++] = (sampleR >> 8) & 0xFF;\n                rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos++] = (sampleR >> 16) & 0xFF;\n                rec").concat(n,"_samplesRecorded++;\n\n                // When current block is full, push to ring buffer for SD writer task\n                if (rec").concat(n,"_currentBlockPos >= REC").concat(n,"_BLOCK_SIZE) {\n                    // Check if ring buffer has space\n                    if (rec").concat(n,"_buffered < REC").concat(n,"_BLOCK_COUNT) {\n                        // Copy block to ring buffer\n                        memcpy(&rec").concat(n,"_ringBuffer[rec").concat(n,"_writeIdx * REC").concat(n,"_BLOCK_SIZE],\n                               rec").concat(n,"_currentBlock,\n                               REC").concat(n,"_BLOCK_SIZE);\n\n                        // Update ring buffer pointers (thread-safe)\n                        if (xSemaphoreTake(rec").concat(n,"_bufferMutex, 0)) {  // Try-lock (don't block audio!)\n                            rec").concat(n,"_writeIdx = (rec").concat(n,"_writeIdx + 1) % REC").concat(n,"_BLOCK_COUNT;\n                            rec").concat(n,"_buffered++;\n                            xSemaphoreGive(rec").concat(n,'_bufferMutex);\n                        } else {\n                            // Couldn\'t get mutex - skip this block (rare, but prevents audio glitches)\n                            Serial.printf("[REC%d] Mutex busy, skipping block\\n", ').concat(n,');\n                        }\n                    } else {\n                        // Ring buffer full! SD writer task can\'t keep up\n                        Serial.printf("[REC%d] Ring buffer full! Dropping block (SD too slow)\\n", ').concat(n,");\n                    }\n\n                    // Reset current block\n                    rec").concat(n,"_currentBlockPos = 0;\n                }\n\n                // Auto-stop at max duration (").concat(r," samples = ").concat(o," seconds)\n                if (rec").concat(n,"_samplesRecorded >= ").concat(r,') {\n                    Serial.printf("[REC%d] Auto-stop at %lu samples (%.2f seconds)\\n",\n                                 ').concat(n,", rec").concat(n,"_samplesRecorded, rec").concat(n,"_samplesRecorded / 44100.0f);\n\n                    rec").concat(n,"_recording = false;  // Stop accepting new samples\n\n                    // Flush partial block to ring buffer (same as manual stop)\n                    if (rec").concat(n,"_currentBlockPos > 0) {\n                        memset(&rec").concat(n,"_currentBlock[rec").concat(n,"_currentBlockPos], 0,\n                               REC").concat(n,"_BLOCK_SIZE - rec").concat(n,"_currentBlockPos);\n\n                        if (rec").concat(n,"_buffered < REC").concat(n,"_BLOCK_COUNT) {\n                            memcpy(&rec").concat(n,"_ringBuffer[rec").concat(n,"_writeIdx * REC").concat(n,"_BLOCK_SIZE],\n                                   rec").concat(n,"_currentBlock, REC").concat(n,"_BLOCK_SIZE);\n\n                            if (xSemaphoreTake(rec").concat(n,"_bufferMutex, portMAX_DELAY)) {\n                                rec").concat(n,"_writeIdx = (rec").concat(n,"_writeIdx + 1) % REC").concat(n,"_BLOCK_COUNT;\n                                rec").concat(n,"_buffered++;\n                                xSemaphoreGive(rec").concat(n,"_bufferMutex);\n                            }\n                        }\n                        rec").concat(n,"_currentBlockPos = 0;\n                    }\n\n                    // Wait for SD writer to finish (with timeout)\n                    uint32_t waitStart = millis();\n                    while (rec").concat(n,"_buffered > 0 && (millis() - waitStart < 5000)) {\n                        delay(10);\n                    }\n\n                    // Update WAV header and close file\n                    if (rec").concat(n,"_recFile) {\n                        uint32_t dataSize = rec").concat(n,"_samplesRecorded * 2 * ").concat(i,";\n                        uint32_t fileSize = dataSize + 36;\n                        rec").concat(n,"_recFile.seek(4);\n                        rec").concat(n,"_recFile.write((uint8_t*)&fileSize, 4);\n                        rec").concat(n,"_recFile.seek(40);\n                        rec").concat(n,"_recFile.write((uint8_t*)&dataSize, 4);\n                        rec").concat(n,'_recFile.close();\n                    }\n\n                    Serial.printf("[REC%d] Recording flag cleared (auto-stop)\\n", ').concat(n,");\n                }\n            }\n\n            // PLAYBACK PROCESS - Read from ring buffer (streaming playback, glitch-free!)\n            if (rec").concat(n,"_playing && !rec").concat(n,"_paused) {\n                // Check if current block needs refill\n                if (play").concat(n,"_currentBlockPos >= play").concat(n,"_currentBlockSize) {\n                    // Try to get next block from ring buffer\n                    if (play").concat(n,"_buffered > 0) {\n                        // Get next block from ring\n                        if (xSemaphoreTake(play").concat(n,"_bufferMutex, 0)) {  // Try-lock (don't block audio!)\n                            size_t idx = play").concat(n,"_readIdx;\n\n                            // Calculate how many bytes we actually need (handle last partial block)\n                            uint32_t samplesRemaining = rec").concat(n,"_totalSamples - rec").concat(n,"_samplesPlayed;\n                            uint32_t bytesRemaining = samplesRemaining * 6;  // 6 bytes per stereo sample\n                            size_t blockSize = (bytesRemaining >= PLAY").concat(n,"_BLOCK_SIZE) ? PLAY").concat(n,"_BLOCK_SIZE : bytesRemaining;\n\n                            // Copy block from ring buffer (only copy what we need)\n                            memcpy(play").concat(n,"_currentBlock,\n                                   &play").concat(n,"_ringBuffer[idx * PLAY").concat(n,"_BLOCK_SIZE],\n                                   blockSize);\n                            play").concat(n,"_readIdx = (play").concat(n,"_readIdx + 1) % PLAY").concat(n,"_BLOCK_COUNT;\n                            play").concat(n,"_buffered--;\n                            xSemaphoreGive(play").concat(n,"_bufferMutex);\n\n                            play").concat(n,"_currentBlockPos = 0;\n                            play").concat(n,"_currentBlockSize = blockSize;  // Use calculated size (handles last partial block)\n                        } else {\n                            // Couldn't get mutex - keep previous output (sample-and-hold, prevents clicks)\n                        }\n                    } else if (play").concat(n,"_eofReached) {\n                        // Ring buffer empty and EOF reached - playback finished\n                        rec").concat(n,"_playing = false;\n                        rec").concat(n,"_playFile.close();\n                        rec").concat(n,'_samplesPlayed = 0;\n                        Serial.printf("[PLAY%d] Playback finished\\n", ').concat(n,");\n                        rec").concat(n,"_outputL = inL;\n                        rec").concat(n,"_outputR = inR;\n                    } else {\n                        // Ring buffer temporarily empty (SD reader still filling) - keep previous output\n                        // (No serial output here - Serial.print is SLOW and causes glitches!)\n                    }\n                }\n\n                // Variable speed playback using fractional sample accumulator\n                rec").concat(n,"_sampleAccumulator += rec").concat(n,"_playSpeed;\n\n                // Read sample from current block when accumulator >= 1.0\n                bool canReadSample = play").concat(n,"_currentBlockPos < play").concat(n,"_currentBlockSize &&\n                                     ((!rec").concat(n,"_playReverse && rec").concat(n,"_samplesPlayed < rec").concat(n,"_totalSamples) ||\n                                      (rec").concat(n,"_playReverse && rec").concat(n,"_samplesPlayed > 0));\n\n                while (rec").concat(n,"_sampleAccumulator >= 1.0f && canReadSample) {\n                    // Read 24-bit stereo sample (6 bytes total)\n                    uint8_t* pos = &play").concat(n,"_currentBlock[play").concat(n,"_currentBlockPos];\n                    int32_t sampleL = (int32_t)(pos[0] | (pos[1] << 8) | (pos[2] << 16));\n                    int32_t sampleR = (int32_t)(pos[3] | (pos[4] << 8) | (pos[5] << 16));\n\n                    // Sign extend 24-bit to 32-bit\n                    if (sampleL & 0x800000) sampleL |= 0xFF000000;\n                    if (sampleR & 0x800000) sampleR |= 0xFF000000;\n\n                    // Convert to float (-1.0 to 1.0), apply playback volume, and mix with live input (scaled by inputGain)\n                    rec").concat(n,"_outputL = (sampleL / 8388607.0f) * rec").concat(n,"_playbackVol + inL * rec").concat(n,"_inputGain;\n                    rec").concat(n,"_outputR = (sampleR / 8388607.0f) * rec").concat(n,"_playbackVol + inR * rec").concat(n,"_inputGain;\n\n                    play").concat(n,"_currentBlockPos += 6;  // Advance by 6 bytes (24-bit stereo)\n\n                    // Increment or decrement sample position based on direction\n                    if (rec").concat(n,"_playReverse) {\n                        rec").concat(n,"_samplesPlayed--;\n                    } else {\n                        rec").concat(n,"_samplesPlayed++;\n                    }\n                    rec").concat(n,"_sampleAccumulator -= 1.0f;  // Consume one sample from accumulator\n\n                    // Update canReadSample for next iteration\n                    canReadSample = play").concat(n,"_currentBlockPos < play").concat(n,"_currentBlockSize &&\n                                    ((!rec").concat(n,"_playReverse && rec").concat(n,"_samplesPlayed < rec").concat(n,"_totalSamples) ||\n                                     (rec").concat(n,"_playReverse && rec").concat(n,"_samplesPlayed > 0));\n                }\n\n                // Check for end of file (or start if playing reverse)\n                bool hitEnd = (!rec").concat(n,"_playReverse && rec").concat(n,"_samplesPlayed >= rec").concat(n,"_totalSamples) ||\n                              (rec").concat(n,"_playReverse && rec").concat(n,"_samplesPlayed == 0);\n\n                if (hitEnd) {\n                    // Play mode handling\n                    if (rec").concat(n,"_playMode == 1) {\n                        // LOOP MODE - Restart from beginning\n                        rec").concat(n,"_samplesPlayed = 0;\n                        rec").concat(n,"_sampleAccumulator = 0.0f;\n                        rec").concat(n,"_playReverse = false;  // Always loop forward\n                        play").concat(n,"_currentBlockPos = 0;\n                        play").concat(n,"_currentBlockSize = 0;\n                        // Reset ring buffer and SD reader (restart streaming from beginning)\n                        if (xSemaphoreTake(play").concat(n,"_bufferMutex, 0)) {\n                            play").concat(n,"_writeIdx = 0;\n                            play").concat(n,"_readIdx = 0;\n                            play").concat(n,"_buffered = 0;\n                            play").concat(n,"_eofReached = false;\n                            xSemaphoreGive(play").concat(n,"_bufferMutex);\n                        }\n                        rec").concat(n,'_playFile.seek(44);  // Seek back to audio data start\n                        Serial.printf("[PLAY%d] Loop mode: Restarting from beginning\\n", ').concat(n,");\n                    } else if (rec").concat(n,"_playMode == 2) {\n                        // REVERSE MODE - Loop backwards\n                        rec").concat(n,"_samplesPlayed = rec").concat(n,"_totalSamples - 1;\n                        rec").concat(n,"_sampleAccumulator = 0.0f;\n                        rec").concat(n,"_playReverse = true;  // Keep playing reverse\n                        play").concat(n,"_currentBlockPos = 0;\n                        play").concat(n,'_currentBlockSize = 0;\n                        Serial.printf("[PLAY%d] Reverse mode: Looping to end\\n", ').concat(n,");\n                    } else if (rec").concat(n,"_playMode == 3) {\n                        // PING-PONG MODE - Reverse direction\n                        rec").concat(n,"_playReverse = !rec").concat(n,"_playReverse;\n                        rec").concat(n,"_sampleAccumulator = 0.0f;\n                        if (rec").concat(n,"_playReverse) {\n                            rec").concat(n,"_samplesPlayed = rec").concat(n,'_totalSamples - 1;\n                            Serial.printf("[PLAY%d] Ping-pong mode: Now playing backwards\\n", ').concat(n,");\n                        } else {\n                            rec").concat(n,'_samplesPlayed = 0;\n                            Serial.printf("[PLAY%d] Ping-pong mode: Now playing forwards\\n", ').concat(n,");\n                        }\n                        play").concat(n,"_currentBlockPos = 0;\n                        play").concat(n,"_currentBlockSize = 0;\n                        // Reset ring buffer\n                        if (xSemaphoreTake(play").concat(n,"_bufferMutex, 0)) {\n                            play").concat(n,"_writeIdx = 0;\n                            play").concat(n,"_readIdx = 0;\n                            play").concat(n,"_buffered = 0;\n                            play").concat(n,"_eofReached = false;\n                            xSemaphoreGive(play").concat(n,"_bufferMutex);\n                        }\n                        rec").concat(n,"_playFile.seek(44 + (rec").concat(n,"_samplesPlayed * 6));\n                    } else {\n                        // NORMAL MODE - Stop playback\n                        rec").concat(n,"_playing = false;\n                        rec").concat(n,"_playFile.close();\n                        rec").concat(n,"_samplesPlayed = 0;\n                        rec").concat(n,"_sampleAccumulator = 0.0f;\n                        rec").concat(n,'_playReverse = false;\n                        Serial.printf("[PLAY%d] Playback finished\\n", ').concat(n,");\n                        rec").concat(n,"_outputL = inL;\n                        rec").concat(n,"_outputR = inR;\n                    }\n                }\n                // Note: If no new sample read, output keeps previous value (sample-and-hold for slow speeds)\n            } else {\n                // PASS-THROUGH MODE (not playing or paused)\n                rec").concat(n,"_outputL = inL;\n                rec").concat(n,"_outputR = inR;\n            }\n        }\n")}},{key:"generateDelayCode",value:function(e,n,t){var a=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&("inL"===a||"in"===a)}),o=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"inR"===a}),r=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"time"===a}),c=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"feedback"===a}),i=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"mix"===a}),l=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"tempo_hz"===a}),s=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"freeze"===a}),u=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"pingpong"===a}),d=t.find(function(n){var t,a;if(n.to&&"string"==typeof n.to)t=n.to,a=n.toPort;else{if(!n.to||!n.to.id)return!1;t=n.to.id.split(":")[0],a=n.to.port||n.to.id.split(":")[1]}return t===e.id&&"pitch_shift"===a}),p="delay".concat(n,"_time_ms"),f="delay".concat(n,"_feedback"),m="delay".concat(n,"_mix"),_="delay".concat(n,"_pingpong"),g="delay".concat(n,"_freeze"),h="delay".concat(n,"_pitch_shift"),v="delay".concat(n,"_division"),b="delay".concat(n,"_tempo_hz");if(a){var y;a.from&&"string"==typeof a.from?y=a.from:a.from&&a.from.id&&(y=a.from.id.split(":")[0]);var k=this.connectionResolver.modules.find(function(e){return e.id===y});if(k){var S,x=(null===(S=y.match(/\d+$/))||void 0===S?void 0:S[0])||"1";switch(k.type){case"VCA":"vca".concat(x,"_outputL");break;case"Oscillator":"osc".concat(x,"_outputL");break;case"Filter":"filter".concat(x,"_outputL");break;case"Noise":case"NoiseGenerator":"noise".concat(x,"_output");break;case"CleanReverb":"cleanreverb".concat(x,"_outputL");break;case"StereoMixer4":"stereoMixer4_".concat(x,"_outputL")}}}if(o){var E;o.from&&"string"==typeof o.from?E=o.from:o.from&&o.from.id&&(E=o.from.id.split(":")[0]);var P=this.connectionResolver.modules.find(function(e){return e.id===E});if(P){var w,C=(null===(w=E.match(/\d+$/))||void 0===w?void 0:w[0])||"1";switch(P.type){case"VCA":"vca".concat(C,"_outputR");break;case"Oscillator":"osc".concat(C,"_outputR");break;case"Filter":"filter".concat(C,"_outputR");break;case"Noise":case"NoiseGenerator":"noise".concat(C,"_output");break;case"CleanReverb":"cleanreverb".concat(C,"_outputR");break;case"StereoMixer4":"stereoMixer4_".concat(C,"_outputR")}}}if(r){var R;r.from&&"string"==typeof r.from?R=r.from:r.from&&r.from.id&&(R=r.from.id.split(":")[0]);var L=this.connectionResolver.modules.find(function(e){return e.id===R});if(L){var I,M=(null===(I=R.match(/\d+$/))||void 0===I?void 0:I[0])||"1";if("Pot"===L.type){var D=L.params.index||M;p="(pot".concat(D,"_value * 1000.0)")}}}if(c){var A;c.from&&"string"==typeof c.from?A=c.from:c.from&&c.from.id&&(A=c.from.id.split(":")[0]);var O=this.connectionResolver.modules.find(function(e){return e.id===A});if(O){var T,B=(null===(T=A.match(/\d+$/))||void 0===T?void 0:T[0])||"1";if("Pot"===O.type){var z=O.params.index||B;f="pot".concat(z,"_value")}}}if(i){var F;i.from&&"string"==typeof i.from?F=i.from:i.from&&i.from.id&&(F=i.from.id.split(":")[0]);var N=this.connectionResolver.modules.find(function(e){return e.id===F});if(N){var G,q=(null===(G=F.match(/\d+$/))||void 0===G?void 0:G[0])||"1";if("Pot"===N.type){var U=N.params.index||q;m="pot".concat(U,"_value")}}}if(l){var W;l.from&&"string"==typeof l.from?W=l.from:l.from&&l.from.id&&(W=l.from.id.split(":")[0]);var V=this.connectionResolver.modules.find(function(e){return e.id===W});if(V){var H,j=(null===(H=W.match(/\d+$/))||void 0===H?void 0:H[0])||"1";switch(V.type){case"GateGen":case"Gate Generator":b="gate".concat(j,"_rate");break;case"Clock":b="clock".concat(j,"_tempo_hz")}}}if(s){var K;s.from&&"string"==typeof s.from?K=s.from:s.from&&s.from.id&&(K=s.from.id.split(":")[0]);var $=this.connectionResolver.modules.find(function(e){return e.id===K});if($){var Y,X,Z=(null===(Y=K.match(/\d+$/))||void 0===Y?void 0:Y[0])||"1",Q=(null===(X=$.params)||void 0===X?void 0:X.index)||Z;switch($.type){case"LEDButton":g="btn".concat(Q,"_pressed ? 1.0 : 0.0");break;case"Pot":g="pot".concat(Q,"_value");break;case"ADSR":g="adsr".concat(Z,"_output");break;case"LFO":g="lfo".concat(Z,"_output")}}}if(u){var J;u.from&&"string"==typeof u.from?J=u.from:u.from&&u.from.id&&(J=u.from.id.split(":")[0]);var ee=this.connectionResolver.modules.find(function(e){return e.id===J});if(ee){var ne,te,ae=(null===(ne=J.match(/\d+$/))||void 0===ne?void 0:ne[0])||"1",oe=(null===(te=ee.params)||void 0===te?void 0:te.index)||ae;switch(ee.type){case"Pot":_="pot".concat(oe,"_value");break;case"LFO":_="lfo".concat(ae,"_output")}}}if(d){var re;d.from&&"string"==typeof d.from?re=d.from:d.from&&d.from.id&&(re=d.from.id.split(":")[0]);var ce=this.connectionResolver.modules.find(function(e){return e.id===re});if(ce){var ie,le,se=(null===(ie=re.match(/\d+$/))||void 0===ie?void 0:ie[0])||"1",ue=(null===(le=ce.params)||void 0===le?void 0:le.index)||se;switch(ce.type){case"Pot":h="(0.25 + pot".concat(ue,"_value * 3.75)");break;case"LFO":h="(0.25 + lfo".concat(se,"_output * 3.75)")}}}return"\n        // Delay ".concat(n," processing - Professional Feedback Delay with Ping-Pong, Freeze & Pitch Shift\n        {\n            float time_ms = ").concat(p,";\n            float tempo_hz = ").concat(b,";\n            float division = ").concat(v,";\n            float feedback = ").concat(f,";\n            float mix = ").concat(m,";\n            float pingpong = constrain(").concat(_,", 0.0, 1.0);\n            float freeze = ").concat(g,";\n            float pitch_shift = constrain(").concat(h,", 0.25, 4.0);\n            float inputL = delay").concat(n,"_inputL;\n            float inputR = delay").concat(n,"_inputR;\n\n            // Tempo sync: if tempo_hz is connected, calculate time from tempo and division\n            if (tempo_hz > 0.01) {\n                time_ms = (1000.0 / tempo_hz) * division;\n            }\n\n            float delayTime = constrain(time_ms, 1.0, 2000.0); // 1ms to 2000ms\n            mix = constrain(mix, 0.0, 1.0);\n\n            // Freeze mode: mute input and set infinite feedback\n            if (freeze > 0.5) {\n                inputL = 0.0; // Mute input\n                inputR = 0.0;\n                feedback = 0.99; // Infinite feedback (freeze buffer)\n            } else {\n                feedback = constrain(feedback, 0.0, 0.95); // Prevent runaway feedback (normal mode)\n            }\n\n            // Calculate delay samples from time in milliseconds\n            float delaySamplesFloat = delayTime * 44.1; // Samples at 44.1kHz\n            int delaySamplesInt = (int)delaySamplesFloat;\n            delaySamplesInt = constrain(delaySamplesInt, 1, DELAY").concat(n,"_BUFFER_SIZE - 1);\n\n            // Pitch shift: variable read speed (only when pitch_shift != 1.0)\n            float readPosFloatL, readPosFloatR;\n            if (pitch_shift != 1.0) {\n                // Update read position with pitch ratio\n                delay").concat(n,"_readPosFloat += pitch_shift;\n                if (delay").concat(n,"_readPosFloat >= DELAY").concat(n,"_BUFFER_SIZE) {\n                    delay").concat(n,"_readPosFloat -= DELAY").concat(n,"_BUFFER_SIZE;\n                }\n                readPosFloatL = delay").concat(n,"_readPosFloat;\n                readPosFloatR = delay").concat(n,"_readPosFloat;\n            } else {\n                // Normal mode: read from delay time\n                readPosFloatL = (float)((delay").concat(n,"_writePos - delaySamplesInt + DELAY").concat(n,"_BUFFER_SIZE) % DELAY").concat(n,"_BUFFER_SIZE);\n                readPosFloatR = readPosFloatL;\n            }\n\n            // Linear interpolation for smooth pitch shifting\n            int readPosL_int = (int)readPosFloatL;\n            int readPosL_next = (readPosL_int + 1) % DELAY").concat(n,"_BUFFER_SIZE;\n            float fracL = readPosFloatL - (float)readPosL_int;\n            float delayedL = delay").concat(n,"_bufferL[readPosL_int] * (1.0 - fracL) + delay").concat(n,"_bufferL[readPosL_next] * fracL;\n\n            int readPosR_int = (int)readPosFloatR;\n            int readPosR_next = (readPosR_int + 1) % DELAY").concat(n,"_BUFFER_SIZE;\n            float fracR = readPosFloatR - (float)readPosR_int;\n            float delayedR = delay").concat(n,"_bufferR[readPosR_int] * (1.0 - fracR) + delay").concat(n,"_bufferR[readPosR_next] * fracR;\n\n            // Apply feedback damping filter to prevent harsh feedback\n            delay").concat(n,"_feedback_lpf_L = delay").concat(n,"_feedback_lpf_L * 0.7 + delayedL * 0.3;\n            delay").concat(n,"_feedback_lpf_R = delay").concat(n,"_feedback_lpf_R * 0.7 + delayedR * 0.3;\n\n            // Ping-pong mode: swap L/R feedback\n            float feedbackL_source = delay").concat(n,"_feedback_lpf_L * (1.0 - pingpong) + delay").concat(n,"_feedback_lpf_R * pingpong;\n            float feedbackR_source = delay").concat(n,"_feedback_lpf_R * (1.0 - pingpong) + delay").concat(n,"_feedback_lpf_L * pingpong;\n\n            // Write new samples with feedback\n            delay").concat(n,"_bufferL[delay").concat(n,"_writePos] = inputL + feedbackL_source * feedback;\n            delay").concat(n,"_bufferR[delay").concat(n,"_writePos] = inputR + feedbackR_source * feedback;\n\n            // Advance write position\n            delay").concat(n,"_writePos = (delay").concat(n,"_writePos + 1) % DELAY").concat(n,"_BUFFER_SIZE;\n\n            // Output with dry/wet mix\n            delay").concat(n,"_outputL = inputL * (1.0 - mix) + delayedL * mix;\n            delay").concat(n,"_outputR = inputR * (1.0 - mix) + delayedR * mix;\n\n            // Denormal protection (prevent CPU performance issues and artifacts)\n            if (fabsf(delay").concat(n,"_outputL) < 1e-12f) delay").concat(n,"_outputL = 0.0f;\n            if (fabsf(delay").concat(n,"_outputR) < 1e-12f) delay").concat(n,"_outputR = 0.0f;\n        }\n")}},{key:"generateWavetableVariables",value:function(e,n,t){for(var a=e.params.wavetables||[],o=512,r="",c=0;c<4;c++){var i=a[c];if(i&&i.length>0)r+="\n// Wavetable ".concat(c," data (").concat(i.length," samples)\nfloat wt").concat(n,"_table").concat(c,"[").concat(o,"] = {\n    ").concat(Array.from(i).map(function(e,n){var t=e.toFixed(6)+"f";return n%8==0&&n>0?"\n    "+t:t}).join(", "),"\n};");else{var l=void 0,s=void 0;switch(c){case 0:l=Array.from({length:o},function(e,n){return Math.sin(n/o*2*Math.PI)}),s="sine wave - default";break;case 1:l=Array.from({length:o},function(e,n){return n/o*2-1}),s="sawtooth wave - default";break;case 2:l=Array.from({length:o},function(e,n){return n<256?1:-1}),s="square wave - default";break;case 3:l=Array.from({length:o},function(e,n){var t=n/o;return t<.5?4*t-1:3-4*t}),s="triangle wave - default"}r+="\n// Wavetable ".concat(c," data (").concat(s,")\nfloat wt").concat(n,"_table").concat(c,"[").concat(o,"] = {\n    ").concat(l.map(function(e,n){var t=e.toFixed(6)+"f";return n%8==0&&n>0?"\n    "+t:t}).join(", "),"\n};")}}return"\n// ".concat(t.label," ").concat(n,"\n").concat(r,"\n\n// Wavetable oscillator variables\n#define WT").concat(n,"_TABLE_SIZE ").concat(o,"\nfloat wt").concat(n,"_phase = 0.0;\nfloat wt").concat(n,"_freq = ").concat(e.params.freq||440,";\nfloat wt").concat(n,"_gain = ").concat(e.params.gain||.25,";\nfloat wt").concat(n,"_gate = ").concat(e.params.gate||1,";\nfloat wt").concat(n,"_morph = ").concat(e.params.morph||0,";\nint wt").concat(n,"_current_table = ").concat(e.params.current_table||0,";\nfloat wt").concat(n,"_pitch_amount = ").concat(e.params.pitch_range||24,";\nfloat wt").concat(n,"_fm_amount = ").concat(e.params.fm_amount||0,";\nfloat wt").concat(n,"_fm_ratio = ").concat(e.params.fm_ratio||1,";\nfloat wt").concat(n,"_fm_ratio_cv = 0.0; // CV control for FM ratio (0-1)\nfloat wt").concat(n,"_pitch_smooth = 0.5;\nfloat wt").concat(n,"_outputL = 0.0;\nfloat wt").concat(n,"_outputR = 0.0;\n")}},{key:"generateSamplePlayerProcessingCode",value:function(e,n,t){return this.generateSamplePlayerCode(e,n,t)}},{key:"generateGranularDenseProcessingCode",value:function(e,n,t){var a=this,o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inL"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"inR"===n.to.port}),c="0.0",i="0.0";if(o){var l=o.from.id.split(":")[0],s=this.connectionResolver.modules.find(function(e){return e.id===l});if(s){var u,d=(null===(u=l.match(/\d+$/))||void 0===u?void 0:u[0])||"1";c="".concat(s.type.toLowerCase()).concat(d,"_outputL"),"Oscillator"===s.type&&(c="osc".concat(d,"_outputL"))}}if(r){var p=r.from.id.split(":")[0],f=this.connectionResolver.modules.find(function(e){return e.id===p});if(f){var m,_=(null===(m=p.match(/\d+$/))||void 0===m?void 0:m[0])||"1";i="".concat(f.type.toLowerCase()).concat(_,"_outputR"),"Oscillator"===f.type&&(i="osc".concat(_,"_outputR"))}}var g=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"grain_density"===n.to.port}),h=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"position"===n.to.port}),v=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch"===n.to.port}),b=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"dry_wet"===n.to.port}),y=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"freeze"===n.to.port}),k=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"stereo_width"===n.to.port}),S=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"cloud_pan"===n.to.port}),x=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch_cv_1"===n.to.port}),E=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch_cv_2"===n.to.port}),P=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch_cv_3"===n.to.port}),w=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch_cv_4"===n.to.port}),C="\n        // GranularDense ".concat(n," - Dense granular synthesis with 20 grains (round-robin: 10 grains/sample, ~76% CPU at max density)\n        granular").concat(n,"_inputL = ").concat(c,";\n        granular").concat(n,"_inputR = ").concat(i,";");if(g||(C+="\n        granular".concat(n,"_currentDensity = granular").concat(n,"_grain_density;")),h||(C+="\n        granular".concat(n,"_currentPosition = granular").concat(n,"_position;")),v||(C+="\n        granular".concat(n,"_currentPitch = granular").concat(n,"_pitch;")),b||(C+="\n        granular".concat(n,"_currentDryWet = granular").concat(n,"_dry_wet;")),y||(C+="\n        granular".concat(n,"_currentFreeze = granular").concat(n,"_freeze;")),C+="\n",g){var R=g.from.id.split(":")[0],L=this.connectionResolver.modules.find(function(e){return e.id===R});if("Pot"===(null==L?void 0:L.type)){var I=L.params.index||1;C+=this.generateBankAwareAssignment(L,"granular".concat(n,"_currentDensity = pot").concat(I,"_value * 20.0; // 0-20 grains/sec (round-robin processing)"))}}if(h){var M=h.from.id.split(":")[0],D=this.connectionResolver.modules.find(function(e){return e.id===M});if("Pot"===(null==D?void 0:D.type)){var A=D.params.index||1;C+=this.generateBankAwareAssignment(D,"granular".concat(n,"_currentPosition = pot").concat(A,"_value; // 0-1 position"))}}if(v){var O=v.from.id.split(":")[0],T=this.connectionResolver.modules.find(function(e){return e.id===O});if("Pot"===(null==T?void 0:T.type)){var B=T.params.index||1;C+=this.generateBankAwareAssignment(T,"granular".concat(n,"_currentPitch = (pot").concat(B,"_value - 0.5) * 24.0; // -12 to +12 semitones (1 octave)"))}}if(b){var z=b.from.id.split(":")[0],F=this.connectionResolver.modules.find(function(e){return e.id===z});if("Pot"===(null==F?void 0:F.type)){var N=F.params.index||1;C+=this.generateBankAwareAssignment(F,"granular".concat(n,"_currentDryWet = pot").concat(N,"_value; // 0-1 dry/wet"))}}if(y){var G=y.from.id.split(":")[0],q=this.connectionResolver.modules.find(function(e){return e.id===G});if("LEDButton"===(null==q?void 0:q.type)){var U,W=(null===(U=G.match(/\d+$/))||void 0===U?void 0:U[0])||"1";C+="        granular".concat(n,"_currentFreeze = btn").concat(W,"_output; // Button freeze control\n")}}if(k){var V=k.from.id.split(":")[0],H=this.connectionResolver.modules.find(function(e){return e.id===V});if("Pot"===(null==H?void 0:H.type)){var j=H.params.index||1;C+=this.generateBankAwareAssignment(H,"granular".concat(n,"_currentStereoWidth = pot").concat(j,"_value; // 0-1 stereo width"))}}if(S){var K=S.from.id.split(":")[0],$=this.connectionResolver.modules.find(function(e){return e.id===K});if("Pot"===(null==$?void 0:$.type)){var Y=$.params.index||1;C+=this.generateBankAwareAssignment($,"granular".concat(n,"_currentCloudPan = 0.1 + (pot").concat(Y,"_value * 0.8); // 0.1-0.9 cloud pan (10% margin)"))}}var X=function(e,t){if(!e)return"";var o="",r=e.from.id.split(":")[0],c=a.connectionResolver.modules.find(function(e){return e.id===r});if("Pot"===(null==c?void 0:c.type)){var i=c.params.index||1;o+=a.generateBankAwareAssignment(c,"granular".concat(n,"_currentPitchCV").concat(t," = (pot").concat(i,"_value - 0.5) * 24.0; // -12 to +12 semitones CV").concat(t))}else if("ADSR"===(null==c?void 0:c.type)){var l,s=(null===(l=r.match(/\d+$/))||void 0===l?void 0:l[0])||"1";o+="        granular".concat(n,"_currentPitchCV").concat(t," = (adsr").concat(s,"_output - 0.5) * 24.0; // CV").concat(t," from ADSR\n")}else if("LFO"===(null==c?void 0:c.type)){var u,d=(null===(u=r.match(/\d+$/))||void 0===u?void 0:u[0])||"1";o+="        granular".concat(n,"_currentPitchCV").concat(t," = lfo").concat(d,"_output * 12.0; // CV").concat(t," from LFO\n")}else if("HarmonicSequencer"===(null==c?void 0:c.type)){var p,f,m=(null===(p=r.match(/\d+$/))||void 0===p?void 0:p[0])||"1",_=(null===(f=e.from.port.match(/v(\d+)_pitch/))||void 0===f?void 0:f[1])||"1";o+="        granular".concat(n,"_currentPitchCV").concat(t," = harmseq").concat(m,"_v").concat(_,"_pitch; // CV").concat(t," from HarmonicSequencer voice ").concat(_,"\n")}return o};C+=X(x,1),C+=X(E,2),C+=X(P,3),C+=X(w,4),C+="\n        // Dense granular processing with freeze capability - 32ms grains, 20 concurrent\n        // Only fill buffer if not frozen\n        if (granular".concat(n,"_currentFreeze < 0.9) {\n            granular").concat(n,"_buffer_L[granular").concat(n,"_write_pos] = granular").concat(n,"_inputL;\n            granular").concat(n,"_buffer_R[granular").concat(n,"_write_pos] = granular").concat(n,"_inputR;\n            granular").concat(n,"_write_pos = (granular").concat(n,"_write_pos + 1) % granular").concat(n,"_buffer_size;\n        }\n\n        // Dense grain triggering with memory-efficient rate limiting\n        granular").concat(n,"_samples_since_grain++;\n        float grainInterval = 44100.0 / constrain(granular").concat(n,"_currentDensity, 0.1f, 20.0f);\n\n        // Only trigger if we have a reasonable interval and available grain slots\n        static int granular").concat(n,"_activeGrainCount = 0;\n        if (granular").concat(n,"_samples_since_grain >= (int)grainInterval && granular").concat(n,"_activeGrainCount < 16) {\n            // Find an inactive grain slot (limit to 16 concurrent for stability at max density)\n            for (int i = 0; i < 20; i++) {\n                if (!granular").concat(n,"_grains[i].active) {\n                    granular").concat(n,"_grains[i].active = true;\n\n                    // Position in buffer with spread - read from BEHIND write position for delay effect\n                    // currentPosition: 0=max delay (oldest audio), 1=min delay (recent audio)\n                    float delayAmount = (1.0f - granular").concat(n,"_currentPosition) * granular").concat(n,"_buffer_size * 0.9f; // Up to 90% of buffer\n                    float basePos = (float)granular").concat(n,"_write_pos - delayAmount;\n                    if (basePos < 0) basePos += granular").concat(n,"_buffer_size;\n\n                    float spreadRange = granular").concat(n,"_position_spread * granular").concat(n,"_buffer_size * 0.5;\n                    float spread = ((float)random(-1000, 1000) / 1000.0) * spreadRange;\n                    granular").concat(n,"_grains[i].position = basePos + spread;\n\n                    // Ensure position is within buffer bounds\n                    if (granular").concat(n,"_grains[i].position < 0)\n                        granular").concat(n,"_grains[i].position += granular").concat(n,"_buffer_size;\n                    if (granular").concat(n,"_grains[i].position >= granular").concat(n,"_buffer_size)\n                        granular").concat(n,"_grains[i].position -= granular").concat(n,"_buffer_size;\n\n                    // Pitch ratio with spread and grouped CV modulation\n                    float pitchSpread = ((float)random(-1000, 1000) / 1000.0) * granular").concat(n,"_pitch_spread;\n\n                    // Select pitch CV based on grain group (dynamic grouping)\n                    float cvPitch = 0.0;\n");var Z=[x,E,P,w].filter(function(e){return void 0!==e}).length;if(0===Z)C+="                    // No pitch CV connections\n";else if(1===Z){var Q=x?1:E?2:P?3:4;C+="                    // Single pitch CV - all grains use CV".concat(Q,"\n"),C+="                    cvPitch = granular".concat(n,"_currentPitchCV").concat(Q,";\n")}else if(2===Z){var J=x?1:E?2:3,ee=w?4:P?3:2;C+="                    // 2 pitch CVs - 10 grains per group\n",C+="                    if (i < 10) {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV").concat(J,";\n"),C+="                    } else {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV").concat(ee,";\n"),C+="                    }\n"}else if(3===Z){var ne=[x?1:0,E?2:0,P?3:0,w?4:0].filter(function(e){return e>0});C+="                    // 3 pitch CVs - groups of 7, 7, 6 grains\n",C+="                    if (i < 7) {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV").concat(ne[0],";\n"),C+="                    } else if (i < 14) {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV").concat(ne[1],";\n"),C+="                    } else {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV").concat(ne[2],";\n"),C+="                    }\n"}else C+="                    // 4 pitch CVs - 5 grains per group\n",C+="                    if (i < 5) {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV1;\n"),C+="                    } else if (i < 10) {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV2;\n"),C+="                    } else if (i < 15) {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV3;\n"),C+="                    } else {\n",C+="                        cvPitch = granular".concat(n,"_currentPitchCV4;\n"),C+="                    }\n";return C+="\n                    float totalPitch = granular".concat(n,"_currentPitch + cvPitch + pitchSpread;\n                    granular").concat(n,"_grains[i].pitch_ratio = pow(2.0, totalPitch / 12.0);\n\n                    // Reverse every second grain (odd indices)\n                    if (i % 2 == 1) {\n                        granular").concat(n,"_grains[i].pitch_ratio = -granular").concat(n,"_grains[i].pitch_ratio;\n                    }\n"),C+="\n                    // Stereo panning calculation\n",Z>1?(C+="                    if (granular".concat(n,"_grouped_panning > 0.5) {\n"),C+="                        // GROUPED PANNING MODE: Each pitch group has its own pan anchor\n",2===Z?(C+="                        float groupAnchor;\n",C+="                        int groupIndex;\n",C+="                        bool isGroupLeader;\n",C+="                        if (i < 10) {\n",C+="                            groupIndex = 0;\n",C+="                            isGroupLeader = (i == 0);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan - granular").concat(n,"_currentStereoWidth * 0.25; // Group 1 left\n"),C+="                        } else {\n",C+="                            groupIndex = 1;\n",C+="                            isGroupLeader = (i == 10);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan + granular").concat(n,"_currentStereoWidth * 0.25; // Group 2 right\n"),C+="                        }\n"):3===Z?(C+="                        float groupAnchor;\n",C+="                        int groupIndex;\n",C+="                        bool isGroupLeader;\n",C+="                        if (i < 7) {\n",C+="                            groupIndex = 0;\n",C+="                            isGroupLeader = (i == 0);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan - granular").concat(n,"_currentStereoWidth * 0.333; // Group 1 left\n"),C+="                        } else if (i < 14) {\n",C+="                            groupIndex = 1;\n",C+="                            isGroupLeader = (i == 7);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan; // Group 2 center\n"),C+="                        } else {\n",C+="                            groupIndex = 2;\n",C+="                            isGroupLeader = (i == 14);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan + granular").concat(n,"_currentStereoWidth * 0.333; // Group 3 right\n"),C+="                        }\n"):4===Z&&(C+="                        float groupAnchor;\n",C+="                        int groupIndex;\n",C+="                        bool isGroupLeader;\n",C+="                        if (i < 5) {\n",C+="                            groupIndex = 0;\n",C+="                            isGroupLeader = (i == 0);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan - granular").concat(n,"_currentStereoWidth * 0.375; // Group 1 far left\n"),C+="                        } else if (i < 10) {\n",C+="                            groupIndex = 1;\n",C+="                            isGroupLeader = (i == 5);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan - granular").concat(n,"_currentStereoWidth * 0.125; // Group 2 center-left\n"),C+="                        } else if (i < 15) {\n",C+="                            groupIndex = 2;\n",C+="                            isGroupLeader = (i == 10);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan + granular").concat(n,"_currentStereoWidth * 0.125; // Group 3 center-right\n"),C+="                        } else {\n",C+="                            groupIndex = 3;\n",C+="                            isGroupLeader = (i == 15);\n",C+="                            groupAnchor = granular".concat(n,"_currentCloudPan + granular").concat(n,"_currentStereoWidth * 0.375; // Group 4 far right\n"),C+="                        }\n"),C+="                        // First grain of each group uses exact anchor, others spread relative to it\n",C+="                        if (isGroupLeader) {\n",C+="                            granular".concat(n,"_grains[i].pan = constrain(groupAnchor, 0.0f, 1.0f);\n"),C+="                        } else {\n",C+="                            // Spread within group (1/".concat(Z," of total stereo_width per group)\n"),C+="                            float groupSpread = ((float)random(-1000, 1000) / 1000.0) * granular".concat(n,"_currentStereoWidth * 0.5 / ").concat(Z,".0;\n"),C+="                            granular".concat(n,"_grains[i].pan = constrain(groupAnchor + groupSpread, 0.0f, 1.0f);\n"),C+="                        }\n",C+="                    } else {\n",C+="                        // NORMAL MODE: All grains spread from single cloud_pan anchor\n",C+="                        if (i == 0) {\n",C+="                            granular".concat(n,"_grains[i].pan = granular").concat(n,"_currentCloudPan;\n"),C+="                        } else {\n",C+="                            float panSpread = ((float)random(-1000, 1000) / 1000.0) * granular".concat(n,"_currentStereoWidth;\n"),C+="                            granular".concat(n,"_grains[i].pan = constrain(granular").concat(n,"_currentCloudPan + panSpread, 0.05f, 0.95f);\n"),C+="                        }\n",C+="                    }\n"):(C+="                    // Normal panning - first grain anchored, others spread relative\n",C+="                    if (i == 0) {\n",C+="                        granular".concat(n,"_grains[i].pan = granular").concat(n,"_currentCloudPan;\n"),C+="                    } else {\n",C+="                        float panSpread = ((float)random(-1000, 1000) / 1000.0) * granular".concat(n,"_currentStereoWidth;\n"),C+="                        granular".concat(n,"_grains[i].pan = constrain(granular").concat(n,"_currentCloudPan + panSpread, 0.05f, 0.95f);\n"),C+="                    }\n"),C+"\n\n                    // Short 32ms grains for dense texture - fixed size for consistent texture\n                    const int grainSamples = (int)(0.032 * 44100.0); // 32ms\n                    granular".concat(n,"_grains[i].samples_remaining = grainSamples;\n\n                    // Envelope setup for short grains\n                    granular").concat(n,"_grains[i].envelope_pos = 0.0;\n                    granular").concat(n,"_grains[i].envelope_inc = 1.0 / grainSamples;\n\n                    granular").concat(n,"_samples_since_grain = 0;\n                    granular").concat(n,"_activeGrainCount++;\n                    break;\n                }\n            }\n        }\n\n        // Process grains (round-robin: 10 grains per sample for 50% CPU reduction)\n        float grainSumL = 0.0;\n        float grainSumR = 0.0;\n        int activeGrains = 0;\n\n        // Alternate between even-indexed (0,2,4...) and odd-indexed (1,3,5...) grains\n        int startGrain = granular").concat(n,"_process_even ? 0 : 1;\n        for (int i = startGrain; i < 20; i += 2) {\n            if (granular").concat(n,"_grains[i].active) {\n                activeGrains++;\n\n                // Read from buffer with pitch shifting\n                int readPos = (int)granular").concat(n,"_grains[i].position;\n                float sampleL = granular").concat(n,"_buffer_L[readPos];\n                float sampleR = granular").concat(n,"_buffer_R[readPos];\n\n                // Apply envelope (Hann window from pre-calculated table - fast lookup)\n                // Clamp envelope_pos to [0.0, 1.0] to prevent clicks from out-of-range lookups\n                float envPos = constrain(granular").concat(n,"_grains[i].envelope_pos, 0.0f, 1.0f);\n                int tableIdx = (int)(envPos * 255.0f);\n                float envelope = granular").concat(n,"_envelopeTable[tableIdx];\n\n                // Additional fade-in/fade-out for click-free grain edges (first/last 5% of grain)\n                float fadeFactor = 1.0f;\n                if (envPos < 0.05f) {\n                    fadeFactor = envPos / 0.05f; // Fade in over first 5%\n                } else if (envPos > 0.95f) {\n                    fadeFactor = (1.0f - envPos) / 0.05f; // Fade out over last 5%\n                }\n                envelope *= fadeFactor;\n\n                // Apply stereo panning (equal power pan law)\n                float panL = sqrt(1.0 - granular").concat(n,"_grains[i].pan);  // Left channel gain\n                float panR = sqrt(granular").concat(n,"_grains[i].pan);        // Right channel gain\n\n                grainSumL += sampleL * envelope * panL;\n                grainSumR += sampleR * envelope * panR;\n\n                // Advance grain\n                granular").concat(n,"_grains[i].position += granular").concat(n,"_grains[i].pitch_ratio;\n\n                // Wrap position\n                if (granular").concat(n,"_grains[i].position >= granular").concat(n,"_buffer_size) {\n                    granular").concat(n,"_grains[i].position -= granular").concat(n,"_buffer_size;\n                }\n\n                // Advance envelope\n                granular").concat(n,"_grains[i].envelope_pos += granular").concat(n,"_grains[i].envelope_inc;\n                granular").concat(n,"_grains[i].samples_remaining--;\n\n                // Deactivate when finished\n                if (granular").concat(n,"_grains[i].samples_remaining <= 0) {\n                    granular").concat(n,"_grains[i].active = false;\n                    granular").concat(n,"_activeGrainCount--;\n                }\n            }\n        }\n\n        // Toggle round-robin flag for next sample (alternate even/odd grains)\n        granular").concat(n,"_process_even = !granular").concat(n,"_process_even;\n\n        // Scale output by active grains to prevent excessive volume with many concurrent grains\n        if (activeGrains > 0) {\n            float grainScale = 2.0 / sqrt((float)activeGrains); // Boosted grain amplitude for better presence\n            grainSumL *= grainScale;\n            grainSumR *= grainScale;\n        }\n\n        // Apply dry/wet mix\n        float dryGain = 1.0 - granular").concat(n,"_currentDryWet;\n        float wetGain = granular").concat(n,"_currentDryWet;\n\n        granular").concat(n,"_outputL = granular").concat(n,"_inputL * dryGain + grainSumL * wetGain;\n        granular").concat(n,"_outputR = granular").concat(n,"_inputR * dryGain + grainSumR * wetGain;\n")}},{key:"generateGranularSynthProcessingCode",value:function(e,n,t){return"\n        // TODO: Implement GranularSynth processing (4 grains, variable size 10-200ms)\n        granular".concat(n,"_outputL = 0.0;\n        granular").concat(n,"_outputR = 0.0;\n")}},{key:"generateResonanceProcessingCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"trigger"===n.to.port}),o="0.0";if(a){var r,c=a.from.id.split(":")[0],i=(a.from.port,this.connectionResolver.modules.find(function(e){return e.id===c})),l=(null===(r=c.match(/\d+$/))||void 0===r?void 0:r[0])||"1";if(i)switch(i.type){case"LEDButton":o="btn".concat(l,"_gate");break;case"GateGen":o="gategen".concat(l,"_gate");break;default:o="resonance".concat(n,"_trigger")}}return"\n        // Resonance ".concat(n," - Resonant Object Exploration System\n        {\n            // Read control inputs\n            bool trigger = ").concat(o," > 0.5;\n\n            // Mode handling: 0=discovery, 1=performance, 2=exploration\n            int currentMode = resonance").concat(n,"_mode;\n\n            // Update mode from control input if connected\n            if (resonance").concat(n,"_mode_select > 0.0) {\n                currentMode = (int)(resonance").concat(n,"_mode_select * 2.0); // 0.0-0.5=discovery, 0.5-1.0=performance\n                resonance").concat(n,"_mode = currentMode;\n            }\n\n            // Update sensitivity and intensity from control inputs\n            if (resonance").concat(n,"_sensitivity > 0.0) {\n                resonance").concat(n,"_gyroSensitivity = resonance").concat(n,"_sensitivity;\n            }\n            if (resonance").concat(n,"_intensity > 0.0) {\n                resonance").concat(n,"_hapticIntensity = resonance").concat(n,"_intensity;\n            }\n\n            switch (currentMode) {\n                case 0: // DISCOVERY MODE: Frequency sweep analysis\n                {\n                    if (trigger && !resonance").concat(n,"_analyzing) {\n                        // Start frequency sweep analysis\n                        resonance").concat(n,"_analyzing = true;\n                        resonance").concat(n,"_sweepStartTime = millis();\n                        resonance").concat(n,"_currentSweepFreq = resonance").concat(n,"_sweepStart;\n                        resonance").concat(n,"_sweepPhase = 0.0;\n                        resonance").concat(n,"_analysis_complete = 0.0;\n\n                        // Allocate FFT buffers in PSRAM if not already allocated\n                        if (resonance").concat(n,"_fft_input == nullptr) {\n                            resonance").concat(n,"_fft_input = (float*)ps_malloc(resonance").concat(n,"_fftSize * sizeof(float));\n                            resonance").concat(n,"_fft_output = (float*)ps_malloc(resonance").concat(n,"_fftSize * sizeof(float));\n                            resonance").concat(n,"_window = (float*)ps_malloc(resonance").concat(n,"_fftSize * sizeof(float));\n\n                            // Initialize Hann window\n                            for (int i = 0; i < resonance").concat(n,"_fftSize; i++) {\n                                resonance").concat(n,"_window[i] = 0.5 * (1.0 - cos(2.0 * PI * i / (resonance").concat(n,"_fftSize - 1)));\n                            }\n                        }\n                    }\n\n                    if (resonance").concat(n,"_analyzing) {\n                        unsigned long elapsed = millis() - resonance").concat(n,"_sweepStartTime;\n                        float sweepProgress = (float)elapsed / resonance").concat(n,"_sweepDuration;\n\n                        if (sweepProgress < 1.0) {\n                            // Generate logarithmic frequency sweep\n                            float logStart = log(resonance").concat(n,"_sweepStart);\n                            float logEnd = log(resonance").concat(n,"_sweepEnd);\n                            resonance").concat(n,"_currentSweepFreq = exp(logStart + sweepProgress * (logEnd - logStart));\n\n                            // Generate sweep tone through exciter\n                            resonance").concat(n,"_sweepPhase += 2.0 * PI * resonance").concat(n,"_currentSweepFreq / SAMPLE_RATE;\n                            if (resonance").concat(n,"_sweepPhase >= 2.0 * PI) resonance").concat(n,"_sweepPhase -= 2.0 * PI;\n\n                            resonance").concat(n,"_exciterOutput = sin(resonance").concat(n,"_sweepPhase) * 0.3; // 30% amplitude\n\n                            // Collect contact mic input for FFT analysis\n                            // NOTE: Actual FFT runs on Core 0 task to avoid blocking audio\n                            // This is a placeholder - full implementation requires FreeRTOS task\n\n                        } else {\n                            // Sweep complete - trigger FFT analysis\n                            resonance").concat(n,"_analyzing = false;\n                            resonance").concat(n,"_analysis_complete = 1.0;\n                            resonance").concat(n,"_exciterOutput = 0.0;\n\n                            // TODO: Launch Core 0 FFT task here\n                            // For now, output placeholder frequencies\n                            resonance").concat(n,"_freq1 = 100.0;\n                            resonance").concat(n,"_freq2 = 200.0;\n                            resonance").concat(n,"_freq3 = 400.0;\n                            resonance").concat(n,"_freq4 = 800.0;\n                            resonance").concat(n,"_freq5 = 1600.0;\n                            resonance").concat(n,"_freq6 = 3200.0;\n                            resonance").concat(n,"_freq7 = 6400.0;\n                            resonance").concat(n,"_freq8 = 12800.0;\n                            resonance").concat(n,"_resonance_strength = 0.8;\n                        }\n                    } else {\n                        resonance").concat(n,"_exciterOutput = 0.0;\n                    }\n                    break;\n                }\n\n                case 1: // PERFORMANCE MODE: Output stored resonant frequencies\n                {\n                    // Read from object library slot\n                    int objectSlot = (int)(resonance").concat(n,"_object_select * 39.0); // 0-1 maps to 0-39\n                    if (objectSlot != resonance").concat(n,"_objectSlot) {\n                        resonance").concat(n,"_objectSlot = objectSlot;\n                        // TODO: Load resonant frequencies from SPIFFS/SD\n                        // String path = resonance").concat(n,'_objectLibraryPath + String(objectSlot) + ".json";\n                    }\n\n                    // Output resonant frequencies as CV (already set during discovery)\n                    // Frequencies remain stable for performance use\n\n                    // Optionally play through exciter when triggered\n                    if (trigger) {\n                        // Simple resonant tone using detected fundamental\n                        static float perfPhase = 0.0;\n                        perfPhase += 2.0 * PI * resonance').concat(n,"_freq1 / SAMPLE_RATE;\n                        if (perfPhase >= 2.0 * PI) perfPhase -= 2.0 * PI;\n                        resonance").concat(n,"_exciterOutput = sin(perfPhase) * 0.2;\n                    } else {\n                        resonance").concat(n,"_exciterOutput = 0.0;\n                    }\n                    break;\n                }\n\n                case 2: // EXPLORATION MODE: Impulse response with gyroscope sensing\n                {\n                    if (trigger && !resonance").concat(n,"_analyzing) {\n                        // Send impulse through exciter\n                        resonance").concat(n,"_analyzing = true;\n                        resonance").concat(n,"_sweepStartTime = millis();\n                        resonance").concat(n,"_analysis_complete = 0.0;\n                    }\n\n                    if (resonance").concat(n,"_analyzing) {\n                        unsigned long elapsed = millis() - resonance").concat(n,"_sweepStartTime;\n\n                        if (elapsed < resonance").concat(n,"_impulseLength) {\n                            // Generate brief impulse (first 10% is the actual impulse)\n                            if (elapsed < resonance").concat(n,"_impulseLength * 0.1) {\n                                resonance").concat(n,"_exciterOutput = 1.0; // Full amplitude impulse\n                            } else {\n                                resonance").concat(n,"_exciterOutput = 0.0; // Listen to decay\n                            }\n\n                            // Record contact mic response (decay analysis)\n                            // TODO: Measure decay time for Q factor calculation\n\n                        } else {\n                            // Impulse analysis complete\n                            resonance").concat(n,"_analyzing = false;\n                            resonance").concat(n,"_analysis_complete = 1.0;\n                            resonance").concat(n,"_exciterOutput = 0.0;\n\n                            // TODO: Analyze decay for resonance strength\n                            resonance").concat(n,"_resonance_strength = 0.6; // Placeholder\n                        }\n                    } else {\n                        resonance").concat(n,"_exciterOutput = 0.0;\n                    }\n\n                    // TODO: Read gyroscope for vibration sensing\n                    // Wire.requestFrom(GYRO_I2C_ADDR, 6); // Read 6 bytes (XYZ accelerometer)\n\n                    // TODO: Control haptic motors if enabled\n                    if (resonance").concat(n,"_hapticEnable && trigger) {\n                        // Wire.beginTransmission(HAPTIC_I2C_ADDR);\n                        // Wire.write((uint8_t)(resonance").concat(n,"_hapticIntensity * 255));\n                        // Wire.endTransmission();\n                    }\n                    break;\n                }\n            }\n\n            // Read contact mic input (placeholder - actual ADC read goes here)\n            // resonance").concat(n,"_contactMicInput = analogRead(CONTACT_MIC_PIN) / 4095.0;\n        }\n")}}])&&de(e.prototype,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function me(e){return me="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},me(e)}function _e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,ge(a.key),a)}}function ge(e){var n=function(e){if("object"!=me(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=me(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==me(n)?n:n+""}var he=function(){return e=function e(n){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.connectionResolver=n},(n=[{key:"generateIncludes",value:function(e){var n=[];return"Sample Player"===e&&(n.push("#include <SD.h>"),n.push("#include <FS.h>"),n.push("#include <freertos/FreeRTOS.h>"),n.push("#include <freertos/task.h>"),n.push("#include <freertos/semphr.h>")),n}},{key:"generateModuleClasses",value:function(){return'\n// WAV File Header Structure\nstruct WAVHeader {\n    char riff[4];           // "RIFF"\n    uint32_t fileSize;      // File size minus 8 bytes\n    char wave[4];           // "WAVE"\n    char fmt[4];            // "fmt "\n    uint32_t fmtSize;       // Format chunk size\n    uint16_t audioFormat;   // Audio format (1 = PCM)\n    uint16_t numChannels;   // Number of channels\n    uint32_t sampleRate;    // Sample rate\n    uint32_t byteRate;      // Byte rate\n    uint16_t blockAlign;    // Block alignment\n    uint16_t bitsPerSample; // Bits per sample\n    char data[4];           // "data"\n    uint32_t dataSize;      // Data size\n};\n\n#define CHUNK_SIZE 4096  // Buffer size in bytes (1024 samples * 2 channels * 2 bytes)\n#define CHUNK_SAMPLES (CHUNK_SIZE / 4) // 1024 samples for stereo 16-bit\n\nclass MinimalWAVPlayer {\nprivate:\n    File wavFile;\n    WAVHeader header;\n    \n    // Double buffering for seamless playback\n    int16_t* bufferA;\n    int16_t* bufferB;\n    int16_t* playingBuffer;       // Currently being played\n    int16_t* loadingBuffer;       // Being loaded in background\n    \n    uint32_t totalDataBytes;      // Total bytes in WAV data section\n    uint32_t filePosition;        // Current position in file (bytes from start of data)\n    uint32_t playingSamples;      // Samples in currently playing buffer\n    uint32_t playPosition;        // Current play position within playing buffer (legacy)\n    float fractionalPosition;     // Fractional position for pitch control\n    \n    bool isPlaying;\n    bool fileEnded;\n    uint16_t channels;\n    \n    // Control variables for new functionality\n    float playbackSpeed;          // Playback speed multiplier (0.1 to 4.0)\n    float startPosition;          // Start position (0.0 to 1.0)  \n    float endPosition;            // End position (0.0 to 1.0)\n    \n    // Background loading task\n    TaskHandle_t loaderTaskHandle;\n    SemaphoreHandle_t bufferMutex;\n    volatile bool loadingBufferReady;\n    volatile uint32_t loadingBufferSamples;\n    \npublic:\n    MinimalWAVPlayer() : bufferA(nullptr), bufferB(nullptr), totalDataBytes(0), filePosition(0),\n                         playingSamples(0), playPosition(0), fractionalPosition(0.0f), isPlaying(false),\n                         fileEnded(false), channels(2), playbackSpeed(1.0f), startPosition(0.0f), \n                         endPosition(1.0f), loaderTaskHandle(NULL), loadingBufferReady(false), \n                         loadingBufferSamples(0) {\n        \n        // Allocate double buffers\n        bufferA = (int16_t*)heap_caps_malloc(CHUNK_SIZE, MALLOC_CAP_SPIRAM);\n        bufferB = (int16_t*)heap_caps_malloc(CHUNK_SIZE, MALLOC_CAP_SPIRAM);\n        \n        if (!bufferA || !bufferB) {\n            if (bufferA) free(bufferA);\n            if (bufferB) free(bufferB);\n            bufferA = (int16_t*)malloc(CHUNK_SIZE);\n            bufferB = (int16_t*)malloc(CHUNK_SIZE);\n        }\n        \n        if (bufferA && bufferB) {\n            playingBuffer = bufferA;\n            loadingBuffer = bufferB;\n            bufferMutex = xSemaphoreCreateMutex();\n        }\n    }\n    \n    // Core player methods would be defined here\n    bool loadFile(const String& filename);\n    void play();\n    void stop();\n    bool playing();\n    void setPlaybackSpeed(float speed);\n    void setStartPosition(float pos);\n    void setEndPosition(float pos);\n    int16_t getNextSample();\n    \n    ~MinimalWAVPlayer() {\n        stop();\n        if (bufferA) free(bufferA);\n        if (bufferB) free(bufferB);\n        if (bufferMutex) vSemaphoreDelete(bufferMutex);\n    }\n};\n'}},{key:"generateGlobalVariables",value:function(e,n,t){return"\n// ".concat(t.label," ").concat(n," - Minimal WAV Player (legacy single-voice)\nMinimalWAVPlayer sdPlayer").concat(n,"_player;\nfloat sdPlayer").concat(n,"_gain = ").concat(e.params.gain||3,";\nfloat sdPlayer").concat(n,"_pitch = ").concat(e.params.pitch||1,";\nbool sdPlayer").concat(n,"_loop = ").concat(e.params.loop||!0,";\nbool sdPlayer").concat(n,"_playing = false;\nint sdPlayer").concat(n,"_currentFile = 1;\nint sdPlayer").concat(n,"_sampleCount = 0;  // Dynamic count of available samples\nString sdPlayer").concat(n,'_currentFileName = "";\nfloat sdPlayer').concat(n,"_triggerThreshold = 0.5;\nbool sdPlayer").concat(n,"_lastTrigger = false;\nfloat sdPlayer").concat(n,"_outputL = 0.0;\nfloat sdPlayer").concat(n,"_outputR = 0.0;\nint sdPlayer").concat(n,"_lastLoadedFile = -1;  // Track loaded sample to avoid unnecessary reloads\n\n// File transfer variables (inline implementation - no external library needed)\nbool fileTransferActive").concat(n," = false;\nString transferFilename").concat(n,' = "";\nFile transferFile').concat(n,";\nuint32_t expectedFileSize").concat(n," = 0;\nuint32_t receivedBytes").concat(n," = 0;\n\n// Ring buffer variables for credit-based file transfer\nuint8_t* ringBuffer").concat(n," = NULL;\nvolatile int ringWritePos").concat(n," = 0;\nvolatile int ringReadPos").concat(n," = 0;\nvolatile int ringBufferCount").concat(n," = 0;\nconst int ringBufferSize").concat(n," = 65536; // 64KB ring buffer\nportMUX_TYPE ringBufferMux").concat(n," = portMUX_INITIALIZER_UNLOCKED;\n")}},{key:"generateSetupCode",value:function(e,n,t){return"\n    // Sample Player ".concat(n," setup\n    sdPlayer").concat(n,'_sampleCount = 10; // Default sample count\n    \n    // Count actual samples available on SD card\n    File root = SD.open("/");\n    int count = 0;\n    while (true) {\n        File entry = root.openNextFile();\n        if (!entry) break;\n        if (entry.name()[0] != \'.\' && !entry.isDirectory()) {\n            String name = String(entry.name()).toLowerCase();\n            if (name.endsWith(".wav")) {\n                count++;\n            }\n        }\n        entry.close();\n    }\n    root.close();\n    \n    if (count > 0) {\n        sdPlayer').concat(n,"_sampleCount = count;\n    }\n    \n    // Preload default sample to avoid SD I/O during audio processing\n    String preloadFile").concat(n,' = "/sample0" + String(sdPlayer').concat(n,'_currentFile) + ".wav";\n    if (SD.exists(preloadFile').concat(n,") && sdPlayer").concat(n,"_player.loadFile(preloadFile").concat(n,".c_str())) {\n        sdPlayer").concat(n,"_lastLoadedFile = 1;\n    }\n    \n    // Initialize ring buffer for file transfers\n    ringBuffer").concat(n," = (uint8_t*)heap_caps_malloc(ringBufferSize").concat(n,", MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);\n    if (!ringBuffer").concat(n,") {\n        ringBuffer").concat(n," = (uint8_t*)malloc(ringBufferSize").concat(n,");\n    }\n")}},{key:"generateProcessingCode",value:function(e,n,t){return["SamplePlayer","SDPlayer"].includes(e.type)?"\n        // Sample Player ".concat(n," processing\n        {\n            // Process control inputs\n            ").concat(this.generateControlProcessing(e,n,t),"\n\n            // Audio generation\n            if (sdPlayer").concat(n,"_playing) {\n                int16_t sampleL = sdPlayer").concat(n,"_player.getNextSample();\n                int16_t sampleR = sampleL; // Mono for now\n\n                sdPlayer").concat(n,"_outputL = (float)sampleL / 32767.0f * sdPlayer").concat(n,"_gain;\n                sdPlayer").concat(n,"_outputR = (float)sampleR / 32767.0f * sdPlayer").concat(n,"_gain;\n\n                sdPlayer").concat(n,"_playing = sdPlayer").concat(n,"_player.playing();\n            } else {\n                sdPlayer").concat(n,"_outputL = 0.0f;\n                sdPlayer").concat(n,"_outputR = 0.0f;\n            }\n        }\n"):null}},{key:"generateControlProcessing",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"pitch"===n.to.port}),r=(t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"sample_select"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"start_pos"===n.to.port}),t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"end_pos"===n.to.port}),"\n            // Control signal processing\n            float sdPlayer".concat(n,"_currentPitch = sdPlayer").concat(n,"_pitch;\n            int sdPlayer").concat(n,"_targetFile = sdPlayer").concat(n,"_currentFile;\n            float sdPlayer").concat(n,"_startPos = ").concat(e.params.start_pos||0,";\n            float sdPlayer").concat(n,"_endPos = ").concat(e.params.end_pos||1,";\n            \n            // Track loaded sample to avoid unnecessary reloads (declared globally)\n"));if(a){var c=a.from.id.split(":")[0],i=this.connectionResolver.modules.find(function(e){return e.id===c});if(i){var l,s=(null===(l=c.match(/\d+$/))||void 0===l?void 0:l[0])||"1";r+="\n                // Trigger from ".concat(i.type," ").concat(s,"\n                bool currentTrigger = false;\n                switch (").concat("LEDButton"===i.type?"true":"false",") {\n                    case true: // LEDButton\n                        currentTrigger = btn").concat(s,"_pressed;\n                        break;\n                    default:\n                        currentTrigger = false;\n                        break;\n                }\n                \n                // Edge detection for trigger\n                if (currentTrigger && !sdPlayer").concat(n,"_lastTrigger) {\n                    // Trigger detected - start playback\n                    if (sdPlayer").concat(n,"_lastLoadedFile != -1) {\n                        sdPlayer").concat(n,"_player.play();\n                        sdPlayer").concat(n,"_playing = true;\n                    }\n                }\n                sdPlayer").concat(n,"_lastTrigger = currentTrigger;\n")}}if(o){var u=o.from.id.split(":")[0],d=this.connectionResolver.modules.find(function(e){return e.id===u});if(d){var p,f=(null===(p=u.match(/\d+$/))||void 0===p?void 0:p[0])||"1";r+="\n                // Pitch control from ".concat(d.type," ").concat(f,"\n                float scaleFreq = scale").concat(f,"_output;\n                float scalePitchRatio = scaleFreq / 440.0; // Convert frequency to pitch ratio (440Hz = 1.0x)\n                scalePitchRatio = constrain(scalePitchRatio, 0.25, 4.0); // Limit to reasonable range\n                sdPlayer").concat(n,"_currentPitch = scalePitchRatio;\n                \n                // Final safety constraint\n                sdPlayer").concat(n,"_currentPitch = constrain(sdPlayer").concat(n,"_currentPitch, 0.1, 8.0);\n                \n                sdPlayer").concat(n,"_player.setPlaybackSpeed(sdPlayer").concat(n,"_currentPitch);\n")}}return r}}])&&_e(e.prototype,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function ve(e){return ve="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},ve(e)}function be(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,ye(a.key),a)}}function ye(e){var n=function(e){if("object"!=ve(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=ve(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==ve(n)?n:n+""}var ke=function(){return e=function e(n){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.connectionResolver=n},(n=[{key:"getWaveTypeIndex",value:function(e){if("number"==typeof e)return e;if("string"!=typeof e)return 0;switch(e.toLowerCase()){case"sine":default:return 0;case"sawtooth":case"saw":return 1;case"square":return 2;case"triangle":case"tri":return 3}}},{key:"generateIncludes",value:function(e){var n=[];switch(e){case"ADSR":case"Scale":case"LFO":case"HarmonicSequencer":n.push("#include <math.h>"),n.push("#include <string.h>");break;case"MIDIIn":n.push("#include <HardwareSerial.h>")}return n}},{key:"generateGlobalVariables",value:function(e,n,t){switch(e.type){case"ADSR":var a=e.params.loop_mode||"oneshot";return"\n// ".concat(t.label," ").concat(n,"\nfloat adsr").concat(n,"_attack = ").concat((e.params.attack_ms||10)/1e3,"; // Convert ms to seconds\nfloat adsr").concat(n,"_decay = ").concat((e.params.decay_ms||120)/1e3,"; // Convert ms to seconds\nfloat adsr").concat(n,"_sustain = ").concat(e.params.sustain||.6,"; // Already 0-1 range\nfloat adsr").concat(n,"_release = ").concat((e.params.release_ms||200)/1e3,"; // Convert ms to seconds\nfloat adsr").concat(n,"_timescale = ").concat(e.params.timescale||1,"; // Timing scale multiplier\nconst char* adsr").concat(n,'_loop_mode = "').concat(a,'"; // "oneshot", "loop", "pingpong"\nfloat adsr').concat(n,"_level = 0.0;\nint adsr").concat(n,"_stage = 0; // 0=idle, 1=attack, 2=decay, 3=sustain, 4=release\nbool adsr").concat(n,"_gate = false;\nbool adsr").concat(n,"_lastGate = false;\nvolatile float adsr").concat(n,"_output = 0.0;\nvolatile float adsr").concat(n,"_prevOutput = 0.0; // Previous buffer's output for interpolation\nvolatile float adsr").concat(n,"_targetOutput = 0.0; // Target output from envelope processing\nfloat adsr").concat(n,"_stageTime = 0.0; // Time within current stage\nfloat adsr").concat(n,"_releaseStartLevel = 0.0; // Level when release stage started\nfloat adsr").concat(n,"_attackStartLevel = 0.0; // Level when attack stage started\n// Curve types: ").concat(e.params.attack_curve||"linear",", ").concat(e.params.decay_curve||"exp",", ").concat(e.params.release_curve||"exp","\n");case"Scale":return"\n// ".concat(t.label," ").concat(n,"\nfloat scale").concat(n,"_input = 0.0;\nvolatile float scale").concat(n,"_output = ").concat(12*e.params.base_octave+60||60,"; // Middle C as default\n");case"LFO":return"\n// ".concat(t.label," ").concat(n,"\nfloat lfo").concat(n,"_freq = ").concat(e.params.freq||1,";\nfloat lfo").concat(n,"_phase = 0.0;\nvolatile float lfo").concat(n,"_output = 0.0;\nint lfo").concat(n,"_waveform = ").concat(this.getWaveTypeIndex(e.params.waveform),"; // 0=sine, 1=triangle, 2=saw, 3=square\nfloat lfo").concat(n,"_amplitude = ").concat(e.params.amplitude||1,";\nfloat lfo").concat(n,"_offset = ").concat(e.params.offset||0,";\n\n// Additional variables for legacy compatibility\nbool lfo").concat(n,"_sync_to_clock = ").concat(e.params.sync_to_clock||!1,";\nunsigned long lfo").concat(n,"_last_update = 0;\nfloat lfo").concat(n,"_rate_hz = ").concat(e.params.rate_hz||e.params.freq||1,";\nint lfo").concat(n,"_wave = ").concat(this.getWaveTypeIndex(e.params.wave||e.params.waveform),";\nfloat lfo").concat(n,"_depth = ").concat(e.params.depth||e.params.amplitude||1,";\n");case"Automation":for(var o=e.params.buffer_size||1e3,r=e.params.num_inputs||1,c="",i="",l="",s="",u="",d=1;d<=r;d++)c+="float automation".concat(n,"_input_").concat(d," = 0.0;\n"),i+="volatile float automation".concat(n,"_output_").concat(d," = 0.0;\n"),l+="float* automation".concat(n,"_buffer_").concat(d," = nullptr; // PSRAM buffer for channel ").concat(d,"\n"),s+="float automation".concat(n,"_last_input_").concat(d," = 0.0; // For touch detection\n"),u+="int automation".concat(n,"_channel_").concat(d,"_length = 0; // Channel ").concat(d," loop length\n"),u+="int automation".concat(n,"_channel_").concat(d,"_position = 0; // Channel ").concat(d," playback position\n"),u+="bool automation".concat(n,"_channel_").concat(d,"_recording = false; // Channel ").concat(d," recording\n"),u+="bool automation".concat(n,"_channel_").concat(d,"_playing = false; // Channel ").concat(d," playing\n"),u+="unsigned long automation".concat(n,"_channel_").concat(d,"_start_time = 0; // Channel ").concat(d," playback start\n");return"\n// ".concat(t.label," ").concat(n," - Independent Per-Channel Automation (").concat(r," channels)\nconst int automation").concat(n,"_buffer_size = ").concat(o,";\nconst int automation").concat(n,"_num_inputs = ").concat(r,";\nconst float automation").concat(n,"_movement_threshold = 0.005; // 0.5% movement = channel is being moved\nconst float automation").concat(n,"_touch_threshold = 0.01; // 1% change triggers touch override (smooth takeover)\nconst unsigned long automation").concat(n,"_touch_grace_ms = 50; // 50ms grace period (minimal for responsiveness)\n").concat(l).concat(u,"\n// Global recording trigger (button)\nbool automation").concat(n,"_record_trigger = false;\nbool automation").concat(n,"_last_record_trigger = false;\nbool automation").concat(n,"_loop = ").concat(e.params.loop||!0,";\n\n// Clock sync and playback modes\nbool automation").concat(n,"_clock_sync = ").concat(e.params.clock_sync||!1,"; // Sync to Clock module\nint automation").concat(n,"_clock_quantize = ").concat(e.params.clock_quantize||4,"; // Quantize to N beats (1, 2, 4, 8, 16)\nfloat automation").concat(n,"_clock_input = 0.0; // Clock signal input\nbool automation").concat(n,"_last_clock = false;\nint automation").concat(n,"_playback_mode = 0; // 0=normal, 1=reverse, 2=double, 3=half, 4=pingpong\nbool automation").concat(n,"_mode_select = false; // Encoder button held for mode selection\nint automation").concat(n,"_selected_mode = 0; // Mode being previewed during selection\n\n").concat(c).concat(i).concat(s,"\n");case"GateGen":return"\n// ".concat(t.label," ").concat(n," - Gate Generator with S&H and gate input control\nfloat gate").concat(n,"_length = ").concat(e.params.gate_length||.8,"; // Gate length as fraction of clock period\nbool gate").concat(n,"_use_self_clock = ").concat(e.params.use_self_clock||!0,";\nfloat gate").concat(n,"_self_clock_bpm = ").concat(e.params.self_clock_bpm||120,";\nfloat gate").concat(n,"_probability = ").concat(e.params.probability||1,"; // Probability 0-1\nbool gate").concat(n,"_retrigger = ").concat(e.params.retrigger||!0,";\nbool gate").concat(n,"_sh_enabled = ").concat(e.params.sh_enabled||!0,"; // Sample & Hold enabled\nbool gate").concat(n,"_state = false;\nbool gate").concat(n,"_last_clock = false;\nunsigned long gate").concat(n,"_start_time = 0;\nunsigned long gate").concat(n,"_last_self_clock = 0;\nfloat gate").concat(n,"_output = 0.0;\nfloat gate").concat(n,"_led_output = 0.0; // Separate LED output for metronome flash\nunsigned long gate").concat(n,"_led_start_time = 0;\nint gate").concat(n,"_led_flash_ms = ").concat(e.params.led_flash_ms||0,"; // LED flash duration (0 = follow gate)\nfloat gate").concat(n,"_sh_input = 0.0; // Sample & Hold input\nfloat gate").concat(n,"_sh_output = 0.0; // Sample & Hold output (held value)\nfloat gate").concat(n,"_gate_input = 0.0; // Gate input control\nbool gate").concat(n,"_gate_enabled = true; // Gate control state\nfloat gate").concat(n,"_rate = 0.0; // Rate output in Hz for tempo sync\nbool gate").concat(n,"_running = false; // Start/stop control (encoder button)\n");case"MIDIIn":return"\n// ".concat(t.label," ").concat(n," - UART MIDI Input\nHardwareSerial midi").concat(n,"Serial(").concat(e.params.rxPin>=16?2:1,"); // Serial2 for GPIO16+, Serial1 for lower pins\n// MIDI parsing state\nbyte midi").concat(n,"_status = 0;\nbyte midi").concat(n,"_data1 = 0;\nbyte midi").concat(n,"_data2 = 0;\nint midi").concat(n,"_dataIndex = 0;\nbool midi").concat(n,"_running_status = false;\n\n// Configuration\nint midi").concat(n,"_channel = ").concat(e.params.channel||1,"; // MIDI channel (1-16)\nbool midi").concat(n,"_omni = ").concat(e.params.omni||!0,"; // Omni mode\nint midi").concat(n,"_rxPin = ").concat(e.params.rxPin||18,";\nint midi").concat(n,"_txPin = ").concat(e.params.txPin||-1,"; // -1 = RX only\n\n// Control Change mappings\nint midi").concat(n,"_cc1 = ").concat(e.params.cc1||1,"; // Modulation wheel\nint midi").concat(n,"_cc2 = ").concat(e.params.cc2||74,"; // Filter cutoff\nint midi").concat(n,"_cc3 = ").concat(e.params.cc3||71,"; // Filter resonance\nint midi").concat(n,"_cc4 = ").concat(e.params.cc4||10,"; // Pan\n\n// Feature enables\nbool midi").concat(n,"_use_gate = ").concat(e.params.use_gate||!0,";\nbool midi").concat(n,"_use_vel = ").concat(e.params.use_vel||!1,";\nbool midi").concat(n,"_use_clock = ").concat(e.params.use_clock||!0,";\nbool midi").concat(n,"_use_prog = ").concat(e.params.use_prog||!0,";\n\n// Output values\nfloat midi").concat(n,"_note = 60.0; // Current MIDI note number\nfloat midi").concat(n,"_freq = 261.63; // Current frequency (C4)\nfloat midi").concat(n,"_gate = 0.0; // Gate output (0 or 1)\nfloat midi").concat(n,"_velocity = 0.8; // Velocity (0-1)\nfloat midi").concat(n,"_cc1_value = 0.0; // CC1 value (0-1)\nfloat midi").concat(n,"_cc2_value = 0.0; // CC2 value (0-1)\nfloat midi").concat(n,"_cc3_value = 0.0; // CC3 value (0-1)\nfloat midi").concat(n,"_cc4_value = 0.0; // CC4 value (0-1)\nbool midi").concat(n,"_clock_tick = false; // Clock tick output\nint midi").concat(n,"_program = 0; // Program change value (0-127)\n\n// Note tracking for monophonic mode\nint midi").concat(n,"_last_note = -1;\nbool midi").concat(n,"_note_on = false;\n");case"Clock":return"\n// ".concat(t.label," ").concat(n," - 8-output clock divider/multiplier\nfloat clock").concat(n,"_bpm = ").concat(e.params.bpm||120,";\nbool clock").concat(n,"_running = true;\nfloat clock").concat(n,"_period_ms = 0.0;\nunsigned long clock").concat(n,"_last_tick = 0;\nbool clock").concat(n,"_master_pulse = false;\nfloat clock").concat(n,"_master_phase = 0.0;\n\n// 8 output counters and rate multipliers (0.0625 = /16, 1.0 = clock rate, 16.0 = x16)\nfloat clock").concat(n,"_counter1 = 0.0, clock").concat(n,"_rate1 = ").concat(e.params.rate1||1,";\nfloat clock").concat(n,"_counter2 = 0.0, clock").concat(n,"_rate2 = ").concat(e.params.rate2||.5,";\nfloat clock").concat(n,"_counter3 = 0.0, clock").concat(n,"_rate3 = ").concat(e.params.rate3||.25,";\nfloat clock").concat(n,"_counter4 = 0.0, clock").concat(n,"_rate4 = ").concat(e.params.rate4||.125,";\nfloat clock").concat(n,"_counter5 = 0.0, clock").concat(n,"_rate5 = ").concat(e.params.rate5||2,";\nfloat clock").concat(n,"_counter6 = 0.0, clock").concat(n,"_rate6 = ").concat(e.params.rate6||4,";\nfloat clock").concat(n,"_counter7 = 0.0, clock").concat(n,"_rate7 = ").concat(e.params.rate7||8,";\nfloat clock").concat(n,"_counter8 = 0.0, clock").concat(n,"_rate8 = ").concat(e.params.rate8||16,";\n\n// Gate mode for each output (false = clock/toggle, true = gate/pulse)\nbool clock").concat(n,"_gate_mode1 = ").concat(e.params.gate_mode1?"true":"false",";\nbool clock").concat(n,"_gate_mode2 = ").concat(e.params.gate_mode2?"true":"false",";\nbool clock").concat(n,"_gate_mode3 = ").concat(e.params.gate_mode3?"true":"false",";\nbool clock").concat(n,"_gate_mode4 = ").concat(e.params.gate_mode4?"true":"false",";\nbool clock").concat(n,"_gate_mode5 = ").concat(e.params.gate_mode5?"true":"false",";\nbool clock").concat(n,"_gate_mode6 = ").concat(e.params.gate_mode6?"true":"false",";\nbool clock").concat(n,"_gate_mode7 = ").concat(e.params.gate_mode7?"true":"false",";\nbool clock").concat(n,"_gate_mode8 = ").concat(e.params.gate_mode8?"true":"false",";\n\n// Probability for each output (0.0 = never, 1.0 = always)\nfloat clock").concat(n,"_prob1 = ").concat(e.params.prob1||1,";\nfloat clock").concat(n,"_prob2 = ").concat(e.params.prob2||1,";\nfloat clock").concat(n,"_prob3 = ").concat(e.params.prob3||1,";\nfloat clock").concat(n,"_prob4 = ").concat(e.params.prob4||1,";\nfloat clock").concat(n,"_prob5 = ").concat(e.params.prob5||1,";\nfloat clock").concat(n,"_prob6 = ").concat(e.params.prob6||1,";\nfloat clock").concat(n,"_prob7 = ").concat(e.params.prob7||1,";\nfloat clock").concat(n,"_prob8 = ").concat(e.params.prob8||1,";\n\n// Euclidean subdivisions (1-8: 1=no subdivision, 8=8 rate subdivision for fills)\nint clock").concat(n,"_euclid1 = ").concat(e.params.euclid1||1,";\nint clock").concat(n,"_euclid2 = ").concat(e.params.euclid2||1,";\nint clock").concat(n,"_euclid3 = ").concat(e.params.euclid3||1,";\nint clock").concat(n,"_euclid4 = ").concat(e.params.euclid4||1,";\nint clock").concat(n,"_euclid5 = ").concat(e.params.euclid5||1,";\nint clock").concat(n,"_euclid6 = ").concat(e.params.euclid6||1,";\nint clock").concat(n,"_euclid7 = ").concat(e.params.euclid7||1,";\nint clock").concat(n,"_euclid8 = ").concat(e.params.euclid8||1,";\n\n// Fill button states (momentary - multiply rate by euclid while held)\nbool clock").concat(n,"_fill1 = false, clock").concat(n,"_fill2 = false;\nbool clock").concat(n,"_fill3 = false, clock").concat(n,"_fill4 = false;\nbool clock").concat(n,"_fill5 = false, clock").concat(n,"_fill6 = false;\nbool clock").concat(n,"_fill7 = false, clock").concat(n,"_fill8 = false;\n\n// Pot values for probability attenuation during fill (0.0-1.0)\nfloat clock").concat(n,"_pot_value1 = ").concat(e.params.rate1||1,";\nfloat clock").concat(n,"_pot_value2 = ").concat(e.params.rate2||.5,";\nfloat clock").concat(n,"_pot_value3 = ").concat(e.params.rate3||.25,";\nfloat clock").concat(n,"_pot_value4 = ").concat(e.params.rate4||.125,";\nfloat clock").concat(n,"_pot_value5 = ").concat(e.params.rate5||2,";\nfloat clock").concat(n,"_pot_value6 = ").concat(e.params.rate6||4,";\nfloat clock").concat(n,"_pot_value7 = ").concat(e.params.rate7||8,";\nfloat clock").concat(n,"_pot_value8 = ").concat(e.params.rate8||16,";\n\n// Soft takeover for banking (outputs 1-4 only)\nfloat clock").concat(n,"_rate_physical[4] = {").concat(e.params.rate1||1,", ").concat(e.params.rate2||.5,", ").concat(e.params.rate3||.25,", ").concat(e.params.rate4||.125,"};\nfloat clock").concat(n,"_rate_target[4] = {").concat(e.params.rate1||1,", ").concat(e.params.rate2||.5,", ").concat(e.params.rate3||.25,", ").concat(e.params.rate4||.125,"};\nfloat clock").concat(n,"_rate_saved[4] = {").concat(e.params.rate1||1,", ").concat(e.params.rate2||.5,", ").concat(e.params.rate3||.25,", ").concat(e.params.rate4||.125,"};\nbool clock").concat(n,"_rate_taken_over[4] = {false, false, false, false}; // Start as NOT taken over\nint clock").concat(n,"_last_bank = -1; // Track bank entry (-1 = first time)\n\n// 8 output states\nbool clock").concat(n,"_out1 = false;\nbool clock").concat(n,"_out2 = false;\nbool clock").concat(n,"_out3 = false;\nbool clock").concat(n,"_out4 = false;\nbool clock").concat(n,"_out5 = false;\nbool clock").concat(n,"_out6 = false;\nbool clock").concat(n,"_out7 = false;\nbool clock").concat(n,"_out8 = false;\n\n// Gate pulse timing (for gate mode outputs)\nunsigned long clock").concat(n,"_gate_start1 = 0, clock").concat(n,"_gate_start2 = 0;\nunsigned long clock").concat(n,"_gate_start3 = 0, clock").concat(n,"_gate_start4 = 0;\nunsigned long clock").concat(n,"_gate_start5 = 0, clock").concat(n,"_gate_start6 = 0;\nunsigned long clock").concat(n,"_gate_start7 = 0, clock").concat(n,"_gate_start8 = 0;\nint clock").concat(n,"_gate_length_ms = ").concat(e.params.gate_length_ms||20,"; // Gate pulse duration\n\n// LED flash output for pot NeoPixel (metronome flash)\nfloat clock").concat(n,"_led_output = 0.0;\nunsigned long clock").concat(n,"_led_start_time = 0;\nint clock").concat(n,"_led_flash_ms = ").concat(e.params.led_flash_ms||50,"; // LED flash duration (50ms default)\n");case"Modulation":return"\n// ".concat(t.label," ").concat(n," - 4LFO Modulation Matrix\nfloat mod").concat(n,"_lfo1_rate = ").concat(e.params.lfo1_rate||1,";\nfloat mod").concat(n,"_lfo2_rate = ").concat(e.params.lfo2_rate||2,";\nfloat mod").concat(n,"_lfo3_rate = ").concat(e.params.lfo3_rate||.5,";\nfloat mod").concat(n,"_lfo4_rate = ").concat(e.params.lfo4_rate||4,";\nfloat mod").concat(n,"_phase1 = 0.0, mod").concat(n,"_phase2 = 0.0;\nfloat mod").concat(n,"_phase3 = 0.0, mod").concat(n,"_phase4 = 0.0;\nfloat mod").concat(n,"_output1 = 0.0, mod").concat(n,"_output2 = 0.0;\nfloat mod").concat(n,"_output3 = 0.0, mod").concat(n,"_output4 = 0.0;\nint mod").concat(n,"_wave1 = ").concat(e.params.wave1||0,"; // 0=sine, 1=tri, 2=saw, 3=square\nint mod").concat(n,"_wave2 = ").concat(e.params.wave2||1,";\nint mod").concat(n,"_wave3 = ").concat(e.params.wave3||2,";\nint mod").concat(n,"_wave4 = ").concat(e.params.wave4||3,";\n");case"Invert":return"\n// ".concat(t.label," ").concat(n," - Control Signal Inverter\nfloat invert").concat(n,"_input = 0.0;\nfloat invert").concat(n,"_output = 0.0;\nfloat invert").concat(n,"_gain = ").concat(e.params.gain||1,";\nfloat invert").concat(n,"_offset = ").concat(e.params.offset||0,";\n");case"HarmonicSequencer":var p=this.generateStepArray(e,4,1,"pitch",function(e){return(.1*e).toFixed(2)}),f=this.generateStepArray(e,4,1,"duration",function(){return"1.0"}),m=this.generateStepArray(e,4,1,"muted",function(){return"false"}),_=this.generateStepArray(e,4,1,"active",function(e){return"true"}),g=this.generateStepArray(e,4,1,"pitchRandomness",function(){return"0.0"}),h=this.generateStepArray(e,4,1,"probability",function(){return"1.0"}),v=this.generateStepArray(e,4,1,"glissando_time",function(){return"0.0"}),b=this.generateStepArray(e,4,1,"glissando_probability",function(){return"0.0"}),y=this.generateStepArray(e,4,1,"glissando_curve",function(){return"0"},function(e){return"exponential"===e?"1":"logarithmic"===e?"2":"0"}),k=this.generateStepArray(e,4,1,"pattern",function(){return"0"},function(e){return"up_down"===e?"1":"chord"===e?"2":"random"===e?"3":"octave"===e?"4":"fifth"===e?"5":"0"}),S=this.generateStepArray(e,4,1,"interval",function(){return"2"}),x=this.generateStepArray(e,4,1,"patternProbability",function(){return"1.0"});return"\n// ".concat(t.label," ").concat(n," - Single-Bank Navigation Sequencer\n// Sequencer state\nbool seq").concat(n,"_running = ").concat(e.params.running||!1,";\nint seq").concat(n,"_current_step = ").concat(e.params.current_step||0,"; // 0-3 (fixed 4 steps)\nint seq").concat(n,"_sequence_length = ").concat(e.params.sequence_length||4,";\nint seq").concat(n,"_loop_start = ").concat(e.params.loop_start||0,";\nint seq").concat(n,"_loop_end = ").concat(e.params.loop_end||3,";\nbool seq").concat(n,"_loop_active = ").concat(e.params.loop_active||!1,";\n\n// Timing\nfloat seq").concat(n,"_bpm = ").concat(e.params.bpm||120,";\nint seq").concat(n,"_clock_div = ").concat(e.params.clock_div||4,";\nfloat seq").concat(n,"_swing = ").concat(e.params.swing||0,";\nfloat seq").concat(n,"_gate_length = ").concat(e.params.gate_length||.7,";\nunsigned long seq").concat(n,"_last_clock = 0;\nunsigned long seq").concat(n,"_step_start_time = 0;\nbool seq").concat(n,"_last_clock_state = false;\nbool seq").concat(n,"_gate_active = false;\n\n// Step data arrays (").concat(1," banks  4 steps each = ").concat(4," total steps)\nfloat seq").concat(n,"_pitch[").concat(4,"] = {").concat(p,"};\nfloat seq").concat(n,"_duration[").concat(4,"] = {").concat(f,"};\nbool seq").concat(n,"_muted[").concat(4,"] = {").concat(m,"};\nbool seq").concat(n,"_active[").concat(4,"] = {").concat(_,"};\nfloat seq").concat(n,"_pitch_randomness[").concat(4,"] = {").concat(g,"};\nfloat seq").concat(n,"_probability[").concat(4,"] = {").concat(h,"};\nfloat seq").concat(n,"_glissando_time[").concat(4,"] = {").concat(v,"};\nfloat seq").concat(n,"_glissando_probability[").concat(4,"] = {").concat(b,"};\nint seq").concat(n,"_glissando_curve[").concat(4,"] = {").concat(y,"}; // 0=linear, 1=exponential, 2=logarithmic\nint seq").concat(n,"_pattern[").concat(4,"] = {").concat(k,"}; // 0=static, 1=up_down, 2=chord, 3=random, 4=octave, 5=fifth\nint seq").concat(n,"_interval[").concat(4,"] = {").concat(S,"}; // Semitone interval amount (1-12)\nfloat seq").concat(n,"_pattern_probability[").concat(4,"] = {").concat(x,"}; // Pattern trigger probability (0.0-1.0)\nint seq").concat(n,"_pattern_counter[").concat(4,"] = {0, 0, 0, 0}; // Pattern alternation counter per step\n\n// Hardware button states\nbool seq").concat(n,"_btn_pressed[4] = {false, false, false, false};\nbool seq").concat(n,"_btn_last[4] = {false, false, false, false};\nunsigned long seq").concat(n,"_btn_press_time[4] = {0, 0, 0, 0}; // Track button press duration\nbool seq").concat(n,"_btn_long_hold_handled[4] = {false, false, false, false}; // Prevent multiple long hold actions\nbool seq").concat(n,"_btn_used_for_shift[4] = {false, false, false, false}; // Track if button was used for shift mode\n\n// Encoder button states for sequence clear\nbool seq").concat(n,"_enc_btn_last = false;\nunsigned long seq").concat(n,"_enc_btn_press_time = 0;\nbool seq").concat(n,"_enc_long_hold_handled = false;\n\n// Playback behavior control\nint seq").concat(n,"_playback_mode = 0; // 0=iteration, 1=rest, 2=reverse\nbool seq").concat(n,"_reverse_direction = false; // For reverse mode\n\n// Soft takeover system for duration control (when in shift mode)\nfloat seq").concat(n,"_last_pot_values[4] = {0.0, 0.0, 0.0, 0.0}; // Last pot positions\nbool seq").concat(n,"_pot_taken_over[4] = {true, true, true, true}; // Has pot taken over pitch control\n\n// Pot smoothing to reduce noise-induced pitch wavering\nfloat seq").concat(n,"_smoothed_pot[4] = {0.0, 0.0, 0.0, 0.0}; // Smoothed pot values\n\n// Cascading harmonic linking system\nbool seq").concat(n,"_harmonic_linking = ").concat(e.params.harmonic_linking?"true":"false",";\nint seq").concat(n,"_harmonic_follow_steps[").concat(4,"] = {").concat(e.params.harmonic_follow_steps?e.params.harmonic_follow_steps.join(", "):"-1, -1, -1, -1","}; // Which step each step follows (-1 = none)\nfloat seq").concat(n,"_harmonic_intervals[").concat(4,"] = {").concat(e.params.harmonic_intervals?e.params.harmonic_intervals.map(function(e){return e/12}).join(", "):"0.583, 0.583, 0.583, 0.583","}; // Convert semitones to CV (7/12 = perfect fifth)\nfloat seq").concat(n,"_base_pitch[").concat(4,"] = {").concat(f.split(", ").map(function(e,n){return"0.0"}).join(", "),"}; // Base pitch before harmonic adjustments\nfloat seq").concat(n,"_last_base_pitch[").concat(4,"] = {").concat(f.split(", ").map(function(e,n){return"0.0"}).join(", "),"}; // Track base pitch changes for cascading updates\nconst float seq").concat(n,"_pot_smooth_factor = 0.8; // Smoothing factor (0.0=no smooth, 1.0=max smooth)\n\n// Musical Scale System (always active)\nconst char* seq").concat(n,'_quantization_scale = "').concat(e.params.quantization_scale||"major",'";\nconst char* seq').concat(n,'_quantization_root = "').concat(e.params.quantization_root||"C",'";\nconst char* seq').concat(n,'_quantization_tuning = "').concat(e.params.quantization_tuning||"12tet",'";\n\n// Outputs\nvolatile float seq').concat(n,"_pitch_sum = 0.0;\nvolatile float seq").concat(n,"_pitch_hz = 440.0;  // Direct frequency output in Hz\nvolatile float seq").concat(n,"_gate_sum = 0.0;\nvolatile float seq").concat(n,"_current_step_cv = 0.0;\nvolatile float seq").concat(n,"_current_bank_cv = 0.0;\nvolatile float seq").concat(n,"_sampled_pitch = 0.0; // Sample-and-hold for pitch randomness\n\n// Random pitch offsets - calculated once per sequence pass, not per step\nfloat seq").concat(n,"_pitch_random_offset[").concat(4,"] = {").concat(f.split(", ").map(function(e,n){return"0.0"}).join(", "),"}; // Random offset per step\nint seq").concat(n,"_last_step = -1; // Track last step to detect sequence loop\n\n// Chord/arpeggio intervals (semitone offsets from root)\n").concat(e.params.steps.map(function(e,t){var a=e.chordIntervals||[0];return"const float seq".concat(n,"_chord_intervals_step").concat(t+1,"[] = {").concat(a.map(function(e){return"".concat(e,".0")}).join(", "),"}; // Step ").concat(t+1," chord intervals\nconst int seq").concat(n,"_chord_intervals_step").concat(t+1,"_count = ").concat(a.length,";")}).join("\n"),"\n// Diatonic mode flags (true = scale-aware transposition)\n").concat(e.params.steps.map(function(e,t){return"const bool seq".concat(n,"_chord_diatonic_step").concat(t+1," = ").concat(!1!==e.chordDiatonic?"true":"false",";")}).join("\n"),"\n// Chord position counters (which interval in the chord is currently playing)\nint seq").concat(n,"_chord_position[").concat(4,"] = {").concat(e.params.steps.map(function(){return"0"}).join(", "),"}; // Current chord tone index per step\n\n// Individual step outputs (4 steps)\nvolatile float seq").concat(n,"_pitch_step1 = 0.0, seq").concat(n,"_pitch_step2 = 0.0, seq").concat(n,"_pitch_step3 = 0.0, seq").concat(n,"_pitch_step4 = 0.0;\nvolatile float seq").concat(n,"_pitch_step1_hz = 440.0, seq").concat(n,"_pitch_step2_hz = 440.0, seq").concat(n,"_pitch_step3_hz = 440.0, seq").concat(n,"_pitch_step4_hz = 440.0;\nvolatile float seq").concat(n,"_gate_step1 = 0.0, seq").concat(n,"_gate_step2 = 0.0, seq").concat(n,"_gate_step3 = 0.0, seq").concat(n,"_gate_step4 = 0.0;\n\n// Glissando state variables\nfloat seq").concat(n,"_glissando_start_pitch = 0.0; // Starting pitch for glissando\nfloat seq").concat(n,"_glissando_target_pitch = 0.0; // Target pitch for glissando\nunsigned long seq").concat(n,"_glissando_start_time = 0; // When glissando started\nbool seq").concat(n,"_glissando_active = false; // Whether glissando is currently active\nvolatile float seq").concat(n,"_glissando_current_hz = 440.0; // Current interpolated frequency\n\n// Pattern variables (melodic patterns)\nbool seq").concat(n,"_pattern_enabled = ").concat(e.params.pattern_enabled?"true":"false",";\nunsigned long seq").concat(n,"_pattern_start_time = 0; // When current step pattern started\nfloat seq").concat(n,"_pattern_phase = 0.0; // Pattern phase (0.0-1.0)\n\n// Pattern calculation function - works around pot position with intervals and probability\nfloat calculatePatternModulation").concat(n,"(int stepIndex, unsigned long currentTime, unsigned long stepStartTime, float stepDuration, float potPosition) {\n    if (!seq").concat(n,"_pattern_enabled) return 0.0;\n\n    int patternType = seq").concat(n,"_pattern[stepIndex];\n    if (patternType == 0) return 0.0; // Static pattern\n\n    // Check probability - use deterministic check based on pattern counter to avoid tremolo\n    float probability = seq").concat(n,"_pattern_probability[stepIndex];\n    // Use pattern counter to create deterministic but varied probability\n    float deterministicCheck = (float)(seq").concat(n,"_pattern_counter[stepIndex] % 100) / 100.0;\n    if (deterministicCheck > probability) return 0.0;\n\n    // Get interval amount in semitones\n    int intervalSemitones = seq").concat(n,"_interval[stepIndex];\n    float intervalCV = (float)intervalSemitones / 12.0; // Convert semitones to CV (1V/oct)\n\n    // Calculate pattern phase (0.0-1.0) based on time within step\n    float stepTimeMs = stepDuration * 1000.0;\n    float elapsedTime = (float)(currentTime - stepStartTime);\n    float phase = elapsedTime / stepTimeMs;\n    phase = constrain(phase, 0.0, 1.0);\n\n    float modulation = 0.0;\n    switch (patternType) {\n        case 1: // Up/Down Alternating - alternate between +interval and -interval\n            modulation = (seq").concat(n,"_pattern_counter[stepIndex] % 2 == 0) ? intervalCV : -intervalCV;\n            break;\n\n        case 2: // Chord/Arpeggio - cycle through custom chord intervals per pass\n            {\n                // Get the correct chord interval array and count for this step\n                const float* chordIntervals;\n                int chordCount;\n                switch (stepIndex) {\n                    case 0: chordIntervals = seq").concat(n,"_chord_intervals_step1; chordCount = seq").concat(n,"_chord_intervals_step1_count; break;\n                    case 1: chordIntervals = seq").concat(n,"_chord_intervals_step2; chordCount = seq").concat(n,"_chord_intervals_step2_count; break;\n                    case 2: chordIntervals = seq").concat(n,"_chord_intervals_step3; chordCount = seq").concat(n,"_chord_intervals_step3_count; break;\n                    case 3: chordIntervals = seq").concat(n,"_chord_intervals_step4; chordCount = seq").concat(n,"_chord_intervals_step4_count; break;\n                    default: chordIntervals = seq").concat(n,"_chord_intervals_step1; chordCount = 1; break;\n                }\n\n                // Cycle through chord tones - one different tone per pass through step\n                int chordTone = seq").concat(n,"_pattern_counter[stepIndex] % chordCount;\n                float intervalSemitones = chordIntervals[chordTone];\n                modulation = intervalSemitones / 12.0; // Convert semitones to CV (1V/oct)\n            }\n            break;\n\n        case 3: // Random Jump - random interval amount\n            modulation = (((float)random(0, 1000) / 1000.0) - 0.5) * 2.0 * intervalCV;\n            break;\n\n        case 4: // Octave Jump - alternate between pot position and +octave\n            modulation = (seq").concat(n,"_pattern_counter[stepIndex] % 2 == 0) ? 0.0 : (12.0 / 12.0); // +1 octave\n            break;\n\n        case 5: // Fifth Jump - alternate between pot position and +perfect fifth\n            modulation = (seq").concat(n,"_pattern_counter[stepIndex] % 2 == 0) ? 0.0 : (7.0 / 12.0); // +perfect fifth\n            break;\n    }\n\n    return modulation;\n}\n\n// Cascading harmonic relationship system - allows chained dependencies\nvoid updateHarmonicRelationships").concat(n,"() {\n    if (!seq").concat(n,"_harmonic_linking) return;\n\n    // Check each step to see if its followed step has changed\n    bool needsAnotherPass = true;\n    int passCount = 0;\n    const int maxPasses = 4; // Prevent infinite loops\n\n    while (needsAnotherPass && passCount < maxPasses) {\n        needsAnotherPass = false;\n        passCount++;\n\n        for (int step = 0; step < ").concat(4,"; step++) {\n            int followsStep = seq").concat(n,"_harmonic_follow_steps[step];\n            if (followsStep == -1) continue; // This step doesn't follow anyone\n\n            // Check if the step we're following has changed its base pitch\n            float followedBasePitch = seq").concat(n,"_base_pitch[followsStep];\n            if (abs(followedBasePitch - seq").concat(n,"_last_base_pitch[followsStep]) > 0.001) {\n                // The followed step's base pitch changed, update this step\n                float pitchChange = followedBasePitch - seq").concat(n,"_last_base_pitch[followsStep];\n\n                // Apply additive harmonic interval + cascading change\n                float harmonicInterval = seq").concat(n,"_harmonic_intervals[step];\n                float newPitch = seq").concat(n,"_base_pitch[step] + pitchChange + harmonicInterval;\n\n                // Extended range: allow harmonic relationships to exceed 0-1 pot range\n                // Clamp to reasonable musical range: -2 to +3 (5 octave span)\n                newPitch = constrain(newPitch, -2.0, 3.0);\n\n                // Update this step's pitch if it changed significantly\n                if (abs(newPitch - seq").concat(n,"_pitch[step]) > 0.001) {\n                    seq").concat(n,"_pitch[step] = newPitch;\n                    // Mark that we need another pass to handle cascading\n                    needsAnotherPass = true;\n                }\n            }\n        }\n\n        // Update last base pitch tracking after each pass\n        for (int step = 0; step < ").concat(4,"; step++) {\n            seq").concat(n,"_last_base_pitch[step] = seq").concat(n,"_base_pitch[step];\n        }\n    }\n}\n");default:return""}}},{key:"generateGlissandoFunction",value:function(e,n){return"\n// Glissando interpolation function for Sequencer ".concat(n,"\nfloat glissandoInterpolate").concat(n,'(float startPitch, float targetPitch, float progress, const char* curve) {\n    // Clamp progress to 0-1 range\n    progress = constrain(progress, 0.0, 1.0);\n\n    if (strcmp(curve, "linear") == 0) {\n        // Linear interpolation\n        return startPitch + (targetPitch - startPitch) * progress;\n    } else if (strcmp(curve, "exponential") == 0) {\n        // Exponential curve (fast start, slow end)\n        float expProgress = 1.0 - exp(-3.0 * progress);\n        return startPitch + (targetPitch - startPitch) * expProgress;\n    } else if (strcmp(curve, "logarithmic") == 0) {\n        // Logarithmic curve (slow start, fast end)\n        float logProgress = log(1.0 + progress * (exp(1.0) - 1.0));\n        return startPitch + (targetPitch - startPitch) * logProgress;\n    } else {\n        // Default to linear\n        return startPitch + (targetPitch - startPitch) * progress;\n    }\n}\n')}},{key:"generateQuantizationFunction",value:function(e,n){return"\n// Musical Scale Quantization Function for Sequencer ".concat(n,"\nfloat quantizePitch").concat(n,"(float inputPitch) {\n\n    // Convert 0-1 pitch to MIDI note number (C3=48 to C7=84, 3 octaves)\n    float midiNote = 48.0 + (inputPitch * 36.0);\n\n    // Get root note offset (C=0, C#=1, D=2, etc.)\n    int rootOffset = 0;\n    if (strcmp(seq").concat(n,'_quantization_root, "C#") == 0 || strcmp(seq').concat(n,'_quantization_root, "Db") == 0) rootOffset = 1;\n    else if (strcmp(seq').concat(n,'_quantization_root, "D") == 0) rootOffset = 2;\n    else if (strcmp(seq').concat(n,'_quantization_root, "D#") == 0 || strcmp(seq').concat(n,'_quantization_root, "Eb") == 0) rootOffset = 3;\n    else if (strcmp(seq').concat(n,'_quantization_root, "E") == 0) rootOffset = 4;\n    else if (strcmp(seq').concat(n,'_quantization_root, "F") == 0) rootOffset = 5;\n    else if (strcmp(seq').concat(n,'_quantization_root, "F#") == 0 || strcmp(seq').concat(n,'_quantization_root, "Gb") == 0) rootOffset = 6;\n    else if (strcmp(seq').concat(n,'_quantization_root, "G") == 0) rootOffset = 7;\n    else if (strcmp(seq').concat(n,'_quantization_root, "G#") == 0 || strcmp(seq').concat(n,'_quantization_root, "Ab") == 0) rootOffset = 8;\n    else if (strcmp(seq').concat(n,'_quantization_root, "A") == 0) rootOffset = 9;\n    else if (strcmp(seq').concat(n,'_quantization_root, "A#") == 0 || strcmp(seq').concat(n,'_quantization_root, "Bb") == 0) rootOffset = 10;\n    else if (strcmp(seq').concat(n,'_quantization_root, "B") == 0) rootOffset = 11;\n\n    // Define scale intervals\n    int scaleIntervals[12];\n    int scaleLength = 12;\n\n    if (strcmp(seq').concat(n,'_quantization_scale, "major") == 0) {\n        int intervals[] = {0, 2, 4, 5, 7, 9, 11};\n        scaleLength = 7;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else if (strcmp(seq').concat(n,'_quantization_scale, "minor") == 0) {\n        int intervals[] = {0, 2, 3, 5, 7, 8, 10};\n        scaleLength = 7;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else if (strcmp(seq').concat(n,'_quantization_scale, "pentatonic_major") == 0) {\n        int intervals[] = {0, 2, 4, 7, 9};\n        scaleLength = 5;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else if (strcmp(seq').concat(n,'_quantization_scale, "pentatonic_minor") == 0) {\n        int intervals[] = {0, 3, 5, 7, 10};\n        scaleLength = 5;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else if (strcmp(seq').concat(n,'_quantization_scale, "blues") == 0) {\n        int intervals[] = {0, 3, 5, 6, 7, 10};\n        scaleLength = 6;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else if (strcmp(seq').concat(n,'_quantization_scale, "dorian") == 0) {\n        int intervals[] = {0, 2, 3, 5, 7, 9, 10};\n        scaleLength = 7;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else if (strcmp(seq').concat(n,'_quantization_scale, "wholetone") == 0) {\n        int intervals[] = {0, 2, 4, 6, 8, 10};\n        scaleLength = 6;\n        for (int i = 0; i < scaleLength; i++) scaleIntervals[i] = intervals[i];\n    } else {\n        // Chromatic or unknown scale - all 12 semitones\n        for (int i = 0; i < 12; i++) scaleIntervals[i] = i;\n        scaleLength = 12;\n    }\n\n    // Get the note within the octave (0-11)\n    int noteInOctave = ((int)midiNote + rootOffset) % 12;\n    int octave = ((int)midiNote + rootOffset) / 12;\n\n    // Find closest scale note\n    int closestInterval = scaleIntervals[0];\n    int minDistance = abs(noteInOctave - closestInterval);\n\n    for (int i = 1; i < scaleLength; i++) {\n        int distance = abs(noteInOctave - scaleIntervals[i]);\n        if (distance < minDistance) {\n            minDistance = distance;\n            closestInterval = scaleIntervals[i];\n        }\n    }\n\n    // Handle wrapping at octave boundaries\n    if (minDistance > 6) {\n        // Check if wrapping to next/previous octave is closer\n        int wrapUpDistance = abs(noteInOctave - (closestInterval + 12));\n        int wrapDownDistance = abs(noteInOctave - (closestInterval - 12));\n\n        if (wrapUpDistance < minDistance) {\n            closestInterval += 12;\n            octave -= 1;\n        } else if (wrapDownDistance < minDistance) {\n            closestInterval -= 12;\n            octave += 1;\n        }\n    }\n\n    // Reconstruct quantized MIDI note\n    float quantizedMidi = (octave * 12) + closestInterval - rootOffset;\n\n    // Convert back to 0-1 range\n    float quantizedPitch = (quantizedMidi - 48.0) / 36.0;\n\n    // Clamp to valid range\n    if (quantizedPitch < 0.0) quantizedPitch = 0.0;\n    if (quantizedPitch > 1.0) quantizedPitch = 1.0;\n\n    return quantizedPitch;\n}\n')}},{key:"generateProcessingCode",value:function(e,n,t){switch(e.type){case"ADSR":return this.generateADSRCode(e,n,t);case"Scale":return this.generateScaleCode(e,n,t);case"LFO":return this.generateLFOCode(e,n,t);case"GateGen":return this.generateGateGenCode(e,n,t);case"MIDIIn":return this.generateMIDIInCode(e,n,t);case"Clock":return this.generateClockCode(e,n,t);case"Modulation":return this.generateModulationCode(e,n,t);case"Invert":return this.generateInvertCode(e,n,t);case"HarmonicSequencer":return this.generateHarmonicSequencerCode(e,n,t);case"Automation":return this.generateAutomationCode(e,n,t);default:return""}}},{key:"generateADSRCode",value:function(e,n,t){return"\n        // ADSR ".concat(n," processing\n        {\n            bool currentGate = (adsr").concat(n,"_gate > 0.5);\n            \n            // Gate edge detection\n            if (currentGate && !adsr").concat(n,"_lastGate) {\n                // Gate on - start attack\n                // Capture current level to avoid click (smooth retriggering)\n                adsr").concat(n,"_attackStartLevel = adsr").concat(n,"_level;\n                adsr").concat(n,"_stage = 1;\n                adsr").concat(n,"_stageTime = 0.0;\n            } else if (!currentGate && adsr").concat(n,"_lastGate) {\n                // Gate off - start release\n                if (adsr").concat(n,"_stage != 0) {\n                    adsr").concat(n,"_releaseStartLevel = adsr").concat(n,"_level; // Capture current level for release\n                    adsr").concat(n,"_stage = 4;\n                    adsr").concat(n,"_stageTime = 0.0;\n                }\n            }\n            \n            adsr").concat(n,"_lastGate = currentGate;\n\n            // Process envelope stages\n            // CRITICAL: This runs once per buffer, so advance time by buffer duration\n            // timescale > 1 = slower (more time per buffer), timescale < 1 = faster (less time per buffer)\n            float bufferTime = (BUFFER_SIZE / 44100.0) / adsr").concat(n,"_timescale; // Buffer duration in seconds (DIVIDE for correct behavior)\n            adsr").concat(n,"_stageTime += bufferTime;\n            \n            switch (adsr").concat(n,"_stage) {\n                case 0: // Idle\n                    adsr").concat(n,"_level = 0.0;\n                    break;\n                    \n                case 1: // Attack\n                    if (adsr").concat(n,"_attack > 0.0) {\n                        float progress = adsr").concat(n,"_stageTime / adsr").concat(n,"_attack;\n                        if (progress >= 1.0) {\n                            adsr").concat(n,"_level = 1.0;\n                            adsr").concat(n,"_stage = 2;\n                            adsr").concat(n,"_stageTime = 0.0;\n                        } else {\n                            // Smooth attack: interpolate from captured start level to 1.0\n                            // This prevents clicks when retriggering during decay/release\n                            adsr").concat(n,"_level = adsr").concat(n,"_attackStartLevel + (1.0 - adsr").concat(n,"_attackStartLevel) * progress;\n                        }\n                    } else {\n                        adsr").concat(n,"_level = 1.0;\n                        adsr").concat(n,"_stage = 2;\n                        adsr").concat(n,"_stageTime = 0.0;\n                    }\n                    break;\n                    \n                case 2: // Decay\n                    if (adsr").concat(n,"_decay > 0.0) {\n                        float progress = adsr").concat(n,"_stageTime / adsr").concat(n,"_decay;\n                        if (progress >= 1.0) {\n                            adsr").concat(n,"_level = adsr").concat(n,"_sustain;\n                            adsr").concat(n,"_stage = 3;\n                        } else {\n                            adsr").concat(n,"_level = 1.0 - progress * (1.0 - adsr").concat(n,"_sustain);\n                        }\n                    } else {\n                        adsr").concat(n,"_level = adsr").concat(n,"_sustain;\n                        adsr").concat(n,"_stage = 3;\n                    }\n                    break;\n                    \n                case 3: // Sustain\n                    adsr").concat(n,"_level = adsr").concat(n,"_sustain;\n                    break;\n                    \n                case 4: // Release\n                    if (adsr").concat(n,"_release > 0.0) {\n                        float progress = adsr").concat(n,"_stageTime / adsr").concat(n,"_release;\n                        if (progress >= 1.0) {\n                            adsr").concat(n,"_level = 0.0;\n\n                            // Looping logic\n                            if (strcmp(adsr").concat(n,'_loop_mode, "loop") == 0) {\n                                // Loop mode: restart attack from 0\n                                adsr').concat(n,"_attackStartLevel = 0.0;\n                                adsr").concat(n,"_stage = 1; // Go to attack\n                                adsr").concat(n,"_stageTime = 0.0;\n                            } else if (strcmp(adsr").concat(n,'_loop_mode, "pingpong") == 0) {\n                                // Pingpong mode: reverse direction (future implementation)\n                                adsr').concat(n,"_attackStartLevel = 0.0;\n                                adsr").concat(n,"_stage = 1; // For now, same as loop\n                                adsr").concat(n,"_stageTime = 0.0;\n                            } else {\n                                // Oneshot mode: go to idle\n                                adsr").concat(n,"_stage = 0;\n                            }\n                        } else {\n                            // Exponential release curve: faster at start, slower toward zero\n                            float releaseAmount = progress * progress; // Quadratic curve for smooth release\n                            adsr").concat(n,"_level = adsr").concat(n,"_releaseStartLevel * (1.0 - releaseAmount);\n\n                            // Ensure envelope reaches exactly zero when very close\n                            if (adsr").concat(n,"_level < 0.001) {\n                                adsr").concat(n,"_level = 0.0;\n\n                                // Looping logic for early termination\n                                if (strcmp(adsr").concat(n,'_loop_mode, "loop") == 0) {\n                                    adsr').concat(n,"_attackStartLevel = 0.0;\n                                    adsr").concat(n,"_stage = 1;\n                                    adsr").concat(n,"_stageTime = 0.0;\n                                } else if (strcmp(adsr").concat(n,'_loop_mode, "pingpong") == 0) {\n                                    adsr').concat(n,"_attackStartLevel = 0.0;\n                                    adsr").concat(n,"_stage = 1;\n                                    adsr").concat(n,"_stageTime = 0.0;\n                                } else {\n                                    adsr").concat(n,"_stage = 0;\n                                }\n                            }\n                        }\n                    } else {\n                        adsr").concat(n,"_level = 0.0;\n\n                        // Looping logic for instant release\n                        if (strcmp(adsr").concat(n,'_loop_mode, "loop") == 0) {\n                            adsr').concat(n,"_attackStartLevel = 0.0;\n                            adsr").concat(n,"_stage = 1;\n                            adsr").concat(n,"_stageTime = 0.0;\n                        } else if (strcmp(adsr").concat(n,'_loop_mode, "pingpong") == 0) {\n                            adsr').concat(n,"_attackStartLevel = 0.0;\n                            adsr").concat(n,"_stage = 1;\n                            adsr").concat(n,"_stageTime = 0.0;\n                        } else {\n                            adsr").concat(n,"_stage = 0;\n                        }\n                    }\n                    break;\n            }\n\n            // Store previous output and set new target for interpolation\n            adsr").concat(n,"_prevOutput = adsr").concat(n,"_output;\n            adsr").concat(n,"_targetOutput = adsr").concat(n,"_level;\n        }\n")}},{key:"generateScaleCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&("in"===n.to.port||void 0===n.to.port)}),o="0.0",r="",c=this.connectionResolver.modules.find(function(e){return"HarmonicSequencer"===e.type});if(c){var i,l=(null===(i=c.id.match(/\d+$/))||void 0===i?void 0:i[0])||"1";o="seq".concat(l,"_pitch_sum"),r="seq".concat(l,"_running && seq").concat(l,"_gate_active")}else r="false";if(a){var s=a.from.id.split(":")[0],u=this.connectionResolver.modules.find(function(e){return e.id===s});if(u){var d,p=(null===(d=s.match(/\d+$/))||void 0===d?void 0:d[0])||"1";switch(u.type){case"GateGen":o="gate".concat(p,"_sh_output");break;case"LFO":o="lfo".concat(p,"_output");break;case"Pot":o="pot".concat(p,"_value")}}}return"\n        // Scale ".concat(n," processing\n        {\n            float input = ").concat(o,";\n            scale").concat(n,"_input = input;\n\n            // Only output frequency when HarmonicSequencer is running and has a gate\n            bool hasActiveGate = ").concat(r,";\n\n            static float lastInput = -1.0;\n            static float lastOutput = 0.0;\n            static bool lastGateState = false;\n            static unsigned long lastDebugTime = 0;\n\n            // Debug output every 100ms or when values change significantly\n            unsigned long currentTime = millis();\n            bool shouldDebug = (currentTime - lastDebugTime > 100) ||\n                              (abs(input - lastInput) > 0.01) ||\n                              (hasActiveGate != lastGateState);\n\n            if (hasActiveGate && input > 0.0) {\n                // Convert 0-1 input to MIDI note number using module parameters\n                int baseOctave = ").concat(e.params.base_octave||4,"; // Base octave (C4 = octave 4)\n                int octaveRange = ").concat(e.params.octave_range||2,'; // Octaves to span\n                int baseNote = (baseOctave * 12) + 12; // Convert octave to MIDI note (C0=12, C4=60)\n                int rangeSemitones = octaveRange * 12; // Convert octaves to semitones\n                int midiNote = baseNote + (int)(input * rangeSemitones);\n                float newOutput = 440.0 * pow(2.0, (midiNote - 69) / 12.0); // Convert to frequency\n\n                // Debug output changes\n                if (shouldDebug && (abs(newOutput - lastOutput) > 1.0)) {\n                    Serial.print("Scale').concat(n,': IN=");\n                    Serial.print(input, 3);\n                    Serial.print(" MIDI=");\n                    Serial.print(midiNote);\n                    Serial.print(" FREQ=");\n                    Serial.print(newOutput, 1);\n                    Serial.print(" GATE=");\n                    Serial.println(hasActiveGate ? "ON" : "OFF");\n                    lastDebugTime = currentTime;\n                }\n\n                scale').concat(n,'_output = newOutput;\n                lastOutput = newOutput;\n            } else {\n                // No active gate or zero input - maintain last frequency to avoid clicks\n                if (shouldDebug && hasActiveGate != lastGateState) {\n                    Serial.print("Scale').concat(n,': GATE=");\n                    Serial.print(hasActiveGate ? "ON" : "OFF");\n                    Serial.print(" (holding freq=");\n                    Serial.print(scale').concat(n,'_output, 1);\n                    Serial.println(")");\n                    lastDebugTime = currentTime;\n                }\n                // scale').concat(n,"_output remains at last value\n            }\n\n            lastInput = input;\n            lastGateState = hasActiveGate;\n        }\n")}},{key:"generateLFOCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"rate_hz"===n.to.port}),o="lfo".concat(n,"_rate_hz");if(a){var r=a.from.id.split(":")[0],c=this.connectionResolver.modules.find(function(e){return e.id===r});if(c){var i,l=(null===(i=r.match(/\d+$/))||void 0===i?void 0:i[0])||"1",s=e.params.rate_min_hz||.01,u=(e.params.rate_max_hz||40)-s;switch(c.type){case"Pot":o="(".concat(s," + pot").concat(l,"_value * ").concat(u,")");break;case"ADSR":o="(".concat(s," + adsr").concat(l,"_output * ").concat(u,")")}}}var d=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"depth"===n.to.port}),p="lfo".concat(n,"_depth");if(d){var f=d.from.id.split(":")[0],m=this.connectionResolver.modules.find(function(e){return e.id===f});if(m){var _,g=(null===(_=f.match(/\d+$/))||void 0===_?void 0:_[0])||"1";switch(m.type){case"Pot":p="pot".concat(g,"_value");break;case"ADSR":p="adsr".concat(g,"_output");break;case"LFO":p="((lfo".concat(g,"_output + 1.0) * 0.5)")}}}return"\n        // LFO ".concat(n," - Low Frequency Oscillator (RESTORED ORIGINAL IMPLEMENTATION)\n        {\n            unsigned long currentTime = millis();\n\n            // Update LFO phase based on rate\n            if (!lfo").concat(n,"_sync_to_clock) {\n                // Free-running mode\n                float deltaTime = (currentTime - lfo").concat(n,"_last_update) / 1000.0; // Convert to seconds\n                lfo").concat(n,"_phase += ").concat(o," * deltaTime * 2.0 * M_PI;\n\n                // Wrap phase to 0-2\n                while (lfo").concat(n,"_phase >= 2.0 * M_PI) {\n                    lfo").concat(n,"_phase -= 2.0 * M_PI;\n                }\n            } else {\n                // Clock-sync mode - would need clock input connection\n                // For now, just use free-running mode\n            }\n            lfo").concat(n,"_last_update = currentTime;\n\n            // Generate LFO waveform\n            float waveValue = 0.0;\n            switch (lfo").concat(n,"_wave) {\n                case 0: // Sine\n                    waveValue = sin(lfo").concat(n,"_phase);\n                    break;\n                case 1: // Sawtooth\n                    waveValue = 2.0 * (lfo").concat(n,"_phase / (2.0 * M_PI)) - 1.0;\n                    break;\n                case 2: // Square\n                    waveValue = (lfo").concat(n,"_phase < M_PI) ? 1.0 : -1.0;\n                    break;\n                case 3: // Triangle\n                    if (lfo").concat(n,"_phase < M_PI) {\n                        waveValue = -1.0 + 2.0 * (lfo").concat(n,"_phase / M_PI);\n                    } else {\n                        waveValue = 1.0 - 2.0 * ((lfo").concat(n,"_phase - M_PI) / M_PI);\n                    }\n                    break;\n            }\n\n            // Apply depth and offset\n            // With offset=0.5, depth=0.5: waveValue (-1 to +1) maps to output (0 to 1)\n            // With offset=0.0, depth=1.0: waveValue (-1 to +1) maps to output (-1 to +1)\n            lfo").concat(n,"_output = lfo").concat(n,"_offset + (waveValue * ").concat(p,");\n\n            // Note: No clamping - allow bipolar output for modulation sources\n            // Control connections will handle range conversion as needed\n        }\n")}},{key:"generateClockCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"bpm_input"===n.to.port}),o="clock".concat(n,"_bpm");if(a){var r=a.from.id.split(":")[0],c=this.connectionResolver.modules.find(function(e){return e.id===r});if(c){var i,l=(null===(i=r.match(/\d+$/))||void 0===i?void 0:i[0])||"1";switch(c.type){case"Pot":o="(40.0 + pot".concat(l,"_value * 200.0)");break;case"LFO":o="(40.0 + (lfo".concat(l,"_output * 0.5 + 0.5) * 200.0)")}}}return"\n        // Clock ".concat(n," - 8-output divider processing\n        {\n            unsigned long currentTime = millis();\n\n            // Update BPM from connection\n            clock").concat(n,"_bpm = ").concat(o,";\n\n            // Master clock tick\n            if (clock").concat(n,"_running) {\n                clock").concat(n,"_period_ms = 60000.0 / clock").concat(n,"_bpm; // Period in ms\n\n                if (currentTime - clock").concat(n,"_last_tick >= clock").concat(n,"_period_ms) {\n                    // Master tick occurred\n                    clock").concat(n,"_master_pulse = true;\n                    clock").concat(n,"_last_tick = currentTime;\n\n                    // Increment master phase\n                    clock").concat(n,"_master_phase += 1.0;\n\n                    // Process all 8 outputs with rate multipliers, gate modes, and probability\n                    // Output 1\n                    float effective_rate1 = clock").concat(n,"_fill1 ? (clock").concat(n,"_rate1 * clock").concat(n,"_euclid1) : clock").concat(n,"_rate1;\n                    clock").concat(n,"_counter1 += effective_rate1;\n                    if (clock").concat(n,"_counter1 >= 1.0) {\n                        clock").concat(n,"_counter1 -= 1.0;  // Preserve fractional remainder\n                        // Probability check: base probability  pot attenuation (when fill active)\n                        float effective_prob1 = clock").concat(n,"_fill1 ? (clock").concat(n,"_prob1 * clock").concat(n,"_pot_value1) : clock").concat(n,"_prob1;\n                        if ((float)random(10000) / 10000.0 <= effective_prob1) {\n                            if (clock").concat(n,"_gate_mode1) {\n                                // Gate mode: pulse HIGH then LOW\n                                clock").concat(n,"_out1 = true;\n                                clock").concat(n,"_gate_start1 = currentTime;\n                            } else {\n                                // Toggle mode: alternate HIGH/LOW\n                                clock").concat(n,"_out1 = !clock").concat(n,"_out1;\n                            }\n                        }\n                    }\n\n                    // Output 2\n                    float effective_rate2 = clock").concat(n,"_fill2 ? (clock").concat(n,"_rate2 * clock").concat(n,"_euclid2) : clock").concat(n,"_rate2;\n                    clock").concat(n,"_counter2 += effective_rate2;\n                    if (clock").concat(n,"_counter2 >= 1.0) {\n                        clock").concat(n,"_counter2 -= 1.0;\n                        float effective_prob2 = clock").concat(n,"_fill2 ? (clock").concat(n,"_prob2 * clock").concat(n,"_pot_value2) : clock").concat(n,"_prob2;\n                        if ((float)random(10000) / 10000.0 <= effective_prob2) {\n                            if (clock").concat(n,"_gate_mode2) {\n                                clock").concat(n,"_out2 = true;\n                                clock").concat(n,"_gate_start2 = currentTime;\n                            } else {\n                                clock").concat(n,"_out2 = !clock").concat(n,"_out2;\n                            }\n                        }\n                    }\n\n                    // Output 3\n                    float effective_rate3 = clock").concat(n,"_fill3 ? (clock").concat(n,"_rate3 * clock").concat(n,"_euclid3) : clock").concat(n,"_rate3;\n                    clock").concat(n,"_counter3 += effective_rate3;\n                    if (clock").concat(n,"_counter3 >= 1.0) {\n                        clock").concat(n,"_counter3 -= 1.0;\n                        float effective_prob3 = clock").concat(n,"_fill3 ? (clock").concat(n,"_prob3 * clock").concat(n,"_pot_value3) : clock").concat(n,"_prob3;\n                        if ((float)random(10000) / 10000.0 <= effective_prob3) {\n                            if (clock").concat(n,"_gate_mode3) {\n                                clock").concat(n,"_out3 = true;\n                                clock").concat(n,"_gate_start3 = currentTime;\n                            } else {\n                                clock").concat(n,"_out3 = !clock").concat(n,"_out3;\n                            }\n                        }\n                    }\n\n                    // Output 4\n                    float effective_rate4 = clock").concat(n,"_fill4 ? (clock").concat(n,"_rate4 * clock").concat(n,"_euclid4) : clock").concat(n,"_rate4;\n                    clock").concat(n,"_counter4 += effective_rate4;\n                    if (clock").concat(n,"_counter4 >= 1.0) {\n                        clock").concat(n,"_counter4 -= 1.0;\n                        float effective_prob4 = clock").concat(n,"_fill4 ? (clock").concat(n,"_prob4 * clock").concat(n,"_pot_value4) : clock").concat(n,"_prob4;\n                        if ((float)random(10000) / 10000.0 <= effective_prob4) {\n                            if (clock").concat(n,"_gate_mode4) {\n                                clock").concat(n,"_out4 = true;\n                                clock").concat(n,"_gate_start4 = currentTime;\n                            } else {\n                                clock").concat(n,"_out4 = !clock").concat(n,"_out4;\n                            }\n                        }\n                    }\n\n                    // Output 5\n                    float effective_rate5 = clock").concat(n,"_fill5 ? (clock").concat(n,"_rate5 * clock").concat(n,"_euclid5) : clock").concat(n,"_rate5;\n                    clock").concat(n,"_counter5 += effective_rate5;\n                    if (clock").concat(n,"_counter5 >= 1.0) {\n                        clock").concat(n,"_counter5 -= 1.0;\n                        float effective_prob5 = clock").concat(n,"_fill5 ? (clock").concat(n,"_prob5 * clock").concat(n,"_pot_value5) : clock").concat(n,"_prob5;\n                        if ((float)random(10000) / 10000.0 <= effective_prob5) {\n                            if (clock").concat(n,"_gate_mode5) {\n                                clock").concat(n,"_out5 = true;\n                                clock").concat(n,"_gate_start5 = currentTime;\n                            } else {\n                                clock").concat(n,"_out5 = !clock").concat(n,"_out5;\n                            }\n                        }\n                    }\n\n                    // Output 6\n                    float effective_rate6 = clock").concat(n,"_fill6 ? (clock").concat(n,"_rate6 * clock").concat(n,"_euclid6) : clock").concat(n,"_rate6;\n                    clock").concat(n,"_counter6 += effective_rate6;\n                    if (clock").concat(n,"_counter6 >= 1.0) {\n                        clock").concat(n,"_counter6 -= 1.0;\n                        float effective_prob6 = clock").concat(n,"_fill6 ? (clock").concat(n,"_prob6 * clock").concat(n,"_pot_value6) : clock").concat(n,"_prob6;\n                        if ((float)random(10000) / 10000.0 <= effective_prob6) {\n                            if (clock").concat(n,"_gate_mode6) {\n                                clock").concat(n,"_out6 = true;\n                                clock").concat(n,"_gate_start6 = currentTime;\n                            } else {\n                                clock").concat(n,"_out6 = !clock").concat(n,"_out6;\n                            }\n                        }\n                    }\n\n                    // Output 7\n                    float effective_rate7 = clock").concat(n,"_fill7 ? (clock").concat(n,"_rate7 * clock").concat(n,"_euclid7) : clock").concat(n,"_rate7;\n                    clock").concat(n,"_counter7 += effective_rate7;\n                    if (clock").concat(n,"_counter7 >= 1.0) {\n                        clock").concat(n,"_counter7 -= 1.0;\n                        float effective_prob7 = clock").concat(n,"_fill7 ? (clock").concat(n,"_prob7 * clock").concat(n,"_pot_value7) : clock").concat(n,"_prob7;\n                        if ((float)random(10000) / 10000.0 <= effective_prob7) {\n                            if (clock").concat(n,"_gate_mode7) {\n                                clock").concat(n,"_out7 = true;\n                                clock").concat(n,"_gate_start7 = currentTime;\n                            } else {\n                                clock").concat(n,"_out7 = !clock").concat(n,"_out7;\n                            }\n                        }\n                    }\n\n                    // Output 8\n                    float effective_rate8 = clock").concat(n,"_fill8 ? (clock").concat(n,"_rate8 * clock").concat(n,"_euclid8) : clock").concat(n,"_rate8;\n                    clock").concat(n,"_counter8 += effective_rate8;\n                    if (clock").concat(n,"_counter8 >= 1.0) {\n                        clock").concat(n,"_counter8 -= 1.0;\n                        float effective_prob8 = clock").concat(n,"_fill8 ? (clock").concat(n,"_prob8 * clock").concat(n,"_pot_value8) : clock").concat(n,"_prob8;\n                        if ((float)random(10000) / 10000.0 <= effective_prob8) {\n                            if (clock").concat(n,"_gate_mode8) {\n                                clock").concat(n,"_out8 = true;\n                                clock").concat(n,"_gate_start8 = currentTime;\n                            } else {\n                                clock").concat(n,"_out8 = !clock").concat(n,"_out8;\n                            }\n                        }\n                    }\n\n                    clock").concat(n,"_master_pulse = false;\n                }\n\n                // Gate pulse end detection (turn off gates after gate_length_ms)\n                if (clock").concat(n,"_gate_mode1 && clock").concat(n,"_out1 && (currentTime - clock").concat(n,"_gate_start1 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out1 = false;\n                }\n                if (clock").concat(n,"_gate_mode2 && clock").concat(n,"_out2 && (currentTime - clock").concat(n,"_gate_start2 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out2 = false;\n                }\n                if (clock").concat(n,"_gate_mode3 && clock").concat(n,"_out3 && (currentTime - clock").concat(n,"_gate_start3 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out3 = false;\n                }\n                if (clock").concat(n,"_gate_mode4 && clock").concat(n,"_out4 && (currentTime - clock").concat(n,"_gate_start4 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out4 = false;\n                }\n                if (clock").concat(n,"_gate_mode5 && clock").concat(n,"_out5 && (currentTime - clock").concat(n,"_gate_start5 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out5 = false;\n                }\n                if (clock").concat(n,"_gate_mode6 && clock").concat(n,"_out6 && (currentTime - clock").concat(n,"_gate_start6 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out6 = false;\n                }\n                if (clock").concat(n,"_gate_mode7 && clock").concat(n,"_out7 && (currentTime - clock").concat(n,"_gate_start7 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out7 = false;\n                }\n                if (clock").concat(n,"_gate_mode8 && clock").concat(n,"_out8 && (currentTime - clock").concat(n,"_gate_start8 >= clock").concat(n,"_gate_length_ms)) {\n                    clock").concat(n,"_out8 = false;\n                }\n            } else {\n                // Clock stopped - reset all gate outputs to LOW for proper note release\n                clock").concat(n,"_out1 = false;\n                clock").concat(n,"_out2 = false;\n                clock").concat(n,"_out3 = false;\n                clock").concat(n,"_out4 = false;\n                clock").concat(n,"_out5 = false;\n                clock").concat(n,"_out6 = false;\n                clock").concat(n,"_out7 = false;\n                clock").concat(n,"_out8 = false;\n                clock").concat(n,"_master_pulse = false;\n            }\n        }\n")}},{key:"generateGateGenCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"self_clock_bpm"===n.to.port}),o=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"probability"===n.to.port}),r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate_input"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"sh_input"===n.to.port}),i="gate".concat(n,"_self_clock_bpm"),l="gate".concat(n,"_probability"),s="true",u="0.5",d=e.params.bpm_min||40,p=(e.params.bpm_max||180)-d;if(a){var f=a.from.id.split(":")[0],m=this.connectionResolver.modules.find(function(e){return e.id===f});if(m){var _,g=(null===(_=f.match(/\d+$/))||void 0===_?void 0:_[0])||"1";"Pot"===m.type&&(i="(".concat(d,".0 + pot").concat(g,"_value * ").concat(p,".0)"))}}if(o){var h=o.from.id.split(":")[0],v=this.connectionResolver.modules.find(function(e){return e.id===h});if(v){var b,y=(null===(b=h.match(/\d+$/))||void 0===b?void 0:b[0])||"1";"Pot"===v.type&&(l="pot".concat(y,"_value"))}}if(r){var k=r.from.id.split(":")[0],S=this.connectionResolver.modules.find(function(e){return e.id===k});if(S){var x=S.params.index;switch(S.type){case"LEDButton":s="btn".concat(x,"_pressed");break;case"ADSR":s="(adsr".concat(x,"_output > 0.5)");break;case"LFO":s="(lfo".concat(x,"_output > 0.5)");break;case"Clock":s="clock".concat(x,"_output")}}}if(c){var E=c.from.id.split(":")[0],P=this.connectionResolver.modules.find(function(e){return e.id===E});if(P){var w,C=(null===(w=E.match(/\d+$/))||void 0===w?void 0:w[0])||"1";switch(P.type){case"LFO":u="lfo".concat(C,"_output");break;case"Pot":u="pot".concat(C,"_value");break;case"ADSR":u="adsr".concat(C,"_output")}}}return"\n        // GateGen ".concat(n," processing\n        {\n            float currentBPM = ").concat(i,";\n            float currentProbability = ").concat(l,";\n            bool gateInputState = ").concat(s,";\n            float shInput = ").concat(u,";\n\n            // Output rate in Hz for tempo sync\n            gate").concat(n,"_rate = currentBPM / 60.0;\n\n            // Update gate enable state\n            gate").concat(n,"_gate_enabled = gateInputState;\n\n            // Self-clock generation (only when running)\n            if (gate").concat(n,"_use_self_clock && gate").concat(n,"_gate_enabled && gate").concat(n,"_running) {\n                unsigned long currentTime = millis();\n                unsigned long clockInterval = (unsigned long)(60000.0 / currentBPM);\n\n                if (currentTime - gate").concat(n,"_last_self_clock >= clockInterval) {\n                    // Clock trigger - test probability\n                    float randVal = (float)random(0, 1000) / 1000.0;\n                    if (randVal < currentProbability) {\n                        // Trigger gate\n                        gate").concat(n,"_state = true;\n                        gate").concat(n,"_start_time = currentTime;\n\n                        // Sample & Hold on trigger\n                        if (gate").concat(n,"_sh_enabled) {\n                            gate").concat(n,"_sh_output = shInput;\n                        }\n                    }\n                    gate").concat(n,"_last_self_clock = currentTime;\n                }\n\n                // Check gate length\n                if (gate").concat(n,"_state) {\n                    unsigned long gateLength = (unsigned long)(clockInterval * gate").concat(n,"_length);\n                    if (currentTime - gate").concat(n,"_start_time >= gateLength) {\n                        gate").concat(n,"_state = false;\n                    }\n                }\n            }\n\n            // Update gate output\n            gate").concat(n,"_output = gate").concat(n,"_state ? 1.0 : 0.0;\n\n            // Update LED output (metronome flash mode if led_flash_ms > 0)\n            if (gate").concat(n,"_led_flash_ms > 0) {\n                // Metronome mode: Fixed-duration flash on gate trigger\n                if (gate").concat(n,"_state && gate").concat(n,"_led_output == 0.0f) {\n                    // Gate just went high - start LED flash\n                    gate").concat(n,"_led_output = 1.0f;\n                    gate").concat(n,"_led_start_time = currentTime;\n                } else if (gate").concat(n,"_led_output > 0.0f) {\n                    // LED is on - check if flash duration expired\n                    if (currentTime - gate").concat(n,"_led_start_time >= gate").concat(n,"_led_flash_ms) {\n                        gate").concat(n,"_led_output = 0.0f; // Turn off LED after flash\n                    }\n                }\n            } else {\n                // Normal mode: LED follows gate state\n                gate").concat(n,"_led_output = gate").concat(n,"_output;\n            }\n\n            gate").concat(n,"_sh_input = shInput;\n        }\n")}},{key:"generateMIDIInCode",value:function(e,n,t){return"\n        // MIDIIn ".concat(n," processing - UART MIDI Input\n        {\n            // Process incoming MIDI bytes\n            while (midi").concat(n,"Serial.available()) {\n                byte midiByte = midi").concat(n,"Serial.read();\n\n                // Parse MIDI message\n                if (midiByte >= 0x80) {\n                    // Status byte\n                    midi").concat(n,"_status = midiByte;\n                    midi").concat(n,"_dataIndex = 0;\n                    midi").concat(n,"_running_status = true;\n                } else if (midi").concat(n,"_running_status) {\n                    // Data byte\n                    if (midi").concat(n,"_dataIndex == 0) {\n                        midi").concat(n,"_data1 = midiByte;\n                        midi").concat(n,"_dataIndex = 1;\n                    } else if (midi").concat(n,"_dataIndex == 1) {\n                        midi").concat(n,"_data2 = midiByte;\n                        midi").concat(n,"_dataIndex = 0;\n\n                        // Process complete MIDI message\n                        byte messageType = midi").concat(n,"_status & 0xF0;\n                        byte channel = (midi").concat(n,"_status & 0x0F) + 1; // Convert to 1-16\n\n                        // Check channel filter\n                        if (midi").concat(n,"_omni || channel == midi").concat(n,"_channel) {\n                            switch (messageType) {\n                                case 0x90: // Note On\n                                    if (midi").concat(n,"_data2 > 0) { // Velocity > 0\n                                        if (midi").concat(n,"_use_gate) {\n                                            midi").concat(n,"_note = midi").concat(n,"_data1;\n                                            midi").concat(n,"_freq = 440.0 * pow(2.0, (midi").concat(n,"_note - 69) / 12.0);\n                                            midi").concat(n,"_gate = 1.0;\n                                            midi").concat(n,"_note_on = true;\n                                            midi").concat(n,"_last_note = midi").concat(n,"_data1;\n                                        }\n                                        if (midi").concat(n,"_use_vel) {\n                                            midi").concat(n,"_velocity = midi").concat(n,"_data2 / 127.0;\n                                        }\n                                    } else {\n                                        // Note On with velocity 0 = Note Off\n                                        if (midi").concat(n,"_use_gate && midi").concat(n,"_data1 == midi").concat(n,"_last_note) {\n                                            midi").concat(n,"_gate = 0.0;\n                                            midi").concat(n,"_note_on = false;\n                                        }\n                                    }\n                                    break;\n\n                                case 0x80: // Note Off\n                                    if (midi").concat(n,"_use_gate && midi").concat(n,"_data1 == midi").concat(n,"_last_note) {\n                                        midi").concat(n,"_gate = 0.0;\n                                        midi").concat(n,"_note_on = false;\n                                    }\n                                    break;\n\n                                case 0xB0: // Control Change\n                                    if (midi").concat(n,"_data1 == midi").concat(n,"_cc1) {\n                                        midi").concat(n,"_cc1_value = midi").concat(n,"_data2 / 127.0;\n                                    } else if (midi").concat(n,"_data1 == midi").concat(n,"_cc2) {\n                                        midi").concat(n,"_cc2_value = midi").concat(n,"_data2 / 127.0;\n                                    } else if (midi").concat(n,"_data1 == midi").concat(n,"_cc3) {\n                                        midi").concat(n,"_cc3_value = midi").concat(n,"_data2 / 127.0;\n                                    } else if (midi").concat(n,"_data1 == midi").concat(n,"_cc4) {\n                                        midi").concat(n,"_cc4_value = midi").concat(n,"_data2 / 127.0;\n                                    }\n                                    break;\n\n                                case 0xC0: // Program Change\n                                    if (midi").concat(n,"_use_prog) {\n                                        midi").concat(n,"_program = midi").concat(n,"_data1;\n                                    }\n                                    break;\n\n                                case 0xF8: // MIDI Clock\n                                    if (midi").concat(n,"_use_clock) {\n                                        midi").concat(n,"_clock_tick = true;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Clear clock tick (it's a momentary signal)\n            if (midi").concat(n,"_clock_tick) {\n                midi").concat(n,"_clock_tick = false;\n            }\n        }\n")}},{key:"generateModulationCode",value:function(e,n,t){return"\n        // Modulation ".concat(n," - 4LFO Matrix processing\n        {\n            unsigned long currentTime = millis();\n            float deltaTime = (currentTime - lfo").concat(n,"_last_update) / 1000.0;\n\n            // Update all 4 LFO phases\n            mod").concat(n,"_phase1 += mod").concat(n,"_lfo1_rate * deltaTime * 2.0 * M_PI;\n            mod").concat(n,"_phase2 += mod").concat(n,"_lfo2_rate * deltaTime * 2.0 * M_PI;\n            mod").concat(n,"_phase3 += mod").concat(n,"_lfo3_rate * deltaTime * 2.0 * M_PI;\n            mod").concat(n,"_phase4 += mod").concat(n,"_lfo4_rate * deltaTime * 2.0 * M_PI;\n\n            // Wrap phases\n            if (mod").concat(n,"_phase1 >= 2.0 * M_PI) mod").concat(n,"_phase1 -= 2.0 * M_PI;\n            if (mod").concat(n,"_phase2 >= 2.0 * M_PI) mod").concat(n,"_phase2 -= 2.0 * M_PI;\n            if (mod").concat(n,"_phase3 >= 2.0 * M_PI) mod").concat(n,"_phase3 -= 2.0 * M_PI;\n            if (mod").concat(n,"_phase4 >= 2.0 * M_PI) mod").concat(n,"_phase4 -= 2.0 * M_PI;\n\n            // Generate LFO outputs (simplified - just sine waves for now)\n            mod").concat(n,"_output1 = (sin(mod").concat(n,"_phase1) + 1.0) * 0.5; // 0-1 range\n            mod").concat(n,"_output2 = (sin(mod").concat(n,"_phase2) + 1.0) * 0.5;\n            mod").concat(n,"_output3 = (sin(mod").concat(n,"_phase3) + 1.0) * 0.5;\n            mod").concat(n,"_output4 = (sin(mod").concat(n,"_phase4) + 1.0) * 0.5;\n        }\n")}},{key:"generateInvertCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&("in"===n.to.port||void 0===n.to.port)}),o="0.5";if(a){var r=a.from.id.split(":")[0],c=this.connectionResolver.modules.find(function(e){return e.id===r});if(c){var i,l=(null===(i=r.match(/\d+$/))||void 0===i?void 0:i[0])||"1";switch(c.type){case"ADSR":o="adsr".concat(l,"_output");break;case"LFO":o="lfo".concat(l,"_output");break;case"Pot":o="pot".concat(l,"_value")}}}return"\n        // Invert ".concat(n," processing\n        {\n            invert").concat(n,"_input = ").concat(o,";\n            // Invert: 1.0 - input, with gain and offset\n            invert").concat(n,"_output = (1.0 - invert").concat(n,"_input) * invert").concat(n,"_gain + invert").concat(n,"_offset;\n            // Clamp to 0-1 range for control signals\n            invert").concat(n,"_output = constrain(invert").concat(n,"_output, 0.0, 1.0);\n        }\n")}},{key:"generateStepArray",value:function(e,n,t,a,o,r){for(var c=[],i=0;i<t;i++)for(var l=e.params["bank".concat(i,"_steps")]||[],s=0;s<4;s++){var u=4*i+s;if(u<n){var d=null;if(l[s]&&void 0!==l[s][a]?d=l[s]:e.params.steps&&e.params.steps[u]&&void 0!==e.params.steps[u][a]&&(d=e.params.steps[u]),d)if("muted"===a||"active"===a)c.push(d[a]?"true":"false");else{var p=d[a].toString();r&&(p=r(d[a])),c.push(p)}else c.push(o(u))}}return c.join(", ")}},{key:"generateHarmonicSequencerCode",value:function(e,n,t){var a=e.params.step_count||4,o=e.params.start_bank||1,r=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"clock"===n.to.port}),c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"start_stop"===n.to.port}),i=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"behavior"===n.to.port}),l=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"bpm"===n.to.port}),s=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"clock_div"===n.to.port}),u="false",d="false",p="0.0";"rest"===e.params.playback_mode?p="0.5":"reverse"===e.params.playback_mode&&(p="0.8");var f="seq".concat(n,"_bpm"),m="seq".concat(n,"_clock_div");if(r){var _=r.from.id.split(":")[0],g=this.connectionResolver.modules.find(function(e){return e.id===_});if(g){var h,v=(null===(h=_.match(/\d+$/))||void 0===h?void 0:h[0])||"1";switch(g.type){case"Clock":u="clock".concat(v,"_output");break;case"LFO":u="(lfo".concat(v,"_output > 0.5)");break;case"LEDButton":u="btn".concat(g.params.index,"_pressed")}}}if(c){var b=c.from.id.split(":")[0],y=this.connectionResolver.modules.find(function(e){return e.id===b});if(y){var k=y.params.index;switch(y.type){case"LEDButton":d="btn".concat(k,"_pressed");break;case"Encoder":d="enc".concat(k,"_button_pressed")}}}var S=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"gate"===n.to.port}),x=null;if(S){var E=S.from.id.split(":")[0],P=this.connectionResolver.modules.find(function(e){return e.id===E});if(P){var w,C=(null===(w=E.match(/\d+$/))||void 0===w?void 0:w[0])||"1";switch(P.type){case"ADSR":x="adsr".concat(C,"_output");break;case"LFO":x="lfo".concat(C,"_output");break;case"LEDButton":x="btn".concat(P.params.index,"_gate");break;case"Clock":x="clock".concat(C,"_output");break;case"GateGen":x="gategen".concat(C,"_gate");break;case"HarmonicSequencer":x="seq".concat(C,"_gate_sum")}}}if(i){var R=i.from.id.split(":")[0],L=this.connectionResolver.modules.find(function(e){return e.id===R});if(L){var I,M=(null===(I=R.match(/\d+$/))||void 0===I?void 0:I[0])||"1";switch(L.type){case"Pot":p="pot".concat(L.params.index,"_value");break;case"ADSR":p="adsr".concat(M,"_output");break;case"LFO":p="lfo".concat(M,"_output")}}}if(l){var D=l.from.id.split(":")[0],A=this.connectionResolver.modules.find(function(e){return e.id===D});if(A){var O,T=(null===(O=D.match(/\d+$/))||void 0===O?void 0:O[0])||"1";switch(A.type){case"Pot":f="(60.0 + pot".concat(A.params.index,"_value * 200.0)");break;case"ADSR":f="(60.0 + adsr".concat(T,"_output * 200.0)");break;case"LFO":f="(60.0 + lfo".concat(T,"_output * 200.0)")}}}if(s){var B=s.from.id.split(":")[0],z=this.connectionResolver.modules.find(function(e){return e.id===B});if(z){var F,N=(null===(F=B.match(/\d+$/))||void 0===F?void 0:F[0])||"1";switch(z.type){case"Pot":m="(int)(1.0 + pot".concat(z.params.index,"_value * 15.0)");break;case"ADSR":m="(int)(1.0 + adsr".concat(N,"_output * 15.0)");break;case"LFO":m="(int)(1.0 + lfo".concat(N,"_output * 15.0)")}}}return"\n        // HarmonicSequencer ".concat(n," processing\n        {\n            // Banking: Only process pots when in correct bank (").concat(o,")\n            if (currentBank == ").concat(o,") {\n                // Read and smooth hardware pots to reduce noise-induced pitch wavering\n                float pot1_raw = analogRead(4) / 4095.0; // GPIO4 - POT1\n                float pot2_raw = analogRead(5) / 4095.0; // GPIO5 - POT2\n                float pot3_raw = analogRead(6) / 4095.0; // GPIO6 - POT3\n                float pot4_raw = analogRead(7) / 4095.0; // GPIO7 - POT4\n\n                // Apply exponential smoothing to reduce pot noise\n                seq").concat(n,"_smoothed_pot[0] = seq").concat(n,"_smoothed_pot[0] * seq").concat(n,"_pot_smooth_factor + pot1_raw * (1.0 - seq").concat(n,"_pot_smooth_factor);\n                seq").concat(n,"_smoothed_pot[1] = seq").concat(n,"_smoothed_pot[1] * seq").concat(n,"_pot_smooth_factor + pot2_raw * (1.0 - seq").concat(n,"_pot_smooth_factor);\n                seq").concat(n,"_smoothed_pot[2] = seq").concat(n,"_smoothed_pot[2] * seq").concat(n,"_pot_smooth_factor + pot3_raw * (1.0 - seq").concat(n,"_pot_smooth_factor);\n                seq").concat(n,"_smoothed_pot[3] = seq").concat(n,"_smoothed_pot[3] * seq").concat(n,"_pot_smooth_factor + pot4_raw * (1.0 - seq").concat(n,"_pot_smooth_factor);\n            } // End banking check for pot reading\n\n            float pot1_val = seq").concat(n,"_smoothed_pot[0];\n            float pot2_val = seq").concat(n,"_smoothed_pot[1];\n            float pot3_val = seq").concat(n,"_smoothed_pot[2];\n            float pot4_val = seq").concat(n,"_smoothed_pot[3];\n\n            // Rate-limited MCP23017 I2C read to prevent audio interference\n            static unsigned long lastMcpRead = 0;\n            static bool btn_current[4] = {false, false, false, false};\n            if (currentTime - lastMcpRead > 20) { // Read every 20ms to avoid I2S interference\n                lastMcpRead = currentTime;\n                uint16_t mcpInputs = mcp.readGPIOAB();\n                btn_current[0] = !(mcpInputs & (1 << 0)); // GPA0 - active low\n                btn_current[1] = !(mcpInputs & (1 << 1)); // GPA1 - active low\n                btn_current[2] = !(mcpInputs & (1 << 2)); // GPA2 - active low\n                btn_current[3] = !(mcpInputs & (1 << 3)); // GPA3 - active low\n            }\n\n            // Banking: Only process pot manipulation when in correct bank (").concat(o,")\n            if (currentBank == ").concat(o,") {\n                // Direct mapping: Button 1-4 controls steps 0-3\n                {\n                    // Check if any buttons are currently held (shift mode)\n                    bool shiftMode = btn_current[0] || btn_current[1] || btn_current[2] || btn_current[3];\n\n                if (shiftMode) {\n                    // SHIFT MODE: Held buttons enable duration control\n                    // Only update duration for pots whose buttons are held\n                    if (btn_current[0]) {\n                        // Check soft takeover for duration\n                        float targetDuration = 0.25 + (pot1_val * 3.75); // Map to 0.25x-4.0x\n                        float currentDuration = seq").concat(n,"_duration[0];\n                        if (seq").concat(n,"_pot_taken_over[0] || abs(targetDuration - currentDuration) < 0.1) {\n                            seq").concat(n,"_duration[0] = targetDuration;\n                            seq").concat(n,"_pot_taken_over[0] = true;\n                            // Mark as shift mode only when pot is actually being used\n                            if (currentTime - seq").concat(n,"_btn_press_time[0] > 500) {\n                                seq").concat(n,"_btn_used_for_shift[0] = true;\n                            }\n                        }\n                    }\n                    if (btn_current[1]) {\n                        float targetDuration = 0.25 + (pot2_val * 3.75);\n                        float currentDuration = seq").concat(n,"_duration[1];\n                        if (seq").concat(n,"_pot_taken_over[1] || abs(targetDuration - currentDuration) < 0.1) {\n                            seq").concat(n,"_duration[1] = targetDuration;\n                            seq").concat(n,"_pot_taken_over[1] = true;\n                            // Mark as shift mode only when pot is actually being used\n                            if (currentTime - seq").concat(n,"_btn_press_time[1] > 500) {\n                                seq").concat(n,"_btn_used_for_shift[1] = true;\n                            }\n                        }\n                    }\n                    if (btn_current[2]) {\n                        float targetDuration = 0.25 + (pot3_val * 3.75);\n                        float currentDuration = seq").concat(n,"_duration[2];\n                        if (seq").concat(n,"_pot_taken_over[2] || abs(targetDuration - currentDuration) < 0.1) {\n                            seq").concat(n,"_duration[2] = targetDuration;\n                            seq").concat(n,"_pot_taken_over[2] = true;\n                            // Mark as shift mode only when pot is actually being used\n                            if (currentTime - seq").concat(n,"_btn_press_time[2] > 500) {\n                                seq").concat(n,"_btn_used_for_shift[2] = true;\n                            }\n                        }\n                    }\n                    if (btn_current[3]) {\n                        float targetDuration = 0.25 + (pot4_val * 3.75);\n                        float currentDuration = seq").concat(n,"_duration[3];\n                        if (seq").concat(n,"_pot_taken_over[3] || abs(targetDuration - currentDuration) < 0.1) {\n                            seq").concat(n,"_duration[3] = targetDuration;\n                            seq").concat(n,"_pot_taken_over[3] = true;\n                            // Mark as shift mode only when pot is actually being used\n                            if (currentTime - seq").concat(n,"_btn_press_time[3] > 500) {\n                                seq").concat(n,"_btn_used_for_shift[3] = true;\n                            }\n                        }\n                    }\n                } else {\n                    // NORMAL MODE: Pots control pitch with soft takeover after duration editing\n                    // Pot 1 pitch control with soft takeover\n                    float targetPitch1 = pot1_val;\n                    float currentPitch1 = seq").concat(n,"_pitch[0];\n                    if (seq").concat(n,"_pot_taken_over[0] || abs(targetPitch1 - currentPitch1) < 0.05) {\n                        seq").concat(n,"_pitch[0] = targetPitch1;\n                        seq").concat(n,"_base_pitch[0] = targetPitch1; // Track base pitch for harmonic linking\n                        seq").concat(n,"_pot_taken_over[0] = true;\n                    }\n\n                    // Pot 2 pitch control with soft takeover\n                    float targetPitch2 = pot2_val;\n                    float currentPitch2 = seq").concat(n,"_pitch[1];\n                    if (seq").concat(n,"_pot_taken_over[1] || abs(targetPitch2 - currentPitch2) < 0.05) {\n                        seq").concat(n,"_pitch[1] = targetPitch2;\n                        seq").concat(n,"_base_pitch[1] = targetPitch2; // Track base pitch for harmonic linking\n                        seq").concat(n,"_pot_taken_over[1] = true;\n                    }\n\n                    // Pot 3 pitch control with soft takeover\n                    float targetPitch3 = pot3_val;\n                    float currentPitch3 = seq").concat(n,"_pitch[2];\n                    if (seq").concat(n,"_pot_taken_over[2] || abs(targetPitch3 - currentPitch3) < 0.05) {\n                        seq").concat(n,"_pitch[2] = targetPitch3;\n                        seq").concat(n,"_base_pitch[2] = targetPitch3; // Track base pitch for harmonic linking\n                        seq").concat(n,"_pot_taken_over[2] = true;\n                    }\n\n                    // Pot 4 pitch control with soft takeover\n                    float targetPitch4 = pot4_val;\n                    float currentPitch4 = seq").concat(n,"_pitch[3];\n                    if (seq").concat(n,"_pot_taken_over[3] || abs(targetPitch4 - currentPitch4) < 0.05) {\n                        seq").concat(n,"_pitch[3] = targetPitch4;\n                        seq").concat(n,"_base_pitch[3] = targetPitch4; // Track base pitch for harmonic linking\n                        seq").concat(n,"_pot_taken_over[3] = true;\n                    }\n                }\n\n                // Update harmonic relationships after pot changes\n                updateHarmonicRelationships").concat(n,"();\n\n                // Reset takeover flags when buttons are released\n                if (!btn_current[0]) seq").concat(n,"_pot_taken_over[0] = false;\n                if (!btn_current[1]) seq").concat(n,"_pot_taken_over[1] = false;\n                if (!btn_current[2]) seq").concat(n,"_pot_taken_over[2] = false;\n                if (!btn_current[3]) seq").concat(n,"_pot_taken_over[3] = false;\n            }\n            } // End banking check for pot manipulation\n\n            // Behavior control - determine playback mode\n            float behaviorInput = ").concat(p,";\n            if (behaviorInput < 0.33) {\n                seq").concat(n,"_playback_mode = 0; // Iteration mode (default)\n            } else if (behaviorInput < 0.66) {\n                seq").concat(n,"_playback_mode = 1; // Rest mode (linear ").concat(a," steps)\n            } else {\n                seq").concat(n,"_playback_mode = 2; // Reverse mode\n            }\n\n            // Handle button press detection and timing\n            for (int btn = 0; btn < 4; btn++) {\n                if (btn_current[btn] && !seq").concat(n,"_btn_last[btn]) {\n                    // Button just pressed - start timing\n                    seq").concat(n,"_btn_press_time[btn] = currentTime;\n                    seq").concat(n,"_btn_long_hold_handled[btn] = false;\n                } else if (btn_current[btn] && seq").concat(n,"_btn_last[btn]) {\n                    // Button held - used for shift mode (duration control) - no additional action needed\n                    // The shift mode logic is handled in the pot control section above\n                } else if (!btn_current[btn] && seq").concat(n,"_btn_last[btn]) {\n                    // Button just released - only toggle step if button wasn't used for shift mode\n                    if (!seq").concat(n,"_btn_used_for_shift[btn]) {\n                        int stepIndex = btn; // Button 0-3 = Step 0-3\n                        if (stepIndex >= 0 && stepIndex < ").concat(a,") {\n                            seq").concat(n,"_active[stepIndex] = !seq").concat(n,'_active[stepIndex];\n                            Serial.print("Step ");\n                            Serial.print(stepIndex + 1);\n                            Serial.println(seq').concat(n,'_active[stepIndex] ? " ACTIVATED" : " DEACTIVATED");\n\n                            // Update step count for iteration mode\n                            int activeCount = 0;\n                            for (int i = 0; i < ').concat(a,"; i++) {\n                                if (seq").concat(n,'_active[i]) activeCount++;\n                            }\n                            Serial.print("Active steps: ");\n                            Serial.println(activeCount);\n                        }\n                    } else {\n                        Serial.print("Button ");\n                        Serial.print(btn + 1);\n                        Serial.println(" was used for duration control - no step toggle");\n                    }\n                }\n                seq').concat(n,"_btn_last[btn] = btn_current[btn];\n\n                // Reset shift mode flag after button state is updated\n                if (!btn_current[btn]) {\n                    seq").concat(n,"_btn_used_for_shift[btn] = false;\n                }\n            }\n\n            // Encoder button handling - long hold clears sequence, short press starts/stops\n            bool encBtnCurrent = !digitalRead(48); // Encoder button GPIO48 - active low\n            bool startStopTrigger = ").concat(d,";\n\n            // TEMPORARY: Use encoder button for start/stop if no connection\n            if (").concat(d," == false) {\n                // Encoder button press detection with long hold for sequence clear\n                if (encBtnCurrent && !seq").concat(n,"_enc_btn_last) {\n                    // Button just pressed - start timing\n                    seq").concat(n,"_enc_btn_press_time = currentTime;\n                    seq").concat(n,"_enc_long_hold_handled = false;\n\n                    // IMMEDIATE START/STOP TRIGGER: Trigger immediately on press for responsiveness\n                    // (Long hold will override if held for 2+ seconds)\n                    startStopTrigger = true;\n                } else if (encBtnCurrent && seq").concat(n,"_enc_btn_last) {\n                    // Button held - check for long hold (2 seconds for sequence clear)\n                    unsigned long holdDuration = currentTime - seq").concat(n,"_enc_btn_press_time;\n                    if (holdDuration > 2000 && !seq").concat(n,"_enc_long_hold_handled) {\n                        // Long hold detected - clear sequence and reset all parameters\n                        for (int i = 0; i < ").concat(a,"; i++) {\n                            seq").concat(n,"_active[i] = false;          // Clear active states\n                            seq").concat(n,"_pitch[i] = (i % 4) * 0.25;  // Reset to default pitch pattern (0, 0.25, 0.5, 0.75)\n                            seq").concat(n,"_duration[i] = 1.0;         // Reset to default duration (1.0x)\n                            seq").concat(n,"_muted[i] = false;          // Unmute all steps\n                            seq").concat(n,"_pitch_randomness[i] = 0.0; // Clear pitch randomness\n                            seq").concat(n,"_probability[i] = 1.0;      // Reset probability to 100%\n                            seq").concat(n,"_glissando_time[i] = 0.0;   // Clear glissando time\n                            seq").concat(n,"_glissando_probability[i] = 0.0; // Clear glissando probability\n                        }\n                        seq").concat(n,'_enc_long_hold_handled = true;\n                        Serial.println("HarmonicSequencer: SEQUENCE CLEARED & RESET TO DEFAULTS (long encoder hold)");\n                    }\n                } else if (!encBtnCurrent && seq').concat(n,"_enc_btn_last) {\n                    // Button just released - nothing to do here\n                }\n                seq").concat(n,"_enc_btn_last = encBtnCurrent;\n            } else {\n                // External start/stop connection exists\n                startStopTrigger = ").concat(d,";\n            }\n\n            // Start/Stop processing\n            static bool lastStartStopTrigger = false;\n            if (startStopTrigger && !lastStartStopTrigger) {\n                seq").concat(n,"_running = !seq").concat(n,"_running;\n                if (seq").concat(n,"_running) {\n                    seq").concat(n,"_current_step = 0; // Reset to beginning when starting\n                    seq").concat(n,"_last_step = -1; // Reset last step tracker\n\n                    // Generate initial random offsets for first sequence pass\n                    for (int i = 0; i < ").concat(a,"; i++) {\n                        float basePitch = seq").concat(n,"_pitch[i];\n                        float randomness = seq").concat(n,"_pitch_randomness[i];\n                        float randomRange = basePitch * randomness;\n                        seq").concat(n,'_pitch_random_offset[i] = (((float)random(0, 1000) / 1000.0) - 0.5) * 2.0 * randomRange;\n                    }\n\n                    Serial.println("HarmonicSequencer STARTED");\n                } else {\n                    Serial.println("HarmonicSequencer STOPPED");\n                }\n            }\n            lastStartStopTrigger = startStopTrigger;\n\n            // Clock processing\n            bool clockTrigger = ').concat(u,";\n\n            // AUTO CLOCK: Use internal clock when no external clock connected\n            if (").concat(u," == false) {\n                static unsigned long lastInternalClock = 0;\n                // Calculate step duration based on BPM and clock division (supports CV control)\n                float currentBpm = ").concat(f,";\n                int currentClockDiv = ").concat(m,";\n                unsigned long baseDuration = (60000 / currentBpm) / currentClockDiv; // Convert BPM to milliseconds per step\n                unsigned long currentStepDuration = (unsigned long)(baseDuration * seq").concat(n,"_duration[seq").concat(n,"_current_step]);\n\n                if (currentTime - lastInternalClock > currentStepDuration) {\n                    lastInternalClock = currentTime;\n                    clockTrigger = true;\n                }\n            }\n\n            if (seq").concat(n,"_running) {\n                // Advance step on clock trigger\n                if (clockTrigger && !seq").concat(n,"_last_clock_state) {\n                    // Find next step based on playback mode\n                    int nextStep = seq").concat(n,"_current_step;\n                    int attempts = 0;\n\n                    if (seq").concat(n,"_playback_mode == 1) {\n                        // Rest mode: Linear progression through all ").concat(a," steps (includes rests)\n                        if (seq").concat(n,"_reverse_direction) {\n                            nextStep = (seq").concat(n,"_current_step - 1 + ").concat(a,") % ").concat(a,";\n                        } else {\n                            nextStep = (seq").concat(n,"_current_step + 1) % ").concat(a,";\n                        }\n                    } else if (seq").concat(n,"_playback_mode == 2) {\n                        // Reverse mode: Only active steps, but in reverse order\n                        do {\n                            nextStep = (nextStep - 1 + ").concat(a,") % ").concat(a,";\n                            attempts++;\n                            if (attempts > ").concat(a,") break; // Prevent infinite loop\n                        } while (!seq").concat(n,"_active[nextStep] && attempts <= ").concat(a,");\n                    } else {\n                        // Iteration mode (default): Only active steps, forward\n                        do {\n                            nextStep = (nextStep + 1) % ").concat(a,";\n                            attempts++;\n                            if (attempts > ").concat(a,") break; // Prevent infinite loop\n                        } while (!seq").concat(n,"_active[nextStep] && attempts <= ").concat(a,");\n                    }\n\n                    // Detect sequence loop (when going to step 0 from a higher step)\n                    // Regenerate random pitch offsets once per sequence pass\n                    if (nextStep == 0 && seq").concat(n,"_last_step > 0) {\n                        // Sequence looped - regenerate all random offsets for this pass\n                        for (int i = 0; i < ").concat(a,"; i++) {\n                            float basePitch = seq").concat(n,"_pitch[i];\n                            float patternMod = 0.0; // Simplified - pattern affects playback, not random generation\n                            float modifiedPitch = basePitch + patternMod;\n\n                            float randomness = seq").concat(n,"_pitch_randomness[i];\n                            float randomRange = modifiedPitch * randomness;\n                            seq").concat(n,'_pitch_random_offset[i] = (((float)random(0, 1000) / 1000.0) - 0.5) * 2.0 * randomRange;\n                        }\n                        Serial.println("Seq').concat(n,': New random pass generated");\n                    }\n\n                    seq').concat(n,"_last_step = seq").concat(n,"_current_step; // Store current before updating\n                    seq").concat(n,"_current_step = nextStep;\n                    seq").concat(n,"_step_start_time = currentTime;\n\n                    // Increment pattern counter for this step (for pattern alternation)\n                    seq").concat(n,"_pattern_counter[seq").concat(n,"_current_step]++;\n\n                    // Use pre-calculated random offset from current sequence pass\n                    float basePitch = seq").concat(n,"_pitch[seq").concat(n,"_current_step];\n\n                    // Apply melodic pattern modulation around pot position\n                    // If this step is harmonically linked, use the pattern counter from the followed step\n                    int followedStep = seq").concat(n,"_harmonic_follow_steps[seq").concat(n,"_current_step];\n                    int effectiveStepForPattern = (followedStep != -1) ? followedStep : seq").concat(n,"_current_step;\n                    float patternModulation = calculatePatternModulation").concat(n,"(effectiveStepForPattern, currentTime, seq").concat(n,"_step_start_time, seq").concat(n,"_duration[seq").concat(n,"_current_step], basePitch);\n\n                    // Diatonic mode: double quantization to keep intervals in scale\n                    // Chromatic mode: single quantization at the end\n                    bool isDiatonic = false;\n                    switch (seq").concat(n,"_current_step) {\n                        case 0: isDiatonic = seq").concat(n,"_chord_diatonic_step1; break;\n                        case 1: isDiatonic = seq").concat(n,"_chord_diatonic_step2; break;\n                        case 2: isDiatonic = seq").concat(n,"_chord_diatonic_step3; break;\n                        case 3: isDiatonic = seq").concat(n,"_chord_diatonic_step4; break;\n                    }\n\n                    float modifiedPitch;\n                    if (isDiatonic) {\n                        // Diatonic mode: quantize base, add pattern, quantize again\n                        float quantizedBase = quantizePitch").concat(n,"(basePitch);\n                        modifiedPitch = quantizePitch").concat(n,"(quantizedBase + patternModulation);\n                    } else {\n                        // Chromatic mode: add pattern, quantize once at end\n                        modifiedPitch = basePitch + patternModulation;\n                    }\n\n                    // Use stored random offset instead of calculating new one each step\n                    float randomOffset = seq").concat(n,"_pitch_random_offset[seq").concat(n,"_current_step];\n                    float rawPitch = modifiedPitch + randomOffset;\n\n                    // Apply musical scale quantization (always active)\n                    seq").concat(n,"_sampled_pitch = quantizePitch").concat(n,"(rawPitch);\n\n                    // Gate activation depends on mode and step state\n                    if (seq").concat(n,"_playback_mode == 1) {\n                        // Rest mode: Gate active for all steps, but inactive steps produce silence\n                        seq").concat(n,"_gate_active = !seq").concat(n,"_muted[seq").concat(n,"_current_step];\n                    } else {\n                        // Iteration/Reverse modes: Gate only active for non-muted steps\n                        seq").concat(n,"_gate_active = seq").concat(n,"_active[seq").concat(n,"_current_step] && !seq").concat(n,"_muted[seq").concat(n,'_current_step];\n                    }\n\n                    // Debug output\n                    Serial.print("Step: ");\n                    Serial.print(seq').concat(n,'_current_step + 1);\n                    Serial.print(", Duration: ");\n                    Serial.print(seq').concat(n,"_duration[seq").concat(n,'_current_step]);\n                    Serial.print("x, Gate: ");\n                    Serial.println(seq').concat(n,'_gate_active ? "ON" : "OFF");\n                }\n                seq').concat(n,"_last_clock_state = clockTrigger;\n\n                // Gate length control with individual step durations\n                if (seq").concat(n,"_gate_active) {\n                    unsigned long baseDuration = 500; // Base step duration (120 BPM)\n                    // Apply individual step duration multiplier\n                    unsigned long stepDuration = (unsigned long)(baseDuration * seq").concat(n,"_duration[seq").concat(n,"_current_step]);\n                    unsigned long gateLength = (unsigned long)(stepDuration * seq").concat(n,"_gate_length);\n                    if (currentTime - seq").concat(n,"_step_start_time > gateLength) {\n                        seq").concat(n,"_gate_active = false;\n                    }\n                }\n            }\n\n            // LED Chase - show currently playing step (only if step is active)\n            // LED display (only update when state changes to prevent flickering)\n            static int lastDisplayedStep = -1;\n            static bool lastDisplayedActive[4];\n            static bool lastWasRunning = false;\n            static bool firstRun = true;\n\n            // Initialize array on first run\n            if (firstRun) {\n                for (int i = 0; i < 4; i++) {\n                    lastDisplayedActive[i] = false;\n                }\n                firstRun = false;\n            }\n\n            bool ledsNeedUpdate = false;\n\n            if (seq").concat(n,"_running) {\n                // Check if we need to update LEDs (step changed or just started)\n                int currentStepInBank = seq").concat(n,"_current_step % 4; // 0-3\n                if (currentStepInBank != lastDisplayedStep || !lastWasRunning) {\n                    ledsNeedUpdate = true;\n                    lastDisplayedStep = currentStepInBank;\n                }\n\n                if (ledsNeedUpdate && !showingBankIndicator) {\n                    // Clear all button LEDs\n                    neoPixels.setPixelColor(0, neoPixels.Color(0, 0, 0));\n                    neoPixels.setPixelColor(1, neoPixels.Color(0, 0, 0));\n                    neoPixels.setPixelColor(2, neoPixels.Color(0, 0, 0));\n                    neoPixels.setPixelColor(3, neoPixels.Color(0, 0, 0));\n\n                    // Light current step LED (white) - reversed mapping\n                    if (currentStepInBank == 0) neoPixels.setPixelColor(3, neoPixels.Color(255, 255, 255));      // Step 1  LED3\n                    else if (currentStepInBank == 1) neoPixels.setPixelColor(2, neoPixels.Color(255, 255, 255)); // Step 2  LED2\n                    else if (currentStepInBank == 2) neoPixels.setPixelColor(1, neoPixels.Color(255, 255, 255)); // Step 3  LED1\n                    else if (currentStepInBank == 3) neoPixels.setPixelColor(0, neoPixels.Color(255, 255, 255)); // Step 4  LED0\n\n                    neoPixels.show();\n                }\n            } else {\n                // Check if active states changed or just stopped\n                bool activeChanged = false;\n                for (int i = 0; i < 4; i++) {\n                    if (seq").concat(n,"_active[i] != lastDisplayedActive[i]) {\n                        activeChanged = true;\n                        lastDisplayedActive[i] = seq").concat(n,"_active[i];\n                    }\n                }\n\n                if ((activeChanged || lastWasRunning) && !showingBankIndicator) {\n                    // Show active steps (white) vs inactive steps (off)\n                    // Reversed mapping: Step 1LED3, Step 2LED2, Step 3LED1, Step 4LED0\n                    neoPixels.setPixelColor(3, seq").concat(n,"_active[0] ? neoPixels.Color(255, 255, 255) : neoPixels.Color(0, 0, 0)); // Step 1  LED3\n                    neoPixels.setPixelColor(2, seq").concat(n,"_active[1] ? neoPixels.Color(255, 255, 255) : neoPixels.Color(0, 0, 0)); // Step 2  LED2\n                    neoPixels.setPixelColor(1, seq").concat(n,"_active[2] ? neoPixels.Color(255, 255, 255) : neoPixels.Color(0, 0, 0)); // Step 3  LED1\n                    neoPixels.setPixelColor(0, seq").concat(n,"_active[3] ? neoPixels.Color(255, 255, 255) : neoPixels.Color(0, 0, 0)); // Step 4  LED0\n\n                    neoPixels.show();\n                }\n            }\n\n            lastWasRunning = seq").concat(n,"_running;\n\n            // Generate outputs based on mode and step state\n            static float lastPitchOutput = -1.0;\n            static int lastStepOutput = -1;\n            static unsigned long lastSeqDebugTime = 0;\n            static bool lastRunningState = false;\n\n            if (seq").concat(n,"_running && seq").concat(n,"_gate_active) {\n                // Apply probability check for this step\n                float stepProbability = seq").concat(n,"_probability[seq").concat(n,"_current_step];\n                bool stepFires = ((float)random(0, 1000) / 1000.0) < stepProbability;\n\n                if (seq").concat(n,"_playback_mode == 1) {\n                    // Rest mode: Output pitch only for active steps, gate always on when not muted\n                    if (seq").concat(n,"_active[seq").concat(n,"_current_step] && stepFires) {\n                        // Use sample-and-hold pitch (calculated once when step started)\n                        seq").concat(n,"_pitch_sum = seq").concat(n,"_sampled_pitch;\n                    } else {\n                        seq").concat(n,"_pitch_sum = 0.0; // Rest - no pitch output\n                    }\n                    seq").concat(n,"_gate_sum = stepFires ? 1.0 : 0.0; // Gate depends on probability\n                } else {\n                    // Iteration/Reverse modes: Normal operation (only active steps play)\n                    if (stepFires) {\n                        // Use sample-and-hold pitch (calculated once when step started)\n                        seq").concat(n,"_pitch_sum = seq").concat(n,"_sampled_pitch;\n                        seq").concat(n,"_gate_sum = 1.0;\n                    } else {\n                        seq").concat(n,"_pitch_sum = 0.0;\n                        seq").concat(n,"_gate_sum = 0.0;\n                    }\n                }\n\n                // Convert quantized pitch to Hz frequency using octave_center (octave+1 range)\n                if (seq").concat(n,"_gate_sum > 0.0) {\n                    // Use octave_center parameter (default 4 = C4)\n                    int octave_center = ").concat(e.params.octave_center||4,";\n                    // Convert 0-1 pitch to MIDI note within octave+1 range (13 semitones, C4 to C5)\n                    // Note: pitch_sum = 0.0 is valid (root note), only silence when gate is off\n                    float baseMidi = (octave_center * 12.0); // C of the center octave\n                    float midiNote = baseMidi + (seq").concat(n,"_pitch_sum * 13.0); // octave+1 range (13 semitones)\n                    // Convert MIDI to frequency: f = 440 * 2^((midi-69)/12)\n                    float targetHz = 440.0 * pow(2.0, (midiNote - 69.0) / 12.0);\n\n                    // GLISSANDO PROCESSING\n                    // Check if we should start a new glissando on step change\n                    static int lastProcessedStep = -1;\n                    if (seq").concat(n,"_current_step != lastProcessedStep) {\n                        // Step just changed - check if glissando should trigger\n                        float glissProb = seq").concat(n,"_glissando_probability[seq").concat(n,"_current_step];\n                        float glissTime = seq").concat(n,"_glissando_time[seq").concat(n,"_current_step];\n\n                        // Roll probability dice (simple deterministic approach using step number as seed)\n                        float randomValue = (float)((seq").concat(n,"_current_step * 7 + 13) % 100) / 100.0; // 0-1 pseudo-random\n\n                        if (glissProb > 0.0 && glissTime > 0.0 && randomValue < glissProb) {\n                            // Glissando triggered! Start sliding from current Hz to target Hz\n                            seq").concat(n,"_glissando_start_pitch = seq").concat(n,"_pitch_hz; // Start from current frequency\n                            seq").concat(n,"_glissando_target_pitch = targetHz; // Slide to target frequency\n                            seq").concat(n,"_glissando_start_time = seq").concat(n,"_step_start_time;\n                            seq").concat(n,'_glissando_active = true;\n                            Serial.print("GLISS: Step ");\n                            Serial.print(seq').concat(n,'_current_step + 1);\n                            Serial.print(" triggered (prob=");\n                            Serial.print(glissProb * 100);\n                            Serial.print("%, time=");\n                            Serial.print(glissTime * 100);\n                            Serial.println("%)");\n                        } else {\n                            // No glissando - use target frequency directly\n                            seq').concat(n,"_glissando_active = false;\n                        }\n                        lastProcessedStep = seq").concat(n,"_current_step;\n                    }\n\n                    // Apply glissando interpolation if active\n                    if (seq").concat(n,"_glissando_active) {\n                        float glissTime = seq").concat(n,"_glissando_time[seq").concat(n,"_current_step];\n                        unsigned long stepDuration = (unsigned long)(60000.0 / seq").concat(n,"_bpm * 4.0 / seq").concat(n,"_clock_div * seq").concat(n,"_duration[seq").concat(n,"_current_step]);\n                        unsigned long glissDuration = (unsigned long)(stepDuration * glissTime);\n                        unsigned long elapsed = currentTime - seq").concat(n,"_glissando_start_time;\n\n                        if (elapsed < glissDuration) {\n                            // Still within glissando time - interpolate\n                            float rawProgress = (float)elapsed / (float)glissDuration;\n                            rawProgress = constrain(rawProgress, 0.0, 1.0);\n\n                            // Apply curve shaping based on curve type\n                            int curveType = seq").concat(n,"_glissando_curve[seq").concat(n,"_current_step];\n                            float progress = rawProgress;\n\n                            if (curveType == 1) {\n                                // Exponential curve (slow start, fast end)\n                                progress = pow(rawProgress, 2.0);\n                            } else if (curveType == 2) {\n                                // Logarithmic curve (fast start, slow end)\n                                progress = sqrt(rawProgress);\n                            }\n                            // curveType == 0 is linear (no change needed)\n\n                            // Linear interpolation with curve-shaped progress\n                            float interpolatedPitch = seq").concat(n,"_glissando_start_pitch +\n                                (seq").concat(n,"_glissando_target_pitch - seq").concat(n,"_glissando_start_pitch) * progress;\n\n                            seq").concat(n,"_pitch_hz = interpolatedPitch;\n                            seq").concat(n,"_glissando_current_hz = interpolatedPitch;\n                        } else {\n                            // Glissando finished - use target frequency\n                            seq").concat(n,"_pitch_hz = seq").concat(n,"_glissando_target_pitch;\n                            seq").concat(n,"_glissando_active = false;\n                        }\n                    } else {\n                        // No glissando active - use target frequency directly\n                        seq").concat(n,"_pitch_hz = targetHz;\n                    }\n                } else {\n                    seq").concat(n,"_pitch_hz = 0.0; // Silent when gate is off\n                    seq").concat(n,"_glissando_active = false; // Stop glissando when gate is off\n                }\n\n                // Apply external gate muting (if gate input is connected)\n                // Sequencer continues running, but outputs are muted when gate is low\n                ").concat(x?"\n                float gateInput = ".concat(x,";\n                bool gateEnabled = (gateInput > 0.5);\n                if (!gateEnabled) {\n                    // Mute outputs while sequencer continues running internally\n                    seq").concat(n,"_pitch_sum = 0.0;\n                    seq").concat(n,"_gate_sum = 0.0;\n                    seq").concat(n,"_pitch_hz = 0.0;\n                }\n                "):"// No gate input connected - outputs always enabled","\n\n                // Debug output when step or pitch changes\n                bool shouldSeqDebug = (seq").concat(n,"_current_step != lastStepOutput) ||\n                                     (abs(seq").concat(n,"_pitch_sum - lastPitchOutput) > 0.01) ||\n                                     (currentTime - lastSeqDebugTime > 200) ||\n                                     (seq").concat(n,'_running != lastRunningState);\n\n                if (shouldSeqDebug) {\n                    Serial.print("Seq').concat(n,': Step=");\n                    Serial.print(seq').concat(n,'_current_step + 1);\n                    Serial.print("/");\n                    Serial.print(seq').concat(n,"_active[seq").concat(n,'_current_step] ? "ACT" : "rest");\n                    Serial.print(" Bank=");\n                    Serial.print((seq').concat(n,'_current_step / 4) + 1);\n                    Serial.print(" Pitch=");\n                    Serial.print(seq').concat(n,'_pitch_sum, 3);\n                    Serial.print(" Gate=");\n                    Serial.print(seq').concat(n,'_gate_sum, 1);\n                    Serial.print(" Mode=");\n                    Serial.println(seq').concat(n,'_playback_mode == 0 ? "iter" : (seq').concat(n,'_playback_mode == 1 ? "rest" : "rev"));\n                    lastSeqDebugTime = currentTime;\n                }\n\n                lastPitchOutput = seq').concat(n,"_pitch_sum;\n                lastStepOutput = seq").concat(n,"_current_step;\n            } else {\n                seq").concat(n,"_pitch_sum = 0.0;\n                seq").concat(n,"_pitch_hz = 0.0;\n                seq").concat(n,"_gate_sum = 0.0;\n\n                // Debug when sequencer stops\n                if (seq").concat(n,'_running != lastRunningState) {\n                    Serial.println("Seq').concat(n,': STOPPED");\n                    lastSeqDebugTime = currentTime;\n                }\n            }\n\n            lastRunningState = seq').concat(n,"_running;\n\n            // Individual step outputs - each step gets its own pitch and gate\n            // Clear gate outputs only (pitch values persist from when step was last active)\n            seq").concat(n,"_gate_step1 = 0.0;\n            seq").concat(n,"_gate_step2 = 0.0;\n            seq").concat(n,"_gate_step3 = 0.0;\n            seq").concat(n,"_gate_step4 = 0.0;\n\n            // Update the output for the currently active step only\n            if (seq").concat(n,"_running && seq").concat(n,"_gate_active) {\n                float stepProbability = seq").concat(n,"_probability[seq").concat(n,"_current_step];\n                bool stepFires = ((float)random(0, 1000) / 1000.0) < stepProbability;\n\n                if (seq").concat(n,"_active[seq").concat(n,"_current_step] && stepFires) {\n                    // Calculate pitch and Hz for the current step\n                    float stepPitch = seq").concat(n,"_sampled_pitch;\n\n                    // Convert pitch to Hz using same logic as main output\n                    int octave_center = ").concat(e.params.octave_center||4,";\n                    float baseMidi = (octave_center * 12.0);\n                    float midiNote = baseMidi + (stepPitch * 13.0);\n                    float stepHz = 440.0 * pow(2.0, (midiNote - 69.0) / 12.0);\n\n                    // Set outputs for the current step (1-indexed for outputs)\n                    switch (seq").concat(n,"_current_step) {\n                        case 0: // Step 1\n                            seq").concat(n,"_pitch_step1 = stepPitch;\n                            seq").concat(n,"_pitch_step1_hz = stepHz;\n                            seq").concat(n,"_gate_step1 = 1.0;\n                            break;\n                        case 1: // Step 2\n                            seq").concat(n,"_pitch_step2 = stepPitch;\n                            seq").concat(n,"_pitch_step2_hz = stepHz;\n                            seq").concat(n,"_gate_step2 = 1.0;\n                            break;\n                        case 2: // Step 3\n                            seq").concat(n,"_pitch_step3 = stepPitch;\n                            seq").concat(n,"_pitch_step3_hz = stepHz;\n                            seq").concat(n,"_gate_step3 = 1.0;\n                            break;\n                        case 3: // Step 4\n                            seq").concat(n,"_pitch_step4 = stepPitch;\n                            seq").concat(n,"_pitch_step4_hz = stepHz;\n                            seq").concat(n,"_gate_step4 = 1.0;\n                            break;\n                    }\n                }\n            }\n\n            // Status outputs\n            seq").concat(n,"_current_step_cv = seq").concat(n,"_current_step / 3.0; // 0-1 range (4 steps: 0/3, 1/3, 2/3, 3/3)\n            seq").concat(n,"_current_bank_cv = 0.0; // Fixed single bank - always 0\n        }\n")}},{key:"generateAutomationCode",value:function(e,n,t){for(var a=this,o=e.params.num_inputs||1,r="",c=function(o){var c=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&n.to.port==="in_".concat(o)});if(c){var i=c.from.id.split(":")[0],l=a.connectionResolver.modules.find(function(e){return e.id===i});if(l){var s,u=(null===(s=i.match(/\d+$/))||void 0===s?void 0:s[0])||"1",d="0.0";switch(l.type){case"Pot":d="pot".concat(u,"_value");break;case"ADSR":d="adsr".concat(u,"_output");break;case"LFO":d="lfo".concat(u,"_output");break;case"LEDButton":var p=c.from.port||"value",f=l.params.index;d="btn".concat(f,"sampleOut"===p?"_sampleOut":"gate"===p?"_gate":"_output");break;case"Scale":d="scale".concat(u,"_output");break;case"HarmonicSequencer":var m=c.from.port||"cv1";d="pitch_norm"===m?"seq".concat(u,"_pitch_norm"):"pitch_sum"===m?"seq".concat(u,"_pitch_sum"):m.startsWith("cv")||m.startsWith("pitch_step")?"seq".concat(u,"_").concat(m):"seq".concat(u,"_cv1");break;case"Modulation":var _=c.from.port||"lfo1";d="mod".concat(u,"_").concat(_,"_output");break;case"VCA":d="vca".concat(u,"_outputL");break;case"Automation":var g=(c.from.port||"out_1").replace("out_","output_");d="automation".concat(u,"_").concat(g)}r+="            automation".concat(n,"_input_").concat(o," = ").concat(d,";\n")}}},i=1;i<=o;i++)c(i);for(var l="",s=1;s<=o;s++)l+="\n            // Channel ".concat(s," - Independent recording/playback\n            {\n                // Detect if channel is being moved during recording\n                if (recordTrigger && !automation").concat(n,"_last_record_trigger) {\n                    // Button just pressed - start monitoring for movement\n                    automation").concat(n,"_last_input_").concat(s," = automation").concat(n,"_input_").concat(s,";\n                }\n\n                // Recording mode for this channel\n                if (automation").concat(n,"_channel_").concat(s,"_recording) {\n                    // Check if channel is actually being moved\n                    float movement = abs(automation").concat(n,"_input_").concat(s," - automation").concat(n,"_last_input_").concat(s,");\n\n                    if (movement > automation").concat(n,"_movement_threshold || automation").concat(n,"_channel_").concat(s,"_length > 0) {\n                        // Channel is moving or already started - record it\n                        if (automation").concat(n,"_channel_").concat(s,"_position < automation").concat(n,"_buffer_size) {\n                            automation").concat(n,"_buffer_").concat(s,"[automation").concat(n,"_channel_").concat(s,"_position] = automation").concat(n,"_input_").concat(s,";\n                            automation").concat(n,"_channel_").concat(s,"_position++;\n                            automation").concat(n,"_channel_").concat(s,"_length = automation").concat(n,"_channel_").concat(s,"_position;\n                            // Debug: show recording progress every 50 samples\n                            if (automation").concat(n,"_channel_").concat(s,'_position % 50 == 1) {\n                                Serial.printf("DEBUG: Ch').concat(s,' recording... %d samples (movement=%.4f)\\n",\n                                    automation').concat(n,"_channel_").concat(s,"_position, movement);\n                            }\n                        }\n                    }\n\n                    automation").concat(n,"_last_input_").concat(s," = automation").concat(n,"_input_").concat(s,";\n\n                    // Pass through during recording\n                    automation").concat(n,"_output_").concat(s," = automation").concat(n,"_input_").concat(s,";\n                }\n                // Playback mode for this channel\n                else if (automation").concat(n,"_channel_").concat(s,"_playing && automation").concat(n,"_channel_").concat(s,"_length > 0) {\n                    // Touch detection - check if user moved this channel's control\n                    // BUT: Skip touch detection if encoder button is held (mode selection active)\n                    bool channelTouched = false;\n                    if (!automation").concat(n,"_mode_select && millis() - automation").concat(n,"_channel_").concat(s,"_start_time > automation").concat(n,"_touch_grace_ms) {\n                        float diff = abs(automation").concat(n,"_input_").concat(s," - automation").concat(n,"_last_input_").concat(s,");\n                        if (diff > automation").concat(n,'_touch_threshold) {\n                            Serial.printf("DEBUG: Channel ').concat(s,' TOUCHED - diff=%.3f\\n", diff);\n                            channelTouched = true;\n                        }\n                    }\n\n                    if (channelTouched) {\n                        // Stop playback for this channel, clear data, switch to pass-through\n                        automation').concat(n,"_channel_").concat(s,"_playing = false;\n                        automation").concat(n,"_channel_").concat(s,'_length = 0; // Clear so channel can be re-recorded\n                        Serial.printf("Automation ').concat(n," Channel ").concat(s,': Touch detected, cleared loop\\n");\n                    }\n\n\n                    if (automation').concat(n,"_channel_").concat(s,"_playing) {\n                        // Calculate playback position with mode transformation\n                        int readPosition = automation").concat(n,"_channel_").concat(s,"_position;\n\n                        switch (automation").concat(n,"_playback_mode) {\n                            case 0: // Normal\n                                readPosition = automation").concat(n,"_channel_").concat(s,"_position;\n                                break;\n                            case 1: // Reverse\n                                readPosition = automation").concat(n,"_channel_").concat(s,"_length - 1 - automation").concat(n,"_channel_").concat(s,"_position;\n                                break;\n                            case 2: // 2x speed\n                                readPosition = automation").concat(n,"_channel_").concat(s,"_position * 2;\n                                if (readPosition >= automation").concat(n,"_channel_").concat(s,"_length)\n                                    readPosition = automation").concat(n,"_channel_").concat(s,"_length - 1;\n                                break;\n                            case 3: // 0.5x speed\n                                readPosition = automation").concat(n,"_channel_").concat(s,"_position / 2;\n                                break;\n                            case 4: // Pingpong\n                                static bool automation").concat(n,"_channel_").concat(s,"_pingpong_forward = true;\n                                if (automation").concat(n,"_channel_").concat(s,"_pingpong_forward) {\n                                    readPosition = automation").concat(n,"_channel_").concat(s,"_position;\n                                } else {\n                                    readPosition = automation").concat(n,"_channel_").concat(s,"_length - 1 - automation").concat(n,"_channel_").concat(s,"_position;\n                                }\n                                break;\n                        }\n\n                        // Clamp position\n                        if (readPosition < 0) readPosition = 0;\n                        if (readPosition >= automation").concat(n,"_channel_").concat(s,"_length)\n                            readPosition = automation").concat(n,"_channel_").concat(s,"_length - 1;\n\n                        // Output from buffer\n                        automation").concat(n,"_output_").concat(s," = automation").concat(n,"_buffer_").concat(s,"[readPosition];\n\n                        // Advance position\n                        automation").concat(n,"_channel_").concat(s,"_position++;\n\n                        // Handle loop/stop\n                        int effectiveLength = automation").concat(n,"_channel_").concat(s,"_length;\n                        if (automation").concat(n,"_playback_mode == 2) effectiveLength /= 2;\n                        if (automation").concat(n,"_playback_mode == 3) effectiveLength *= 2;\n\n                        if (automation").concat(n,"_channel_").concat(s,"_position >= effectiveLength) {\n                            if (automation").concat(n,"_loop) {\n                                automation").concat(n,"_channel_").concat(s,"_position = 0;\n                            } else {\n                                automation").concat(n,"_channel_").concat(s,"_playing = false;\n                                automation").concat(n,"_channel_").concat(s,"_position = effectiveLength - 1;\n                            }\n                        }\n                    } else {\n                        // Touched - pass through\n                        automation").concat(n,"_output_").concat(s," = automation").concat(n,"_input_").concat(s,";\n                    }\n\n                    automation").concat(n,"_last_input_").concat(s," = automation").concat(n,"_input_").concat(s,";\n                }\n                // Idle mode - pass through\n                else {\n                    automation").concat(n,"_output_").concat(s," = automation").concat(n,"_input_").concat(s,";\n                }\n            }\n");return"\n        // Automation ".concat(n," - Independent Per-Channel Automation (").concat(o," channels)\n        {\n            // Read input values for all channels\n").concat(r,"\n            // Global recording trigger (button)\n            bool recordTrigger = automation").concat(n,"_record_trigger > 0.5;\n\n            // Rising edge: Start recording for moved channels (preserve playing channels)\n            if (recordTrigger && !automation").concat(n,'_last_record_trigger) {\n                Serial.println("Automation ').concat(n,': Button pressed - starting recording mode");\n                // Start recording mode for all channels (will filter by movement)\n                // Channels already playing are preserved\n').concat(this.generateChannelRecordingStart(n,o),"\n            }\n\n            // Falling edge: Stop recording, start playback for recorded channels\n            else if (!recordTrigger && automation").concat(n,"_last_record_trigger) {\n").concat(this.generateChannelRecordingStop(n,o),"\n            }\n\n            automation").concat(n,'_last_record_trigger = recordTrigger;\n\n            // MODE SELECTION: Encoder button + pot movement selects playback mode\n            // Works regardless of which channels are playing (global mode for all channels)\n            Serial.printf("DEBUG: mode_select=%d, input_1=%.3f\\n", automation').concat(n,"_mode_select, automation").concat(n,"_input_1);\n            if (automation").concat(n,"_mode_select) {\n                // Encoder button is held - use first input to select mode\n                // Map input 0.0-1.0 to modes: 0=normal, 1=reverse, 2=2x, 3=0.5x, 4=pingpong\n                automation").concat(n,"_selected_mode = (int)(automation").concat(n,"_input_1 * 4.99);\n                if (automation").concat(n,"_selected_mode != automation").concat(n,'_playback_mode) {\n                    const char* modeNames[] = {"Normal", "Reverse", "2x Speed", "0.5x Speed", "Pingpong"};\n                    Serial.printf("Automation ').concat(n,': Mode = %s\\n", modeNames[automation').concat(n,"_selected_mode]);\n                    automation").concat(n,"_playback_mode = automation").concat(n,"_selected_mode;\n                }\n            }\n\n").concat(l,"\n        }\n")}},{key:"generateStopAllChannels",value:function(e,n){for(var t="",a=1;a<=n;a++)t+="                automation".concat(e,"_channel_").concat(a,"_playing = false;\n");return t}},{key:"generateChannelRecordingStart",value:function(e,n){for(var t="",a=1;a<=n;a++)t+="                // Only reset channel ".concat(a," if it has no existing recording\n                if (automation").concat(e,"_channel_").concat(a,"_length == 0) {\n                    automation").concat(e,"_channel_").concat(a,"_recording = true;\n                    automation").concat(e,"_channel_").concat(a,"_playing = false;\n                    automation").concat(e,"_channel_").concat(a,"_position = 0;\n                } else {\n                    // Channel ").concat(a,' has existing data - keep it playing\n                    Serial.printf("Automation ').concat(e," Channel ").concat(a,': Preserving existing %d samples\\n", automation').concat(e,"_channel_").concat(a,"_length);\n                }\n");return t}},{key:"generateChannelRecordingStop",value:function(e,n){for(var t="",a=1;a<=n;a++)t+="                if (automation".concat(e,"_channel_").concat(a,"_recording) {\n                    automation").concat(e,"_channel_").concat(a,"_recording = false;\n                    if (automation").concat(e,"_channel_").concat(a,'_length > 0) {\n                        Serial.printf("Automation ').concat(e," Channel ").concat(a,': Recorded %d samples, starting playback\\n",\n                            automation').concat(e,"_channel_").concat(a,"_length);\n                        automation").concat(e,"_channel_").concat(a,"_playing = true;\n                        automation").concat(e,"_channel_").concat(a,"_position = 0;\n                        automation").concat(e,"_channel_").concat(a,"_start_time = millis();\n                        // Initialize last_input for touch detection\n                        automation").concat(e,"_last_input_").concat(a," = automation").concat(e,"_input_").concat(a,';\n                    } else {\n                        Serial.printf("Automation ').concat(e," Channel ").concat(a,': No movement detected\\n");\n                    }\n                }\n');return t}}])&&be(e.prototype,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function Se(e){return Se="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Se(e)}function xe(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,Ee(a.key),a)}}function Ee(e){var n=function(e){if("object"!=Se(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=Se(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==Se(n)?n:n+""}var Pe=function(){return e=function e(n){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.connectionResolver=n,this.pinMapper=ae,this.declaredButtons=new Set},(n=[{key:"generateIncludes",value:function(e){return[]}},{key:"generateGlobalVariables",value:function(e,n,t){switch(e.type){case"GateIn":var a=e.params.index||1,o=1===a?4:5,r=e.params.mode||"trigger";return e.params.trigger_hold_ms,"\n// ".concat(t.label," ").concat(n," - Gate In ").concat(a," (LTV816 optoisolator on MCP23017 GPA").concat(o,")\nconst int GATEIN_PIN_").concat(n," = ").concat(o,"; // MCP23017 GPA").concat(o,"\nbool gatein").concat(n,"_state = false;\nbool gatein").concat(n,"_lastState = false;\nbool gatein").concat(n,"_trigger = false;\nconst char* gatein").concat(n,'_mode = "').concat(r,'"; // "gate" or "trigger"\nunsigned long gatein').concat(n,"_trigHoldUntil = 0; // Latch trigger for reliable sampling\n");case"Pot":default:return"";case"LEDButton":var c=e.params.index||1,i=this.pinMapper.getMCPButtonPin(c-1),l=this.pinMapper.getMCPButtonLEDPin(c-1);return"\n// ".concat(t.label," ").concat(n," (Physical Button ").concat(c,")\nconst int BTN_PIN_").concat(n," = ").concat(i,"; // MCP23017 pin ").concat(i,"\nconst int LED_PIN_").concat(n," = ").concat(l,"; // MCP23017 pin ").concat(l,"\nbool btn").concat(c,"_pressed = false;\nvolatile bool btn").concat(c,"_gate = false;     // Raw gate signal for modular connections\nfloat btn").concat(c,"_output = 0.0;             // Normalized output for control connections\nbool btn").concat(c,"_lastState = false;\nbool btn").concat(c,"_state = false;\nbool btn").concat(c,"_ledState = false;\nunsigned long btn").concat(c,"_lastDebounce = 0;\nconst unsigned long btn").concat(c,"_debounceDelay = 50;\nfloat btn").concat(c,"_sampleIn = 0.0;  // Sample & hold input\nfloat btn").concat(c,"_sampleOut = 0.0; // Sample & hold output (held value)\n");case"Encoder":var s=this.pinMapper.getEncoderPins();return"\n// ".concat(t.label," ").concat(n,"\nconst int ENC_A_PIN_").concat(n," = ").concat(s.A,"; // GPIO").concat(s.A,"\nconst int ENC_B_PIN_").concat(n," = ").concat(s.B,"; // GPIO").concat(s.B,"\nconst int ENC_BTN_PIN_").concat(n," = ").concat(s.BTN,"; // GPIO").concat(s.BTN,"\nvolatile int enc").concat(n,"_position = 0;\nint enc").concat(n,"_lastPosition = 0;\nbool enc").concat(n,"_buttonPressed = false;\nbool enc").concat(n,"_lastButtonState = false;\nvolatile float enc").concat(n,"_value = 0.0; // Normalized 0-1 value\n");case"GateOut":var u=e.params.index||1,d=this.pinMapper.getGateOutPin(u-1);return"\n// ".concat(t.label," ").concat(n," - Gate Out ").concat(u,"\nconst int GATE_PIN_").concat(n," = ").concat(d,"; // GPIO").concat(d," (PWM capable for CV)\nbool gate").concat(n,"_state = false;\n");case"MIDIIn":var p=e.params.channel||0;return"\n// ".concat(t.label," ").concat(n," - UART0 (TXD0/RXD0) with TLP2361 optocoupler\nHardwareSerial MIDISerial").concat(n,"(0); // UART0\nuint8_t midiin").concat(n,"_channel = ").concat(p,"; // 0 = omni, 1-16 = specific channel\nfloat midiin").concat(n,"_note = 0.0;      // 0-1 normalized (C3-C7 range, MIDI 48-96)\nfloat midiin").concat(n,"_velocity = 0.0;  // 0-1 normalized (0-127)\nbool midiin").concat(n,"_gate = false;     // Note on/off gate\nuint8_t midiin").concat(n,"_lastNote = 0;  // Track last note for note-off matching\nunsigned long midiin").concat(n,"_lastRx = 0; // Timestamp for LED feedback\n");case"MIDIOut":for(var f=e.params.channel||1,m=e.params.num_cc||1,_=e.params.cc_numbers||[1,2,3,4,5,6,7,8],g="",h=1;h<=m;h++){var v=_[h-1]||h;g+="const uint8_t midiout".concat(n,"_cc").concat(h,"_number = ").concat(v,"; // CC").concat(v,"\n")}return"\n// ".concat(t.label," ").concat(n," - UART1 (TXD1/RXD1) for MIDI output\nHardwareSerial MIDIOutSerial").concat(n,"(1); // UART1 (TX=GPIO43)\nuint8_t midiout").concat(n,"_channel = ").concat(f,"; // MIDI channel (1-16)\nconst uint8_t midiout").concat(n,"_num_cc = ").concat(m,"; // Number of active CC ports\n").concat(g,"\n// State tracking\nuint8_t midiout").concat(n,"_lastNote = 0;    // Last sent note (for note-off)\nbool midiout").concat(n,"_lastGate = false;   // Last gate state\nfloat midiout").concat(n,"_lastVelocity = 0.0; // Last velocity\nfloat midiout").concat(n,"_lastCC[8] = {0.0}; // Last CC values (for change detection)\nunsigned long midiout").concat(n,"_lastTx = 0; // Timestamp for LED feedback\n");case"USBMIDIIn":var b=e.params.channel||0;return"\n// ".concat(t.label," ").concat(n," - USB MIDI Input (GPIO19/20, class-compliant)\nuint8_t usbmidiin").concat(n,"_channel = ").concat(b,"; // 0 = omni, 1-16 = specific channel\nfloat usbmidiin").concat(n,"_note = 0.0;      // 0-1 normalized (C3-C7 range, MIDI 48-96)\nfloat usbmidiin").concat(n,"_velocity = 0.0;  // 0-1 normalized (0-127)\nbool usbmidiin").concat(n,"_gate = false;     // Note on/off gate\nuint8_t usbmidiin").concat(n,"_lastNote = 0;  // Track last note for note-off matching\n");case"USBMIDIOut":for(var y=e.params.num_outputs||1,k="",S=1;S<=y;S++){var x=e.params["ch_".concat(S)]||S,E=e.params["cc_".concat(S)]||S;k+="const uint8_t usbmidiout".concat(n,"_ch").concat(S," = ").concat(x,"; // Output ").concat(S,"  MIDI channel ").concat(x,"\n"),k+="const uint8_t usbmidiout".concat(n,"_cc").concat(S,"_number = ").concat(E,"; // Output ").concat(S," CC number\n")}var P="";return P+="uint8_t usbmidiout".concat(n,"_lastNote[").concat(y,"] = {0}; // Last sent notes\n"),P+="bool usbmidiout".concat(n,"_lastGate[").concat(y,"] = {false}; // Last gate states\n"),P+="float usbmidiout".concat(n,"_lastVelocity[").concat(y,"] = {0.0}; // Last velocities\n"),P+="float usbmidiout".concat(n,"_lastCC[").concat(y,"] = {0.0}; // Last CC values\n"),"\n// ".concat(t.label," ").concat(n," - USB MIDI Output with multi-channel routing\nconst uint8_t usbmidiout").concat(n,"_num_outputs = ").concat(y,"; // Number of active output groups\n").concat(k,"\n// State tracking (per-output)\n").concat(P,"\n")}}},{key:"generateSetupCode",value:function(e,n){switch(e.type){case"Pot":return"\n    // Pot ".concat(n," setup\n    pinMode(POT_PIN_").concat(n,", INPUT);\n");case"LEDButton":return"\n    // LEDButton ".concat(n," setup (MCP23017 pins configured in base setup)\n");case"Encoder":return"\n    // Encoder ".concat(n," setup\n    pinMode(ENC_A_PIN_").concat(n,", INPUT_PULLUP);\n    pinMode(ENC_B_PIN_").concat(n,", INPUT_PULLUP);\n    pinMode(ENC_BTN_PIN_").concat(n,", INPUT_PULLUP);\n\n    // Attach interrupt for encoder\n    attachInterrupt(digitalPinToInterrupt(ENC_A_PIN_").concat(n,"), []() {\n        if (digitalRead(ENC_A_PIN_").concat(n,") != digitalRead(ENC_B_PIN_").concat(n,")) {\n            enc").concat(n,"_position++;\n        } else {\n            enc").concat(n,"_position--;\n        }\n    }, CHANGE);\n");case"GateOut":return"\n    // GateOut ".concat(n," setup\n    pinMode(GATE_PIN_").concat(n,", OUTPUT);\n    digitalWrite(GATE_PIN_").concat(n,", LOW);\n");case"GateIn":return"\n    // GateIn ".concat(n," setup (MCP23017 pin configured in base setup as INPUT_PULLUP)\n");case"MIDIIn":return"\n    // MIDIIn ".concat(n," setup - UART0 at 31250 baud (MIDI standard)\n    // NOTE: UART0 pins swapped in v1.0 schematic - RX is actually GPIO44, not GPIO43\n    MIDISerial").concat(n,'.begin(31250, SERIAL_8N1, 44, 43); // RX=GPIO44, TX=GPIO43\n    Serial.println("MIDI In ').concat(n,' initialized on UART0 (31250 baud, RX=GPIO44)");\n');case"MIDIOut":return"\n    // MIDIOut ".concat(n," setup - UART1 at 31250 baud (MIDI standard)\n    // TX=GPIO43 (v1.0 confirmed), RX not used for output-only\n    MIDIOutSerial").concat(n,'.begin(31250, SERIAL_8N1, -1, 43); // RX=-1 (not used), TX=GPIO43\n    Serial.println("MIDI Out ').concat(n,' initialized on UART1 (31250 baud, TX=GPIO43)");\n');case"USBMIDIIn":return"\n    // USBMIDIIn ".concat(n,' setup - Initialized globally with USB.begin()\n    Serial.println("USB MIDI In ').concat(n,' ready (class-compliant, GPIO19/20)");\n');case"USBMIDIOut":return"\n    // USBMIDIOut ".concat(n,' setup - Initialized globally with USB.begin()\n    Serial.println("USB MIDI Out ').concat(n,' ready (multi-channel routing)");\n');default:return""}}},{key:"generateControlCode",value:function(e,n,t){switch(e.type){case"Pot":return this.generatePotCode(e,n);case"LEDButton":return this.generateButtonCode(e,n,t);case"Encoder":return this.generateEncoderCode(e,n);case"GateOut":return this.generateGateOutCode(e,n,t);case"GateIn":return this.generateGateInCode(e,n);case"MIDIIn":return this.generateMIDIInCode(e,n);case"MIDIOut":return this.generateMIDIOutCode(e,n,t);case"USBMIDIIn":return this.generateUSBMIDIInCode(e,n);case"USBMIDIOut":return this.generateUSBMIDIOutCode(e,n,t);default:return""}}},{key:"generatePotCode",value:function(e,n){return"\n        // Pot ".concat(n," reading with jitter reduction\n        int rawValue = analogRead(POT_PIN_").concat(n,");\n        float newValue = rawValue / 4095.0; // Convert to 0-1 range (12-bit ADC)\n\n        // Deadband filtering: ignore tiny changes (< 0.005 = ~20 ADC counts)\n        float deadband = 0.005;\n        if (abs(newValue - pot").concat(n,"_smoothed) > deadband) {\n            // Apply smoothing to reduce noise\n            pot").concat(n,"_smoothed = (POT_SMOOTH_FACTOR_").concat(n," * newValue) +\n                                  ((1.0 - POT_SMOOTH_FACTOR_").concat(n,") * pot").concat(n,"_smoothed);\n        }\n        pot").concat(n,"_value = pot").concat(n,"_smoothed;\n")}},{key:"generateButtonCode",value:function(e,n,t){var a="btn".concat(n);if(this.declaredButtons.has(a))return"";this.declaredButtons.add(a);var o=t.some(function(n){return n.from.id.includes("".concat(e.id,":"))&&"pressed"===n.from.port});return"\n        // LEDButton ".concat(n," processing - hasLEDConnection: ").concat(o,"\n        {\n            // Read button state from MCP23017\n            bool buttonState = !mcp.digitalRead(BTN_PIN_").concat(n,"); // Active low\n            \n            // Debounce button\n            if (buttonState != btn").concat(n,"_lastState) {\n                btn").concat(n,"_lastDebounce = millis();\n            }\n            \n            if ((millis() - btn").concat(n,"_lastDebounce) > btn").concat(n,"_debounceDelay) {\n                if (buttonState != btn").concat(n,"_pressed) {\n                    btn").concat(n,"_pressed = buttonState;\n                    btn").concat(n,"_gate = buttonState;  // Raw gate signal always follows button state\n\n                    // Update LED state\n                    ").concat(o?"\n                    if (btn".concat(n,"_pressed) {\n                        btn").concat(n,"_ledState = !btn").concat(n,"_ledState;\n                        mcp.digitalWrite(LED_PIN_").concat(n,", btn").concat(n,"_ledState);\n                    }"):"\n                    mcp.digitalWrite(LED_PIN_".concat(n,", btn").concat(n,"_pressed);"),"\n                }\n            }\n            \n            btn").concat(n,"_lastState = buttonState;\n        }\n")}},{key:"generateEncoderCode",value:function(e,n){return"\n        // Encoder ".concat(n," processing\n        {\n            // Check for position changes\n            if (enc").concat(n,"_position != enc").concat(n,"_lastPosition) {\n                // Convert encoder position to normalized value\n                // Assuming +/- 100 encoder steps for full range\n                float normalizedPos = (enc").concat(n,"_position % 200) / 200.0;\n                if (normalizedPos < 0) normalizedPos += 1.0;\n                enc").concat(n,"_value = normalizedPos;\n                \n                enc").concat(n,"_lastPosition = enc").concat(n,"_position;\n            }\n            \n            // Read button state\n            bool buttonState = !digitalRead(ENC_BTN_PIN_").concat(n,"); // Active low\n            if (buttonState != enc").concat(n,"_lastButtonState) {\n                enc").concat(n,"_buttonPressed = buttonState;\n                enc").concat(n,"_lastButtonState = buttonState;\n            }\n        }\n")}},{key:"generateGateOutCode",value:function(e,n,t){var a=t.find(function(n){return n.to.id.includes("".concat(e.id,":"))&&"in"===n.to.port}),o="false";if(a){var r=a.from.id.split(":")[0],c=this.connectionResolver.modules.find(function(e){return e.id===r});if(c){var i,l=(null===(i=r.match(/\d+$/))||void 0===i?void 0:i[0])||"1";switch(c.type){case"Clock":o="clock".concat(l,"_output");break;case"LEDButton":o="btn".concat(l,"_pressed");break;case"ADSR":o="(adsr".concat(l,"_output > 0.1)")}}}return e.params.pin,"\n        // GateOut ".concat(n," processing\n        {\n            bool gateSignal = ").concat(o,";\n\n            if (gateSignal != gate").concat(n,"_state) {\n                gate").concat(n,"_state = gateSignal;\n                digitalWrite(GATE_PIN_").concat(n,", gateSignal ? HIGH : LOW);\n            }\n\n            // Update LED state for visual feedback\n            // GPIO10 (Gate 3)  led_gateout1_active\n            // GPIO11 (Gate 4)  led_gateout2_active\n            if (GATE_PIN_").concat(n," == 10) {\n                led_gateout1_active = gate").concat(n,"_state;\n            } else if (GATE_PIN_").concat(n," == 11) {\n                led_gateout2_active = gate").concat(n,"_state;\n            }\n        }\n")}},{key:"generateGateInCode",value:function(e,n){var t=e.params.trigger_hold_ms||30;return"\n        // GateIn ".concat(n," processing (LTV816 optoisolator input)\n        {\n            // Extract pin state from batch read (bit GATEIN_PIN_").concat(n," of inputs)\n            bool rawPin = (inputs & (1 << GATEIN_PIN_").concat(n,")) != 0;\n            bool gateInput = !rawPin;  // Active low from optoisolator\n\n            // Rising edge detection (immediate, no debounce - piezo pulses are brief!)\n            if (gateInput && !gatein").concat(n,"_lastState) {\n                gatein").concat(n,"_state = true;\n\n                // LATCH trigger for ").concat(t,"ms so control sampling (10ms rate) can catch it\n                if (strcmp(gatein").concat(n,'_mode, "trigger") == 0) {\n                    gatein').concat(n,"_trigger = true;\n                    gatein").concat(n,"_trigHoldUntil = millis() + ").concat(t,";\n                }\n            }\n            // Falling edge detection\n            else if (!gateInput && gatein").concat(n,"_lastState) {\n                gatein").concat(n,"_state = false;\n            }\n\n            // Auto-clear trigger after hold time\n            if (gatein").concat(n,"_trigger && millis() > gatein").concat(n,"_trigHoldUntil) {\n                gatein").concat(n,"_trigger = false;\n            }\n\n            gatein").concat(n,"_lastState = gateInput;\n\n            // Update LED state for visual feedback\n            // GPA4 (pin 4) = Gate In 1  led_gatein1_active\n            // GPA5 (pin 5) = Gate In 2  led_gatein2_active\n            if (GATEIN_PIN_").concat(n," == 4) {\n                led_gatein1_active = gatein").concat(n,"_state;\n            } else if (GATEIN_PIN_").concat(n," == 5) {\n                led_gatein2_active = gatein").concat(n,"_state;\n            }\n        }\n")}},{key:"generateMIDIInCode",value:function(e,n){return e.params.channel,"\n        // MIDIIn ".concat(n," processing - Parse MIDI messages (31250 baud)\n        {\n            while (MIDISerial").concat(n,".available() >= 3) {\n                uint8_t status = MIDISerial").concat(n,".read();\n\n                // Flash LED on any MIDI receive\n                midiin").concat(n,"_lastRx = millis();\n                led_midiin_active = true;\n\n                // Parse Note On/Off messages (0x80-0x9F)\n                if ((status & 0xF0) == 0x90 || (status & 0xF0) == 0x80) {\n                    uint8_t rxChannel = (status & 0x0F) + 1; // Extract channel (1-16)\n                    uint8_t note = MIDISerial").concat(n,".read();\n                    uint8_t velocity = MIDISerial").concat(n,".read();\n\n                    // Check channel filter (0 = omni)\n                    if (midiin").concat(n,"_channel == 0 || midiin").concat(n,"_channel == rxChannel) {\n                        bool isNoteOn = ((status & 0xF0) == 0x90) && (velocity > 0);\n\n                        if (isNoteOn) {\n                            // Note On: Update pitch and velocity\n                            midiin").concat(n,"_lastNote = note;\n                            midiin").concat(n,"_gate = true;\n\n                            // Normalize note to 0-1 (C3-C7 = MIDI 48-96)\n                            float normalizedNote = (note - 48.0) / 48.0;\n                            midiin").concat(n,"_note = constrain(normalizedNote, 0.0, 1.0);\n\n                            // Normalize velocity to 0-1\n                            midiin").concat(n,"_velocity = velocity / 127.0;\n                        } else {\n                            // Note Off: Clear gate only if it matches last note\n                            if (note == midiin").concat(n,"_lastNote) {\n                                midiin").concat(n,"_gate = false;\n                            }\n                        }\n                    }\n                } else {\n                    // Unknown message: drain 2 data bytes to stay in sync\n                    if (MIDISerial").concat(n,".available() >= 2) {\n                        MIDISerial").concat(n,".read();\n                        MIDISerial").concat(n,".read();\n                    }\n                }\n            }\n\n            // Auto-clear LED after 50ms\n            if (led_midiin_active && (millis() - midiin").concat(n,"_lastRx > 50)) {\n                led_midiin_active = false;\n            }\n        }\n")}},{key:"generateMIDIOutCode",value:function(e,n,t){for(var a=this,o=e.params.num_cc||1,r=function(n){var o,r=t.find(function(t){return t.to.id.includes("".concat(e.id,":"))&&t.to.port===n});if(!r)return null;var c=r.from.id.split(":")[0],i=r.from.port,l=a.connectionResolver.modules.find(function(e){return e.id===c});if(!l)return null;var s=(null===(o=c.match(/\d+$/))||void 0===o?void 0:o[0])||"1";switch(l.type){case"MIDIIn":if("note"===i)return"midiin".concat(s,"_note");if("gate"===i)return"midiin".concat(s,"_gate");if("velocity"===i)return"midiin".concat(s,"_velocity");break;case"Pot":return"pot".concat(s,"_value");case"ADSR":return"adsr".concat(s,"_output");case"LFO":return"lfo".concat(s,"_output");case"Scale":return"scale".concat(s,"_output");default:return null}return null},c=r("note")||"0.0",i=r("gate")||"false",l=r("velocity")||"0.8",s="",u=1;u<=o;u++){var d=r("cc_".concat(u))||"0.0";s+="\n            // Read CC ".concat(u," input\n            float cc").concat(u,"_value = ").concat(d,";\n            uint8_t cc").concat(u,"_midi = constrain((int)(cc").concat(u,"_value * 127.0), 0, 127);\n\n            // Send CC if value changed (threshold: 1/127 = ~0.008)\n            if (abs(cc").concat(u,"_value - midiout").concat(n,"_lastCC[").concat(u-1,"]) > 0.008) {\n                midiout").concat(n,"_lastCC[").concat(u-1,"] = cc").concat(u,"_value;\n                // MIDI CC message: 0xB0 + channel, CC number, value\n                uint8_t ccMsg[3] = {\n                    (uint8_t)(0xB0 | (midiout").concat(n,"_channel - 1)),\n                    midiout").concat(n,"_cc").concat(u,"_number,\n                    cc").concat(u,"_midi\n                };\n                MIDIOutSerial").concat(n,".write(ccMsg, 3);\n                midiout").concat(n,"_lastTx = millis();\n                led_midiout_active = true;\n            }\n")}return"\n        // MIDIOut ".concat(n," processing - Send MIDI messages (31250 baud)\n        {\n            // Read note, gate, velocity inputs\n            float noteCV = ").concat(c,"; // 0-1 CV (C3-C7 = MIDI 48-96)\n            bool gateSignal = ").concat(i,";\n            float velocityCV = ").concat(l,"; // 0-1 velocity\n\n            // Convert note CV to MIDI note number (C3-C7 range)\n            uint8_t midiNote = constrain(48 + (int)(noteCV * 48.0), 0, 127);\n            uint8_t midiVelocity = constrain((int)(velocityCV * 127.0), 1, 127);\n\n            // Gate rising edge: Send Note On\n            if (gateSignal && !midiout").concat(n,"_lastGate) {\n                midiout").concat(n,"_lastNote = midiNote;\n                midiout").concat(n,"_lastVelocity = velocityCV;\n\n                // MIDI Note On: 0x90 + channel, note, velocity\n                uint8_t noteOnMsg[3] = {\n                    (uint8_t)(0x90 | (midiout").concat(n,"_channel - 1)),\n                    midiNote,\n                    midiVelocity\n                };\n                MIDIOutSerial").concat(n,".write(noteOnMsg, 3);\n                midiout").concat(n,"_lastTx = millis();\n                led_midiout_active = true;\n            }\n            // Gate falling edge: Send Note Off\n            else if (!gateSignal && midiout").concat(n,"_lastGate) {\n                // MIDI Note Off: 0x80 + channel, note, 0\n                uint8_t noteOffMsg[3] = {\n                    (uint8_t)(0x80 | (midiout").concat(n,"_channel - 1)),\n                    midiout").concat(n,"_lastNote,\n                    0\n                };\n                MIDIOutSerial").concat(n,".write(noteOffMsg, 3);\n                midiout").concat(n,"_lastTx = millis();\n                led_midiout_active = true;\n            }\n\n            midiout").concat(n,"_lastGate = gateSignal;\n            ").concat(s,"\n            // Auto-clear LED after 50ms\n            if (led_midiout_active && (millis() - midiout").concat(n,"_lastTx > 50)) {\n                led_midiout_active = false;\n            }\n        }\n")}},{key:"generateUSBMIDIInCode",value:function(e,n){return e.params.channel,"\n        // USBMIDIIn ".concat(n," processing - Parse USB MIDI messages\n        {\n            midiEventPacket_t rx;\n            while (usbMIDI.read(&rx)) {\n                // Parse Note On/Off messages (header 0x09 = note on, 0x08 = note off)\n                if (rx.header == 0x09 || rx.header == 0x08) {\n                    uint8_t rxChannel = (rx.byte1 & 0x0F) + 1; // Extract channel (1-16)\n                    uint8_t note = rx.byte2;\n                    uint8_t velocity = rx.byte3;\n\n                    // Check channel filter (0 = omni)\n                    if (usbmidiin").concat(n,"_channel == 0 || usbmidiin").concat(n,"_channel == rxChannel) {\n                        bool isNoteOn = (rx.header == 0x09) && (velocity > 0);\n\n                        if (isNoteOn) {\n                            // Note On: Update pitch and velocity\n                            usbmidiin").concat(n,"_lastNote = note;\n                            usbmidiin").concat(n,"_gate = true;\n\n                            // Normalize note to 0-1 (C3-C7 = MIDI 48-96)\n                            float normalizedNote = (note - 48.0) / 48.0;\n                            usbmidiin").concat(n,"_note = constrain(normalizedNote, 0.0, 1.0);\n\n                            // Normalize velocity to 0-1\n                            usbmidiin").concat(n,"_velocity = velocity / 127.0;\n                        } else {\n                            // Note Off: Clear gate only if it matches last note\n                            if (note == usbmidiin").concat(n,"_lastNote) {\n                                usbmidiin").concat(n,"_gate = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n")}},{key:"generateUSBMIDIOutCode",value:function(e,n,t){for(var a=this,o=e.params.num_outputs||1,r=function(n){var o,r=t.find(function(t){return t.to.id.includes("".concat(e.id,":"))&&t.to.port===n});if(!r)return null;var c=r.from.id.split(":")[0],i=r.from.port,l=a.connectionResolver.modules.find(function(e){return e.id===c});if(!l)return null;var s=(null===(o=c.match(/\\d+$/))||void 0===o?void 0:o[0])||"1";switch(l.type){case"USBMIDIIn":if("note"===i)return"usbmidiin".concat(s,"_note");if("gate"===i)return"usbmidiin".concat(s,"_gate");if("velocity"===i)return"usbmidiin".concat(s,"_velocity");break;case"MIDIIn":if("note"===i)return"midiin".concat(s,"_note");if("gate"===i)return"midiin".concat(s,"_gate");if("velocity"===i)return"midiin".concat(s,"_velocity");break;case"Pot":return"pot".concat(s,"_value");case"ADSR":return"adsr".concat(s,"_output");case"LFO":return"lfo".concat(s,"_output");case"Scale":return"scale".concat(s,"_output");case"HarmonicSequencer":if("pitch_sum"===i)return"seq".concat(s,"_pitch_sum");if("pitch_hz"===i)return"seq".concat(s,"_pitch_hz");if("gate_sum"===i)return"seq".concat(s,"_gate_sum");break;default:return null}return null},c="",i=1;i<=o;i++){var l=r("note_".concat(i))||"0.0",s=r("gate_".concat(i))||"false",u=r("velocity_".concat(i))||"0.8",d=r("cc_".concat(i))||"0.0";c+="\n            // Output ".concat(i,"  MIDI Channel ").concat(e.params["ch_".concat(i)]||i,"\n            {\n                float noteCV = ").concat(l,"; // 0-1 CV (C3-C7 = MIDI 48-96)\n                bool gateSignal = ").concat(s,";\n                float velocityCV = ").concat(u,"; // 0-1 velocity\n                float ccValue = ").concat(d,"; // 0-1 CC value\n\n                // Convert note CV to MIDI note number (C3-C7 range)\n                uint8_t midiNote = constrain(48 + (int)(noteCV * 48.0), 0, 127);\n                uint8_t midiVelocity = constrain((int)(velocityCV * 127.0), 1, 127);\n                uint8_t midiCC = constrain((int)(ccValue * 127.0), 0, 127);\n\n                // Gate rising edge: Send Note On\n                if (gateSignal && !usbmidiout").concat(n,"_lastGate[").concat(i-1,"]) {\n                    usbmidiout").concat(n,"_lastNote[").concat(i-1,"] = midiNote;\n                    usbmidiout").concat(n,"_lastVelocity[").concat(i-1,"] = velocityCV;\n\n                    // USB MIDI Note On packet\n                    midiEventPacket_t noteOn = {0x09, (uint8_t)(0x90 | (usbmidiout").concat(n,"_ch").concat(i," - 1)), midiNote, midiVelocity};\n                    usbMIDI.writePacket(&noteOn);\n                }\n                // Gate falling edge: Send Note Off\n                else if (!gateSignal && usbmidiout").concat(n,"_lastGate[").concat(i-1,"]) {\n                    // USB MIDI Note Off packet\n                    midiEventPacket_t noteOff = {0x08, (uint8_t)(0x80 | (usbmidiout").concat(n,"_ch").concat(i," - 1)), usbmidiout").concat(n,"_lastNote[").concat(i-1,"], 0};\n                    usbMIDI.writePacket(&noteOff);\n                }\n                // Pitch change while gate is high (legato): Send Note Off + Note On\n                else if (gateSignal && usbmidiout").concat(n,"_lastGate[").concat(i-1,"] && midiNote != usbmidiout").concat(n,"_lastNote[").concat(i-1,"]) {\n                    // Note Off for previous note\n                    midiEventPacket_t noteOff = {0x08, (uint8_t)(0x80 | (usbmidiout").concat(n,"_ch").concat(i," - 1)), usbmidiout").concat(n,"_lastNote[").concat(i-1,"], 0};\n                    usbMIDI.writePacket(&noteOff);\n\n                    // Note On for new note\n                    usbmidiout").concat(n,"_lastNote[").concat(i-1,"] = midiNote;\n                    usbmidiout").concat(n,"_lastVelocity[").concat(i-1,"] = velocityCV;\n                    midiEventPacket_t noteOn = {0x09, (uint8_t)(0x90 | (usbmidiout").concat(n,"_ch").concat(i," - 1)), midiNote, midiVelocity};\n                    usbMIDI.writePacket(&noteOn);\n                }\n\n                usbmidiout").concat(n,"_lastGate[").concat(i-1,"] = gateSignal;\n\n                // Send CC if value changed (threshold: 1/127 = ~0.008)\n                if (abs(ccValue - usbmidiout").concat(n,"_lastCC[").concat(i-1,"]) > 0.008) {\n                    usbmidiout").concat(n,"_lastCC[").concat(i-1,"] = ccValue;\n\n                    // USB MIDI CC packet\n                    midiEventPacket_t cc = {0x0B, (uint8_t)(0xB0 | (usbmidiout").concat(n,"_ch").concat(i," - 1)), usbmidiout").concat(n,"_cc").concat(i,"_number, midiCC};\n                    usbMIDI.writePacket(&cc);\n                }\n            }\n")}return"\n        // USBMIDIOut ".concat(n," processing - Send USB MIDI to ").concat(o," channel(s)\n        {").concat(c,"\n        }\n")}},{key:"generateProcessingCode",value:function(e,n,t){return this.generateControlCode(e,n,t)}}])&&xe(e.prototype,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();function we(e){return we="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},we(e)}function Ce(e,n){var t="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=Ie(e))||n&&e&&"number"==typeof e.length){t&&(e=t);var a=0,o=function(){};return{s:o,n:function(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function(e){throw e},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,c=!0,i=!1;return{s:function(){t=t.call(e)},n:function(){var e=t.next();return c=e.done,e},e:function(e){i=!0,r=e},f:function(){try{c||null==t.return||t.return()}finally{if(i)throw r}}}}function Re(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,r,c,i=[],l=!0,s=!1;try{if(r=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=r.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(c=t.return(),Object(c)!==c))return}finally{if(s)throw o}}return i}}(e,n)||Ie(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Le(e){return function(e){if(Array.isArray(e))return Me(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||Ie(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Ie(e,n){if(e){if("string"==typeof e)return Me(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Me(e,n):void 0}}function Me(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}function De(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function Ae(e,n,t){return(n=Te(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function Oe(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,Te(a.key),a)}}function Te(e){var n=function(e){if("object"!=we(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=we(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==we(n)?n:n+""}var Be=function(){return e=function e(n,t){var a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.modules=n,this.connections=this.resolveGroupConnections(t,a),this.groups=a,this.audioChain=[],this.controlChain=[],this.includes=new Set,this.globalVariables=[],this.moduleClasses=[],this.setupCode=[],this.loopCode=[],this.potConnectionCode=[],this.controlConnectionCode=[],this.declaredPots=new Set,this.declaredButtons=new Set,this.updateAudioCode=[],this.modularInstances=new Map,this.connectionResolver=new J(n,this.connections),this.pinMapper=ae,this.baseTemplate=ie,this.audioModules=new fe(this.connectionResolver),this.sampleModules=new he(this.connectionResolver),this.controlModules=new ke(this.connectionResolver),this.hardwareModules=new Pe(this.connectionResolver)},n=[{key:"resolveGroupConnections",value:function(e,n){return n&&0!==n.length?e.map(function(e){var t=function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?De(Object(t),!0).forEach(function(n){Ae(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):De(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}({},e),a=e.from.id.split(":")[0],o=n.find(function(e){return e.id===a});if(o){var r,c=e.from.id,i=e.from.port,l=null===(r=o.outputPorts)||void 0===r?void 0:r.find(function(e){return"".concat(o.id,":out_").concat(e.sourcePort)===c||i==="out_".concat(e.port)});l&&(t.from={id:"".concat(l.sourceModuleId,":").concat(l.sourcePort),port:l.sourcePort,kind:e.from.kind})}var s=e.to.id.split(":")[0],u=n.find(function(e){return e.id===s});if(u){var d,p=e.to.id,f=e.to.port,m=null===(d=u.inputPorts)||void 0===d?void 0:d.find(function(e){return"".concat(u.id,":in_").concat(e.targetPort)===p||f==="in_".concat(e.port)});m&&(t.to={id:"".concat(m.targetModuleId,":").concat(m.targetPort),port:m.targetPort,kind:e.to.kind})}return t}):e}},{key:"getPotReference",value:function(e){var n=this.modules.find(function(n){return n.id===e});if(n&&"Pot"===n.type){var t=n.params.index||1;return n.params.bank,"pot".concat(t)}return console.warn("getPotReference called with non-Pot module: ".concat(e)),null}},{key:"generateBankAwareAssignment",value:function(e,n){var t=this.modules.find(function(n){return n.id===e});if(!t||"Pot"!==t.type)return"        // WARNING: Invalid pot reference for ".concat(e);var a=t.params.bank||1;return t.params.locked?"        ".concat(n," // Pot").concat(t.params.index," (LOCKED across all banks)"):"        if (currentBank == ".concat(a,") { ").concat(n," } // Pot").concat(t.params.index," Bank ").concat(a)}},{key:"generateBankAwareButtonAssignment",value:function(e,n){var t=this.modules.find(function(n){return n.id===e});if(!t||"LEDButton"!==t.type)return"        // WARNING: Invalid button reference for ".concat(e);var a=t.params.bank||1;return t.params.locked?"        ".concat(n," // Button").concat(t.params.index," (LOCKED)"):"        if (currentBank == ".concat(a,") { ").concat(n," } // Button").concat(t.params.index," Bank ").concat(a)}},{key:"getButtonReference",value:function(e){var n,t=this.modules.find(function(n){return n.id===e});if(t&&"LEDButton"===t.type){var a=t.params&&t.params.index?t.params.index:1;return"btn".concat(a)}var o=(null===(n=e.match(/\d+$/))||void 0===n?void 0:n[0])||"1";return"btn".concat(o)}},{key:"getWaveTypeIndex",value:function(e){switch(e.toLowerCase()){case"sine":default:return 0;case"sawtooth":case"saw":return 1;case"square":return 2;case"triangle":case"tri":return 3}}},{key:"generate",value:function(){return console.log("Starting code generation..."),console.log("Modules:",this.modules),console.log("Connections:",this.connections),this.analyzeModules(),this.resolveAudioChain(),this.resolveControlChain(),this.generateIncludes(),this.generateModuleClasses(),this.generateVariables(),this.generateGlobalFunctions(),this.generateSetup(),this.generateLoop(),console.log("Audio chain:",this.audioChain),console.log("Control chain:",this.controlChain),console.log("Hardware modules:",this.hardwareModules),this.assembleCode()}},{key:"analyzeModules",value:function(){}},{key:"generateModuleClasses",value:function(){var e=this,n={Looper:H,BPMLooper:j};this.modules.filter(function(e){return n[e.type]}).forEach(function(t,a){var o=n[t.type];if(o&&o.generateClass){var r=o.generateClass(t.id||a,t.params||{});e.moduleClasses.push(r);var c=(t.id||"".concat(t.type).concat(a)).toLowerCase(),i="".concat(t.type,"_").concat(t.id||a);if(e.moduleClasses.push("\n// Instance of ".concat(t.type," module\n").concat(i," ").concat(c,";\nfloat ").concat(c,"_inputL = 0.0f;\nfloat ").concat(c,"_inputR = 0.0f;\n")),e.modularInstances.set(t.id||"".concat(t.type).concat(a),{instanceName:c,moduleId:t.id||a,type:t.type,originalIndex:a}),o.generateIncludes){var l=o.generateIncludes();l&&e.includes.add(l)}console.log("Generated class and instance for ".concat(t.type," module"))}})}},{key:"resolveAudioChain",value:function(){this.audioChain=this.connectionResolver.resolveAudioChain();var e=new Set;this.audioChain=this.audioChain.filter(function(n){return e.has(n.id)?(console.warn("Removing duplicate ".concat(n.type," ").concat(n.id," from audioChain")),!1):(e.add(n.id),!0)})}},{key:"resolveControlChain",value:function(){var e=this.modules.filter(function(e){return["ADSR","Scale","LFO","Clock","HarmonicSequencer","Automation"].includes(e.type)});this.controlChain=this.topologicalSortControl(e)}},{key:"topologicalSortControl",value:function(e){var n=this,t=[],a=new Set,o=new Set,r=function(c){o.has(c.id)?console.warn("Circular dependency detected in control modules"):a.has(c.id)||(o.add(c.id),n.connections.filter(function(e){return e.to&&"string"==typeof e.to?e.to===c.id:!(!e.to||!e.to.id)&&e.to.id.startsWith(c.id+":")}).map(function(e){return e.from&&"string"==typeof e.from?e.from:e.from&&e.from.id?e.from.id.split(":")[0]:null}).map(function(n){return e.find(function(e){return e.id===n})}).filter(Boolean).forEach(function(e){return r(e)}),o.delete(c.id),a.add(c.id),t.push(c))};return e.forEach(function(e){return r(e)}),t}},{key:"generateIncludes",value:function(){var e=this;this.baseTemplate.generateIncludes().forEach(function(n){e.includes.add(n)}),this.modules.forEach(function(n){switch(e.audioModules.generateIncludes(n.type).forEach(function(n){return e.includes.add(n)}),e.controlModules.generateIncludes(n.type).forEach(function(n){return e.includes.add(n)}),n.type){case"Filter":case"GranularSynth":case"GranularPSRAM":case"GranularDense":e.includes.add("#include <math.h>");break;case"Looper":case"BPMLooper":e.includes.add("#include <cstring>");break;case"AdvancedLooper":e.includes.add("#include <SPIFFS.h>"),e.includes.add("#include <SD.h>"),e.includes.add("#include <esp_heap_caps.h>"),e.includes.add('#include "driver/i2s.h"'),e.includes.add("#include <cstring>");break;case"MIDIIn":case"MIDIOut":e.includes.add("#include <MIDI.h>");break;case"USBMIDIIn":case"USBMIDIOut":e.includes.add('#include "USB.h"'),e.includes.add('#include "USBMIDI.h"');break;case"SDPlayer":case"SamplePlayer":case"KickDrum":case"SnareDrum":case"AudioRecorder":e.includes.add("#include <SD.h>"),e.includes.add("#include <FS.h>"),e.includes.add("#include <SPI.h>")}})}},{key:"generateVariables",value:function(){var e=this;this.globalVariables.push("\n// I2S Configuration for PCM5102A DAC\nstatic const int I2S_BCLK = ".concat(K.I2S_BCLK,";\nstatic const int I2S_LRCK = ").concat(K.I2S_LRCK,";\nstatic const int I2S_DATA = ").concat(K.I2S_DATA,";\nstatic const int SAMPLE_RATE = ").concat(K.SAMPLE_RATE,";\nstatic const int BUFFER_SIZE = ").concat(K.BUFFER_SIZE,";\n        ")),this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type})&&this.globalVariables.push('\n// WAV File Structure (only included when Sample Player modules are present)\nstruct WAVHeader {\n    char riff[4];           // "RIFF"\n    uint32_t fileSize;      // File size - 8\n    char wave[4];           // "WAVE"\n    char fmt[4];            // "fmt "\n    uint32_t fmtSize;       // Format chunk size\n    uint16_t audioFormat;   // Audio format (1 = PCM)\n    uint16_t numChannels;   // Number of channels\n    uint32_t sampleRate;    // Sample rate\n    uint32_t byteRate;      // Byte rate\n    uint16_t blockAlign;    // Block align\n    uint16_t bitsPerSample; // Bits per sample\n    char data[4];           // "data"\n    uint32_t dataSize;      // Data size\n};\n\n// Double Buffer WAV Player Class - Eliminates audio gaps and stuttering\n#define CHUNK_SIZE (16 * 1024)  // 16KB chunks - sector aligned, ~0.09 seconds\n\n// Polyphonic Sample Player with PSRAM caching (2MB optimized)\n#define MAX_VOICES 8                    // Maximum possible voices (will be limited per module)\n#define VOICE_CACHE_SIZE 1024           // 1024 samples per voice cache (internal RAM)\n#define AUDIO_BLOCK_SIZE 256            // Audio processing block size\n#define MAX_PSRAM_SAMPLES (1536 * 1024) // 1.5MB for sample storage\n#define SAMPLE_POOL_SIZE 32             // Maximum 32 different samples loaded\n\n// Ring buffer for credit-based file transfers\n#define RING_BUFFER_SIZE 262144         // 256KB ring buffer in PSRAM\n\nstruct Voice {\n    // PSRAM sample reference\n    int16_t* psramData;              // Pointer to PSRAM sample data\n    uint32_t totalFrames;            // Total frames in this sample (mono or stereo pairs)\n    uint32_t startFrame;             // Start position (0.0-1.0 * totalFrames)\n    uint32_t endFrame;               // End position (0.0-1.0 * totalFrames)\n    uint8_t channels;                // 1=mono, 2=stereo\n    \n    // Playback state (16.16 fixed point for smooth pitch control)\n    uint32_t phase;                  // Current playback position (16.16 fixed point)\n    uint32_t phaseInc;               // Phase increment per sample (pitch * 65536)\n    bool active;                     // Voice is currently playing\n    bool gateOn;                     // Gate signal is high\n    \n    // Hot cache in internal RAM (never blocks PSRAM)\n    alignas(32) int16_t cache[VOICE_CACHE_SIZE]; // 32-byte aligned for DMA efficiency\n    uint32_t cacheBase;              // Which part of sample is cached (frame number)\n    uint32_t cacheFrames;            // How many frames are valid in cache\n    bool cacheValid;                 // Cache contains valid data\n    \n    // Mixing parameters\n    int32_t gainL;                   // Left gain (Q15 format: 0-32767)\n    int32_t gainR;                   // Right gain (Q15 format: 0-32767)\n    \n    // Envelope for click-free triggering\n    uint32_t envPhase;               // Envelope phase (16.16 fixed point)\n    uint32_t envInc;                 // Envelope increment (attack/release speed)\n    bool envAttack;                  // true=attack, false=release\n    \n    // Constructor\n    Voice() : psramData(nullptr), totalFrames(0), startFrame(0), endFrame(0), channels(2),\n              phase(0), phaseInc(65536), active(false), gateOn(false),\n              cacheBase(0), cacheFrames(0), cacheValid(false),\n              gainL(32767), gainR(32767), envPhase(0), envInc(0), envAttack(false) {\n        memset(cache, 0, sizeof(cache));\n    }\n};\n\nstruct SampleEntry {\n    int16_t* psramData;              // PSRAM allocation for this sample\n    uint32_t totalFrames;            // Total frames in sample\n    uint8_t channels;                // 1=mono, 2=stereo\n    String filename;                 // Original filename for reference\n    uint32_t sizeBytes;              // Size in bytes (for memory management)\n    bool loaded;                     // Successfully loaded into PSRAM\n    \n    SampleEntry() : psramData(nullptr), totalFrames(0), channels(2), \n                    sizeBytes(0), loaded(false) {}\n};\n\nclass PolyphonicSamplePlayer {\nprivate:\n    Voice voices[MAX_VOICES];\n    SampleEntry samplePool[SAMPLE_POOL_SIZE];\n    uint32_t usedPSRAM;              // Track PSRAM usage\n    int activeVoiceCount;            // Configurable voice limit (1-8)\n    \n    // Mix buffers in internal RAM (never PSRAM - for I2S DMA)\n    alignas(32) int32_t mixBufferL[AUDIO_BLOCK_SIZE];\n    alignas(32) int32_t mixBufferR[AUDIO_BLOCK_SIZE];\n    alignas(32) int16_t outputBuffer[AUDIO_BLOCK_SIZE * 2]; // Interleaved L/R\n    \n    // Voice allocation\n    int findFreeVoice() {\n        for (int i = 0; i < activeVoiceCount; i++) {\n            if (!voices[i].active) return i;\n        }\n        // Steal oldest voice (voice 0 is oldest)\n        return 0;\n    }\n    \n    // Ensure voice cache contains the data needed for next block\n    void ensureVoiceCache(Voice& v) {\n        if (!v.active || !v.psramData) return;\n        \n        uint32_t neededStart = v.phase >> 16;  // Current frame position\n        uint32_t neededEnd = neededStart + (AUDIO_BLOCK_SIZE * 2); // Worst case: 2x pitch up\n        \n        // Check if cache already contains needed data\n        if (v.cacheValid && neededStart >= v.cacheBase && \n            neededEnd < (v.cacheBase + v.cacheFrames)) {\n            return; // Cache hit - no reload needed\n        }\n        \n        // Cache miss - reload from PSRAM\n        uint32_t cacheStart = neededStart;\n        uint32_t cacheDuration = VOICE_CACHE_SIZE / v.channels;\n        \n        // Handle loop wrapping\n        if (v.endFrame > v.startFrame) {\n            uint32_t loopLength = v.endFrame - v.startFrame;\n            if (cacheStart >= v.endFrame) {\n                cacheStart = v.startFrame + ((cacheStart - v.startFrame) % loopLength);\n            }\n            \n            // Don\'t cache beyond end position\n            uint32_t maxEnd = min(cacheStart + cacheDuration, v.endFrame);\n            cacheDuration = maxEnd - cacheStart;\n        }\n        \n        // Clamp to sample bounds\n        cacheStart = min(cacheStart, v.totalFrames);\n        cacheDuration = min(cacheDuration, v.totalFrames - cacheStart);\n        cacheDuration = min(cacheDuration, (uint32_t)VOICE_CACHE_SIZE / v.channels);\n        \n        // Copy from PSRAM to cache (this is the only PSRAM read per voice per block)\n        if (cacheDuration > 0) {\n            uint32_t samplesToCopy = cacheDuration * v.channels;\n            memcpy(v.cache, v.psramData + (cacheStart * v.channels), \n                   samplesToCopy * sizeof(int16_t));\n            \n            v.cacheBase = cacheStart;\n            v.cacheFrames = cacheDuration;\n            v.cacheValid = true;\n        }\n    }\n    \n    // Linear interpolation for smooth pitch control\n    inline int16_t lerp16(const int16_t* buf, uint32_t frac16, uint32_t i0, uint32_t maxSamples) {\n        if (i0 + 1 >= maxSamples) return buf[i0];\n        \n        int32_t a = buf[i0];\n        int32_t b = buf[i0 + 1];\n        int32_t t = frac16 & 0xFFFF;  // 0..65535\n        return (int16_t)((a * (65536 - t) + b * t) >> 16);\n    }\n    \npublic:\n    PolyphonicSamplePlayer() : usedPSRAM(0), activeVoiceCount(6) {\n        // Initialize sample pool\n        for (int i = 0; i < SAMPLE_POOL_SIZE; i++) {\n            samplePool[i] = SampleEntry();\n        }\n        \n        // Clear mix buffers\n        memset(mixBufferL, 0, sizeof(mixBufferL));\n        memset(mixBufferR, 0, sizeof(mixBufferR));\n        memset(outputBuffer, 0, sizeof(outputBuffer));\n    }\n    \n    // Set maximum concurrent voices (1-8)\n    void setVoiceCount(int voiceCount) {\n        activeVoiceCount = constrain(voiceCount, 1, MAX_VOICES);\n        Serial.printf("Voice count set to: %d\\n", activeVoiceCount);\n    }\n    \n    int getVoiceCount() const { return activeVoiceCount; }\n    \n    // Load sample into PSRAM pool\n    bool loadSample(int sampleIndex, const String& filename) {\n        if (sampleIndex < 0 || sampleIndex >= SAMPLE_POOL_SIZE) return false;\n        \n        SampleEntry& entry = samplePool[sampleIndex];\n        \n        // Free existing sample if present\n        if (entry.loaded && entry.psramData) {\n            heap_caps_free(entry.psramData);\n            usedPSRAM -= entry.sizeBytes;\n            entry.loaded = false;\n        }\n        \n        // Open WAV file\n        File wavFile = SD.open(filename);\n        if (!wavFile) return false;\n        \n        // Read WAV header\n        WAVHeader header;\n        if (wavFile.read((uint8_t*)&header, sizeof(header)) != sizeof(header)) {\n            wavFile.close();\n            return false;\n        }\n        \n        // Validate WAV format\n        if (strncmp(header.riff, "RIFF", 4) != 0 || \n            strncmp(header.wave, "WAVE", 4) != 0 ||\n            header.audioFormat != 1 || \n            header.bitsPerSample != 16) {\n            wavFile.close();\n            return false;\n        }\n        \n        // Calculate sample size\n        uint32_t totalSamples = header.dataSize / sizeof(int16_t);\n        uint32_t totalFrames = totalSamples / header.numChannels;\n        uint32_t sizeBytes = header.dataSize;\n        \n        // Check PSRAM budget\n        if (usedPSRAM + sizeBytes > MAX_PSRAM_SAMPLES * sizeof(int16_t)) {\n            wavFile.close();\n            return false; // Not enough PSRAM\n        }\n        \n        // Allocate PSRAM\n        int16_t* psramBuffer = (int16_t*)heap_caps_malloc(sizeBytes, MALLOC_CAP_SPIRAM);\n        if (!psramBuffer) {\n            wavFile.close();\n            return false;\n        }\n        \n        // Load entire sample into PSRAM\n        size_t bytesRead = wavFile.read((uint8_t*)psramBuffer, sizeBytes);\n        wavFile.close();\n        \n        if (bytesRead != sizeBytes) {\n            heap_caps_free(psramBuffer);\n            return false;\n        }\n        \n        // Update sample entry\n        entry.psramData = psramBuffer;\n        entry.totalFrames = totalFrames;\n        entry.channels = header.numChannels;\n        entry.filename = filename;\n        entry.sizeBytes = sizeBytes;\n        entry.loaded = true;\n        usedPSRAM += sizeBytes;\n        \n        return true;\n    }\n    \n    // Trigger voice with sample\n    void triggerVoice(int sampleIndex, float pitch = 1.0f, float startPos = 0.0f, \n                     float endPos = 1.0f, float gainL = 1.0f, float gainR = 1.0f) {\n        if (sampleIndex < 0 || sampleIndex >= SAMPLE_POOL_SIZE) return;\n        if (!samplePool[sampleIndex].loaded) return;\n        \n        int voiceIndex = findFreeVoice();\n        Voice& v = voices[voiceIndex];\n        SampleEntry& sample = samplePool[sampleIndex];\n        \n        // Set up voice parameters\n        v.psramData = sample.psramData;\n        v.totalFrames = sample.totalFrames;\n        v.channels = sample.channels;\n        v.startFrame = (uint32_t)(startPos * sample.totalFrames);\n        v.endFrame = (uint32_t)(endPos * sample.totalFrames);\n        if (v.endFrame <= v.startFrame) v.endFrame = sample.totalFrames;\n        \n        // Set playback parameters\n        v.phase = v.startFrame << 16; // Start at begin position\n        v.phaseInc = (uint32_t)(pitch * 65536.0f); // Fixed point pitch\n        v.gainL = (int32_t)(gainL * 32767.0f);\n        v.gainR = (int32_t)(gainR * 32767.0f);\n        \n        // Initialize envelope for click-free start\n        v.envPhase = 0;\n        v.envInc = 65536 / 64; // 64-sample attack\n        v.envAttack = true;\n        \n        // Mark voice as active\n        v.active = true;\n        v.gateOn = true;\n        v.cacheValid = false; // Force cache reload\n    }\n    \n    // Release voice (envelope-based)\n    void releaseVoice(int voiceIndex) {\n        if (voiceIndex < 0 || voiceIndex >= MAX_VOICES) return;\n        \n        Voice& v = voices[voiceIndex];\n        if (v.active) {\n            v.gateOn = false;\n            v.envAttack = false;\n            v.envInc = 65536 / 128; // 128-sample release\n        }\n    }\n    \n    // Release all active voices (for button release behavior)\n    void releaseAllVoices() {\n        for (int i = 0; i < activeVoiceCount; i++) {\n            if (voices[i].active && voices[i].gateOn) {\n                voices[i].gateOn = false;\n                voices[i].envAttack = false; \n                voices[i].envInc = 65536 / 128; // 128-sample release\n            }\n        }\n    }\n    \n    // Get number of active voices\n    int getActiveVoices() {\n        int count = 0;\n        for (int i = 0; i < activeVoiceCount; i++) {\n            if (voices[i].active) count++;\n        }\n        return count;\n    }\n    \n    // Check if voice is active\n    bool isVoiceActive(int voiceIndex) {\n        if (voiceIndex < 0 || voiceIndex >= activeVoiceCount) return false;\n        return voices[voiceIndex].active;\n    }\n    \n    // Sustain voice (prevent auto-release)\n    void sustainVoice(int voiceIndex) {\n        if (voiceIndex < 0 || voiceIndex >= activeVoiceCount) return;\n        Voice& v = voices[voiceIndex];\n        if (v.active) {\n            v.gateOn = true;  // Keep gate on\n            if (!v.envAttack && v.envPhase < 65536) {\n                v.envAttack = true; // Resume attack if needed\n            }\n        }\n    }\n    \n    // Render audio block (main audio processing)\n    void renderBlock() {\n        // Clear mix buffers\n        memset(mixBufferL, 0, sizeof(mixBufferL));\n        memset(mixBufferR, 0, sizeof(mixBufferR));\n        \n        // Process each active voice\n        for (int v = 0; v < activeVoiceCount; v++) {\n            Voice& voice = voices[v];\n            if (!voice.active) continue;\n            \n            // Ensure cache contains needed data (only PSRAM access per voice)\n            ensureVoiceCache(voice);\n            \n            // Render voice into mix buffer\n            for (int n = 0; n < AUDIO_BLOCK_SIZE; n++) {\n                // Update envelope\n                if (voice.envAttack) {\n                    voice.envPhase += voice.envInc;\n                    if (voice.envPhase >= 65536) {\n                        voice.envPhase = 65536;\n                        voice.envAttack = false;\n                    }\n                } else if (!voice.gateOn) {\n                    if (voice.envPhase > voice.envInc) {\n                        voice.envPhase -= voice.envInc;\n                    } else {\n                        voice.envPhase = 0;\n                        voice.active = false; // Voice finished\n                        break;\n                    }\n                }\n                \n                // Get current frame position\n                uint32_t currentFrame = voice.phase >> 16;\n                \n                // Check loop bounds\n                if (currentFrame >= voice.endFrame) {\n                    if (voice.gateOn) {\n                        // Loop back to start\n                        uint32_t loopLength = voice.endFrame - voice.startFrame;\n                        if (loopLength > 0) {\n                            currentFrame = voice.startFrame + ((currentFrame - voice.startFrame) % loopLength);\n                            voice.phase = (currentFrame << 16) | (voice.phase & 0xFFFF);\n                        }\n                    } else {\n                        // Stop voice if gate is off\n                        voice.active = false;\n                        break;\n                    }\n                }\n                \n                // Read from cache with interpolation\n                if (voice.cacheValid && currentFrame >= voice.cacheBase && \n                    currentFrame < voice.cacheBase + voice.cacheFrames) {\n                    \n                    uint32_t cacheIndex = (currentFrame - voice.cacheBase) * voice.channels;\n                    uint32_t maxCacheSamples = voice.cacheFrames * voice.channels;\n                    \n                    int16_t sampleL, sampleR;\n                    \n                    if (voice.channels == 2) {\n                        // Stereo\n                        sampleL = lerp16(voice.cache, voice.phase, cacheIndex, maxCacheSamples);\n                        sampleR = lerp16(voice.cache, voice.phase, cacheIndex + 1, maxCacheSamples);\n                    } else {\n                        // Mono to stereo\n                        sampleL = sampleR = lerp16(voice.cache, voice.phase, cacheIndex, maxCacheSamples);\n                    }\n                    \n                    // Apply envelope and gain, mix into buffer\n                    int32_t env = voice.envPhase;\n                    int32_t mixL = (sampleL * voice.gainL * env) >> 12; // >> 12 for balanced headroom\n                    int32_t mixR = (sampleR * voice.gainR * env) >> 12;\n                    \n                    mixBufferL[n] += mixL;\n                    mixBufferR[n] += mixR;\n                }\n                \n                // Advance phase\n                voice.phase += voice.phaseInc;\n            }\n        }\n        \n        // Convert to output format with saturation\n        for (int n = 0; n < AUDIO_BLOCK_SIZE; n++) {\n            int32_t L = mixBufferL[n];\n            int32_t R = mixBufferR[n];\n            \n            // Saturate to 16-bit range\n            if (L > 32767) L = 32767;\n            else if (L < -32768) L = -32768;\n            if (R > 32767) R = 32767;\n            else if (R < -32768) R = -32768;\n            \n            outputBuffer[n * 2] = (int16_t)L;\n            outputBuffer[n * 2 + 1] = (int16_t)R;\n        }\n    }\n    \n    // Get next stereo sample (for compatibility with existing code)\n    void getStereoSample(float& left, float& right) {\n        static int blockIndex = 0;\n        static bool blockReady = false;\n        \n        // Render new block when needed\n        if (!blockReady || blockIndex >= AUDIO_BLOCK_SIZE) {\n            renderBlock();\n            blockIndex = 0;\n            blockReady = true;\n        }\n        \n        // Return current sample from block\n        left = outputBuffer[blockIndex * 2] / 32767.0f;\n        right = outputBuffer[blockIndex * 2 + 1] / 32767.0f;\n        blockIndex++;\n    }\n    \n    // Memory usage info\n    uint32_t getPSRAMUsage() const { return usedPSRAM; }\n    uint32_t getPSRAMFree() const { return MAX_PSRAM_SAMPLES * sizeof(int16_t) - usedPSRAM; }\n    int getActiveVoices() const {\n        int count = 0;\n        for (int i = 0; i < activeVoiceCount; i++) {\n            if (voices[i].active) count++;\n        }\n        return count;\n    }\n};\n\nclass MinimalWAVPlayer {\nprivate:\n    File wavFile;\n    WAVHeader header;\n    \n    // Double buffering for seamless playback\n    int16_t* bufferA;\n    int16_t* bufferB;\n    int16_t* playingBuffer;       // Currently being played\n    int16_t* loadingBuffer;       // Being loaded in background\n    \n    uint32_t totalDataBytes;      // Total bytes in WAV data section\n    uint32_t filePosition;        // Current position in file (bytes from start of data)\n    uint32_t playingSamples;      // Samples in currently playing buffer\n    uint32_t playPosition;        // Current play position within playing buffer (legacy)\n    float fractionalPosition;     // Fractional position for pitch control\n    \n    bool isPlaying;\n    bool fileEnded;\n    uint16_t channels;\n    \n    // Control variables for new functionality\n    float playbackSpeed;          // Playback speed multiplier (0.1 to 4.0)\n    float startPosition;          // Start position (0.0 to 1.0)  \n    float endPosition;            // End position (0.0 to 1.0)\n    \n    // Background loading task\n    TaskHandle_t loaderTaskHandle;\n    SemaphoreHandle_t bufferMutex;\n    volatile bool loadingBufferReady;\n    volatile uint32_t loadingBufferSamples;\n    \npublic:\n    MinimalWAVPlayer() : bufferA(nullptr), bufferB(nullptr), totalDataBytes(0), filePosition(0),\n                         playingSamples(0), playPosition(0), fractionalPosition(0.0f), isPlaying(false),\n                         fileEnded(false), channels(2), playbackSpeed(1.0f), startPosition(0.0f), \n                         endPosition(1.0f), loaderTaskHandle(NULL), loadingBufferReady(false), \n                         loadingBufferSamples(0) {\n        \n        // Allocate double buffers\n        bufferA = (int16_t*)heap_caps_malloc(CHUNK_SIZE, MALLOC_CAP_SPIRAM);\n        bufferB = (int16_t*)heap_caps_malloc(CHUNK_SIZE, MALLOC_CAP_SPIRAM);\n        \n        if (!bufferA || !bufferB) {\n            if (bufferA) free(bufferA);\n            if (bufferB) free(bufferB);\n            bufferA = (int16_t*)malloc(CHUNK_SIZE);\n            bufferB = (int16_t*)malloc(CHUNK_SIZE);\n        }\n        \n        if (bufferA && bufferB) {\n            playingBuffer = bufferA;\n            loadingBuffer = bufferB;\n            bufferMutex = xSemaphoreCreateMutex();\n        }\n    }\n    \n    bool loadFile(const String& filename) {\n        if (!bufferA || !bufferB) return false;\n        \n        // Stop any existing playback\n        stop();\n        \n        // Close any existing file\n        if (wavFile) {\n            wavFile.close();\n        }\n        \n        // Reset all state\n        filePosition = 0;\n        playingSamples = 0;\n        playPosition = 0;\n        fractionalPosition = 0.0f;\n        isPlaying = false;\n        fileEnded = false;\n        loadingBufferReady = false;\n        \n        wavFile = SD.open(filename);\n        if (!wavFile) {\n            return false;\n        }\n        \n        // Read WAV header\n        if (wavFile.read((uint8_t*)&header, sizeof(WAVHeader)) != sizeof(WAVHeader)) {\n            wavFile.close();\n            return false;\n        }\n        \n        // Validate WAV file\n        if (strncmp(header.riff, "RIFF", 4) != 0 || strncmp(header.wave, "WAVE", 4) != 0) {\n            wavFile.close();\n            return false;\n        }\n        \n        channels = header.numChannels;\n        totalDataBytes = header.dataSize;\n        \n        // Load first buffer synchronously\n        loadFirstBuffer();\n        \n        return true;\n    }\n    \n    void play() {\n        if (bufferA && bufferB && playingSamples > 0 && !fileEnded) {\n            isPlaying = true;\n            playPosition = 0;\n            fractionalPosition = 0.0f;\n            \n            // Start background loading task\n            startBackgroundLoader();\n        }\n    }\n    \n    void stop() {\n        isPlaying = false;\n        \n        // Kill background loader task\n        if (loaderTaskHandle) {\n            vTaskDelete(loaderTaskHandle);\n            loaderTaskHandle = NULL;\n        }\n    }\n    \n    bool playing() { \n        return isPlaying && !fileEnded;\n    }\n    \n    // Pitch control methods\n    void setPlaybackSpeed(float speed) {\n        playbackSpeed = constrain(speed, 0.1f, 4.0f); // Limit to reasonable range\n    }\n    \n    // Sample section control methods\n    void setStartPosition(float pos) {\n        startPosition = constrain(pos, 0.0f, 1.0f);\n    }\n    \n    void setEndPosition(float pos) {\n        endPosition = constrain(pos, 0.0f, 1.0f);\n    }\n    \n    // Convenience method for mono output\n    float nextSample() {\n        float left, right;\n        getStereoSample(left, right);\n        return (left + right) * 0.5f; // Mix to mono\n    }\n    \n    // Load first buffer synchronously\n    void loadFirstBuffer() {\n        if (!wavFile || filePosition >= totalDataBytes) return;\n        \n        uint32_t bytesToRead = CHUNK_SIZE;\n        if (bytesToRead > totalDataBytes) {\n            bytesToRead = totalDataBytes;\n        }\n        \n        size_t bytesRead = wavFile.read((uint8_t*)playingBuffer, bytesToRead);\n        playingSamples = bytesRead / sizeof(int16_t);\n        playPosition = 0;\n        fractionalPosition = 0.0f;\n        filePosition += bytesRead;\n        \n        if (bytesRead < CHUNK_SIZE) {\n            memset((uint8_t*)playingBuffer + bytesRead, 0, CHUNK_SIZE - bytesRead);\n        }\n    }\n    \n    // Background loading task (static method)\n    static void backgroundLoaderTask(void* param) {\n        MinimalWAVPlayer* player = (MinimalWAVPlayer*)param;\n        \n        while (player->isPlaying && !player->fileEnded) {\n            // Only load if loading buffer is empty and we need more data\n            if (!player->loadingBufferReady && player->filePosition < player->totalDataBytes) {\n                player->loadNextBufferBackground();\n            }\n            \n            vTaskDelay(5); // 5ms delay\n        }\n        \n        player->loaderTaskHandle = NULL;\n        vTaskDelete(NULL);\n    }\n    \n    void startBackgroundLoader() {\n        if (loaderTaskHandle == NULL) {\n            xTaskCreatePinnedToCore(backgroundLoaderTask, "BGLoader", 4096, this, 1, &loaderTaskHandle, 0);\n        }\n    }\n    \n    void loadNextBufferBackground() {\n        if (!wavFile || filePosition >= totalDataBytes) {\n            fileEnded = true;\n            return;\n        }\n        \n        uint32_t bytesToRead = CHUNK_SIZE;\n        uint32_t remainingBytes = totalDataBytes - filePosition;\n        if (bytesToRead > remainingBytes) {\n            bytesToRead = remainingBytes;\n        }\n        \n        // Read into loading buffer\n        size_t bytesRead = wavFile.read((uint8_t*)loadingBuffer, bytesToRead);\n        filePosition += bytesRead;\n        \n        if (bytesRead < CHUNK_SIZE) {\n            memset((uint8_t*)loadingBuffer + bytesRead, 0, CHUNK_SIZE - bytesRead);\n        }\n        \n        // Atomically update ready status\n        if (xSemaphoreTake(bufferMutex, portMAX_DELAY)) {\n            loadingBufferSamples = bytesRead / sizeof(int16_t);\n            loadingBufferReady = true;\n            xSemaphoreGive(bufferMutex);\n        }\n    }\n    \n    // Get stereo sample - Double buffered, NEVER blocks, with pitch control and start/end positions\n    void getStereoSample(float& left, float& right, float pitchRatio = 0.0) {\n        left = 0.0f;\n        right = 0.0f;\n        \n        if (!isPlaying || !playingBuffer || fileEnded) {\n            // Debug: Print why no audio\n            static unsigned long lastNoAudioDebug = 0;\n            if (millis() - lastNoAudioDebug > 2000) {\n                lastNoAudioDebug = millis();\n                Serial.printf("No audio: isPlaying=%d, playingBuffer=%p, fileEnded=%d\\n", \n                             isPlaying, playingBuffer, fileEnded);\n            }\n            return;\n        }\n        \n        // Use internal playbackSpeed if no external pitch ratio provided\n        if (pitchRatio == 0.0) {\n            pitchRatio = playbackSpeed;\n        }\n        \n        // TODO: Implement start/end position support later\n        // For now, just play the full file to get basic audio working\n        // The complex file position tracking was breaking audio output\n        \n        // Check if we need to switch to the next buffer\n        // For stereo: fractionalPosition is in frames, playingSamples is individual samples\n        // For mono: fractionalPosition is in samples, playingSamples is individual samples\n        uint32_t maxFrames = (channels == 2) ? playingSamples / 2 : playingSamples;\n        if (fractionalPosition >= maxFrames) {\n            // Try to swap to the loading buffer if it\'s ready\n            if (loadingBufferReady && xSemaphoreTake(bufferMutex, 0)) {\n                // Swap buffers: loading becomes playing\n                int16_t* temp = playingBuffer;\n                playingBuffer = loadingBuffer;\n                loadingBuffer = temp;\n                \n                playingSamples = loadingBufferSamples;\n                fractionalPosition = 0.0f;\n                loadingBufferReady = false;\n                \n                xSemaphoreGive(bufferMutex);\n            } else {\n                // No ready buffer available - output silence (seamless gap)\n                if (filePosition >= totalDataBytes) {\n                    fileEnded = true;\n                }\n                return;\n            }\n        }\n        \n        // Read from playing buffer with pitch control (fractional sample reading)\n        if (channels == 2) {\n            // Stereo: fractionalPosition indexes sample pairs (L,R)\n            uint32_t frameIndex = (uint32_t)fractionalPosition; // Current stereo frame\n            uint32_t maxStereoFrames = playingSamples / 2;\n            \n            if (frameIndex < maxStereoFrames) {\n                uint32_t sampleL = frameIndex * 2;     // Left sample index\n                uint32_t sampleR = frameIndex * 2 + 1; // Right sample index\n                \n                // Always use simple sample reading - no interpolation for now\n                // This eliminates interpolation glitches while keeping pitch control working\n                left = playingBuffer[sampleL] / 32767.0f;\n                right = playingBuffer[sampleR] / 32767.0f;\n                \n                fractionalPosition += pitchRatio; // Advance by one frame\n                \n                // Debug: Print audio output occasionally\n                static unsigned long lastAudioDebug = 0;\n                static int audioSampleCount = 0;\n                audioSampleCount++;\n                if (millis() - lastAudioDebug > 2000) {\n                    lastAudioDebug = millis();\n                    Serial.printf("Audio OK: L=%.3f, R=%.3f, frame=%d/%d, fPos=%.2f, samples=%d\\n", \n                                 left, right, frameIndex, maxStereoFrames, fractionalPosition, audioSampleCount);\n                    audioSampleCount = 0;\n                }\n            } else {\n                left = right = 0.0f; // Silence if out of bounds\n                \n                // Debug: Print bounds issue\n                static unsigned long lastBoundsDebug = 0;\n                if (millis() - lastBoundsDebug > 2000) {\n                    lastBoundsDebug = millis();\n                    Serial.printf("Audio bounds: frame=%d >= maxFrames=%d, playingSamples=%d\\n", \n                                 frameIndex, maxStereoFrames, playingSamples);\n                }\n            }\n        } else {\n            // Mono to stereo with pitch control\n            uint32_t sampleIndex = (uint32_t)fractionalPosition;\n            if (sampleIndex < playingSamples) {\n                float mono;\n                \n                // Always use simple sample reading - no interpolation for now\n                // This eliminates interpolation glitches while keeping pitch control working\n                mono = playingBuffer[sampleIndex] / 32767.0f;\n                \n                left = mono;\n                right = mono;\n                fractionalPosition += pitchRatio; // Advance by pitch ratio\n                \n                // Debug: Print mono audio output occasionally\n                static unsigned long lastMonoDebug = 0;\n                static int monoSampleCount = 0;\n                monoSampleCount++;\n                if (millis() - lastMonoDebug > 2000) {\n                    lastMonoDebug = millis();\n                    Serial.printf("Mono OK: %.3f, idx=%d/%d, fPos=%.2f, samples=%d\\n", \n                                 mono, sampleIndex, playingSamples, fractionalPosition, monoSampleCount);\n                    monoSampleCount = 0;\n                }\n            } else {\n                left = right = 0.0f; // Silence if out of bounds\n                \n                // Debug: Print mono bounds issue\n                static unsigned long lastMonoBoundsDebug = 0;\n                if (millis() - lastMonoBoundsDebug > 2000) {\n                    lastMonoBoundsDebug = millis();\n                    Serial.printf("Mono bounds: idx=%d >= samples=%d\\n", sampleIndex, playingSamples);\n                }\n            }\n        }\n    }\n};\n            '),this.globalVariables.push("\n// MCP23017 Pin Definitions for LED Bank Indicators\n// CORRECTED v1.0 hardware mapping (CLAUDE.md verified)\n#define GATE1_LED_PIN 7    // GPA7: Gate 1 LED (Bank 1 indicator)\n#define GATE2_LED_PIN 6    // GPA6: Gate 2 LED (Bank 2 indicator)\n#define GATE3_LED_PIN 8    // GPB0: Gate 3 LED (Bank 5 indicator)\n#define GATE4_LED_PIN 9    // GPB1: Gate 4 LED (Bank 6 indicator)\n// Bank 3 indicator: MIDI-IN LED (GPA5)\n// Bank 4 indicator: MIDI-OUT LED (GPA4)\n// NOTE: GPB2/GPB3 are AUDIO SWITCHES (active-LOW), NOT LEDs!\n\n// Banking System Variables\nint currentBank = 1;           // Current active bank (1-6)\nconst int MAX_BANKS = 6;       // Maximum number of banks\nint activeBanks = 1;           // Number of banks actually used in this patch\nbool showingBankIndicator = false;      // Bank indicator LED state\nunsigned long bankIndicatorTime = 0;    // Bank indicator timing\nint lastEncoderA = HIGH;               // Encoder A state tracking\nbool lastEncoderBtn = false;           // Encoder button state tracking\nbool encoderBtn = false;               // Current encoder button state (updated in updateHardware, used in processAudio)\nunsigned long encoderBtnPressTime = 0; // Encoder button press timestamp for long-press detection\nbool encoderBtnLongPressHandled = false; // Prevent double-triggering on long press\nbool enc1_buttonLongPressed = false;   // Encoder button held for >1s (exposed for Automation mode select)\n\n// Functional LED feedback (active when NOT showing bank indicator)\nbool led_gatein1_active = false;  // Gate In 1 detected\nbool led_gatein2_active = false;  // Gate In 2 detected\nbool led_gateout1_active = false; // Gate Out 1 (Gate 3) active\nbool led_gateout2_active = false; // Gate Out 2 (Gate 4) active\nbool led_midiin_active = false;   // MIDI In activity\nbool led_midiout_active = false;  // MIDI Out activity\nunsigned long led_midiin_time = 0;    // MIDI In LED flash timer\nunsigned long led_midiout_time = 0;   // MIDI Out LED flash timer\n\n// Audio buffers\nfloat leftBuffer[BUFFER_SIZE];\nfloat rightBuffer[BUFFER_SIZE];\n".concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"int32_t i2sBuffer[BUFFER_SIZE * 2]; // I2S output buffer (32-bit for PCM1802 compatibility)":"int16_t i2sBuffer[BUFFER_SIZE * 2]; // I2S output buffer (16-bit)","\n").concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"int32_t i2sInputBuffer[BUFFER_SIZE * 2]; // I2S input for PCM1802 (32-bit stereo interleaved)\n":"","        ")),this.globalVariables.push("\n// MCP23017 I/O Expander\nAdafruit_MCP23X17 mcp;\nuint16_t inputs = 0x3F;  // Global variable for MCP23017 inputs\nunsigned long lastMcpRead = 0;\nunsigned long lastMcpWrite = 0;\n\n".concat(this.modules.some(function(e){return"USBMIDIIn"===e.type||"USBMIDIOut"===e.type})?"// USB MIDI (GPIO19/20)\nUSBMIDI usbMIDI;\n\n":"","// NeoPixel LEDs (WS2812B x8)\nAdafruit_NeoPixel neoPixels(").concat(K.NEOPIXEL_COUNT,", ").concat(K.NEOPIXEL_PIN,", NEO_GRB + NEO_KHZ800);\n        ")),this.modules.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";e.generateModuleVariables(n,o)})}},{key:"generateModuleVariables",value:function(e,n){var t=A[e.type];if(t){var a=this.audioModules.generateGlobalVariables(e,n,t);if(a)this.globalVariables.push(a);else{var o=this.controlModules.generateGlobalVariables(e,n,t);if(o)this.globalVariables.push(o);else{var r=this.hardwareModules.generateGlobalVariables(e,n,t);if(r)this.globalVariables.push(r);else switch(e.type){case"Wavetable":for(var c=e.params.wavetables||[],i=512,l="",s=0;s<4;s++){var u=c[s];if(u&&u.length>0)l+="\n// Wavetable ".concat(s+1," data (").concat(u.length," samples)\nconst float wavetable").concat(n,"_").concat(s,"[").concat(i,"] = {\n    ").concat(Array.from(u).map(function(e,n){var t=e.toFixed(6)+"f";return n%8==0&&n>0?"\n    "+t:t}).join(", "),"\n};");else{var d=void 0,p=void 0;switch(s){case 0:d=Array.from({length:i},function(e,n){return Math.sin(n/i*2*Math.PI)}),p="sine wave - default";break;case 1:d=Array.from({length:i},function(e,n){return n/i*2-1}),p="sawtooth wave - default";break;case 2:d=Array.from({length:i},function(e,n){return n<256?1:-1}),p="square wave - default";break;case 3:d=Array.from({length:i},function(e,n){var t=n/i;return t<.5?4*t-1:3-4*t}),p="triangle wave - default"}l+="\n// Wavetable ".concat(s+1," data (").concat(p,")\nconst float wavetable").concat(n,"_").concat(s,"[").concat(i,"] = {\n    ").concat(d.map(function(e,n){var t=e.toFixed(6)+"f";return n%8==0&&n>0?"\n    "+t:t}).join(", "),"\n};")}}this.globalVariables.push("\n// ".concat(t.label," ").concat(n,"\n").concat(l,"\n\n// Wavetable oscillator variables\nfloat wavetable").concat(n,"_phase = 0.0;\nfloat wavetable").concat(n,"_freq = ").concat(e.params.freq||440,";\nfloat wavetable").concat(n,"_gain = ").concat(e.params.gain||.25,";\nfloat wavetable").concat(n,"_gate = ").concat(e.params.gate||1,";\nfloat wavetable").concat(n,"_fm_amount = ").concat(e.params.fm_amount||0,";\nfloat wavetable").concat(n,"_fm_ratio = ").concat(e.params.fm_ratio||1,";\nfloat wavetable").concat(n,"_fm_ratio_cv = 0.0; // CV control for FM ratio (0-1)\nfloat wavetable").concat(n,"_pitch_amount = ").concat(e.params.pitch_range||24,"; // Pitch CV range in semitones\nfloat wavetable").concat(n,"_pitch_smooth = 0.5; // Smoothed pitch CV to prevent artifacts (0-1)\nint wavetable").concat(n,"_current_table = ").concat(e.params.current_table||0,";\nfloat watetable").concat(n,"_output = 0.0; // Mono output\nfloat wavetable").concat(n,"_outputL = 0.0;\nfloat wavetable").concat(n,"_outputR = 0.0;\nconst int wavetable").concat(n,"_table_size = ").concat(i,";\nconst float wavetable").concat(n,"_sample_rate_inv = 1.0 / ").concat(K.SAMPLE_RATE,".0;\n                "));break;case"Filter":this.globalVariables.push("\n// ".concat(t.label," ").concat(n,"\nfloat filter").concat(n,"_cutoff = ").concat(e.params.cutoff||1e3,";\nfloat filter").concat(n,"_resonance = ").concat(e.params.resonance||.5,";\nfloat filter").concat(n,"_x1 = 0.0, filter").concat(n,"_x2 = 0.0;\nfloat filter").concat(n,"_y1 = 0.0, filter").concat(n,"_y2 = 0.0;\nfloat filter").concat(n,"_input = 0.0;\nfloat filter").concat(n,"_inputL = 0.0;\nfloat filter").concat(n,"_inputR = 0.0;\nfloat filter").concat(n,"_output = 0.0;\nfloat filter").concat(n,"_outputL = 0.0;\nfloat filter").concat(n,"_outputR = 0.0;\n                "));break;case"VCA":this.globalVariables.push("\n// ".concat(t.label," ").concat(n,"\nfloat vca").concat(n,"_gain = ").concat(e.params.gain||1,";\nfloat vca").concat(n,"_inputL = 0.0;\nfloat vca").concat(n,"_inputR = 0.0;\nfloat vca").concat(n,"_outputL = 0.0;\nfloat vca").concat(n,"_outputR = 0.0;\n                "));break;case"Reverb":this.globalVariables.push("\n// ".concat(t.label," ").concat(n,"\nfloat reverb").concat(n,"_mix = ").concat(e.params.mix||.25,";\nfloat reverb").concat(n,"_size = ").concat(e.params.size||.5,";\nfloat reverb").concat(n,"_damp = ").concat(e.params.damp||.4,";\nfloat reverb").concat(n,"_inputL = 0.0;\nfloat reverb").concat(n,"_inputR = 0.0;\nfloat reverb").concat(n,"_outputL = 0.0;\nfloat reverb").concat(n,"_outputR = 0.0;\n                "));break;case"GranularSynth":var f=Math.floor(.5*K.SAMPLE_RATE);this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Granular Synthesis Engine\nconst int granular").concat(moduleIndex,"_buffer_size = ").concat(f,"; // 0.5 seconds at 44.1kHz\nfloat granular").concat(moduleIndex,"_buffer_L[").concat(f,"];\nfloat granular").concat(moduleIndex,"_buffer_R[").concat(f,"];\nint granular").concat(moduleIndex,"_write_pos = 0;\nfloat granular").concat(moduleIndex,"_grain_density = ").concat(e.params.grain_density||8,";\nfloat granular").concat(moduleIndex,"_grain_size_ms = ").concat(e.params.grain_size_ms||50,";\nfloat granular").concat(moduleIndex,"_position = ").concat(e.params.position||.5,";\nfloat granular").concat(moduleIndex,"_position_spread = ").concat(e.params.position_spread||.2,";\nfloat granular").concat(moduleIndex,"_pitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(moduleIndex,"_pitch_spread = ").concat(e.params.pitch_spread||.1,";\nfloat granular").concat(moduleIndex,"_dry_wet = ").concat(e.params.dry_wet||1,";\n\n// 4 concurrent grain players for richer textures\nstruct Grain {\n    bool active;\n    float position;\n    float size_samples;\n    float pitch_ratio;\n    float envelope_pos;\n    float envelope_inc;\n    int samples_remaining;\n};\n\nGrain granular").concat(moduleIndex,"_grains[4];\nfloat granular").concat(moduleIndex,"_outputL = 0.0;\nfloat granular").concat(moduleIndex,"_outputR = 0.0;\nint granular").concat(moduleIndex,"_samples_since_grain = 0;\n                "));break;case"ADSR":this.globalVariables.push("\n// ".concat(t.label," ").concat(n,"\nfloat adsr").concat(n,"_attack = ").concat((e.params.attack_ms||10)/1e3,"; // Convert ms to seconds\nfloat adsr").concat(n,"_decay = ").concat((e.params.decay_ms||120)/1e3,"; // Convert ms to seconds\nfloat adsr").concat(n,"_sustain = ").concat(e.params.sustain||.6,"; // Already 0-1 range\nfloat adsr").concat(n,"_release = ").concat((e.params.release_ms||200)/1e3,"; // Convert ms to seconds\nfloat adsr").concat(n,"_timescale = ").concat(e.params.timescale||1,"; // Timing scale multiplier\nfloat adsr").concat(n,"_level = 0.0;\nint adsr").concat(n,"_stage = 0; // 0=idle, 1=attack, 2=decay, 3=sustain, 4=release\nbool adsr").concat(n,"_gate = false;\nbool adsr").concat(n,"_lastGate = false;\nfloat adsr").concat(n,"_output = 0.0;\nfloat adsr").concat(n,"_stageTime = 0.0; // Time within current stage\n// Curve types: ").concat(e.params.attack_curve||"linear",", ").concat(e.params.decay_curve||"exp",", ").concat(e.params.release_curve||"exp","\n                "));break;case"Scale":break;case"Pot":var m=e.params.index||1;if(!this.declaredPots.has(m)){this.declaredPots.add(m);var _=K.ANALOG_PINS[m-1]||K.ANALOG_PINS[0];this.globalVariables.push("\n// ".concat(t.label," ").concat(m,"\nconst int pot").concat(m,"_pin = ").concat(_,";\nfloat pot").concat(m,"_value = 0.0;\nfloat pot").concat(m,"_physical = 0.0;     // Current physical pot position\nfloat pot").concat(m,"_target = 0.0;       // Target value when bank becomes active\nbool pot").concat(m,"_taken_over = false;  // Has pot taken over after bank change\nfloat pot").concat(m,"_last_bank_change = 0.0; // Time of last bank change for this pot\n                    "))}break;case"GranularPSRAM":Math.floor(4*K.SAMPLE_RATE),this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - PSRAM Granular Synthesis Engine\nint granular").concat(moduleIndex,"_buffer_size; // Set dynamically based on available memory\nfloat* granular").concat(moduleIndex,"_buffer_L; // PSRAM allocation\nfloat* granular").concat(moduleIndex,"_buffer_R; // PSRAM allocation\nint granular").concat(moduleIndex,"_write_pos = 0;\nfloat granular").concat(moduleIndex,"_grain_density = ").concat(e.params.grain_density||8,";\nfloat granular").concat(moduleIndex,"_grain_size_ms = ").concat(e.params.grain_size_ms||100,";\nfloat granular").concat(moduleIndex,"_position = ").concat(e.params.position||.5,";\nfloat granular").concat(moduleIndex,"_position_spread = ").concat(e.params.position_spread||.2,";\nfloat granular").concat(moduleIndex,"_pitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(moduleIndex,"_pitch_spread = ").concat(e.params.pitch_spread||.1,";\nfloat granular").concat(moduleIndex,"_dry_wet = ").concat(e.params.dry_wet||.5,";\nfloat granular").concat(moduleIndex,"_freeze = ").concat(e.params.freeze||0,";\n\n// 8 concurrent grain players for rich textures\nstruct Grain {\n    bool active;\n    float position;\n    float size_samples;\n    float pitch_ratio;\n    float envelope_pos;\n    float envelope_inc;\n    int samples_remaining;\n};\n\nGrain granular").concat(moduleIndex,"_grains[8];\nfloat granular").concat(moduleIndex,"_outputL = 0.0;\nfloat granular").concat(moduleIndex,"_outputR = 0.0;\nint granular").concat(moduleIndex,"_samples_since_grain = 0;\n\n// Runtime variables for control and audio processing\nfloat granular").concat(moduleIndex,"_inputL = 0.0;\nfloat granular").concat(moduleIndex,"_inputR = 0.0;\nfloat granular").concat(moduleIndex,"_currentDensity = ").concat(e.params.grain_density||8,";\nfloat granular").concat(moduleIndex,"_currentSize = ").concat(e.params.grain_size_ms||100,";\nfloat granular").concat(moduleIndex,"_currentPosition = ").concat(e.params.position||.5,";\nfloat granular").concat(moduleIndex,"_currentPitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(moduleIndex,"_currentDryWet = ").concat(e.params.dry_wet||.5,";\nfloat granular").concat(moduleIndex,"_currentFreeze = ").concat(e.params.freeze||0,";\n                "));break;case"Looper_OLD_DISABLED":var g=K.SAMPLE_RATE,h=16*g,v=this.modules[n],b=[];this.connections.forEach(function(e){if(e.to.id==="".concat(v.id,":btn1")||e.to.id==="".concat(v.id,":btn2")||e.to.id==="".concat(v.id,":btn3")||e.to.id==="".concat(v.id,":btn4")){var n=e.to.id.split(":")[1],t=parseInt(n.replace("btn",""));b.push(t)}}),b.sort();var y=b.length;this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - BPM-Synced Multi-track Looper with PSRAM\n// Connected buttons: ").concat(b.length>0?b.join(", "):"none"," (").concat(y," active tracks)\nclass Looper_").concat(n," {\nprivate:\n  static constexpr int NUM_TRACKS = ").concat(Math.max(1,y),"; // Dynamic track count\n  static constexpr int MAX_LOOP_SAMPLES = ").concat(h,";\n  \n  struct Track {\n    float* bufferL = nullptr;\n    float* bufferR = nullptr;\n    int length = 0;           // Length in samples (0 = not set yet)\n    int writePos = 0;\n    float readPosFloat = 0.0f;\n    \n    // State machine\n    enum State { EMPTY, RECORDING, PLAYING, OVERDUBBING, MUTED };\n    State state = EMPTY;\n    \n    // Track-specific parameters\n    int divider = 1;           // Beat division for tracks 2-4\n    bool isTrack1 = false;    // Track 1 has different behavior\n    float lastButtonState = 0.0f;\n  };\n  \n  Track tracks[NUM_TRACKS];\n  \n  // BPM sync\n  float bpm = ").concat(e.params.bpm||120,".0f;\n  int barsTrack1 = ").concat(e.params.bars_track1||4,";\n  int divTrack2 = ").concat(e.params.div_track2||4,";\n  int divTrack3 = ").concat(e.params.div_track3||8,";\n  int divTrack4 = ").concat(e.params.div_track4||16,";\n  \n  // Button timing for long press detection\n  unsigned long btnPressTime[4] = {0, 0, 0, 0};\n  static constexpr unsigned long LONG_PRESS_MS = 500; // 500ms for long press\n  bool quantize = ").concat(e.params.quantize||1,";\n  \n  // Global parameters\n  float feedback = ").concat((e.params.feedback||.95).toFixed(2),"f;\n  float mix = ").concat((e.params.mix||1).toFixed(1),"f;\n  \n  // Clock sync\n  float lastClockIn = 0.0f;\n  unsigned long lastClockTime = 0;\n  float clockPeriod = 0.0f;\n  int clockCounter = 0;\n  int beatsPerBar = 4;\n  \n  // Control inputs\n  float clockIn = 0.0f;\n").concat(b.map(function(e){return"  float btn".concat(e,"In = 0.0f;")}).join("\n"),"\n  float clearAllIn = 0.0f;\n  float lastClearAll = 0.0f;\n  \npublic:\n  float outL = 0.0f;\n  float outR = 0.0f;\n").concat(b.map(function(e){return"  float led".concat(e,"Out = 0.0f;")}).join("\n"),'\n  float positionOut = 0.0f;\n  float playingOut = 0.0f;\n\n  void init() {\n    // Allocate PSRAM buffers for each track\n    for (int i = 0; i < NUM_TRACKS; i++) {\n      // Track 1 gets full buffer, others get 1/4\n      int bufferSize = (i == 0) ? MAX_LOOP_SAMPLES : MAX_LOOP_SAMPLES / 4;\n      \n      tracks[i].bufferL = (float*)ps_malloc(bufferSize * sizeof(float));\n      tracks[i].bufferR = (float*)ps_malloc(bufferSize * sizeof(float));\n      \n      if (!tracks[i].bufferL || !tracks[i].bufferR) {\n        Serial.printf("Looper_').concat(n,': Failed to allocate PSRAM for track %d\\n", i);\n        // Fall back to smaller SRAM buffer if PSRAM fails\n        if (!tracks[i].bufferL) {\n          tracks[i].bufferL = (float*)malloc(22050 * sizeof(float)); // 0.5 second fallback\n        }\n        if (!tracks[i].bufferR) {\n          tracks[i].bufferR = (float*)malloc(22050 * sizeof(float));\n        }\n      } else {\n        // Clear buffers\n        memset(tracks[i].bufferL, 0, bufferSize * sizeof(float));\n        memset(tracks[i].bufferR, 0, bufferSize * sizeof(float));\n      }\n    }\n    \n    // Set track properties\n    tracks[0].isTrack1 = true;  // Track 1 has toggle behavior\n    tracks[1].divider = divTrack2;\n    tracks[2].divider = divTrack3;\n    tracks[3].divider = divTrack4;\n    \n    Serial.println("Looper_').concat(n,' initialized with BPM sync");\n  }\n\n  void setControl(int index, float value) {\n    switch(index) {\n      case 0: clockIn = value; break;           // clock input\n').concat(b.map(function(e,n){return"      case ".concat(n+1,": btn").concat(e,"In = value; break;            // button ").concat(e," (track ").concat(n+1,")")}).join("\n"),"\n      case ").concat(b.length+1,": clearAllIn = value; break;        // clear all\n      case 6: feedback = constrain(value, 0.0f, 1.0f); break;\n      case 7: mix = constrain(value, 0.0f, 1.0f); break;\n    }\n  }\n\n  void process(float inL, float inR) {\n    // Clock detection and BPM sync\n    if (clockIn > 0.5f && lastClockIn <= 0.5f) {\n      // Clock rising edge detected\n      unsigned long currentTime = millis();\n      if (lastClockTime > 0) {\n        clockPeriod = currentTime - lastClockTime;\n      }\n      lastClockTime = currentTime;\n      clockCounter++;\n    }\n    lastClockIn = clockIn;\n    \n    // Calculate track lengths based on BPM\n    int samplesPerBeat = (60.0f / bpm) * ").concat(g,";\n    \n    // Handle button inputs for each track\n").concat(b.map(function(e,n){return"    handleButton(".concat(n,", btn").concat(e,"In, samplesPerBeat);")}).join("\n"),"\n    \n    // Clear all tracks\n    if (clearAllIn > 0.5f && lastClearAll <= 0.5f) {\n      for (int i = 0; i < NUM_TRACKS; i++) {\n        clearTrack(i);\n      }\n    }\n    lastClearAll = clearAllIn;\n    \n    // Process audio for all tracks\n    float wetL = 0.0f;\n    float wetR = 0.0f;\n    \n    for (int i = 0; i < NUM_TRACKS; i++) {\n      Track& track = tracks[i];\n      \n      // Recording\n      if (track.state == Track::RECORDING && track.bufferL && track.bufferR) {\n        if (track.writePos < track.length) {\n          track.bufferL[track.writePos] = inL;\n          track.bufferR[track.writePos] = inR;\n          track.writePos++;\n        } else {\n          // Auto-stop at track length\n          track.state = Track::PLAYING;\n          track.writePos = 0;\n        }\n      }\n      \n      // Playback (both PLAYING and MUTED states advance position)\n      if ((track.state == Track::PLAYING || track.state == Track::MUTED) && \n          track.length > 0 && track.bufferL && track.bufferR) {\n        \n        int readIdx = (int)track.readPosFloat;\n        \n        // Only output audio if PLAYING (not MUTED)\n        if (track.state == Track::PLAYING && readIdx < track.length) {\n          wetL += track.bufferL[readIdx] * 0.25f; // Mix 4 tracks\n          wetR += track.bufferR[readIdx] * 0.25f;\n        }\n        \n        // Advance read position (even when muted to stay in sync)\n        track.readPosFloat += 1.0f;\n        if (track.readPosFloat >= track.length) {\n          track.readPosFloat = 0;\n          \n          // Auto-stop recording for tracks 2-4 after predetermined length\n          if (track.state == Track::RECORDING && !track.isTrack1) {\n            track.state = Track::PLAYING;\n            track.writePos = 0;\n          }\n        }\n      }\n      \n      // Update LED outputs\n      float ledValue = 0.0f;\n      switch(track.state) {\n        case Track::RECORDING: ledValue = 1.0f; break;     // Full brightness - recording\n        case Track::PLAYING: ledValue = 0.5f; break;       // Half brightness - playing\n        case Track::MUTED: ledValue = 0.1f; break;         // Dim - muted but has content\n        case Track::EMPTY: ledValue = 0.0f; break;         // Off - empty\n      }\n      \n      // Assign LED output only for connected buttons\n      if (i < ").concat(b.length,") {\n        switch(i) {\n").concat(b.map(function(e,n){return"          case ".concat(n,": led").concat(e,"Out = ledValue; break;")}).join("\n"),"\n        }\n      }\n    }\n    \n    // Mix dry/wet\n    outL = inL * (1.0f - mix) + wetL * mix;\n    outR = inR * (1.0f - mix) + wetR * mix;\n    \n    // Update position output (track 1 position)\n    positionOut = tracks[0].length > 0 ? tracks[0].readPosFloat / tracks[0].length : 0.0f;\n    playingOut = (tracks[0].state == Track::PLAYING || tracks[0].state == Track::OVERDUBBING) ? 1.0f : 0.0f;\n  }\n\nprivate:\n  void handleButton(int trackIndex, float buttonState, int samplesPerBeat) {\n    Track& track = tracks[trackIndex];\n    unsigned long currentTime = millis();\n    \n    // Button press detection\n    if (buttonState > 0.5f && track.lastButtonState <= 0.5f) {\n      // Button pressed - start timing for long press\n      btnPressTime[trackIndex] = currentTime;\n      \n    } else if (buttonState <= 0.5f && track.lastButtonState > 0.5f) {\n      // Button released\n      unsigned long pressDuration = currentTime - btnPressTime[trackIndex];\n      \n      if (pressDuration >= LONG_PRESS_MS) {\n        // Long press - delete/clear track\n        clearTrack(trackIndex);\n      } else {\n        // Short press - handle based on track type and current state\n        if (track.isTrack1) {\n          // Track 1: Toggle recording (manual length)\n          if (track.state == Track::EMPTY) {\n            // Start recording\n            track.state = Track::RECORDING;\n            track.writePos = 0;\n            track.readPosFloat = 0;\n            track.length = 0; // Length not predetermined\n          } else if (track.state == Track::RECORDING) {\n            // Stop recording, set length, start playing\n            track.length = track.writePos;\n            track.state = Track::PLAYING;\n            track.readPosFloat = 0;\n          } else if (track.state == Track::PLAYING) {\n            // Mute\n            track.state = Track::MUTED;\n          } else if (track.state == Track::MUTED) {\n            // Unmute\n            track.state = Track::PLAYING;\n          }\n        } else {\n          // Tracks 2-4: Red Sound Cycloops behavior\n          if (track.state == Track::EMPTY) {\n            // Start recording with predetermined length\n            track.state = Track::RECORDING;\n            track.writePos = 0;\n            track.readPosFloat = 0;\n            // Set predetermined length based on beat divisions\n            int beatsToRecord = beatsPerBar / track.divider;\n            track.length = samplesPerBeat * beatsToRecord;\n            \n            // Auto-stop will happen when writePos reaches length\n          } else if (track.state == Track::PLAYING) {\n            // Mute\n            track.state = Track::MUTED;\n          } else if (track.state == Track::MUTED) {\n            // Unmute\n            track.state = Track::PLAYING;\n          }\n        }\n      }\n      \n      btnPressTime[trackIndex] = 0; // Reset press time\n    }\n    \n    track.lastButtonState = buttonState;\n  }\n  \n  void clearTrack(int trackIndex) {\n    Track& track = tracks[trackIndex];\n    track.state = Track::EMPTY;\n    track.length = 0;\n    track.writePos = 0;\n    track.readPosFloat = 0;\n    \n    // Clear buffer\n    int bufferSize = (trackIndex == 0) ? MAX_LOOP_SAMPLES : MAX_LOOP_SAMPLES / 4;\n    if (track.bufferL && track.bufferR) {\n      memset(track.bufferL, 0, bufferSize * sizeof(float));\n      memset(track.bufferR, 0, bufferSize * sizeof(float));\n    }\n  }\n};\n\n// OLD DISABLED: Instance creation now handled by modular system\n// Looper_").concat(n," looper").concat(n,";\n// float looper").concat(n,"_inputL = 0.0f;\n// float looper").concat(n,"_inputR = 0.0f;\n                "));break;case"GranularDense":Math.floor(2*K.SAMPLE_RATE),this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Dense Granular Synthesis with 20 Grains\nint granular").concat(moduleIndex,"_buffer_size; // Set dynamically based on available memory\nfloat* granular").concat(moduleIndex,"_buffer_L; // PSRAM allocation\nfloat* granular").concat(moduleIndex,"_buffer_R; // PSRAM allocation\nint granular").concat(moduleIndex,"_write_pos = 0;\nfloat granular").concat(moduleIndex,"_grain_density = ").concat(e.params.grain_density||15,";\nfloat granular").concat(moduleIndex,"_position = ").concat(e.params.position||.5,";\nfloat granular").concat(moduleIndex,"_position_spread = ").concat(e.params.position_spread||.3,";\nfloat granular").concat(moduleIndex,"_pitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(moduleIndex,"_pitch_spread = ").concat(e.params.pitch_spread||.1,";\nfloat granular").concat(moduleIndex,"_dry_wet = ").concat(e.params.dry_wet||1,";\nfloat granular").concat(moduleIndex,"_freeze = ").concat(e.params.freeze||0,";\n\n// Dense grain structure - 20 concurrent 32ms grains for rich textural clouds\nstruct DenseGrain {\n    bool active;\n    float position;\n    float pitch_ratio;\n    float envelope_pos;\n    float envelope_inc;\n    int samples_remaining;\n};\n\nDenseGrain granular").concat(moduleIndex,"_grains[20]; // 20 concurrent grains\nfloat granular").concat(moduleIndex,"_outputL = 0.0;\nfloat granular").concat(moduleIndex,"_outputR = 0.0;\nint granular").concat(moduleIndex,"_samples_since_grain = 0;\n\n// Runtime variables for control and audio processing\nfloat granular").concat(moduleIndex,"_inputL = 0.0;\nfloat granular").concat(moduleIndex,"_inputR = 0.0;\nfloat granular").concat(moduleIndex,"_currentDensity = ").concat(e.params.grain_density||15,";\nfloat granular").concat(moduleIndex,"_currentPosition = ").concat(e.params.position||.5,";\nfloat granular").concat(moduleIndex,"_currentPitch = ").concat(e.params.pitch||0,";\nfloat granular").concat(moduleIndex,"_currentDryWet = ").concat(e.params.dry_wet||1,";\nfloat granular").concat(moduleIndex,"_currentFreeze = ").concat(e.params.freeze||0,";\n                "));break;case"LEDButton":var k=e.params.index||1;this.declaredButtons.has(k)||(this.declaredButtons.add(k),this.globalVariables.push("\n// LEDButton (Physical Button ".concat(k,")\nbool btn").concat(k,"_state = false;\nbool btn").concat(k,"_lastState = false;\nbool btn").concat(k,"_pressed = false;\nbool btn").concat(k,"_gate = false;     // Raw gate signal for modular connections\nfloat btn").concat(k,"_output = 0.0;\nfloat btn").concat(k,"_sampleIn = 0.0;  // Sample & hold input\nfloat btn").concat(k,"_sampleOut = 0.0; // Sample & hold output (held value)\n                    ")));break;case"KickDrum":var S=this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type});this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Layered Drum Synthesizer\n// Oscillator layer\nfloat kick").concat(n,"_osc_phase = 0.0;\nfloat kick").concat(n,"_osc_freq = ").concat(e.params.osc_frequency||60,";\nfloat kick").concat(n,"_osc_level = ").concat(e.params.osc_level||.7,";\n// Oscillator amplitude envelope\nfloat kick").concat(n,"_osc_amp_env = 0.0;\nfloat kick").concat(n,"_osc_amp_attack = ").concat((e.params.osc_amp_attack_ms||1)/1e3,";\nfloat kick").concat(n,"_osc_amp_decay = ").concat((e.params.osc_amp_decay_ms||150)/1e3,";\nfloat kick").concat(n,"_osc_amp_sustain = ").concat(e.params.osc_amp_sustain||.1,";\nfloat kick").concat(n,"_osc_amp_release = ").concat((e.params.osc_amp_release_ms||200)/1e3,";\nint kick").concat(n,"_osc_amp_stage = 0;\nfloat kick").concat(n,"_osc_amp_time = 0.0;\n// Oscillator pitch envelope\nfloat kick").concat(n,"_osc_pitch_env = 0.0;\nfloat kick").concat(n,"_osc_pitch_amount = ").concat(e.params.osc_pitch_amount||.5,";\nfloat kick").concat(n,"_osc_pitch_attack = ").concat((e.params.osc_pitch_attack_ms||1)/1e3,";\nfloat kick").concat(n,"_osc_pitch_decay = ").concat((e.params.osc_pitch_decay_ms||100)/1e3,";\nint kick").concat(n,"_osc_pitch_stage = 0;\nfloat kick").concat(n,"_osc_pitch_time = 0.0;\n\n// Noise layer\nfloat kick").concat(n,"_noise_level = ").concat(e.params.noise_level||.3,";\n// Noise amplitude envelope\nfloat kick").concat(n,"_noise_amp_env = 0.0;\nfloat kick").concat(n,"_noise_amp_attack = ").concat((e.params.noise_amp_attack_ms||1)/1e3,";\nfloat kick").concat(n,"_noise_amp_decay = ").concat((e.params.noise_amp_decay_ms||50)/1e3,";\nint kick").concat(n,"_noise_amp_stage = 0;\nfloat kick").concat(n,"_noise_amp_time = 0.0;\n\n// Layer mute states\nbool kick").concat(n,"_osc_mute = ").concat(e.params.osc_mute||!1,";\nbool kick").concat(n,"_noise_mute = ").concat(e.params.noise_mute||!1,";\nbool kick").concat(n,"_sample_mute = ").concat(e.params.sample_mute||!1,";\n\n// Output mixing\nfloat kick").concat(n,"_output = 0.0;\nbool kick").concat(n,"_trigger = false;\nbool kick").concat(n,"_last_trigger = false;\n                ")),S&&this.globalVariables.push("\n// File transfer variables (only included when Sample Player classes are present)\nbool fileTransferActive".concat(n," = false;\nString transferFilename").concat(n,' = "";\nFile transferFile').concat(n,";\nuint32_t expectedFileSize").concat(n," = 0;\nuint32_t receivedBytes").concat(n," = 0;\n\n// Ring buffer variables for credit-based file transfer\nuint8_t* ringBuffer").concat(n," = NULL;\nvolatile int ringWritePos").concat(n," = 0;\nvolatile int ringReadPos").concat(n," = 0;\nvolatile int ringBufferCount").concat(n," = 0;\nTaskHandle_t sdWriterTaskHandle").concat(n," = NULL;\nportMUX_TYPE ringBufferMux").concat(n," = portMUX_INITIALIZER_UNLOCKED;\n                    "));break;case"DrumDesigner":this.fastSineAdded||(this.globalFunctions=this.globalFunctions||[],this.globalFunctions.push("\n// Fast sine approximation (Bhaskara I's formula) - 5-10x faster than sinf()\n// Accuracy: < 0.002 error across full range (good enough for audio)\ninline float fastSin(float x) {\n    // Normalize to -PI to PI range\n    while (x > PI) x -= 2.0f * PI;\n    while (x < -PI) x += 2.0f * PI;\n\n    // Bhaskara I approximation for -PI to PI\n    // sin(x)  16x( - |x|) / (5 - 4|x|( - |x|))\n    float absX = fabsf(x);\n    float num = 16.0f * x * (PI - absX);\n    float den = 5.0f * PI * PI - 4.0f * absX * (PI - absX);\n    return num / den;\n}\n"),this.fastSineAdded=!0),this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Karplus-Strong Physical Modeling Drum Synthesizer (PSRAM optimized)\n// K-S Delay line allocated in PSRAM (max 8192 samples = 186ms @ 44.1kHz = ~5.4 Hz sub-bass!)\n#define KS_MAX_DELAY_").concat(n," 8192\nfloat* ks").concat(n,"_delayLine = nullptr;  // PSRAM allocation (32KB)\nfloat* ks").concat(n,"_noiseBuffer = nullptr;  // Pre-generated noise for fast excitation (PSRAM, 32KB)\nint ks").concat(n,"_writePos = 0;\nint ks").concat(n,"_delayLength = 512;\nfloat ks").concat(n,"_prevSample = 0.0;\n\n// K-S Parameters\nconst char* ks").concat(n,'_mode = "').concat(e.params.ks_mode||"tonal",'";  // "tonal", "percussive", "noise"\nfloat ks').concat(n,"_pitch = ").concat(e.params.pitch||60,";  // MIDI note\nfloat ks").concat(n,"_fineTune = ").concat(e.params.fine_tune||0,";  // -100 to +100 cents\nfloat ks").concat(n,"_currentFreq = 440.0f;  // Pre-calculated frequency from pitch (updated at control rate to avoid expensive powf)\nfloat ks").concat(n,"_baseSineFreq = 440.0f;  // Pre-calculated base sine frequency (updated at control rate)\nfloat ks").concat(n,"_damping = ").concat(e.params.ks_damping||.995,";  // Decay rate (0.995 = long sustain for bass)\nfloat ks").concat(n,"_stretch = ").concat(e.params.ks_stretch||1,";  // Inharmonicity\nfloat ks").concat(n,"_brightness = ").concat(e.params.ks_brightness||.5,";  // Excitation filter\nfloat ks").concat(n,"_position = ").concat(e.params.ks_position||.5,";  // Strike position (0-1)\nfloat ks").concat(n,"_pitchGainComp = 1.0;  // Pitch-dependent gain compensation for consistent amplitude\n\n// Body Character (simple lowpass filter - replaces heavy comb filters)\nbool ks").concat(n,"_bodyEnabled = ").concat(!1!==e.params.body_enabled,";\nfloat ks").concat(n,"_bodyResonance = ").concat(e.params.body_resonance||.3,";  // Filter resonance (0.3 = subtle warmth)\nfloat ks").concat(n,"_bodySize = ").concat(e.params.body_size||.3,";  // Affects filter cutoff (0.3 = darker, warmer)\nfloat ks").concat(n,"_bodyLpf = 0.0;  // Lowpass filter state\n\n// Level controls for K-S and sine oscillator\nfloat ks").concat(n,"_ksLevel = ").concat(e.params.ks_level||.3,";  // K-S harmonics level (0-1)\nfloat ks").concat(n,"_sineLevel = ").concat(e.params.sine_level||.7,';  // Sine fundamental level (0-1)\n\n// Pitch sweep mode: "none" (no sweep), "sine" (808 style), or "delay" (Boss feedback style)\nconst char* ks').concat(n,'_pitchSweepMode = "').concat(e.params.pitch_sweep_mode||"none",'";\n\n// Sine oscillator for deep bass (hybrid mode with K-S)\nbool ks').concat(n,"_sineEnabled = ").concat(!1!==e.params.sine_enabled,";  // Enable sine bass oscillator\nfloat ks").concat(n,"_sinePhase = 0.0;\nfloat ks").concat(n,"_sinePitchAmount = ").concat(e.params.sine_pitch_amount||2,";  // Octaves of pitch sweep\nfloat ks").concat(n,"_sinePitchDecay = ").concat((e.params.sine_pitch_decay||80)/1e3,";  // Pitch envelope decay time\nint ks").concat(n,"_sinePitchStage = 0;  // 0=idle, 1=attack, 2=decay\nfloat ks").concat(n,"_sinePitchTime = 0.0;\nfloat ks").concat(n,"_sinePitchEnv = 0.0;\n\n// K-S delay sweep variables (Boss delay pitch-drop effect)\nfloat ks").concat(n,"_delayTarget = 0.0f;  // Target delay length (set on trigger)\nfloat ks").concat(n,"_delayCurrent = 0.0f;  // Current delay length (modulated)\nfloat ks").concat(n,"_delaySweepTime = 0.0f;  // Sweep timer\n\n// ADSR Amplitude Envelope\nfloat ks").concat(n,"_ampAttack = ").concat((e.params.amp_attack||1)/1e3,";  // Convert ms to seconds\nfloat ks").concat(n,"_ampDecay = ").concat((e.params.amp_decay||1500)/1e3,";  // 1.5s for bass development\nfloat ks").concat(n,"_ampSustain = ").concat(e.params.amp_sustain||.2,";  // 20% sustain to keep fundamental going\nfloat ks").concat(n,"_ampRelease = ").concat((e.params.amp_release||200)/1e3,";\nint ks").concat(n,"_ampStage = 0;  // 0=idle, 1=attack, 2=decay, 3=sustain, 4=release\nfloat ks").concat(n,"_ampTime = 0.0;\nfloat ks").concat(n,"_ampEnv = 0.0;\n\n// Control inputs\nfloat ks").concat(n,"_gateInput = 0.0;\nfloat ks").concat(n,"_velocityInput = 1.0;\nfloat ks").concat(n,"_pitchCV = 0.0;\nfloat ks").concat(n,"_dampingCV = 0.0;\nfloat ks").concat(n,"_bodyResonanceCV = 0.0;\n\n// Trigger detection\nbool ks").concat(n,"_lastGate = false;\nbool ks").concat(n,"_triggered = false;\n\n// Output\nfloat ks").concat(n,"_outputL = 0.0;\nfloat ks").concat(n,"_outputR = 0.0;\nfloat ks").concat(n,"_outputGain = ").concat(e.params.output_gain||.8,";\nfloat ks").concat(n,"_velocitySensitivity = ").concat(e.params.velocity_sensitivity||.7,";\n                "));break;case"DrumDesigner4":this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - 4-Voice Karplus-Strong Drum Synthesizer\n// Bank ").concat(e.params.bank||1,": Auto-banking (Pot=volume, Button=gate, Button hold + Pot=pitch)\n"));for(var x=1;x<=4;x++)if(this.declaredButtons.has(x)||(this.declaredButtons.add(x),this.globalVariables.push("\n// Button ".concat(x," state (auto-declared for DrumDesigner4)\nbool btn").concat(x,"_state = false;\nbool btn").concat(x,"_lastState = false;\nbool btn").concat(x,"_pressed = false;\n                        "))),!this.declaredPots.has(x)){this.declaredPots.add(x);var E=[4,5,6,7][x-1];this.globalVariables.push("\n// Pot ".concat(x," (auto-declared for DrumDesigner4)\nconst int pot").concat(x,"_pin = ").concat(E,";\nfloat pot").concat(x,"_value = 0.0;\nfloat pot").concat(x,"_physical = 0.0;\nfloat pot").concat(x,"_target = 0.0;\nbool pot").concat(x,"_taken_over = false;\nfloat pot").concat(x,"_last_bank_change = 0.0;\n                        "))}for(var P=1;P<=4;P++)if(!1!==e.params["voice".concat(P,"_enabled")]){var w={pitch:e.params["voice".concat(P,"_pitch")]||60,fineTune:e.params["voice".concat(P,"_fine_tune")]||0,ksDamping:e.params["voice".concat(P,"_ks_damping")]||.6,ksLevel:e.params["voice".concat(P,"_ks_level")]||.3,sineLevel:e.params["voice".concat(P,"_sine_level")]||.7,sineEnabled:!1!==e.params["voice".concat(P,"_sine_enabled")],attack:(e.params["voice".concat(P,"_amp_attack")]||1)/1e3,decay:(e.params["voice".concat(P,"_amp_decay")]||500)/1e3,sustain:e.params["voice".concat(P,"_amp_sustain")]||0,release:(e.params["voice".concat(P,"_amp_release")]||100)/1e3,outputGain:e.params["voice".concat(P,"_output_gain")]||3,volume:e.params["voice".concat(P,"_volume")]||.8};this.globalVariables.push("\n// Voice ".concat(P,": ENABLED\n#define KS_MAX_DELAY_DD4").concat(n,"_V").concat(P," 2048\nfloat* dd4").concat(n,"_v").concat(P,"_delayLine = nullptr;  // PSRAM (8KB)\nfloat* dd4").concat(n,"_v").concat(P,"_noiseBuffer = nullptr;  // PSRAM (8KB)\nint dd4").concat(n,"_v").concat(P,"_writePos = 0;\nint dd4").concat(n,"_v").concat(P,"_delayLength = 512;\nfloat dd4").concat(n,"_v").concat(P,"_prevSample = 0.0f;\nfloat dd4").concat(n,"_v").concat(P,"_pitch = ").concat(w.pitch,";\nfloat dd4").concat(n,"_v").concat(P,"_fineTune = ").concat(w.fineTune,";\nfloat dd4").concat(n,"_v").concat(P,"_currentFreq = 440.0f;\nfloat dd4").concat(n,"_v").concat(P,"_baseSineFreq = 440.0f;\nfloat dd4").concat(n,"_v").concat(P,"_damping = ").concat(w.ksDamping,";\nfloat dd4").concat(n,"_v").concat(P,"_ksLevel = ").concat(w.ksLevel,";\nfloat dd4").concat(n,"_v").concat(P,"_sineLevel = ").concat(w.sineLevel,";\nbool dd4").concat(n,"_v").concat(P,"_sineEnabled = ").concat(w.sineEnabled,";\nfloat dd4").concat(n,"_v").concat(P,"_sinePhase = 0.0f;\nfloat dd4").concat(n,"_v").concat(P,"_attack = ").concat(w.attack,";\nfloat dd4").concat(n,"_v").concat(P,"_decay = ").concat(w.decay,";\nfloat dd4").concat(n,"_v").concat(P,"_sustain = ").concat(w.sustain,";\nfloat dd4").concat(n,"_v").concat(P,"_release = ").concat(w.release,";\nint dd4").concat(n,"_v").concat(P,"_ampStage = 0;\nfloat dd4").concat(n,"_v").concat(P,"_ampTime = 0.0f;\nfloat dd4").concat(n,"_v").concat(P,"_gateInput = 0.0f;\nbool dd4").concat(n,"_v").concat(P,"_lastGate = false;\nfloat dd4").concat(n,"_v").concat(P,"_outputGain = ").concat(w.outputGain,";\nfloat dd4").concat(n,"_v").concat(P,"_volume = ").concat(w.volume,";  // Banking volume control\nfloat dd4").concat(n,"_v").concat(P,"_outL = 0.0f;\nfloat dd4").concat(n,"_v").concat(P,"_outR = 0.0f;\n"))}else this.globalVariables.push("\n// Voice ".concat(P,": DISABLED\nfloat dd4").concat(n,"_v").concat(P,"_outL = 0.0f;\nfloat dd4").concat(n,"_v").concat(P,"_outR = 0.0f;\n"));this.globalVariables.push("\n// Mix outputs\nfloat dd4".concat(n,"_outputMixL = 0.0f;\nfloat dd4").concat(n,"_outputMixR = 0.0f;\n                "));break;case"GateGen":this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Gate Generator with S&H and gate input control\nfloat gate").concat(n,"_length = ").concat(e.params.gate_length||.8,"; // Gate length as fraction of clock period\nbool gate").concat(n,"_use_self_clock = ").concat(e.params.use_self_clock||!0,";\nfloat gate").concat(n,"_self_clock_bpm = ").concat(e.params.self_clock_bpm||120,";\nfloat gate").concat(n,"_probability = ").concat(e.params.probability||1,"; // Probability 0-1\nbool gate").concat(n,"_retrigger = ").concat(e.params.retrigger||!0,";\nbool gate").concat(n,"_sh_enabled = ").concat(e.params.sh_enabled||!0,"; // Sample & Hold enabled\nbool gate").concat(n,"_state = false;\nbool gate").concat(n,"_last_clock = false;\nunsigned long gate").concat(n,"_start_time = 0;\nunsigned long gate").concat(n,"_last_self_clock = 0;\nfloat gate").concat(n,"_output = 0.0;\nfloat gate").concat(n,"_sh_input = 0.0; // Sample & Hold input\nfloat gate").concat(n,"_sh_output = 0.0; // Sample & Hold output (held value)\nfloat gate").concat(n,"_gate_input = 0.0; // Gate input control\nbool gate").concat(n,"_gate_enabled = true; // Gate control state\n                "));break;case"SDPlayer":case"SamplePlayer":this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type})?this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Minimal WAV Player (legacy single-voice)\nMinimalWAVPlayer sdPlayer").concat(n,"_player;\nfloat sdPlayer").concat(n,"_gain = ").concat(e.params.gain||3,";\nfloat sdPlayer").concat(n,"_pitch = ").concat(e.params.pitch||1,";\nbool sdPlayer").concat(n,"_loop = ").concat(e.params.loop||!0,";\nbool sdPlayer").concat(n,"_playing = false;\nint sdPlayer").concat(n,"_currentFile = 1;\nint sdPlayer").concat(n,"_sampleCount = 0;  // Dynamic count of available samples\nString sdPlayer").concat(n,'_currentFileName = "";\nfloat sdPlayer').concat(n,"_triggerThreshold = 0.5;\nbool sdPlayer").concat(n,"_lastTrigger = false;\nfloat sdPlayer").concat(n,"_outputL = 0.0;\nfloat sdPlayer").concat(n,"_outputR = 0.0;\nint sdPlayer").concat(n,"_lastLoadedFile = -1;  // Track loaded sample to avoid unnecessary reloads\n\n// File transfer variables (inline implementation - no external library needed)\nbool fileTransferActive").concat(n," = false;\nString transferFilename").concat(n,' = "";\nFile transferFile').concat(n,";\nuint32_t expectedFileSize").concat(n," = 0;\nuint32_t receivedBytes").concat(n," = 0;\n\n// Ring buffer variables for credit-based file transfer\nuint8_t* ringBuffer").concat(n," = NULL;\nvolatile int ringWritePos").concat(n," = 0;\nvolatile int ringReadPos").concat(n," = 0;\nvolatile int ringBufferCount").concat(n," = 0;\nTaskHandle_t sdWriterTaskHandle").concat(n," = NULL;\nportMUX_TYPE ringBufferMux").concat(n," = portMUX_INITIALIZER_UNLOCKED;\n                        ")):this.globalVariables.push("\n// ".concat(t.label," ").concat(n," - Sample Player module disabled (no Sample Player classes available)\nfloat sdPlayer").concat(n,"_outputL = 0.0; // Stub output - always silent\nfloat sdPlayer").concat(n,"_outputR = 0.0; // Stub output - always silent\n                    "))}}}}}},{key:"calculateActiveBanks",value:function(){var e=this,n=new Set;this.modules.forEach(function(e){if("Pot"===e.type||"LEDButton"===e.type){var t,a,o=(null===(t=e.params)||void 0===t?void 0:t.bank)||1,r=(null===(a=e.params)||void 0===a?void 0:a.locked)||!1;console.log("DEBUG: Found ".concat(e.type," ").concat(e.id," with bank=").concat(o,", locked=").concat(r)),r?n.add(1):n.add(o)}if("HarmonicSequencer"===e.type){var c,i=(null===(c=e.params)||void 0===c?void 0:c.start_bank)||1;console.log("DEBUG: Found HarmonicSequencer ".concat(e.id," with start_bank=").concat(i)),n.add(i)}if("BPMLooper"===e.type){var l,s=(null===(l=e.params)||void 0===l?void 0:l.start_bank)||1;console.log("DEBUG: Found BPMLooper ".concat(e.id," with start_bank=").concat(s," (uses banks ").concat(s," and ").concat(s+1,")")),n.add(s),n.add(s+1)}if("StereoMixer4"===e.type){var u,d=(null===(u=e.params)||void 0===u?void 0:u.start_bank)||2;console.log("DEBUG: Found StereoMixer4 ".concat(e.id," using banks ").concat(d," and ").concat(d+1)),n.add(d),n.add(d+1)}if("Clock"===e.type){var p,f,m=(null===(p=e.params)||void 0===p?void 0:p.bank)||0;0===m&&(m=n.size>0?Math.max.apply(Math,Le(n))+1:1,e.params.bank=m),(null===(f=e.params)||void 0===f?void 0:f.use_outputs_5_8)?(console.log("DEBUG: Found Clock ".concat(e.id," using banks ").concat(m," and ").concat(m+1," (outputs 1-8)")),n.add(m),n.add(m+1)):(console.log("DEBUG: Found Clock ".concat(e.id," using bank ").concat(m," (outputs 1-4 only)")),n.add(m))}}),console.log("DEBUG: usedBanks = ".concat(Array.from(n).sort()));var t=n.size>0?Math.max.apply(Math,Le(n)):1;return console.log("DEBUG: activeBanks result = ".concat(t)),this.setupCode.push('\n    // DEBUG: Banking calculation\n    Serial.print("DEBUG: Found banks in use: ");'),Array.from(n).sort().forEach(function(n){e.setupCode.push('    Serial.print("'.concat(n,' ");'))}),this.setupCode.push('\n    Serial.println();\n    Serial.print("DEBUG: activeBanks calculated as: ");\n    Serial.println('.concat(t,");\n        ")),t}},{key:"generateGlobalFunctions",value:function(){var e=this;this.modules.filter(function(e){return"AudioRecorder"===e.type}).forEach(function(n){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";e.globalFunctions=e.globalFunctions||[],e.globalFunctions.push("\n// Scan SD card for existing recXXX.wav files and return the highest index found\nint rec".concat(a,'_findHighestFileIndex() {\n    int highestIndex = 0;\n    File root = SD.open("/");\n    if (!root) {\n        Serial.println("[REC').concat(a,'] Failed to open root directory");\n        return 0;\n    }\n\n    File entry = root.openNextFile();\n    while (entry) {\n        if (!entry.isDirectory()) {\n            String filename = String(entry.name());\n            // Check if filename matches pattern "recXXX.wav" (case insensitive)\n            if (filename.startsWith("rec") && filename.endsWith(".wav")) {\n                // Extract number from filename (skip "rec" prefix, stop at ".wav")\n                String numStr = filename.substring(3, filename.length() - 4);\n                int fileNum = numStr.toInt();\n                if (fileNum > highestIndex) {\n                    highestIndex = fileNum;\n                }\n            }\n        }\n        entry.close();\n        entry = root.openNextFile();\n    }\n    root.close();\n\n    Serial.printf("[REC').concat(a,'] Highest existing file index: %d\\n", highestIndex);\n    return highestIndex;\n}\n\n// FreeRTOS SD Writer Task for AudioRecorder ').concat(a," (Core 0, async writes)\nvoid rec").concat(a,'_sdWriterTaskFunc(void* param) {\n    Serial.printf("[REC').concat(a,'] SD writer task started on Core %d\\n", xPortGetCoreID());\n\n    while (1) {\n        // Keep draining blocks even after recording stops (for finalization)\n        if (rec').concat(a,"_buffered > 0) {\n            // Get next block to write\n            size_t idx = rec").concat(a,"_readIdx;\n            uint8_t* block = &rec").concat(a,"_ringBuffer[idx * REC").concat(a,"_BLOCK_SIZE];\n\n            // Write to SD (blocking operation, but we're on Core 0)\n            if (rec").concat(a,"_recFile) {\n                size_t written = rec").concat(a,"_recFile.write(block, REC").concat(a,"_BLOCK_SIZE);\n                if (written != REC").concat(a,'_BLOCK_SIZE) {\n                    Serial.printf("[REC').concat(a,'] SD write error: wrote %d/%d bytes\\n", written, REC').concat(a,"_BLOCK_SIZE);\n                }\n            }\n\n            // Update ring buffer pointers (thread-safe)\n            if (xSemaphoreTake(rec").concat(a,"_bufferMutex, portMAX_DELAY)) {\n                rec").concat(a,"_readIdx = (rec").concat(a,"_readIdx + 1) % REC").concat(a,"_BLOCK_COUNT;\n                rec").concat(a,"_buffered--;\n                xSemaphoreGive(rec").concat(a,"_bufferMutex);\n            }\n        } else {\n            // No data to write, yield to other tasks\n            vTaskDelay(1);  // 1ms delay\n        }\n    }\n}\n\n// FreeRTOS SD Reader Task for AudioRecorder ").concat(a," (Core 0, async reads for streaming playback)\nvoid play").concat(a,'_sdReaderTaskFunc(void* param) {\n    Serial.printf("[PLAY').concat(a,'] SD reader task started on Core %d\\n", xPortGetCoreID());\n\n    while (1) {\n        if (rec').concat(a,"_playing && !rec").concat(a,"_paused && !play").concat(a,"_eofReached) {\n            // Check if ring buffer has space\n            if (play").concat(a,"_buffered < PLAY").concat(a,"_BLOCK_COUNT) {\n                // Read next block from SD file\n                size_t idx = play").concat(a,"_writeIdx;\n                uint8_t* block = &play").concat(a,"_ringBuffer[idx * PLAY").concat(a,"_BLOCK_SIZE];\n\n                size_t bytesRead = 0;\n                if (rec").concat(a,"_playFile) {\n                    bytesRead = rec").concat(a,"_playFile.read(block, PLAY").concat(a,"_BLOCK_SIZE);\n                }\n\n                if (bytesRead > 0) {\n                    // Update ring buffer pointers (thread-safe)\n                    if (xSemaphoreTake(play").concat(a,"_bufferMutex, portMAX_DELAY)) {\n                        play").concat(a,"_writeIdx = (play").concat(a,"_writeIdx + 1) % PLAY").concat(a,"_BLOCK_COUNT;\n                        play").concat(a,"_buffered++;\n                        xSemaphoreGive(play").concat(a,"_bufferMutex);\n                    }\n                } else {\n                    // End of file reached\n                    play").concat(a,'_eofReached = true;\n                    Serial.printf("[PLAY').concat(a,'] SD reader reached EOF\\n");\n                }\n            } else {\n                // Ring buffer full, wait for audio thread to consume\n                vTaskDelay(5);  // 5ms delay\n            }\n        } else {\n            // Not playing or paused, yield to other tasks\n            vTaskDelay(10);  // 10ms delay\n        }\n    }\n}\n'))}),this.modules.filter(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type}).forEach(function(n){var t=e.modules.findIndex(function(e){return e.id===n.id});e.globalFunctions=e.globalFunctions||[],e.globalFunctions.push("\n// Credit-Based Ring Buffer File Transfer for module ".concat(t,"\nvoid handleFileTransfer").concat(t,"() {\n    static String commandBuffer").concat(t,' = "";\n    \n    // Handle serial commands\n    if (!fileTransferActive').concat(t,") {\n        while (Serial.available()) {\n            char c = Serial.read();\n            if (c == '\\n' || c == '\\r') {\n                if (commandBuffer").concat(t,".length() > 0) {\n                    processFileCommand").concat(t,"(commandBuffer").concat(t,");\n                    commandBuffer").concat(t,' = "";\n                }\n            } else {\n                commandBuffer').concat(t," += c;\n                if (commandBuffer").concat(t,".length() > 100) commandBuffer").concat(t,' = "";\n            }\n        }\n    } else {\n        // File transfer mode - ring buffer approach\n        handleFileData').concat(t,"();\n    }\n}\n\n// Ring buffer file data handler for module ").concat(t,"\nvoid handleFileData").concat(t,"() {\n    // Read data from USB into ring buffer (non-blocking)\n    while (Serial.available() && ringBufferSpace").concat(t,"() > 0) {\n        uint8_t byte = Serial.read();\n        ringBuffer").concat(t,"[ringWritePos").concat(t,"] = byte;\n        ringWritePos").concat(t," = (ringWritePos").concat(t," + 1) % RING_BUFFER_SIZE;\n        \n        taskENTER_CRITICAL(&ringBufferMux").concat(t,");\n        ringBufferCount").concat(t,"++;\n        taskEXIT_CRITICAL(&ringBufferMux").concat(t,");\n        \n        receivedBytes").concat(t,"++;\n        \n        // Send credits when we have reasonable space\n        if (ringBufferSpace").concat(t,'() >= 32768) { // 32KB threshold\n            Serial.printf("CREDITS:%d\\n", ringBufferSpace').concat(t,"());\n        }\n        \n        if (receivedBytes").concat(t," >= expectedFileSize").concat(t,") {\n            break; // Transfer complete\n        }\n    }\n}\n\n// Process file transfer commands for module ").concat(t,"\nvoid processFileCommand").concat(t,'(String cmd) {\n    cmd.trim();\n    \n    if (cmd == "SD:STATUS") {\n        Serial.println("SD:READY");\n    } else if (cmd == "SD:LIST" || cmd.startsWith("SD:LIST:")) {\n        // List directory contents: SD:LIST or SD:LIST:/path\n        String path = "/";\n        if (cmd.startsWith("SD:LIST:")) {\n            path = cmd.substring(8);\n            if (path.length() == 0) path = "/";\n        }\n        \n        File root = SD.open(path);\n        if (root && root.isDirectory()) {\n            Serial.print("SD:LIST:START:");\n            Serial.println(path);\n            \n            File file = root.openNextFile();\n            while (file) {\n                String itemName = String(file.name());\n                if (file.isDirectory()) {\n                    Serial.print("SD:DIR:");\n                    Serial.print(itemName);\n                    Serial.print(":");\n                    Serial.println(path + (path.endsWith("/") ? "" : "/") + itemName);\n                } else {\n                    Serial.print("SD:FILE:");\n                    Serial.print(itemName);\n                    Serial.print(":");\n                    Serial.print(file.size());\n                    Serial.print(":");\n                    Serial.println(path + (path.endsWith("/") ? "" : "/") + itemName);\n                }\n                file.close();\n                file = root.openNextFile();\n            }\n            root.close();\n            Serial.println("SD:LIST:END");\n        } else {\n            Serial.println("SD:LIST:ERROR");\n        }\n    } else if (cmd.startsWith("SD:MKDIR:")) {\n        // Create directory: SD:MKDIR:/path/newdir\n        String dirPath = cmd.substring(9);\n        if (SD.mkdir(dirPath)) {\n            Serial.print("SD:MKDIR:OK:");\n            Serial.println(dirPath);\n        } else {\n            Serial.print("SD:MKDIR:ERROR:");\n            Serial.println(dirPath);\n        }\n    } else if (cmd.startsWith("SD:DELETE:")) {\n        // Delete file or directory: SD:DELETE:/path/file\n        String deletePath = cmd.substring(10);\n        if (SD.remove(deletePath)) {\n            Serial.print("SD:DELETE:OK:");\n            Serial.println(deletePath);\n        } else {\n            Serial.print("SD:DELETE:ERROR:");\n            Serial.println(deletePath);\n        }\n    } else if (cmd.startsWith("SD:EXISTS:")) {\n        // Check if file/directory exists: SD:EXISTS:/path\n        String checkPath = cmd.substring(10);\n        if (SD.exists(checkPath)) {\n            File item = SD.open(checkPath);\n            if (item.isDirectory()) {\n                Serial.print("SD:EXISTS:DIR:");\n            } else {\n                Serial.print("SD:EXISTS:FILE:");\n                Serial.print(item.size());\n                Serial.print(":");\n            }\n            Serial.println(checkPath);\n            item.close();\n        } else {\n            Serial.print("SD:EXISTS:NO:");\n            Serial.println(checkPath);\n        }\n    } else if (cmd.startsWith("SD:FILE:")) {\n        // Parse: SD:FILE:filename:size\n        int lastColon = cmd.lastIndexOf(\':\');\n        if (lastColon > 8) {\n            transferFilename').concat(t," = cmd.substring(8, lastColon);\n            expectedFileSize").concat(t," = cmd.substring(lastColon + 1).toInt();\n            \n            // Ensure proper path\n            if (!transferFilename").concat(t,'.startsWith("/")) {\n                transferFilename').concat(t,' = "/" + transferFilename').concat(t,";\n            }\n            if (!transferFilename").concat(t,'.startsWith("/samples")) {\n                transferFilename').concat(t,' = "/samples" + transferFilename').concat(t,';\n            }\n            \n            // Create samples directory if needed\n            if (!SD.exists("/samples")) {\n                SD.mkdir("/samples");\n            }\n            \n            // Open file for writing\n            if (SD.exists(transferFilename').concat(t,")) {\n                SD.remove(transferFilename").concat(t,");\n            }\n            \n            transferFile").concat(t," = SD.open(transferFilename").concat(t,", FILE_WRITE);\n            if (transferFile").concat(t,") {\n                // Initialize ring buffer\n                ringWritePos").concat(t," = 0;\n                ringReadPos").concat(t," = 0;\n                ringBufferCount").concat(t," = 0;\n                receivedBytes").concat(t," = 0;\n                fileTransferActive").concat(t," = true;\n                \n                // Start the SD writer task on Core 1\n                xTaskCreatePinnedToCore(\n                    sdWriterTask").concat(t,',\n                    "SDWriter').concat(t,'",\n                    8192,\n                    NULL,\n                    1, // Priority\n                    &sdWriterTaskHandle').concat(t,",\n                    1  // Core 1\n                );\n                \n                // Send initial credit window\n                int initialCredits = ringBufferSpace").concat(t,'();\n                Serial.printf("SD:READY:%d\\n", initialCredits);\n            } else {\n                Serial.println("SD:FILE:ERROR");\n            }\n        }\n    }\n}\n            ')),e.globalFunctions.push("\n\n// Ring buffer utility functions for module ".concat(t,"\nint ringBufferSpace").concat(t,"() {\n    return RING_BUFFER_SIZE - ringBufferCount").concat(t,";\n}\n\nint ringBufferAvailable").concat(t,"() {\n    return ringBufferCount").concat(t,";\n}\n\n// SD writer task for module ").concat(t," - runs on Core 1\nvoid sdWriterTask").concat(t,"(void* parameter) {\n    uint8_t writeBuffer[16384]; // 16KB write buffer\n    \n    while (fileTransferActive").concat(t,") {\n        int available = ringBufferAvailable").concat(t,"();\n        \n        if (available >= sizeof(writeBuffer) || \n           (available > 0 && receivedBytes").concat(t," >= expectedFileSize").concat(t,")) {\n            \n            // Fill write buffer from ring buffer\n            int toWrite = min(available, (int)sizeof(writeBuffer));\n            for (int i = 0; i < toWrite; i++) {\n                writeBuffer[i] = ringBuffer").concat(t,"[ringReadPos").concat(t,"];\n                ringReadPos").concat(t," = (ringReadPos").concat(t," + 1) % RING_BUFFER_SIZE;\n            }\n            \n            // Write to SD card in large block\n            if (transferFile").concat(t," && toWrite > 0) {\n                transferFile").concat(t,".write(writeBuffer, toWrite);\n                transferFile").concat(t,".flush(); // Ensure data is written\n                \n                // Update ring buffer count atomically\n                taskENTER_CRITICAL(&ringBufferMux").concat(t,");\n                ringBufferCount").concat(t," -= toWrite;\n                taskEXIT_CRITICAL(&ringBufferMux").concat(t,");\n                \n                // Send credits to web app\n                int freeSpace = ringBufferSpace").concat(t,'();\n                if (freeSpace >= 32768) { // Send credits when 32KB+ free\n                    Serial.printf("CREDITS:%d\\n", freeSpace);\n                }\n            }\n            \n            // Check if transfer complete\n            if (receivedBytes').concat(t," >= expectedFileSize").concat(t," && available == 0) {\n                transferFile").concat(t,".close();\n                fileTransferActive").concat(t,' = false;\n                Serial.printf("FILE:COMPLETE:%s\\n", transferFilename').concat(t,".c_str());\n                break;\n            }\n        }\n        \n        vTaskDelay(pdMS_TO_TICKS(10)); // Small delay to prevent busy waiting\n    }\n    \n    // Clean up task\n    sdWriterTaskHandle").concat(t," = NULL;\n    vTaskDelete(NULL);\n}\n            "))}),this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type})&&(this.globalFunctions=this.globalFunctions||[],this.globalFunctions.push('\n// Universal SD Directory Browser - Only included when Sample Player modules are present\nvoid handleSDCommands() {\n    static String sdCommandBuffer = "";\n    \n    while (Serial.available()) {\n        char c = Serial.read();\n        if (c == \'\\n\' || c == \'\\r\') {\n            if (sdCommandBuffer.length() > 0) {\n                processGlobalSDCommand(sdCommandBuffer);\n                sdCommandBuffer = "";\n            }\n        } else {\n            sdCommandBuffer += c;\n            if (sdCommandBuffer.length() > 100) sdCommandBuffer = ""; // Prevent overflow\n        }\n    }\n}\n\n// Process global SD commands\nvoid processGlobalSDCommand(String cmd) {\n    cmd.trim();\n    \n    if (cmd == "SD:STATUS") {\n        Serial.println("SD:READY");\n    } else if (cmd == "SD:LIST" || cmd.startsWith("SD:LIST:")) {\n        // List directory contents: SD:LIST or SD:LIST:/path\n        String path = "/";\n        if (cmd.startsWith("SD:LIST:")) {\n            path = cmd.substring(8);\n            if (path.length() == 0) path = "/";\n        }\n        \n        File root = SD.open(path);\n        if (root && root.isDirectory()) {\n            Serial.print("SD:LIST:START:");\n            Serial.println(path);\n            \n            File file = root.openNextFile();\n            while (file) {\n                String itemName = String(file.name());\n                if (file.isDirectory()) {\n                    Serial.print("SD:DIR:");\n                    Serial.print(itemName);\n                    Serial.print(":");\n                    Serial.println(path + (path.endsWith("/") ? "" : "/") + itemName);\n                } else {\n                    Serial.print("SD:FILE:");\n                    Serial.print(itemName);\n                    Serial.print(":");\n                    Serial.print(file.size());\n                    Serial.print(":");\n                    Serial.println(path + (path.endsWith("/") ? "" : "/") + itemName);\n                }\n                file.close();\n                file = root.openNextFile();\n            }\n            root.close();\n            Serial.println("SD:LIST:END");\n        } else {\n            Serial.println("SD:LIST:ERROR");\n        }\n    } else if (cmd.startsWith("SD:MKDIR:")) {\n        // Create directory: SD:MKDIR:/path/newdir\n        String dirPath = cmd.substring(9);\n        if (SD.mkdir(dirPath)) {\n            Serial.print("SD:MKDIR:OK:");\n            Serial.println(dirPath);\n        } else {\n            Serial.print("SD:MKDIR:ERROR:");\n            Serial.println(dirPath);\n        }\n    } else if (cmd.startsWith("SD:DELETE:")) {\n        // Delete file or directory: SD:DELETE:/path/file\n        String deletePath = cmd.substring(10);\n        if (SD.remove(deletePath)) {\n            Serial.print("SD:DELETE:OK:");\n            Serial.println(deletePath);\n        } else {\n            Serial.print("SD:DELETE:ERROR:");\n            Serial.println(deletePath);\n        }\n    } else if (cmd.startsWith("SD:EXISTS:")) {\n        // Check if file/directory exists: SD:EXISTS:/path\n        String checkPath = cmd.substring(10);\n        if (SD.exists(checkPath)) {\n            File item = SD.open(checkPath);\n            if (item.isDirectory()) {\n                Serial.print("SD:EXISTS:DIR:");\n            } else {\n                Serial.print("SD:EXISTS:FILE:");\n                Serial.print(item.size());\n                Serial.print(":");\n            }\n            Serial.println(checkPath);\n            item.close();\n        } else {\n            Serial.print("SD:EXISTS:NO:");\n            Serial.println(checkPath);\n        }\n    } else if (cmd == "SD:INFO") {\n        // SD card info\n        Serial.print("SD:INFO:SIZE:");\n        Serial.print(SD.cardSize() / 1048576); // MB\n        Serial.print(":USED:");\n        Serial.print(SD.usedBytes() / 1048576); // MB\n        Serial.print(":TYPE:");\n        Serial.println(SD.cardType());\n    }\n}\n        ')),this.globalFunctions=this.globalFunctions||[];var n=this.modules.filter(function(e){return"LEDButton"===e.type}),t=this.modules.filter(function(e){return"Pot"===e.type}),a="\n// Bank colors (RGB)\nstruct BankColor {\n  uint8_t r, g, b;\n};\n\nconst BankColor bankColors[6] = {\n  {0, 255, 0}, // Bank 1\n  {255, 0, 0}, // Bank 2\n  {0, 0, 255}, // Bank 3\n  {255, 128, 0}, // Bank 4\n  {0, 255, 255}, // Bank 5\n  {255, 255, 255}  // Bank 6\n};\n\nvoid updateNeoPixels() {\n  // Get current bank color\n  BankColor color = bankColors[currentBank % 6];\n\n  // Clear all NeoPixels first\n  neoPixels.clear();\n";n.forEach(function(n){var t=n.params.index||1,o=[3,2,1,0][t-1],r=null,c=null,i=null;e.modularInstances.forEach(function(t,a){if("Looper"===t.type){var o=e.modules.find(function(n){return(n.id||"".concat(n.type).concat(e.modules.indexOf(n)))===a});e.connections.find(function(e){return e.from.id===n.id+":press"&&e.to.id===o.id+":record"})&&(r=t.instanceName)}else if("BPMLooper"===t.type){var l=e.modules.find(function(n){return(n.id||"".concat(n.type).concat(e.modules.indexOf(n)))===a});if((n.params.bank||1)===(l.params.start_bank||1)){var s=n.params.index||1;c=t.instanceName,i=s-1}}});var l=e.modules.filter(function(e){return"Automation"===e.type}),s="false";if(l.forEach(function(a){var o=e.modules.findIndex(function(e){return e.id===a.id}),r=e.connections.find(function(e){return e.to.id.includes("".concat(a.id,":"))&&"record_trigger"===e.to.port});r&&r.from.id.split(":")[0]===n.id&&(s="(btn".concat(t,"_gate && automation").concat(o,"_record_trigger)"))}),r)a+="\n  // Button ".concat(t," NeoPixel (LED index ").concat(o,") - Looper control\n  float looperState = ").concat(r,".ledOut;\n  if (looperState < 0.5f) {\n    // EMPTY state: Pulsing red (ready to record)\n    uint8_t pulse = (uint8_t)((sin(millis() / 300.0) + 1.0) * 127.5);\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(pulse, 0, 0));\n  } else if (looperState < 1.5f) {\n    // RECORDING state: Solid red\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(255, 0, 0));\n  } else if (looperState < 2.5f) {\n    // PLAYING state: Solid green (looping)\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(0, 255, 0));\n  } else if (looperState < 3.5f) {\n    // MUTED state: Off\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(0, 0, 0));\n  } else {\n    // OVERDUBBING state: Solid orange (layering audio)\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(255, 128, 0));\n  }\n");else if(c)a+="\n  // Button ".concat(t," NeoPixel (LED index ").concat(o,") - BPM Looper slot ").concat(i+1,"\n  float bpmLooperLed = ").concat(c,".ledOutputs[").concat(i,"];\n  // bpmLooperLed is 0.0-1.0 representing brightness (fade from beat start)\n  uint8_t brightness = (uint8_t)(bpmLooperLed * 255.0f);\n  neoPixels.setPixelColor(").concat(o,", neoPixels.Color(0, brightness, 0)); // Green fade\n");else if(e.checkAudioRecorderButton(n,t)){var u=e.getAudioRecorderForButton(n,t);if(u){var d=u.instanceIndex,p=u.buttonRole;a+="\n  // Button ".concat(t," NeoPixel (LED index ").concat(o,") - AudioRecorder ").concat(p,"\n  float recLed = rec").concat(d,"_led").concat("record"===p?"1":"2",";\n  if (recLed > 0.9f) {\n    // Full brightness: Recording or Playing\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(").concat("record"===p?"255, 0, 0":"0, 255, 0","));\n  } else if (recLed > 0.01f) {\n    // Pulsing: Armed or Paused\n    uint8_t brightness = (uint8_t)(recLed * 255.0f);\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(").concat("record"===p?"brightness, 0, 0":"0, brightness, 0","));\n  } else {\n    // Off\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(0, 0, 0));\n  }\n")}}else{var f=e.connections.find(function(e){return!(e.from.id!==n.id+":press"&&e.from.id!==n.id+":gate"||e.to.id.includes("Automation:record_trigger")||e.to.id.includes("Looper:record"))});a+=f?"\n  // Button ".concat(t," NeoPixel (LED index ").concat(o,") - Gate mode (dim=inactive, bright=active)\n  if (btn").concat(t,"_gate) {\n    // Gate active: Full brightness bank color\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(color.r, color.g, color.b));\n  } else {\n    // Gate inactive: Dim (20% brightness) to show it's in operation but inactive\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(\n      (uint8_t)(color.r * 0.2),\n      (uint8_t)(color.g * 0.2),\n      (uint8_t)(color.b * 0.2)\n    ));\n  }\n"):"\n  // Button ".concat(t," NeoPixel (LED index ").concat(o,")\n  if (").concat(s,") {\n    // Override with red for automation record\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(255, 0, 0));\n  } else {\n    // Use bank color\n    neoPixels.setPixelColor(").concat(o,", neoPixels.Color(color.r, color.g, color.b));\n  }\n")}}),this.modules.filter(function(e){return"AudioRecorder"===e.type}).forEach(function(e){var n,t=e.params.bank||1,o=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1";a+="\n  // AudioRecorder ".concat(o," Button 1 (Record) - Bank ").concat(t,"\n  if (currentBank == ").concat(t,") {\n    float recLed = rec").concat(o,"_led1;\n    if (recLed > 0.9f) {\n      // Full brightness: Recording\n      neoPixels.setPixelColor(").concat(3,", neoPixels.Color(255, 0, 0));\n    } else if (recLed > 0.01f) {\n      // Pulsing: Armed\n      uint8_t brightness = (uint8_t)(recLed * 255.0f);\n      neoPixels.setPixelColor(").concat(3,", neoPixels.Color(brightness, 0, 0));\n    } else {\n      // Off\n      neoPixels.setPixelColor(").concat(3,", neoPixels.Color(0, 0, 0));\n    }\n  }\n"),a+="\n  // AudioRecorder ".concat(o," Button 2 (Play/Pause) - Bank ").concat(t,"\n  if (currentBank == ").concat(t,") {\n    float recLed = rec").concat(o,"_led2;\n    if (recLed > 0.9f) {\n      // Full brightness: Playing\n      neoPixels.setPixelColor(").concat(2,", neoPixels.Color(0, 255, 0));\n    } else if (recLed > 0.01f) {\n      // Pulsing: Paused\n      uint8_t brightness = (uint8_t)(recLed * 255.0f);\n      neoPixels.setPixelColor(").concat(2,", neoPixels.Color(0, brightness, 0));\n    } else {\n      // Off\n      neoPixels.setPixelColor(").concat(2,", neoPixels.Color(0, 0, 0));\n    }\n  }\n")}),this.modules.filter(function(e){return"StereoMixer4"===e.type}).forEach(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1",o=e.params.start_bank||2,r=o+1,c=[3,2,1,0];a+="\n  // StereoMixer4 ".concat(t," button LEDs (Banks ").concat(o," and ").concat(r,")\n\n  // Bank ").concat(o,": Mute status indicators\n  if (currentBank == ").concat(o,") {\n    // Button LEDs show mute status: Green = unmuted, Off = muted\n    for (int ch = 0; ch < 4; ch++) {\n      int ledIdx = ").concat(c[0],"; // Will be overwritten in loop\n      if (ch == 0) ledIdx = ").concat(c[0],"; // Button 1  LED 3\n      if (ch == 1) ledIdx = ").concat(c[1],"; // Button 2  LED 2\n      if (ch == 2) ledIdx = ").concat(c[2],"; // Button 3  LED 1\n      if (ch == 3) ledIdx = ").concat(c[3],"; // Button 4  LED 0\n\n      if (!stereoMixer4_").concat(t,"_mute[ch]) {\n        // Unmuted: Green (channel active)\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(0, 255, 0));\n      } else {\n        // Muted: Off\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(0, 0, 0));\n      }\n    }\n  }\n\n  // Bank ").concat(r,": Pan/Solo indicators\n  if (currentBank == ").concat(r,") {\n    // Button LEDs: Yellow when channel is soloed, Off otherwise\n    for (int ch = 0; ch < 4; ch++) {\n      int ledIdx = ").concat(c[0],"; // Will be overwritten in loop\n      if (ch == 0) ledIdx = ").concat(c[0],"; // Button 1  LED 3\n      if (ch == 1) ledIdx = ").concat(c[1],"; // Button 2  LED 2\n      if (ch == 2) ledIdx = ").concat(c[2],"; // Button 3  LED 1\n      if (ch == 3) ledIdx = ").concat(c[3],"; // Button 4  LED 0\n\n      if (stereoMixer4_").concat(t,"_solo_channel == (ch + 1)) {\n        // Channel soloed: Yellow\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(255, 180, 0));\n      } else {\n        // Normal: Off\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(0, 0, 0));\n      }\n    }\n  }\n")});var o=new Set;t.forEach(function(n){var t=n.params.index||1;if(!o.has(t)){o.add(t);var r=[7,6,5,4][t-1],c=e.connections.find(function(e){return e.from.id===n.id+":value"}),i="brightness",l=null;if(c){var s,u=c.to.id.split(":")[0],d=c.to.id.split(":")[1],p=e.modules.find(function(e){return e.id===u});if(p&&"GateGen"===p.type&&"self_clock_bpm"===d)i="gate_pulse",l=(null===(s=p.id.match(/\d+$/))||void 0===s?void 0:s[0])||"1";else if(p&&"Clock"===p.type&&"bpm_input"===d){var f;i="clock_pulse",l=(null===(f=p.id.match(/\d+$/))||void 0===f?void 0:f[0])||"1"}}var m=n.params.bank||1;a+="gate_pulse"===i?"\n  // Pot ".concat(t," NeoPixel (LED index ").concat(r,") - Flash in sync with Gate Generator pulses (only in bank ").concat(m,")\n  float pot").concat(t,"_brightness;\n  if (currentBank == ").concat(m,") {\n    pot").concat(t,"_brightness = gate").concat(l,"_led_output; // Flash with gate when in correct bank\n  } else {\n    pot").concat(t,"_brightness = 0.0f; // Off when not in pot's bank\n  }\n  neoPixels.setPixelColor(").concat(r,", neoPixels.Color(\n    (uint8_t)(color.r * pot").concat(t,"_brightness),\n    (uint8_t)(color.g * pot").concat(t,"_brightness),\n    (uint8_t)(color.b * pot").concat(t,"_brightness)\n  ));\n"):"clock_pulse"===i?"\n  // Pot ".concat(t," NeoPixel (LED index ").concat(r,") - Flash in sync with Clock pulses (only in bank ").concat(m,")\n  float pot").concat(t,"_brightness;\n  if (currentBank == ").concat(m,") {\n    pot").concat(t,"_brightness = clock").concat(l,"_led_output; // Flash with clock when in correct bank\n  } else {\n    pot").concat(t,"_brightness = 0.0f; // Off when not in pot's bank\n  }\n  neoPixels.setPixelColor(").concat(r,", neoPixels.Color(\n    (uint8_t)(color.r * pot").concat(t,"_brightness),\n    (uint8_t)(color.g * pot").concat(t,"_brightness),\n    (uint8_t)(color.b * pot").concat(t,"_brightness)\n  ));\n"):"\n  // Pot ".concat(t," NeoPixel (LED index ").concat(r,") - Brightness reflects pot value (only in bank ").concat(m,")\n  float pot").concat(t,"_brightness;\n  if (currentBank == ").concat(m,") {\n    pot").concat(t,"_brightness = pot").concat(t,"_value; // Show value when in correct bank\n  } else {\n    pot").concat(t,"_brightness = 0.0f; // Off when not in pot's bank\n  }\n  neoPixels.setPixelColor(").concat(r,", neoPixels.Color(\n    (uint8_t)(color.r * pot").concat(t,"_brightness),\n    (uint8_t)(color.g * pot").concat(t,"_brightness),\n    (uint8_t)(color.b * pot").concat(t,"_brightness)\n  ));\n")}}),this.modules.filter(function(e){return"StereoMixer4"===e.type}).forEach(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1",o=e.params.start_bank||2,r=[7,6,5,4];a+="\n  // StereoMixer4 ".concat(t," volume visualization (Bank ").concat(o,")\n  if (currentBank == ").concat(o,") {\n    // Show volume level on pot LEDs using bank color with brightness control\n    BankColor color = bankColors[currentBank % 6];\n    for (int ch = 0; ch < 4; ch++) {\n      int ledIdx = ").concat(r[0],"; // Will be overwritten in loop\n      if (ch == 0) ledIdx = ").concat(r[0],"; // Pot 1  LED 7\n      if (ch == 1) ledIdx = ").concat(r[1],"; // Pot 2  LED 6\n      if (ch == 2) ledIdx = ").concat(r[2],"; // Pot 3  LED 5\n      if (ch == 3) ledIdx = ").concat(r[3],"; // Pot 4  LED 4\n\n      float brightness = stereoMixer4_").concat(t,"_smoothed_pot[ch]; // 0.0-1.0\n      neoPixels.setPixelColor(ledIdx, neoPixels.Color(\n        (uint8_t)(color.r * brightness),\n        (uint8_t)(color.g * brightness),\n        (uint8_t)(color.b * brightness)\n      ));\n    }\n  }\n")}),this.modules.filter(function(e){return"StereoMixer4"===e.type}).forEach(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1",o=(e.params.start_bank||2)+1,r=[7,6,5,4];a+="\n  // StereoMixer4 ".concat(t," pan visualization (Bank ").concat(o,")\n  if (currentBank == ").concat(o,") {\n    // Show pan position on pot LEDs: Purple (left)  Green (center)  Blue (right)\n    for (int ch = 0; ch < 4; ch++) {\n      int ledIdx = ").concat(r[0],"; // Will be overwritten in loop\n      if (ch == 0) ledIdx = ").concat(r[0],"; // Pot 1  LED 7\n      if (ch == 1) ledIdx = ").concat(r[1],"; // Pot 2  LED 6\n      if (ch == 2) ledIdx = ").concat(r[2],"; // Pot 3  LED 5\n      if (ch == 3) ledIdx = ").concat(r[3],"; // Pot 4  LED 4\n\n      float panPos = stereoMixer4_").concat(t,"_pan[ch]; // 0.0=left, 0.5=center, 1.0=right\n      uint8_t r, g, b;\n\n      if (panPos < 0.5) {\n        // Left half: Purple (128,0,255)  Green (0,255,0)\n        float t = panPos * 2.0; // 0.01.0 over left half\n        r = (uint8_t)(128 * (1.0 - t));           // 1280\n        g = (uint8_t)(255 * t);                   // 0255\n        b = (uint8_t)(255 * (1.0 - t));           // 2550\n      } else {\n        // Right half: Green (0,255,0)  Blue (0,0,255)\n        float t = (panPos - 0.5) * 2.0; // 0.01.0 over right half\n        r = 0;                                    // 00\n        g = (uint8_t)(255 * (1.0 - t));           // 2550\n        b = (uint8_t)(255 * t);                   // 0255\n      }\n\n      neoPixels.setPixelColor(ledIdx, neoPixels.Color(r, g, b));\n    }\n  }\n")}),this.modules.filter(function(e){return"Clock"===e.type}).forEach(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1",o=e.params.bank||4,r=[7,6,5,4],c=[3,2,1,0];a+="\n  // Clock ".concat(t," NeoPixel visualization (Bank ").concat(o,")\n  if (currentBank == ").concat(o,") {\n    BankColor color = bankColors[currentBank % 6];\n\n    // Pot LEDs: Show trigger pulses (flash when output fires)\n    // This visualizes the beat relationship between the 4 channels\n    for (int i = 0; i < 4; i++) {\n      int ledIdx = ").concat(r[0],"; // Will be overwritten in loop\n      if (i == 0) ledIdx = ").concat(r[0],"; // Pot 1  LED 7\n      if (i == 1) ledIdx = ").concat(r[1],"; // Pot 2  LED 6\n      if (i == 2) ledIdx = ").concat(r[2],"; // Pot 3  LED 5\n      if (i == 3) ledIdx = ").concat(r[3],"; // Pot 4  LED 4\n\n      bool outputState = false;\n      if (i == 0) outputState = clock").concat(t,"_out1;\n      if (i == 1) outputState = clock").concat(t,"_out2;\n      if (i == 2) outputState = clock").concat(t,"_out3;\n      if (i == 3) outputState = clock").concat(t,"_out4;\n\n      if (outputState) {\n        // Output HIGH: Full brightness pulse (shows trigger)\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(color.r, color.g, color.b));\n      } else {\n        // Output LOW: Dim baseline (10% brightness for visibility)\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(\n          (uint8_t)(color.r * 0.1f),\n          (uint8_t)(color.g * 0.1f),\n          (uint8_t)(color.b * 0.1f)\n        ));\n      }\n    }\n\n    // Button LEDs: Show fill button states (on when pressed, off when released)\n    for (int i = 0; i < 4; i++) {\n      int ledIdx = ").concat(c[0],"; // Will be overwritten in loop\n      if (i == 0) ledIdx = ").concat(c[0],"; // Btn 1  LED 3\n      if (i == 1) ledIdx = ").concat(c[1],"; // Btn 2  LED 2\n      if (i == 2) ledIdx = ").concat(c[2],"; // Btn 3  LED 1\n      if (i == 3) ledIdx = ").concat(c[3],"; // Btn 4  LED 0\n\n      bool fillState = false;\n      if (i == 0) fillState = clock").concat(t,"_fill1;\n      if (i == 1) fillState = clock").concat(t,"_fill2;\n      if (i == 2) fillState = clock").concat(t,"_fill3;\n      if (i == 3) fillState = clock").concat(t,"_fill4;\n\n      if (fillState) {\n        // Fill active: Full bank color\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(color.r, color.g, color.b));\n      } else {\n        // Fill inactive: Off\n        neoPixels.setPixelColor(ledIdx, neoPixels.Color(0, 0, 0));\n      }\n    }\n  }\n")}),this.modules.filter(function(e){return"BPMLooper"===e.type}).forEach(function(n){var t=e.modularInstances.get(n.id);if(t)for(var o=n.params.start_bank||1,r=o+1,c=0;c<4;c++){var i=[3,2,1,0][c];a+="\n  // BPM Looper slot ".concat(c+1," NeoPixel (LED index ").concat(i,") - Banks ").concat(o,"-").concat(r,"\n  if (currentBank == ").concat(o,") {\n    // Bank 1: Record/Mix mode (Red/Green)\n    float bpmLooperLed = ").concat(t.instanceName,".ledOutputs[").concat(c,"];\n    // Negative = red (empty/recording), Positive = green (playing), 0 = off (muted)\n    if (bpmLooperLed < 0.0f) {\n      // Red states (empty pulsing or recording solid)\n      uint8_t brightness = (uint8_t)(fabsf(bpmLooperLed) * 255.0f);\n      neoPixels.setPixelColor(").concat(i,", neoPixels.Color(brightness, 0, 0)); // Red\n    } else if (bpmLooperLed > 0.0f) {\n      // Green state (playing with beat pulse)\n      uint8_t brightness = (uint8_t)(bpmLooperLed * 255.0f);\n      neoPixels.setPixelColor(").concat(i,", neoPixels.Color(0, brightness, 0)); // Green\n    } else {\n      // Off (muted)\n      neoPixels.setPixelColor(").concat(i,", neoPixels.Color(0, 0, 0));\n    }\n  } else if (currentBank == ").concat(r,") {\n    // Bank 2: Randomization/Pitch mode (Blue/Cyan/Yellow)\n    float randomization = ").concat(t.instanceName,".slotRandomization[").concat(c,"];\n    float pitch = ").concat(t.instanceName,".slotPitch[").concat(c,"];\n    bool buttonPressed = ").concat(t.instanceName,".bank2ButtonPressed[").concat(c,"];\n\n    if (buttonPressed) {\n      // Button held: Pitch mode - color shift based on pitch (Blue=slow, Cyan=normal, Yellow=fast)\n      uint8_t r, g, b;\n      if (pitch < 0.75f) {\n        // Slow (0.5x-0.75x): Blue to Cyan\n        float t = (pitch - 0.5f) / 0.25f; // 0-1\n        r = 0;\n        g = (uint8_t)(t * 200.0f);\n        b = 200;\n      } else if (pitch < 1.25f) {\n        // Normal (0.75x-1.25x): Cyan\n        r = 0;\n        g = 200;\n        b = 200;\n      } else {\n        // Fast (1.25x-2.0x): Cyan to Yellow\n        float t = (pitch - 1.25f) / 0.75f; // 0-1\n        r = (uint8_t)(t * 200.0f);\n        g = 200;\n        b = (uint8_t)((1.0f - t) * 200.0f);\n      }\n      neoPixels.setPixelColor(").concat(i,", neoPixels.Color(r, g, b));\n    } else {\n      // Button released: Randomization mode - green intensity = randomization amount\n      uint8_t brightness = (uint8_t)(randomization * 200.0f);\n      neoPixels.setPixelColor(").concat(i,", neoPixels.Color(0, brightness, 0));\n    }\n  }\n")}}),a+="\n  neoPixels.show();\n}\n",this.globalFunctions.push(a)}},{key:"generateSetup",value:function(){var e=this,n=this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type})?921600:115200;this.setupCode.push("\nvoid setup() {\n    Serial.begin(".concat(n,');\n    delay(1000);\n    Serial.println("ESP32 Patcher starting...");\n    Serial.print("CPU Frequency: ");\n    Serial.print(getCpuFrequencyMhz());\n    Serial.println("MHz");\n\n').concat(this.modules.some(function(e){return"USBMIDIIn"===e.type||"USBMIDIOut"===e.type})?'    // Initialize USB MIDI (GPIO19/20)\n    // IMPORTANT: Arduino IDE  Tools  USB CDC On Boot: "Enabled"\n    // This ensures Serial/CDC remains available alongside USB MIDI\n    #if !ARDUINO_USB_CDC_ON_BOOT\n        #warning "USB CDC On Boot is DISABLED. Arduino IDE will not show device after upload!"\n        #warning "Go to Tools  USB CDC On Boot  Enabled to fix this."\n    #endif\n\n    USB.VID(0x239A);  // Adafruit VID (standard for TinyUSB)\n    USB.PID(0x4100);  // Generic MIDI device PID\n    USB.productName("SoniphormGen");  // Device name (no spaces for compatibility)\n    USB.manufacturerName("Soniphorm");\n    USB.serialNumber("0001");\n    USB.webUSB(false);\n    USB.begin();\n    usbMIDI.begin();\n    Serial.println("USB MIDI initialized (class-compliant, GPIO19/20)");\n    #if ARDUINO_USB_CDC_ON_BOOT\n        Serial.println("USB CDC enabled - Arduino IDE connectivity maintained");\n    #else\n        Serial.println("WARNING: USB CDC disabled - Device will not show in Arduino IDE!");\n    #endif\n\n':"",'    // Set a reasonable timestamp for file operations (no RTC)\n    // This prevents 1980 dates on SD card files\n    struct tm timeinfo;\n    timeinfo.tm_year = 2025 - 1900;  // Year since 1900\n    timeinfo.tm_mon = 0;              // January\n    timeinfo.tm_mday = 9;             // 9th\n    timeinfo.tm_hour = 12;\n    timeinfo.tm_min = 0;\n    timeinfo.tm_sec = 0;\n    time_t t = mktime(&timeinfo);\n    struct timeval now = { .tv_sec = t };\n    settimeofday(&now, NULL);\n    \n    // Comprehensive PSRAM detection and testing\n    Serial.println("=== PSRAM Detection ===");\n    \n    // Check if PSRAM is physically present\n    size_t psramSize = ESP.getPsramSize();\n    Serial.print("ESP.getPsramSize(): ");\n    Serial.print(psramSize);\n    Serial.println(" bytes");\n    \n    if (psramSize == 0) {\n        Serial.println("PSRAM: Not detected in hardware");\n    } else {\n        Serial.print("PSRAM: Detected ");\n        Serial.print(psramSize / 1024 / 1024);\n        Serial.println("MB chip");\n        \n        // Try to initialize PSRAM\n        if (psramInit()) {\n            Serial.println("PSRAM: Initialization successful");\n            \n            // Get available memory\n            size_t freePsram = ESP.getFreePsram();\n            Serial.print("Free PSRAM: ");\n            Serial.print(freePsram);\n            Serial.print(" bytes (");\n            Serial.print(freePsram / 1024 / 1024);\n            Serial.println("MB)");\n            \n            // Skip dangerous PSRAM test allocations that can cause crashes\n            Serial.println("PSRAM available - skipping test allocations for stability");\n        } else {\n            Serial.println("PSRAM: Initialization FAILED");\n        }\n    }\n    Serial.println("=== End PSRAM Detection ===");\n    Serial.println();\n\n    // Initialize I2C for MCP23017 (CRITICAL: I2C uses GPIO1/2, NOT GPIO17/18)\n    Wire.begin(').concat(K.I2C_SDA,", ").concat(K.I2C_SCL,');\n    Wire.setClock(400000); // 400kHz I2C Fast Mode (4 faster than default 100kHz)\n    Serial.println("I2C initialized on GPIO1/2 @ 400kHz");\n\n    // Initialize I2S FIRST (before MCP23017 to establish clean audio)\n    i2s_config_t i2s_config = {\n        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX').concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?" | I2S_MODE_RX":"","),\n        .sample_rate = SAMPLE_RATE,\n        .bits_per_sample = I2S_BITS_PER_SAMPLE_").concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"32BIT":"16BIT",",\n        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\n        .communication_format = I2S_COMM_FORMAT_STAND_I2S,\n        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n        .dma_buf_count = 8,\n        .dma_buf_len = 128, // Increased from 64 for more buffering headroom (prevents glitches at high CPU)\n        .use_apll = ").concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"true":"false",", // APLL required for PCM1802 MCLK\n        .tx_desc_auto_clear = true,\n        .fixed_mclk = 0\n    };\n\n    i2s_pin_config_t pin_config = {\n        ").concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?".mck_io_num = 16, // MCLK required for PCM1802\n        ":"",".bck_io_num = I2S_BCLK,\n        .ws_io_num = I2S_LRCK,\n        .data_out_num = I2S_DATA,\n        .data_in_num = ").concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"8 // GPIO8 - PCM1802 DOUT":"I2S_PIN_NO_CHANGE",'\n    };\n\n    i2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);\n    i2s_set_pin(I2S_NUM_0, &pin_config);\n    Serial.println("I2S initialized on GPIO15(BCK)/17(LRCK)/18(DATA)').concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"/16(MCLK)/8(DIN)":"",'");\n        ')),this.setupCode.push(this.generatePSRAMInitialization());var t=this.modules.filter(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type});t.length>0&&(this.setupCode.push('\n    // Initialize ring buffers for file transfer modules\n    Serial.println("Initializing file transfer ring buffers...");'),t.forEach(function(n){var t=e.modules.findIndex(function(e){return e.id===n.id});n.type,e.setupCode.push("\n    ringBuffer".concat(t," = (uint8_t*)ps_malloc(RING_BUFFER_SIZE);\n    if (ringBuffer").concat(t,') {\n        Serial.printf("Ring buffer ').concat(t,': 256KB allocated in PSRAM\\n");\n        ringWritePos').concat(t," = 0;\n        ringReadPos").concat(t," = 0;\n        ringBufferCount").concat(t,' = 0;\n    } else {\n        Serial.println("ERROR: Failed to allocate ring buffer ').concat(t,' in PSRAM!");\n    }'))}),this.setupCode.push('\n    Serial.println("Ring buffer initialization complete.");')),this.setupCode.push('\n    // Initialize MCP23017 AFTER I2S\n    if (!mcp.begin_I2C(0x20)) {\n        Serial.println("Error initializing MCP23017");\n        while(1);\n    }\n    Serial.println("MCP23017 initialized at address 0x20");\n        '),this.setupCode.push('\n    // Configure MCP23017 pins\n    // Port A: Buttons (0-3) as INPUT_PULLUP\n    for (int i = 0; i < 4; i++) {\n        mcp.pinMode(i, INPUT_PULLUP);\n    }\n    // Port A: MIDI LEDs (4-5) as OUTPUT (GPA4=MIDI_OUT_LED, GPA5=MIDI_IN_LED)\n    mcp.pinMode(4, OUTPUT);\n    mcp.pinMode(5, OUTPUT);\n    // Port A: Gate LEDs (6-7) as OUTPUT\n    for (int i = 6; i < 8; i++) {\n        mcp.pinMode(i, OUTPUT);\n    }\n    // Port B: Button LEDs (8-9) and Gate LEDs (10-13) as OUTPUT\n    for (int i = 8; i < 14; i++) {\n        mcp.pinMode(i, OUTPUT);\n    }\n\n    // CRITICAL: ALWAYS disable PAM8302 speaker amp at startup (GPB6, pin 14)\n    // This prevents amp staying on from previous patch uploads (MCP23017 doesn\'t reset with ESP32)\n    mcp.pinMode(14, OUTPUT);      // GPB6 - Amp shutdown control\n    mcp.digitalWrite(14, LOW);    // Amp disabled by default (HIGH = enabled)\n    Serial.println("PAM8302 speaker amp: DISABLED (safety default)");\n\n'.concat(this.modules.some(function(e){return["LineIn","Piezo","Coil","Exciter"].includes(e.type)})?"\n    // Audio input switches (GPB2/3 - Line In, GPB4 - Mono, GPB5 - PiP, GPB6 - Amp shutdown)\n    // GPB2/3 are active-LOW (LOW = line input enabled)\n    mcp.pinMode(10, OUTPUT); // GPB2 - LineR switch\n    mcp.pinMode(11, OUTPUT); // GPB3 - LineL switch\n    mcp.pinMode(12, OUTPUT); // GPB4 - Mono switch\n    mcp.pinMode(13, OUTPUT); // GPB5 - PiP switch\n    mcp.pinMode(14, OUTPUT); // GPB6 - Amp shutdown\n\n    // Enable line input (active-LOW: set to LOW)\n    mcp.digitalWrite(10, LOW);  // LineR enabled\n    mcp.digitalWrite(11, LOW);  // LineL enabled\n    mcp.digitalWrite(12, LOW);  // Mono off\n    mcp.digitalWrite(13, LOW);  // PiP off\n    mcp.digitalWrite(14, ".concat(this.modules.some(function(e){return"Exciter"===e.type})?"HIGH":"LOW","); // Amp ").concat(this.modules.some(function(e){return"Exciter"===e.type})?"enabled":"disabled",' (HIGH = on, ONLY for Exciter module)\n    Serial.println("Audio I/O: ').concat(this.modules.filter(function(e){return["LineIn","Piezo","Coil"].includes(e.type)}).map(function(e){return e.type}).join("/")," input enabled").concat(this.modules.some(function(e){return"Exciter"===e.type})?", Speaker amp enabled":", Speaker amp DISABLED",'");\n'):"",'\n    // Initialize all menu indicator LEDs to OFF by default\n    Serial.println("Initializing all menu indicator LEDs to OFF...");\n    mcp.digitalWrite(').concat($.MIDI_IN_LED,", LOW);   // Bank 3 indicator\n    mcp.digitalWrite(").concat($.MIDI_OUT_LED,', LOW);  // Bank 4 indicator\n    mcp.digitalWrite(GATE1_LED_PIN, LOW);             // Bank 1 indicator\n    mcp.digitalWrite(GATE2_LED_PIN, LOW);             // Bank 2 indicator\n    mcp.digitalWrite(GATE3_LED_PIN, LOW);             // Bank 5 indicator\n    mcp.digitalWrite(GATE4_LED_PIN, LOW);             // Bank 6 indicator\n\n    // Light up the initial bank indicator (currentBank = 1 by default)\n    Serial.print("Lighting initial bank indicator for bank: ");\n    Serial.println(currentBank);\n    mcp.digitalWrite(GATE1_LED_PIN, HIGH);            // Bank 1 starts active\n        ')),this.modules.filter(function(e){return["Pot","LEDButton","Encoder","GateOut","GateIn"].includes(e.type)}).forEach(function(n,t){if("Pot"===n.type){var a=n.params.index||1,o=K.ANALOG_PINS[a-1]||K.ANALOG_PINS[0];e.setupCode.push("    pinMode(".concat(o,", INPUT);"))}}),this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type})&&this.setupCode.push('\n    // Initialize SD Card with high-speed setup for smooth sample playback\n    Serial.println("Initializing SD card...");\n    Serial.printf("SD SPI Pins: SCK=%d, MISO=%d, MOSI=%d, CS=%d\\n", '.concat(K.SD_SCK,", ").concat(K.SD_MISO,", ").concat(K.SD_MOSI,", ").concat(K.SD_CS,");\n    SPI.begin(").concat(K.SD_SCK,", ").concat(K.SD_MISO,", ").concat(K.SD_MOSI,", ").concat(K.SD_CS,');\n    delay(100);  // Give SD card time to stabilize after SPI.begin()\n\n    // Start at low speed for initialization\n    Serial.println("Attempting SD.begin() at 400kHz...");\n    if (!SD.begin(').concat(K.SD_CS,', SPI, 400000)) {\n        Serial.println("SD Card initialization FAILED at 400kHz!");\n        Serial.println("Possible causes:");\n        Serial.println("  1) SD card not inserted or not seated properly");\n        Serial.println("  2) SD card not FAT32 formatted");\n        Serial.println("  3) SPI wiring issue (check SCK=12, MISO=11, MOSI=10, CS=9)");\n        Serial.println("  4) SD card damaged or incompatible");\n        Serial.println("  5) Power issue (SD card needs 3.3V)");\n        Serial.println("Try: Remove and reinsert SD card, then press RESET button");\n    } else {\n        Serial.println("SD Card initialized at 400kHz successfully!");\n        // Reinitialize at high speed for fast reads (eliminates audio stuttering)\n        SD.end();\n        const uint32_t SD_SPI_HZ = 40000000; // 40 MHz\n        if (!SD.begin(').concat(K.SD_CS,', SPI, SD_SPI_HZ)) {\n            Serial.println("SD Card high-speed init failed, trying 25MHz");\n            SD.end();\n            if (!SD.begin(').concat(K.SD_CS,', SPI, 25000000)) {\n                Serial.println("SD Card failed at all speeds!");\n                return;\n            }\n        }\n        Serial.println("SD Card initialized at high speed for smooth sample playback");\n        uint64_t cardSize = SD.cardSize() / (1024 * 1024);\n        Serial.printf("SD Card size: %lluMB\\n", cardSize);\n        \n        // Initialize SD card file transfer handler for modules with samples\n        // SD sample players initialized automatically\n        \n        // List WAV files in root directory\n        File root = SD.open("/");\n        if (root) {\n            Serial.println("WAV files on SD card:");\n            File file = root.openNextFile();\n            int fileCount = 0;\n            while (file) {\n                String fname = file.name();\n                if (!file.isDirectory() && (fname.endsWith(".wav") || fname.endsWith(".WAV"))) {\n                    fileCount++;\n                    Serial.printf("  %d: %s (%lu bytes)\\n", fileCount, file.name(), file.size());\n                }\n                file.close();\n                file = root.openNextFile();\n            }\n            root.close();\n            if (fileCount == 0) {\n                Serial.println("  No WAV files found. Copy sample1.wav, sample2.wav, etc. to SD card");\n            }\n            \n            // Count samples for each Sample Player module and set dynamic ranges\n            ').concat(this.modules.filter(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type}).map(function(n){var t=e.modules.findIndex(function(e){return e.id===n.id});return"\n            // Count available samples for Sample Player ".concat(t,'\n            Serial.printf("Counting samples for Sample Player %d...\\n", ').concat(t,");\n            int sampleCount").concat(t,' = 0;\n            \n            // Check numbered samples (sample1.wav, sample2.wav, etc.)\n            for (int i = 1; i <= 99; i++) {\n                String testPaths[] = {\n                    "/sample" + String(i) + ".wav",\n                    "/samples/sample" + String(i) + ".wav"\n                };\n                \n                bool found = false;\n                for (String testPath : testPaths) {\n                    if (SD.exists(testPath)) {\n                        sampleCount').concat(t,'++;\n                        found = true;\n                        break;\n                    }\n                }\n                \n                // Also check session folders\n                File rootCount = SD.open("/");\n                if (rootCount && !found) {\n                    File entryCount = rootCount.openNextFile();\n                    while (entryCount && !found) {\n                        String entryName = String(entryCount.name());\n                        if (entryCount.isDirectory() && entryName.startsWith("session_")) {\n                            String sessionPath = "/" + entryName + "/sample" + String(i) + ".wav";\n                            if (SD.exists(sessionPath)) {\n                                sampleCount').concat(t,"++;\n                                found = true;\n                            }\n                        }\n                        entryCount.close();\n                        entryCount = rootCount.openNextFile();\n                    }\n                    rootCount.close();\n                }\n                \n                // Stop counting if we hit a gap (sample1.wav, sample2.wav exist, but sample3.wav missing)\n                if (!found) break;\n            }\n            \n            sdPlayer").concat(t,"_sampleCount = sampleCount").concat(t,';\n            Serial.printf("Sample Player %d: Found %d samples (pot will map across full range)\\n", ').concat(t,", sampleCount").concat(t,");")}).join(""),"\n        }\n    }\n            ")),this.setupCode.push("\n    // Initialize direct GPIO pins\n    pinMode(".concat(K.ENCODER_A,", INPUT_PULLUP);\n    pinMode(").concat(K.ENCODER_B,", INPUT_PULLUP);\n    pinMode(").concat(K.ENCODER_BTN,", INPUT_PULLUP);\n    \n    // Calculate number of active banks based on hardware modules in patch\n    activeBanks = ").concat(this.calculateActiveBanks(),';\n    Serial.print("ESP32-S3 Patcher initialized with ");\n    Serial.print(activeBanks);\n    Serial.println(" active banks");\n    \n    // Initialize banking system state\n    currentBank = 1;\n    showingBankIndicator = false;\n    Serial.print("Starting in Bank ");\n    Serial.println(currentBank);\n    \n    // Allocate PSRAM for DrumDesigner delay lines and noise buffers\n    ').concat(this.modules.filter(function(e){return"DrumDesigner"===e.type}).map(function(e,n){var t,a=(null===(t=e.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";return"\n    // Allocate K-S delay line for DrumDesigner ".concat(a,' from PSRAM\n    Serial.println("Allocating DrumDesigner').concat(a,' delay line from PSRAM...");\n    ks').concat(a,"_delayLine = (float*)ps_malloc(KS_MAX_DELAY_").concat(a," * sizeof(float));\n    if (!ks").concat(a,'_delayLine) {\n        Serial.println("ERROR: Failed to allocate DrumDesigner').concat(a,' delay line from PSRAM!");\n        Serial.printf("Free PSRAM: %d bytes\\n", ESP.getFreePsram());\n        while(1); // Halt - cannot continue without delay line\n    }\n    memset(ks').concat(a,"_delayLine, 0, KS_MAX_DELAY_").concat(a,' * sizeof(float));\n    Serial.printf("DrumDesigner').concat(a,' delay line: 32KB allocated (8192 samples for sub-bass)\\n");\n\n    // Allocate and pre-generate noise buffer for fast excitation\n    Serial.println("Pre-generating noise buffer for DrumDesigner').concat(a,'...");\n    ks').concat(a,"_noiseBuffer = (float*)ps_malloc(KS_MAX_DELAY_").concat(a," * sizeof(float));\n    if (!ks").concat(a,'_noiseBuffer) {\n        Serial.println("ERROR: Failed to allocate DrumDesigner').concat(a,' noise buffer from PSRAM!");\n        Serial.printf("Free PSRAM: %d bytes\\n", ESP.getFreePsram());\n        while(1); // Halt - cannot continue without noise buffer\n    }\n    // Fill noise buffer with random values (done once at startup)\n    for (int i = 0; i < KS_MAX_DELAY_').concat(a,"; i++) {\n        ks").concat(a,'_noiseBuffer[i] = ((float)random(-32768, 32767) / 32768.0f);\n    }\n    Serial.printf("DrumDesigner').concat(a,' noise buffer: 32KB allocated and initialized\\n");\n    Serial.printf("Free PSRAM remaining: %d bytes (64KB total for DrumDesigner').concat(a,')\\n", ESP.getFreePsram());')}).join(""),"\n\n    // Allocate PSRAM for DrumDesigner4 (4-voice) delay lines and noise buffers\n    ").concat(this.modules.filter(function(e){return"DrumDesigner4"===e.type}).map(function(e,n){for(var t,a=(null===(t=e.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1",o="",r=1;r<=4;r++)!1!==e.params["voice".concat(r,"_enabled")]&&(o+="\n    // Allocate Voice ".concat(r," for DrumDesigner4 ").concat(a,'\n    Serial.println("Allocating DrumDesigner4_').concat(a," Voice ").concat(r,' delay line from PSRAM...");\n    dd4').concat(a,"_v").concat(r,"_delayLine = (float*)ps_malloc(KS_MAX_DELAY_DD4").concat(a,"_V").concat(r," * sizeof(float));\n    if (!dd4").concat(a,"_v").concat(r,'_delayLine) {\n        Serial.println("ERROR: Failed to allocate DrumDesigner4_').concat(a,"_v").concat(r,' delay line!");\n        while(1);\n    }\n    memset(dd4').concat(a,"_v").concat(r,"_delayLine, 0, KS_MAX_DELAY_DD4").concat(a,"_V").concat(r,' * sizeof(float));\n    Serial.printf("DrumDesigner4_').concat(a," Voice ").concat(r,' delay line: 8KB allocated\\n");\n\n    dd4').concat(a,"_v").concat(r,"_noiseBuffer = (float*)ps_malloc(KS_MAX_DELAY_DD4").concat(a,"_V").concat(r," * sizeof(float));\n    if (!dd4").concat(a,"_v").concat(r,'_noiseBuffer) {\n        Serial.println("ERROR: Failed to allocate DrumDesigner4_').concat(a,"_v").concat(r,' noise buffer!");\n        while(1);\n    }\n    for (int i = 0; i < KS_MAX_DELAY_DD4').concat(a,"_V").concat(r,"; i++) {\n        dd4").concat(a,"_v").concat(r,'_noiseBuffer[i] = ((float)random(-32768, 32767) / 32768.0f);\n    }\n    Serial.printf("DrumDesigner4_').concat(a," Voice ").concat(r,' initialized\\n");'));return o}).join(""),"\n\n    // Initialize wavetables for Wavetable oscillators\n    ").concat(this.modules.filter(function(e){return"Wavetable"===e.type}).map(function(e,n){var t,a=(null===(t=e.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";return"\n    // Initialize default wavetables for Wavetable ".concat(a,'\n    Serial.println("Initializing wavetables for Wavetable ').concat(a,'...");\n    for (int i = 0; i < WT').concat(a,"_TABLE_SIZE; i++) {\n        float phase = (2.0 * PI * i) / WT").concat(a,"_TABLE_SIZE;\n        wt").concat(a,"_table0[i] = sin(phase);                    // Sine wave\n        wt").concat(a,"_table1[i] = (i < WT").concat(a,"_TABLE_SIZE/2) ? 1.0 : -1.0; // Square wave\n        wt").concat(a,"_table2[i] = 2.0 * (float)i / WT").concat(a,"_TABLE_SIZE - 1.0; // Sawtooth wave\n        wt").concat(a,'_table3[i] = 1.0 - 4.0 * abs(phase - PI) / PI; // Triangle wave\n    }\n    Serial.println("Wavetables initialized for Wavetable ').concat(a,'");')}).join(""),"\n\n    // SAFE: Preload first sample for each Sample Player during setup (not during audio processing)\n    ").concat(this.modules.filter(function(e){return"SamplePlayer"===e.type}).map(function(e,n){var t,a=(null===(t=e.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";return"\n    // Preload sample1.wav for Sample Player ".concat(a,"\n    String preloadFile").concat(a,' = "/sample1.wav";\n    if (!SD.exists(preloadFile').concat(a,")) {\n        preloadFile").concat(a,' = "/samples/sample1.wav";\n    }\n    if (SD.exists(preloadFile').concat(a,") && sdPlayer").concat(a,"_player.loadFile(preloadFile").concat(a,".c_str())) {\n        sdPlayer").concat(a,'_lastLoadedFile = 1;\n        Serial.println("Preloaded: " + preloadFile').concat(a,');\n    } else {\n        Serial.println("Warning: Could not preload sample1.wav for Sample Player ').concat(a,'");\n    }')}).join(""),"\n\n    // Initialize AudioRecorder ring buffers and FreeRTOS tasks\n    ").concat(this.modules.filter(function(e){return"AudioRecorder"===e.type}).map(function(e,n){var t,a=(null===(t=e.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";return"\n    // AudioRecorder ".concat(a,' - Allocate PSRAM ring buffer and create SD writer task\n    Serial.println("Initializing AudioRecorder ').concat(a,' ring buffer...");\n    rec').concat(a,"_ringBuffer = (uint8_t*)ps_malloc(REC").concat(a,"_BLOCK_SIZE * REC").concat(a,"_BLOCK_COUNT);\n    if (rec").concat(a,'_ringBuffer == nullptr) {\n        Serial.println("ERROR: Failed to allocate PSRAM ring buffer for AudioRecorder ').concat(a,'!");\n    } else {\n        Serial.printf("AudioRecorder ').concat(a,' ring buffer allocated: %lu bytes\\n",\n                     REC').concat(a,"_BLOCK_SIZE * REC").concat(a,"_BLOCK_COUNT);\n\n        // Create mutex for thread-safe ring buffer access\n        rec").concat(a,"_bufferMutex = xSemaphoreCreateMutex();\n        if (rec").concat(a,'_bufferMutex == nullptr) {\n            Serial.println("ERROR: Failed to create buffer mutex for AudioRecorder ').concat(a,'!");\n        }\n\n        // Create SD writer task on Core 0 (non-audio core)\n        BaseType_t taskCreated = xTaskCreatePinnedToCore(\n            rec').concat(a,'_sdWriterTaskFunc,  // Task function\n            "Rec').concat(a,'Writer",           // Task name\n            8192,                                // Stack size (8KB)\n            nullptr,                             // Parameters\n            2,                                   // Priority (higher than reader for recording priority)\n            &rec').concat(a,'_sdWriterTask,     // Task handle\n            0                                    // Core 0 (not audio core)\n        );\n        if (taskCreated != pdPASS) {\n            Serial.println("ERROR: Failed to create SD writer task for AudioRecorder ').concat(a,'!");\n        } else {\n            Serial.println("AudioRecorder ').concat(a,' SD writer task created on Core 0");\n        }\n\n        // Allocate playback ring buffer for streaming playback\n        Serial.println("Initializing AudioRecorder ').concat(a,' playback ring buffer...");\n        play').concat(a,"_ringBuffer = (uint8_t*)ps_malloc(PLAY").concat(a,"_BLOCK_SIZE * PLAY").concat(a,"_BLOCK_COUNT);\n        if (play").concat(a,'_ringBuffer == nullptr) {\n            Serial.println("ERROR: Failed to allocate PSRAM playback ring buffer for AudioRecorder ').concat(a,'!");\n        } else {\n            Serial.printf("AudioRecorder ').concat(a,' playback ring buffer allocated: %lu bytes\\n",\n                         PLAY').concat(a,"_BLOCK_SIZE * PLAY").concat(a,"_BLOCK_COUNT);\n\n            // Create mutex for thread-safe playback ring buffer access\n            play").concat(a,"_bufferMutex = xSemaphoreCreateMutex();\n            if (play").concat(a,'_bufferMutex == nullptr) {\n                Serial.println("ERROR: Failed to create playback buffer mutex for AudioRecorder ').concat(a,'!");\n            }\n\n            // Create SD reader task on Core 0 (non-audio core)\n            BaseType_t playTaskCreated = xTaskCreatePinnedToCore(\n                play').concat(a,'_sdReaderTaskFunc,  // Task function\n                "Play').concat(a,'Reader",           // Task name\n                8192,                                 // Stack size (8KB)\n                nullptr,                              // Parameters\n                1,                                    // Priority (low)\n                &play').concat(a,'_sdReaderTask,     // Task handle\n                0                                     // Core 0 (not audio core)\n            );\n            if (playTaskCreated != pdPASS) {\n                Serial.println("ERROR: Failed to create SD reader task for AudioRecorder ').concat(a,'!");\n            } else {\n                Serial.println("AudioRecorder ').concat(a,' SD reader task created on Core 0");\n            }\n\n            // Scan SD card for existing recordings and set next file index\n            int highestIndex = rec').concat(a,"_findHighestFileIndex();\n            rec").concat(a,'_currentFileIndex = highestIndex + 1;\n            Serial.printf("AudioRecorder ').concat(a,' will record to: rec%03d.wav\\n", rec').concat(a,"_currentFileIndex);\n        }\n    }")}).join(""),'\n\n    // CRITICAL: Clear audio buffers and output silence before starting main loop\n    // This prevents startup glitches from uninitialized memory\n    Serial.println("Clearing audio buffers and outputting initial silence...");\n\n    // Clear all buffers\n    memset(leftBuffer, 0, sizeof(leftBuffer));\n    memset(rightBuffer, 0, sizeof(rightBuffer));\n    memset(i2sBuffer, 0, sizeof(i2sBuffer));\n\n    // Output 3 silent frames to let I2S stabilize\n    for (int frame = 0; frame < 3; frame++) {\n        size_t bytes_written;\n        i2s_write(I2S_NUM_0, i2sBuffer, sizeof(i2sBuffer), &bytes_written, portMAX_DELAY);\n    }\n\n    // Initialize NeoPixels\n    neoPixels.begin();\n    neoPixels.setBrightness(').concat(K.NEOPIXEL_BRIGHTNESS,');\n    neoPixels.clear();\n    neoPixels.show();\n    Serial.println("NeoPixels initialized (8 LEDs, GPIO46)");\n\n    Serial.println("Audio system ready!");\n\n    // Launch control task on Core 0 (audio runs on Core 1 in loop())\n    Serial.println("Creating control task on Core 0...");\n    xTaskCreatePinnedToCore(\n        controlTask,           // Task function\n        "ControlTask",         // Task name\n        8192,                  // Stack size (bytes)\n        NULL,                  // Parameters\n        1,                     // Priority\n        NULL,                  // Task handle (not needed)\n        0                      // Core 0\n    );\n    Serial.println("Control task launched on Core 0 - dual-core operation active");\n}\n        '))}},{key:"generatePSRAMInitialization",value:function(){var e="";return this.modules.forEach(function(n,t){"Looper_OLD_DISABLED"===n.type&&(e+="\n    // OLD DISABLED: Initialize Looper module ".concat(t,"\n    // looper").concat(t,".init();\n                "))}),this.modularInstances.forEach(function(n,t){e+="\n    // Initialize modular ".concat(n.type," instance\n    ").concat(n.instanceName,".init();\n            ")}),this.modules.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||t+1;if("Delay"===n.type){var r=Math.round(44.1*(n.params.time_ms||380)*2);e+="\n    // Initialize PSRAM buffers for Delay module ".concat(o,'\n    Serial.println("Allocating PSRAM buffers for delay effect...");\n    delay').concat(o,"_bufferL = (float*)ps_malloc(").concat(r," * sizeof(float));\n    delay").concat(o,"_bufferR = (float*)ps_malloc(").concat(r," * sizeof(float));\n\n    if (!delay").concat(o,"_bufferL || !delay").concat(o,'_bufferR) {\n        Serial.println("PSRAM allocation failed for delay, falling back to DRAM with smaller buffers...");\n\n        // Fallback to DRAM - try progressively smaller buffers\n        const int maxDRAMSize = ').concat(Math.floor(4410),"; // 100ms max for DRAM\n        const int minDRAMSize = ").concat(Math.floor(441),"; // 10ms minimum\n        int fallbackSize = maxDRAMSize;\n\n        while (fallbackSize >= minDRAMSize) {\n            delay").concat(o,"_bufferL = (float*)malloc(fallbackSize * sizeof(float));\n            delay").concat(o,"_bufferR = (float*)malloc(fallbackSize * sizeof(float));\n\n            if (delay").concat(o,"_bufferL && delay").concat(o,'_bufferR) {\n                Serial.printf("Delay ').concat(o,': Allocated %d samples in DRAM (%.1fms)\\n", fallbackSize, fallbackSize / 44.1f);\n                break;\n            }\n\n            if (delay').concat(o,"_bufferL) free(delay").concat(o,"_bufferL);\n            if (delay").concat(o,"_bufferR) free(delay").concat(o,"_bufferR);\n\n            fallbackSize = (int)(fallbackSize * 0.75); // Reduce by 25%\n        }\n\n        if (!delay").concat(o,"_bufferL || !delay").concat(o,'_bufferR) {\n            Serial.println("ERROR: Even DRAM allocation failed for delay!");\n            while(1);\n        }\n    } else {\n        Serial.printf("Delay ').concat(o,': Allocated %d samples in PSRAM (%.1fms)\\n", ').concat(r,", ").concat(r," / 44.1f);\n\n        // Initialize buffers to silence\n        memset(delay").concat(o,"_bufferL, 0, ").concat(r," * sizeof(float));\n        memset(delay").concat(o,"_bufferR, 0, ").concat(r," * sizeof(float));\n    }\n                ")}else if("GranularSynth"===n.type){var c=Math.floor(.5*K.SAMPLE_RATE);e+="\n    // Initialize PSRAM buffers for GranularSynth module ".concat(o,'\n    Serial.println("Allocating PSRAM buffers for granular synthesis...");\n    granular').concat(o,"_buffer_L = (float*)ps_malloc(").concat(c," * sizeof(float));\n    granular").concat(o,"_buffer_R = (float*)ps_malloc(").concat(c," * sizeof(float));\n\n    if (!granular").concat(o,"_buffer_L || !granular").concat(o,'_buffer_R) {\n        Serial.println("PSRAM allocation failed, falling back to DRAM with smaller buffers...");\n\n        // Fallback to DRAM - try progressively smaller buffers\n        const int maxDRAMSize = ').concat(Math.floor(.5*K.SAMPLE_RATE),"; // 0.5s max\n        const int minDRAMSize = ").concat(Math.floor(.25*K.SAMPLE_RATE),"; // Minimum 0.25s\n        int fallbackSize = maxDRAMSize;\n\n        while (fallbackSize >= minDRAMSize) {\n            granular").concat(o,"_buffer_L = (float*)malloc(fallbackSize * sizeof(float));\n            granular").concat(o,"_buffer_R = (float*)malloc(fallbackSize * sizeof(float));\n\n            if (granular").concat(o,"_buffer_L && granular").concat(o,"_buffer_R) {\n                break; // Success!\n            }\n\n            // Free any partial allocation\n            if (granular").concat(o,"_buffer_L) free(granular").concat(o,"_buffer_L);\n            if (granular").concat(o,"_buffer_R) free(granular").concat(o,'_buffer_R);\n\n            // Try smaller buffer\n            fallbackSize = (int)(fallbackSize * 0.75); // Reduce by 25%\n            Serial.print("Retrying with smaller buffer: ");\n            Serial.print(fallbackSize);\n            Serial.println(" samples");\n        }\n\n        if (!granular').concat(o,"_buffer_L || !granular").concat(o,'_buffer_R) {\n            Serial.println("ERROR: Even DRAM allocation failed!");\n            while(1);\n        }\n\n        granular').concat(o,'_buffer_size = fallbackSize;\n        Serial.printf("Using DRAM buffers: %d bytes (%.2fs buffer)\\n",\n            fallbackSize * sizeof(float) * 2, (float)fallbackSize / ').concat(K.SAMPLE_RATE,");\n    } else {\n        granular").concat(o,"_buffer_size = ").concat(c,';\n        Serial.printf("PSRAM granular buffers allocated: %d bytes (%.2fs buffer)\\n",\n            ').concat(c," * sizeof(float) * 2, (float)").concat(c," / ").concat(K.SAMPLE_RATE,");\n    }\n\n    // Initialize buffers to silence\n    for (int i = 0; i < granular").concat(o,"_buffer_size; i++) {\n        granular").concat(o,"_buffer_L[i] = 0.0f;\n        granular").concat(o,"_buffer_R[i] = 0.0f;\n    }\n\n    granular").concat(o,"_write_pos = 0;\n\n    // Initialize 4 grains to inactive\n    for (int i = 0; i < 4; i++) {\n        granular").concat(o,"_grains[i].active = false;\n        granular").concat(o,"_grains[i].position = 0.0f;\n        granular").concat(o,"_grains[i].pitch_ratio = 1.0f;\n        granular").concat(o,"_grains[i].amplitude = 0.0f;\n        granular").concat(o,"_grains[i].samples_remaining = 0;\n        granular").concat(o,"_grains[i].grain_size_samples = 0;\n    }\n")}else if("GranularDense"===n.type){var i=Math.floor(2*K.SAMPLE_RATE);e+="\n    // Initialize PSRAM buffers for GranularDense module ".concat(o,'\n    Serial.println("Allocating PSRAM buffers for dense granular synthesis...");\n    granular').concat(o,"_buffer_L = (float*)ps_malloc(").concat(i," * sizeof(float));\n    granular").concat(o,"_buffer_R = (float*)ps_malloc(").concat(i," * sizeof(float));\n    \n    if (!granular").concat(o,"_buffer_L || !granular").concat(o,'_buffer_R) {\n        Serial.println("PSRAM allocation failed, falling back to DRAM with smaller buffers...");\n        \n        // Fallback to DRAM - smaller buffer sizes for dense processing\n        const int maxDRAMSize = ').concat(Math.floor(1*K.SAMPLE_RATE),"; // 1s max for DRAM\n        const int minDRAMSize = ").concat(Math.floor(.5*K.SAMPLE_RATE),"; // Minimum 0.5s\n        int fallbackSize = maxDRAMSize;\n        \n        while (fallbackSize >= minDRAMSize) {\n            granular").concat(o,"_buffer_L = (float*)malloc(fallbackSize * sizeof(float));\n            granular").concat(o,"_buffer_R = (float*)malloc(fallbackSize * sizeof(float));\n            \n            if (granular").concat(o,"_buffer_L && granular").concat(o,"_buffer_R) {\n                break; // Success!\n            }\n            \n            // Free any partial allocation\n            if (granular").concat(o,"_buffer_L) free(granular").concat(o,"_buffer_L);\n            if (granular").concat(o,"_buffer_R) free(granular").concat(o,'_buffer_R);\n            \n            // Try smaller buffer\n            fallbackSize = (int)(fallbackSize * 0.75); // Reduce by 25%\n            Serial.print("Retrying dense granular with smaller buffer: ");\n            Serial.print(fallbackSize);\n            Serial.println(" samples");\n        }\n        \n        if (!granular').concat(o,"_buffer_L || !granular").concat(o,'_buffer_R) {\n            Serial.println("ERROR: Even DRAM allocation failed for dense granular!");\n            while(1);\n        }\n        \n        granular').concat(o,'_buffer_size = fallbackSize;\n        Serial.print("Using DRAM buffers for dense granular: ");\n        Serial.print(fallbackSize * sizeof(float) * 2);\n        Serial.print(" bytes (");\n        Serial.print((float)fallbackSize / ').concat(K.SAMPLE_RATE,');\n        Serial.println("s buffer)");\n    } else {\n        granular').concat(o,"_buffer_size = ").concat(i,';\n        Serial.print("PSRAM dense granular buffers allocated successfully: ");\n        Serial.print(').concat(i,' * sizeof(float) * 2);\n        Serial.print(" bytes (");\n        Serial.print((float)').concat(i," / ").concat(K.SAMPLE_RATE,');\n        Serial.println("s buffer)");\n    }\n    \n    // Initialize dense granular buffers to silence\n    for (int i = 0; i < granular').concat(o,"_buffer_size; i++) {\n        granular").concat(o,"_buffer_L[i] = 0.0f;\n        granular").concat(o,"_buffer_R[i] = 0.0f;\n    }\n    \n    granular").concat(o,"_write_pos = 0;\n    \n    // Initialize all 20 dense grains to inactive\n    for (int i = 0; i < 20; i++) {\n        granular").concat(o,"_grains[i].active = false;\n        granular").concat(o,"_grains[i].position = 0.0f;\n        granular").concat(o,"_grains[i].pitch_ratio = 1.0f;\n        granular").concat(o,"_grains[i].envelope_pos = 0.0f;\n        granular").concat(o,"_grains[i].envelope_inc = 0.0f;\n        granular").concat(o,"_grains[i].samples_remaining = 0;\n    }\n")}else if("Automation"===n.type){var l=n.params.buffer_size||1e3,s=n.params.num_inputs||1;e+="\n    // Initialize PSRAM buffers for Automation module ".concat(o," (").concat(s,' channels)\n    Serial.println("Allocating PSRAM buffers for automation recording...");\n');for(var u=1;u<=s;u++)e+="    automation".concat(o,"_buffer_").concat(u," = (float*)ps_malloc(").concat(l," * sizeof(float));\n    if (!automation").concat(o,"_buffer_").concat(u,') {\n        Serial.println("ERROR: PSRAM allocation failed for automation channel ').concat(u,'");\n        while(1);\n    } else {\n        memset(automation').concat(o,"_buffer_").concat(u,", 0, ").concat(l,' * sizeof(float));\n        Serial.printf("Automation ').concat(o," channel ").concat(u,': Allocated %d samples in PSRAM (%.1fs @ 50Hz)\\n", ').concat(l,", ").concat(l," / 50.0f);\n    }\n")}else"CleanReverb"===n.type&&(e+="\n    // Initialize CleanReverb ".concat(o,' buffers to zero (critical to prevent glitching)\n    Serial.println("Initializing CleanReverb buffers...");\n    initCleanReverb').concat(o,"();\n"))}),e}},{key:"generateLoop",value:function(){var e=this,n=this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type||"AudioRecorder"===e.type});this.loopCode.push('\n// Core 0 Task: Control Processing\nvoid controlTask(void* parameter) {\n    Serial.println("  Control Task started on Core 0");\n\n    while(1) {\n        '.concat(n?"// Universal SD directory browser\n        handleSDCommands();":"// No SD modules - SD commands disabled","\n\n        ").concat(this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type})?"\n        // Handle SD card file transfers from web app (NOT AudioRecorder - it writes directly)\n        ".concat(this.modules.filter(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type}).map(function(n){var t=e.modules.findIndex(function(e){return e.id===n.id});return"handleFileTransfer".concat(t,"();")}).join("\n        "),"\n        "):"","\n        // Fast encoder button polling (every 1ms for responsive button presses)\n        // This is direct GPIO read, not I2C, so it doesn't interfere with audio\n        updateEncoderButton();\n\n        // Timed I2C access to prevent I2S interference\n        // ").concat(this.modules.some(function(e){return"GateIn"===e.type})?"1ms polling (1kHz) for piezo trigger detection (brief pulses)":"100ms polling (10Hz) reduces audio glitches while maintaining responsive UI","\n        if (millis() - lastMcpRead > ").concat(this.modules.some(function(e){return"GateIn"===e.type})?"1":"100",") {\n            lastMcpRead = millis();\n            updateHardware();\n        }\n\n        // Update control signals at 100Hz\n        static unsigned long lastControlUpdate = 0;\n        if (millis() - lastControlUpdate > 10) {\n            lastControlUpdate = millis();\n            updateControl();\n        }\n\n        // Update NeoPixels every 100ms (10Hz) - reduced from 50Hz for lower CPU usage\n        // Visual feedback is still very responsive at 10Hz\n        static unsigned long lastNeoPixelUpdate = 0;\n        if (millis() - lastNeoPixelUpdate > 100) {\n            lastNeoPixelUpdate = millis();\n            updateNeoPixels();\n        }\n\n        // Yield to FreeRTOS scheduler (1ms delay)\n        vTaskDelay(1 / portTICK_PERIOD_MS);\n    }\n}\n\n// Core 1 Loop: Audio Processing ONLY\nvoid loop() {\n    // Generate and output audio buffer\n    // This runs as fast as possible on Core 1\n    processAudio();\n    outputAudio();\n}\n        "));var t=this.modules.some(function(e){return"GateGen"===e.type}),a=this.modules.some(function(e){return"Clock"===e.type});this.loopCode.push("\n// Fast encoder button polling (GPIO48 direct read, no I2C delay)\n// Called every 1ms from controlTask for instant button response\nvoid updateEncoderButton() {\n    // Read encoder button state (GPIO48 - direct GPIO, not I2C)\n    encoderBtn = !digitalRead(".concat(K.ENCODER_BTN,"); // Active low (pullup)\n\n    // Encoder button: long-press detection for future automation recording\n    // Short press (<1s): Toggle Gate Generator or Clock start/stop\n    // Long press (>1s): Toggle automation recording (future feature)\n\n    // On button press, record timestamp\n    if (encoderBtn && !lastEncoderBtn) {\n        encoderBtnPressTime = millis();\n        encoderBtnLongPressHandled = false;\n        // Serial.println removed - causes audio glitches\n    }\n\n    // Check for long press while button is still held (>1000ms)\n    if (encoderBtn && (millis() - encoderBtnPressTime > 1000) && !encoderBtnLongPressHandled) {\n        encoderBtnLongPressHandled = true;\n        ").concat(this.modules.some(function(e){return"StereoMixer4"===e.type})?"\n        // Check if in mixer banks - encoder button reserved for solo mode in pan bank\n        bool inMixerBanks = false;\n        ".concat(this.modules.filter(function(e){return"StereoMixer4"===e.type}).map(function(e){var n=e.params.start_bank||2,t=n+1;return"if (currentBank == ".concat(n," || currentBank == ").concat(t,") inMixerBanks = true;")}).join("\n        "),"\n\n        if (!inMixerBanks) {\n            // LONG PRESS: Encoder button available for Automation mode selection (non-mixer banks)\n            enc1_buttonLongPressed = true;\n        }\n        // Note: In mixer banks, encoder hold is used for solo mode (not long-press toggle)\n        "):"\n        // LONG PRESS: Encoder button available for Automation mode selection\n        enc1_buttonLongPressed = true; // Expose to Automation modules\n        ","\n    }\n\n    // While button is held after long press, keep enc1_buttonLongPressed true (unless in mixer banks)\n    if (encoderBtn && encoderBtnLongPressHandled) {\n        ").concat(this.modules.some(function(e){return"StereoMixer4"===e.type})?"\n        // Check if in mixer banks - don't set enc1_buttonLongPressed in mixer banks\n        bool inMixerBanks = false;\n        ".concat(this.modules.filter(function(e){return"StereoMixer4"===e.type}).map(function(e){var n=e.params.start_bank||2,t=n+1;return"if (currentBank == ".concat(n," || currentBank == ").concat(t,") inMixerBanks = true;")}).join("\n        "),"\n        if (!inMixerBanks) {\n            enc1_buttonLongPressed = true;\n        }\n        "):"\n        enc1_buttonLongPressed = true;\n        ","\n    }\n\n    // Clear enc1_buttonLongPressed when button is released\n    if (!encoderBtn && enc1_buttonLongPressed) {\n        enc1_buttonLongPressed = false;\n        // Serial.println removed - causes audio glitches\n    }\n\n    // On button release, check if it was a short press\n    if (!encoderBtn && lastEncoderBtn && !encoderBtnLongPressHandled) {\n        ").concat(this.modules.some(function(e){return"StereoMixer4"===e.type})?"\n        // Check if in mixer banks - skip Gate Gen/Clock toggle in mixer banks\n        bool inMixerBanks = false;\n        ".concat(this.modules.filter(function(e){return"StereoMixer4"===e.type}).map(function(e){var n=e.params.start_bank||2,t=n+1;return"if (currentBank == ".concat(n," || currentBank == ").concat(t,") inMixerBanks = true;")}).join("\n        "),"\n\n        if (inMixerBanks) {\n            // SHORT PRESS IN MIXER BANKS: Just show bank indicator (no Gate Gen/Clock toggle)\n            showingBankIndicator = true;\n            bankIndicatorTime = millis();\n        } else {\n        "):"","\n        // SHORT PRESS: Toggle Gate Generator/Clock or show bank\n        ").concat(t?'\n        // Toggle Gate Generator run state\n        gate1_running = !gate1_running;\n        Serial.print("Gate Generator ");\n        Serial.println(gate1_running ? "STARTED" : "STOPPED");\n\n        // Show bank indicator when stopped\n        if (!gate1_running) {\n            showingBankIndicator = true;\n            bankIndicatorTime = millis();\n        }\n        ':a?"\n        // Toggle Clock run state (toggle all Clock modules)\n        ".concat(this.modules.filter(function(e){return"Clock"===e.type}).map(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1";return"clock".concat(t,"_running = !clock").concat(t,"_running;")}).join("\n        "),'\n        Serial.println("Clock(s) toggled");\n\n        // Show bank indicator\n        showingBankIndicator = true;\n        bankIndicatorTime = millis();\n        '):"\n        // No Gate Generator or Clock - just show bank indicator\n        showingBankIndicator = true;\n        bankIndicatorTime = millis();\n        ","\n        ").concat(this.modules.some(function(e){return"StereoMixer4"===e.type})?"\n        } // End mixer bank check\n        ":"",'\n    }\n\n    lastEncoderBtn = encoderBtn;\n}\n\nvoid updateHardware() {\n    // Batch read all MCP23017 inputs (single I2C transaction) into global variable\n    inputs = mcp.readGPIOAB();\n\n    // DEBUG: Print raw MCP23017 input values periodically\n    static unsigned long lastInputDebug = 0;\n    static uint16_t lastInputs = 0xFFFF;\n    if (inputs != lastInputs || millis() - lastInputDebug > 5000) {\n        lastInputDebug = millis();\n        lastInputs = inputs;\n        Serial.print("MCP23017 raw inputs: 0x");\n        Serial.println(inputs, HEX);\n    }\n\n    // DEDICATED ENCODER BANKING SYSTEM\n    // ================================\n    // Encoder controls bank switching for virtual pots/buttons\n    // LED Bank Indication (clockwise navigation):\n    //   Bank 1: Gate1 LED     Bank 2: Gate2 LED      Bank 3: MIDI-IN LED\n    //   Bank 4: MIDI-OUT LED  Bank 5: Gate3 LED      Bank 6: Gate4 LED  wraps to Bank 1\n    //\n    // Hardware: GPIO21(A), GPIO47(B) - encoder rotation only (button handled in updateEncoderButton())\n    // LEDs temporarily override normal operation during navigation\n\n\n    int encoderA = digitalRead(').concat(K.ENCODER_A,");\n    int encoderB = digitalRead(").concat(K.ENCODER_B,");\n    \n    // 20-detent encoder: One detent = one menu step (improved precision)\n    static unsigned long lastEncoderChange = 0;\n    static int encoderState = 0;\n    static const int encoderStates[4][2] = {{0,1},{1,1},{1,0},{0,0}}; // Quadrature sequence\n    \n    // Detect state changes for precise detent detection\n    int currentState = (encoderA << 1) | encoderB;\n    static int lastState = 0;\n    \n    if (currentState != lastState && millis() - lastEncoderChange > 25) { // 25ms debounce for 20-detent encoder\n        // Determine direction by comparing state transitions\n        int direction = 0;\n        if ((lastState == 0 && currentState == 1) || (lastState == 1 && currentState == 3) ||\n            (lastState == 3 && currentState == 2) || (lastState == 2 && currentState == 0)) {\n            direction = 1; // Clockwise\n        } else if ((lastState == 0 && currentState == 2) || (lastState == 2 && currentState == 3) ||\n                   (lastState == 3 && currentState == 1) || (lastState == 1 && currentState == 0)) {\n            direction = -1; // Counter-clockwise\n        }\n        \n        if (direction != 0) {\n            lastEncoderChange = millis();\n\n            // Additional safeguard: prevent rapid changes within 150ms (20-detent encoder)\n            static unsigned long lastBankChange = 0;\n            if (millis() - lastBankChange >= 150) {\n                lastBankChange = millis();\n\n            ").concat(this.modules.some(function(e){return"Clock"===e.type})?"\n            // ENCODER HOLD + ROTATE: Clock BPM adjustment\n            if (encoderBtn) {\n                // Encoder button held - adjust Clock BPM instead of navigating banks\n                const float BPM_STEP = 5.0; // 5 BPM per detent\n                const float BPM_MIN = 40.0;\n                const float BPM_MAX = 240.0;\n\n                ".concat(this.modules.filter(function(e){return"Clock"===e.type}).map(function(e){var n,t=(null===(n=e.id.match(/\d+$/))||void 0===n?void 0:n[0])||"1";return"\n                // Adjust Clock ".concat(t," BPM\n                if (direction > 0) {\n                    clock").concat(t,"_bpm = min(clock").concat(t,"_bpm + BPM_STEP, BPM_MAX);\n                } else {\n                    clock").concat(t,"_bpm = max(clock").concat(t,'_bpm - BPM_STEP, BPM_MIN);\n                }\n                Serial.print("Clock ').concat(t,' BPM: ");\n                Serial.println(clock').concat(t,"_bpm);")}).join(""),"\n            } else {\n            "):"",'\n                // Normal encoder rotation - bank navigation\n                Serial.print("DEBUG: Encoder direction = ");\n                Serial.print(direction);\n                Serial.print(", currentBank before = ");\n                Serial.print(currentBank);\n                Serial.print(", activeBanks = ");\n                Serial.println(activeBanks);\n\n                if (direction > 0) {\n                    currentBank++;\n                    Serial.print("DEBUG: After increment, currentBank = ");\n                    Serial.print(currentBank);\n                    if (currentBank > activeBanks) {\n                        Serial.print(" > activeBanks, resetting to 1");\n                        currentBank = 1;\n                    }\n                    Serial.println();\n                } else {\n                    currentBank--;\n                    Serial.print("DEBUG: After decrement, currentBank = ");\n                    Serial.print(currentBank);\n                    if (currentBank < 1) {\n                        Serial.print(" < 1, setting to activeBanks");\n                        currentBank = activeBanks;\n                    }\n                    Serial.println();\n                }\n\n                // Show bank indicator LED\n                showingBankIndicator = true;\n                bankIndicatorTime = millis();\n                Serial.print("Bank navigation (detent-precise): ");\n                Serial.println(currentBank);\n            ').concat(this.modules.some(function(e){return"Clock"===e.type})?"}":"",'\n            } else {\n                Serial.println("DEBUG: Ignoring rapid encoder change");\n            }\n        }\n        lastState = currentState;\n    }\n\n    // NOTE: Encoder button handling moved to updateEncoderButton() for faster polling (1ms vs 100ms)\n\n    // Bank indicator LED control (only controls indicator LEDs, not button LEDs)\n    if (showingBankIndicator) {\n        // Turn off only the bank indicator LEDs (not button LEDs!)\n        mcp.digitalWrite(').concat($.MIDI_IN_LED,", LOW);\n        mcp.digitalWrite(").concat($.MIDI_OUT_LED,', LOW);\n        // Gate LEDs controlled via MCP23017 (set to LOW)\n        mcp.digitalWrite(GATE1_LED_PIN, LOW);\n        mcp.digitalWrite(GATE2_LED_PIN, LOW);\n        mcp.digitalWrite(GATE3_LED_PIN, LOW);\n        mcp.digitalWrite(GATE4_LED_PIN, LOW);\n\n        // Light up the current bank indicator\n        Serial.print("Lighting bank indicator for bank: ");\n        Serial.println(currentBank);\n        switch(currentBank) {\n            case 1:\n                mcp.digitalWrite(GATE1_LED_PIN, HIGH);\n                Serial.println("Gate1 LED ON");\n                break;    // Bank 1: Gate1 LED\n            case 2:\n                mcp.digitalWrite(GATE2_LED_PIN, HIGH);\n                Serial.println("Gate2 LED ON");\n                break;    // Bank 2: Gate2 LED\n            case 3:\n                mcp.digitalWrite(').concat($.MIDI_IN_LED,', HIGH);\n                Serial.println("MIDI-IN LED ON");\n                break;  // Bank 3: MIDI-IN LED\n            case 4:\n                mcp.digitalWrite(').concat($.MIDI_OUT_LED,', HIGH);\n                Serial.println("MIDI-OUT LED ON");\n                break; // Bank 4: MIDI-OUT LED\n            case 5:\n                mcp.digitalWrite(GATE3_LED_PIN, HIGH);\n                Serial.println("Gate3 LED ON");\n                break;    // Bank 5: Gate3 LED\n            case 6:\n                mcp.digitalWrite(GATE4_LED_PIN, HIGH);\n                Serial.println("Gate4 LED ON");\n                break;    // Bank 6: Gate4 LED\n            case 7: /* Reserved for future expansion */ break;\n            case 8: /* Reserved for future expansion */ break;\n        }\n\n        // Auto-fade back to functional LED display after 1 second\n        if (millis() - bankIndicatorTime > 1000) {\n            showingBankIndicator = false;\n            Serial.println("Bank indicator faded - returning to functional LED display");\n        }\n    } else {\n        // Functional LED feedback (Gate/MIDI activity) when NOT showing bank indicator\n\n        // Gate In LEDs (GPA4Gate1 LED, GPA5Gate2 LED)\n        mcp.digitalWrite(GATE1_LED_PIN, led_gatein1_active ? HIGH : LOW);\n        mcp.digitalWrite(GATE2_LED_PIN, led_gatein2_active ? HIGH : LOW);\n\n        // Gate Out LEDs (Gate3 LED, Gate4 LED)\n        mcp.digitalWrite(GATE3_LED_PIN, led_gateout1_active ? HIGH : LOW);\n        mcp.digitalWrite(GATE4_LED_PIN, led_gateout2_active ? HIGH : LOW);\n\n        // MIDI In LED (50ms flash on activity)\n        if (led_midiin_active && (millis() - led_midiin_time < 50)) {\n            mcp.digitalWrite(').concat($.MIDI_IN_LED,", HIGH);\n        } else {\n            mcp.digitalWrite(").concat($.MIDI_IN_LED,", LOW);\n            led_midiin_active = false;\n        }\n\n        // MIDI Out LED (50ms flash on activity)\n        if (led_midiout_active && (millis() - led_midiout_time < 50)) {\n            mcp.digitalWrite(").concat($.MIDI_OUT_LED,", HIGH);\n        } else {\n            mcp.digitalWrite(").concat($.MIDI_OUT_LED,", LOW);\n            led_midiout_active = false;\n        }\n    }\n\n    lastEncoderA = encoderA;\n    // NOTE: lastEncoderBtn updated in updateEncoderButton() for fast polling\n        ")),this.modules.filter(function(e){return["Pot","LEDButton","Encoder","GateOut","GateIn"].includes(e.type)}).forEach(function(n,t){var a=e.modules.findIndex(function(e){return e.id===n.id});switch(n.type){case"LEDButton":var o=n.params.index||1,r=n.params.bank||1,c=n.params.locked||!1,i=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"sampleIn"===e.to.port}),l=i,s="0.0";if(i){var u=i.from.id.split(":")[0],d=e.modules.find(function(e){return e.id===u});if(d){var p,f=(null===(p=u.match(/\d+$/))||void 0===p?void 0:p[0])||"1";switch(d.type){case"Pot":var m=d.params.index||1;s="pot".concat(m,"_value");break;case"ADSR":s="adsr".concat(f,"_output");break;case"LFO":s="lfo".concat(f,"_output");break;case"Scale":s="scale".concat(f,"_output");break;default:s="0.0"}}}e.loopCode.push("\n    // Button ".concat(a," (Bank ").concat(r,", Physical ").concat(o).concat(c?" - LOCKED":"",")").concat(l?" - SAMPLE & HOLD MODE":"","\n    btn").concat(o,"_lastState = btn").concat(o,"_state;\n    if (").concat(c?"true":"currentBank == ".concat(r),") {\n        // Physical buttons use actual hardware pin mapping (Button 1=GPA2, 2=GPA1, 3=GPA0, 4=GPA3)\n        bool rawBit = (inputs & (1 << BTN_PIN_").concat(o,")) != 0; // Use actual MCP23017 pin from ESP32Config\n        btn").concat(o,"_state = !rawBit; // Inverted due to pullup\n        btn").concat(o,"_pressed = btn").concat(o,"_state && !btn").concat(o,"_lastState;\n        btn").concat(o,"_gate = btn").concat(o,"_state;  // Raw gate signal always follows button state\n        btn").concat(o,"_output = btn").concat(o,"_state ? 1.0 : 0.0;\n\n        ").concat(l?"\n        // Sample & Hold: Read sampleIn and capture on button press\n        btn".concat(o,"_sampleIn = ").concat(s,";\n        if (btn").concat(o,"_pressed) {\n            btn").concat(o,"_sampleOut = btn").concat(o,'_sampleIn; // Sample and hold\n            Serial.print("Button ').concat(o,' S&H: Sampled value = ");\n            Serial.println(btn').concat(o,"_sampleOut);\n        }\n        // Note: sampleOut holds its value until next press"):"","\n        \n        // DEBUG: Print button state changes\n        if (btn").concat(o,"_state != btn").concat(o,'_lastState) {\n            Serial.print("Button ').concat(a," (Physical ").concat(o,'): ");\n            Serial.print(btn').concat(o,'_state ? "PRESSED" : "RELEASED");\n            Serial.print(" (raw bit: ");\n            Serial.print(rawBit);\n            Serial.print(", inputs: 0x");\n            Serial.print(inputs, HEX);\n            Serial.println(")");\n        }\n        \n        // DEBUG: Print button press detection\n        if (btn').concat(o,'_pressed) {\n            Serial.println("BUTTON EDGE DETECTED!");\n        }\n\n        // Note: Button LED feedback is handled by NeoPixels in updateNeoPixels() on Core 0\n        // MCP23017 pins 6-9 are Gate LEDs and MIDI LEDs, NOT button LEDs\n    } else {\n        // Button not in current bank - set to inactive\n        btn').concat(o,"_state = false;\n        btn").concat(o,"_pressed = false;\n        btn").concat(o,"_gate = false;  // CRITICAL: Clear gate signal for proper bank isolation\n        btn").concat(o,"_output = 0.0;\n    }\n                    "));break;case"GateIn":var _=n.params.index||1,g=e.hardwareModules.generateControlCode(n,_,e.connections);g&&e.loopCode.push(g)}}),this.loopCode.push("\n}\n        "),this.loopCode.push("\nvoid updateControl() {\n        "),this.loopCode.push("\n        unsigned long currentTime = millis(); // Shared time for all control modules\n        "),this.modules.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";if("ADSR"!==n.type)switch(n.type){case"GateGen":e.loopCode.push("\n        // Gate Generator ".concat(o," - Clock-triggered gate with S&H\n        bool clockTrigger = false;\n        \n        // Update BPM from pot connection if available\n        float currentBPM = gate").concat(o,"_self_clock_bpm;\n        // Update probability from pot connection if available\n        float currentProbability = gate").concat(o,"_probability;\n                    "));var r=e.connections.find(function(e){return e.to.id==="".concat(n.id,":self_clock_bpm")});if(r){var c,i=r.from.id.split(":")[0],l=e.modules.find(function(e){return e.id===i});if(null===(c=i.match(/\d+$/))||void 0===c||c[0],l&&"Pot"===l.type){var s=e.getPotReference(l.id);s&&e.loopCode.push("        currentBPM = 60.0 + ".concat(s,"_value * 240.0; // BPM from pot (60-300 BPM)"))}}var u=e.connections.find(function(e){return e.to.id==="".concat(n.id,":probability")});if(u){var d,p=u.from.id.split(":")[0],f=e.modules.find(function(e){return e.id===p});if(null===(d=p.match(/\d+$/))||void 0===d||d[0],f&&"Pot"===f.type){var m=e.getPotReference(f.id);m&&e.loopCode.push("        currentProbability = ".concat(m,"_value; // Probability from pot"))}}var _=e.connections.find(function(e){return e.to.id==="".concat(n.id,":gate_input")});if(_){var g,h=_.from.id.split(":")[0],v=e.modules.find(function(e){return e.id===h}),b=(null===(g=h.match(/\d+$/))||void 0===g?void 0:g[0])||"1";if(v&&b>=0){if("LEDButton"===v.type){var y=v.params.index||1;e.loopCode.push("        gate".concat(o,"_gate_input = btn").concat(y,"_state; // Gate input from button ").concat(y)),e.loopCode.push("        gate".concat(o,"_use_self_clock = true; // Button connected - run sequence when button held"))}else"ADSR"===v.type?e.loopCode.push("        gate".concat(o,"_gate_input = adsr").concat(b,"_output; // Gate input from ADSR")):"LFO"===v.type?e.loopCode.push("        gate".concat(o,"_gate_input = lfo").concat(b,"_output; // Gate input from LFO")):"Clock"===v.type?e.loopCode.push("        gate".concat(o,"_gate_input = clock").concat(b,"_out1; // Gate input from clock")):e.loopCode.push("        gate".concat(o,"_gate_input = ").concat(v.type.toLowerCase()).concat(b,"_output; // Gate input"));e.loopCode.push("        gate".concat(o,"_gate_enabled = (gate").concat(o,"_gate_input > 0.5); // Gate active when > 0.5"))}else e.loopCode.push("        gate".concat(o,"_gate_enabled = true; // Invalid gate input connection - always enabled"))}else e.loopCode.push("        gate".concat(o,"_gate_enabled = true; // No gate input - always enabled"));var k=e.connections.find(function(e){return e.to.id==="".concat(n.id,":sh_input")});if(k){var S,x=k.from.id.split(":")[0],E=e.modules.find(function(e){return e.id===x}),P=(null===(S=x.match(/\d+$/))||void 0===S?void 0:S[0])||"1";if(E)if("LFO"===E.type)e.loopCode.push("        gate".concat(o,"_sh_input = lfo").concat(P,"_output; // S&H input from LFO"));else if("Pot"===E.type){var w=e.getPotReference(E.id);e.loopCode.push("        gate".concat(o,"_sh_input = ").concat(w,"_value; // S&H input from Pot"))}else"ADSR"===E.type?e.loopCode.push("        gate".concat(o,"_sh_input = adsr").concat(P,"_output; // S&H input from ADSR")):e.loopCode.push("        gate".concat(o,"_sh_input = ").concat(E.type.toLowerCase()).concat(P,"_output; // S&H input"))}e.loopCode.push("\n        // Check for clock input or use self-clock (only when running)\n        if (gate".concat(o,"_use_self_clock && gate").concat(o,"_running) {\n            // Self-clock mode - generate internal clock\n            float clockPeriod = 60000.0 / currentBPM; // Period in ms using current BPM\n            if (currentTime - gate").concat(o,"_last_self_clock >= clockPeriod) {\n                clockTrigger = true;\n                gate").concat(o,"_last_self_clock = currentTime;\n            }\n        } else {\n            // External clock mode - would need external clock source\n            // This mode is for connecting to other clock generators\n        }\n        \n        // Process gate logic (only when gate is enabled)\n        // Gate input acts as an on/off toggle - when enabled, generator runs normally\n        if (clockTrigger && !gate").concat(o,"_last_clock && gate").concat(o,"_gate_enabled) {\n            // Rising edge of clock - check probability\n            float random_val = (float)random(0, 1000) / 1000.0; // 0.0 to 1.0\n            if (random_val <= currentProbability) {\n                gate").concat(o,"_state = true;\n                gate").concat(o,'_start_time = currentTime;\n                \n                // Debug: Gate triggered\n                Serial.println("Gate Generator triggered");\n                \n                // Sample & Hold: capture input value on gate trigger\n                if (gate').concat(o,"_sh_enabled) {\n                    gate").concat(o,"_sh_output = gate").concat(o,'_sh_input;\n                }\n            }\n            // Debug: Print probability info occasionally\n            static unsigned long lastProbDebug = 0;\n            if (millis() - lastProbDebug > 2000) { // Every 2 seconds\n                lastProbDebug = millis();\n                Serial.print("Gate Gen Prob: ");\n                Serial.print(currentProbability);\n                Serial.print(", Random: ");\n                Serial.print(random_val);\n                Serial.print(", Triggered: ");\n                Serial.println(random_val <= currentProbability ? "YES" : "NO");\n            }\n        }\n        \n        // Gate input controls whether the generator is enabled to run\n        // When gate_enabled is false, generator doesn\'t trigger new gates\n        \n        gate').concat(o,"_last_clock = clockTrigger;\n        \n        // Check gate length (in self-clock mode)\n        if (gate").concat(o,"_state) {\n            float gatePeriod = 60000.0 / currentBPM; // Period in ms using current BPM\n            float gateDuration = gatePeriod * gate").concat(o,"_length; // Gate duration in ms\n            \n            if (currentTime - gate").concat(o,"_start_time >= gateDuration) {\n                gate").concat(o,"_state = false;\n            }\n        }\n        \n        // Gate input behavior: when gate_enabled is false, generator stops triggering new gates\n        // but existing gate states continue their natural length for musical timing\n\n        gate").concat(o,"_output = gate").concat(o,"_state ? 1.0 : 0.0;\n\n        // Update LED output (metronome flash mode if led_flash_ms > 0)\n        if (gate").concat(o,"_led_flash_ms > 0) {\n            // Metronome mode: Fixed-duration flash on gate trigger\n            if (gate").concat(o,"_state && gate").concat(o,"_led_output == 0.0f) {\n                // Gate just went high - start LED flash\n                gate").concat(o,"_led_output = 1.0f;\n                gate").concat(o,"_led_start_time = currentTime;\n            } else if (gate").concat(o,"_led_output > 0.0f) {\n                // LED is on - check if flash duration expired\n                if (currentTime - gate").concat(o,"_led_start_time >= gate").concat(o,"_led_flash_ms) {\n                    gate").concat(o,"_led_output = 0.0f; // Turn off LED after flash\n                }\n            }\n        } else {\n            // Normal mode: LED follows gate state\n            gate").concat(o,"_led_output = gate").concat(o,"_output;\n        }\n                    "));break;case"Oscillator":var C=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"gate"===e.to.port});if(C){var R=C.from.id.split(":")[0],L=e.modules.find(function(e){return e.id===R});if(L&&"LEDButton"===L.type){var I=L.params.index||1;e.loopCode.push("    // Oscillator ".concat(o," gate from Button ").concat(I)),e.loopCode.push(e.generateBankAwareButtonAssignment(L.id,"osc".concat(o,"_gate = btn").concat(I,"_gate ? 1.0 : 0.0;")))}else if(L&&"ADSR"===L.type){var M,D=(null===(M=R.match(/\d+$/))||void 0===M?void 0:M[0])||"1";e.loopCode.push("    // Oscillator ".concat(o," gate from ADSR ").concat(D)),e.loopCode.push("    osc".concat(o,"_gate = adsr").concat(D,"_output;"))}else if(L&&"GateGen"===L.type){var A,O=(null===(A=R.match(/\d+$/))||void 0===A?void 0:A[0])||"1";e.loopCode.push("    // Oscillator ".concat(o," gate from GateGen ").concat(O)),e.loopCode.push("    osc".concat(o,"_gate = gate").concat(O,"_output;"))}}var T=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"freq"===e.to.port});if(T){var B=T.from.id.split(":")[0],z=e.modules.find(function(e){return e.id===B});if(z&&"Scale"===z.type){var F,N=(null===(F=B.match(/\d+$/))||void 0===F?void 0:F[0])||"1";e.controlConnectionCode.push("    // Oscillator ".concat(o," frequency from Scale ").concat(N)),e.controlConnectionCode.push("    osc".concat(o,"_freq = scale").concat(N,"_output;"))}}var G=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"gain"===e.to.port});if(G){var q=G.from.id.split(":")[0],U=e.modules.find(function(e){return e.id===q});if(U&&"Pot"===U.type){var W=e.getPotReference(U.id);e.loopCode.push("    // Oscillator ".concat(o," gain from ").concat(U.id)),e.loopCode.push("    osc".concat(o,"_amplitude = ").concat(W,"_value; // 0-1 amplitude control"))}else if(U&&"ADSR"===U.type){var V,H=(null===(V=q.match(/\d+$/))||void 0===V?void 0:V[0])||"1";e.loopCode.push("    // Oscillator ".concat(o," gain from ADSR ").concat(H)),e.loopCode.push("    osc".concat(o,"_amplitude = adsr").concat(H,"_output;"))}}var j=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"wave"===e.to.port});if(j){var K=j.from.id.split(":")[0],$=e.modules.find(function(e){return e.id===K});if($&&"Pot"===$.type){var Y=e.getPotReference($.id);e.loopCode.push("    // Oscillator ".concat(o," waveform from ").concat($.id)),e.loopCode.push(e.generateBankAwareAssignment($.id,"osc".concat(o,"_waveform = (int)(").concat(Y,"_value * 3.99);")))}}var X=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"morph"===e.to.port});if(X){var Z=X.from.id.split(":")[0],Q=e.modules.find(function(e){return e.id===Z});if(Q&&"Pot"===Q.type){var J=e.getPotReference(Q.id);e.loopCode.push("    // Oscillator ".concat(o," morph from ").concat(Q.id)),e.loopCode.push("    osc".concat(o,"_morph = ").concat(J,"_value; // 0-1 wave morphing"))}}break;case"NoiseGenerator":case"Noise":var ee=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"gate"===e.to.port});if(ee){var ne=ee.from.id.split(":")[0],te=e.modules.find(function(e){return e.id===ne});if(te&&"LEDButton"===te.type){var ae=te.params.index||1;e.loopCode.push("    // NoiseGenerator ".concat(o," gate from Button ").concat(ae)),e.loopCode.push(e.generateBankAwareButtonAssignment(te.id,"noise".concat(o,"_gate = btn").concat(ae,"_gate ? 1.0 : 0.0;")))}else if(te&&"ADSR"===te.type){var oe,re=(null===(oe=ne.match(/\d+$/))||void 0===oe?void 0:oe[0])||"1";e.loopCode.push("    // NoiseGenerator ".concat(o," gate from ADSR ").concat(re)),e.loopCode.push("    noise".concat(o,"_gate = adsr").concat(re,"_output;"))}else if(te&&"GateGen"===te.type){var ce,ie=(null===(ce=ne.match(/\d+$/))||void 0===ce?void 0:ce[0])||"1";e.loopCode.push("    // NoiseGenerator ".concat(o," gate from GateGen ").concat(ie)),e.loopCode.push("    noise".concat(o,"_gate = gate").concat(ie,"_output;"))}}var le=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"gain"===e.to.port});if(le){var se=le.from.id.split(":")[0],ue=e.modules.find(function(e){return e.id===se});if(ue&&"Pot"===ue.type){var de=e.getPotReference(ue.id);e.loopCode.push("    // NoiseGenerator ".concat(o," gain from ").concat(ue.id)),e.loopCode.push(e.generateBankAwareAssignment(ue.id,"noise".concat(o,"_gain = ").concat(de,"_value;")))}}var pe=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"type"===e.to.port});if(pe){var fe=pe.from.id.split(":")[0],me=e.modules.find(function(e){return e.id===fe});if(me&&"Pot"===me.type){var _e=e.getPotReference(me.id);e.loopCode.push("    // NoiseGenerator ".concat(o," type from ").concat(me.id)),e.loopCode.push(e.generateBankAwareAssignment(me.id,"noise".concat(o,"_type = (int)(").concat(_e,"_value * 3.99);")))}}var ge=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"morph"===e.to.port});if(ge){var he=ge.from.id.split(":")[0],ve=e.modules.find(function(e){return e.id===he});if(ve&&"Pot"===ve.type){var be=e.getPotReference(ve.id);e.loopCode.push("    // NoiseGenerator ".concat(o," morph from ").concat(ve.id)),e.loopCode.push(e.generateBankAwareAssignment(ve.id,"noise".concat(o,"_morph = ").concat(be,"_value;")))}}break;case"StereoMixer4":var ye=n.params.start_bank||2,ke=ye+1;e.loopCode.push("\n    // StereoMixer4 ".concat(o," banking controls (Banks ").concat(ye," and ").concat(ke,")\n\n    // BANK ").concat(ye,": Volume/Mute controls\n    if (currentBank == ").concat(ye,") {\n        // Detect bank change for soft takeover\n        if (stereoMixer4_").concat(o,"_last_bank == -1) {\n            // First time entering ANY bank - initialize to physical position immediately (like manual pots)\n            for (int i = 0; i < 4; i++) {\n                stereoMixer4_").concat(o,"_vol_physical[i] = analogRead(4 + i) / 4095.0;\n                stereoMixer4_").concat(o,"_smoothed_pot[i] = stereoMixer4_").concat(o,"_vol_physical[i];\n                stereoMixer4_").concat(o,"_vol_target[i] = stereoMixer4_").concat(o,"_vol_physical[i];\n                stereoMixer4_").concat(o,"_vol_saved[i] = stereoMixer4_").concat(o,"_vol_physical[i];\n                stereoMixer4_").concat(o,"_vol_taken_over[i] = true; // Taken over immediately on first entry\n            }\n            stereoMixer4_").concat(o,"_last_bank = 0;\n        } else if (stereoMixer4_").concat(o,"_last_bank != 0) {\n            // Switching FROM pan bank TO volume bank - load saved volume values as targets\n            for (int i = 0; i < 4; i++) {\n                stereoMixer4_").concat(o,"_vol_target[i] = stereoMixer4_").concat(o,"_vol_saved[i]; // Load saved value as target\n                stereoMixer4_").concat(o,"_vol_taken_over[i] = false; // Require soft takeover\n            }\n            stereoMixer4_").concat(o,"_last_bank = 0;\n        }\n\n        // Read and smooth hardware pots to reduce noise\n        float pot_raw[4];\n        pot_raw[0] = analogRead(4) / 4095.0; // GPIO4 - POT1\n        pot_raw[1] = analogRead(5) / 4095.0; // GPIO5 - POT2\n        pot_raw[2] = analogRead(6) / 4095.0; // GPIO6 - POT3\n        pot_raw[3] = analogRead(7) / 4095.0; // GPIO7 - POT4\n\n        // Apply exponential smoothing and soft takeover\n        for (int i = 0; i < 4; i++) {\n            // Smooth physical pot reading\n            stereoMixer4_").concat(o,"_vol_physical[i] = stereoMixer4_").concat(o,"_vol_physical[i] * stereoMixer4_").concat(o,"_pot_smooth_factor +\n                                                           pot_raw[i] * (1.0 - stereoMixer4_").concat(o,"_pot_smooth_factor);\n\n            // Soft takeover logic\n            if (!stereoMixer4_").concat(o,"_vol_taken_over[i]) {\n                // Check if physical pot has crossed within threshold of target\n                float diff = fabsf(stereoMixer4_").concat(o,"_vol_physical[i] - stereoMixer4_").concat(o,"_vol_target[i]);\n                if (diff < 0.05 ||\n                    (stereoMixer4_").concat(o,"_vol_physical[i] < stereoMixer4_").concat(o,"_vol_target[i] && stereoMixer4_").concat(o,"_vol_physical[i] > pot_raw[i]) ||\n                    (stereoMixer4_").concat(o,"_vol_physical[i] > stereoMixer4_").concat(o,"_vol_target[i] && stereoMixer4_").concat(o,"_vol_physical[i] < pot_raw[i])) {\n                    // Pot has crossed the target value - TAKEOVER\n                    stereoMixer4_").concat(o,"_vol_taken_over[i] = true;\n                } else {\n                    // Not taken over - maintain target value\n                    stereoMixer4_").concat(o,"_smoothed_pot[i] = stereoMixer4_").concat(o,"_vol_target[i];\n                    continue; // Skip to next channel\n                }\n            }\n\n            // Taken over - follow physical pot\n            stereoMixer4_").concat(o,"_smoothed_pot[i] = stereoMixer4_").concat(o,"_vol_physical[i];\n        }\n\n        // Apply pot values to gains (pots control channel volumes)\n        stereoMixer4_").concat(o,"_gain1 = stereoMixer4_").concat(o,"_smoothed_pot[0];\n        stereoMixer4_").concat(o,"_gain2 = stereoMixer4_").concat(o,"_smoothed_pot[1];\n        stereoMixer4_").concat(o,"_gain3 = stereoMixer4_").concat(o,"_smoothed_pot[2];\n        stereoMixer4_").concat(o,"_gain4 = stereoMixer4_").concat(o,"_smoothed_pot[3];\n\n        // Save current gain values for this bank (for recall when switching back)\n        for (int i = 0; i < 4; i++) {\n            stereoMixer4_").concat(o,"_vol_saved[i] = stereoMixer4_").concat(o,"_smoothed_pot[i];\n        }\n\n        // Rate-limited MCP23017 I2C read to prevent audio interference\n        static unsigned long lastMcpRead_mixer").concat(o," = 0;\n        static bool btn_current_mixer").concat(o,"[4] = {false, false, false, false};\n        if (currentTime - lastMcpRead_mixer").concat(o," > 20) { // Read every 20ms to avoid I2S interference\n            lastMcpRead_mixer").concat(o," = currentTime;\n            uint16_t mcpInputs = mcp.readGPIOAB();\n            btn_current_mixer").concat(o,"[0] = !(mcpInputs & (1 << 2)); // GPA2 - Btn1 - active low\n            btn_current_mixer").concat(o,"[1] = !(mcpInputs & (1 << 1)); // GPA1 - Btn2 - active low\n            btn_current_mixer").concat(o,"[2] = !(mcpInputs & (1 << 0)); // GPA0 - Btn3 - active low\n            btn_current_mixer").concat(o,"[3] = !(mcpInputs & (1 << 3)); // GPA3 - Btn4 - active low\n        }\n\n        // Button mute toggles (debounced)\n        for (int i = 0; i < 4; i++) {\n            if (btn_current_mixer").concat(o,"[i] && !stereoMixer4_").concat(o,"_btn_last[i]) {\n                // BANK 1: Button press toggles mute\n                stereoMixer4_").concat(o,"_mute[i] = !stereoMixer4_").concat(o,"_mute[i];\n            }\n            stereoMixer4_").concat(o,"_btn_last[i] = btn_current_mixer").concat(o,"[i];\n        }\n    } // End Bank ").concat(ye,"\n\n    // BANK ").concat(ke,": Pan/Solo controls\n    if (currentBank == ").concat(ke,") {\n        // Detect bank change for soft takeover\n        if (stereoMixer4_").concat(o,"_last_bank == -1) {\n            // First time entering ANY bank - initialize to physical position immediately (like manual pots)\n            for (int i = 0; i < 4; i++) {\n                stereoMixer4_").concat(o,"_pan_physical[i] = analogRead(4 + i) / 4095.0;\n                stereoMixer4_").concat(o,"_smoothed_pan[i] = stereoMixer4_").concat(o,"_pan_physical[i];\n                stereoMixer4_").concat(o,"_pan_target[i] = stereoMixer4_").concat(o,"_pan_physical[i];\n                stereoMixer4_").concat(o,"_pan_saved[i] = stereoMixer4_").concat(o,"_pan_physical[i];\n                stereoMixer4_").concat(o,"_pan_taken_over[i] = true; // Taken over immediately on first entry\n            }\n            stereoMixer4_").concat(o,"_last_bank = 1;\n        } else if (stereoMixer4_").concat(o,"_last_bank != 1) {\n            // Switching FROM volume bank TO pan bank - load saved pan values as targets\n            for (int i = 0; i < 4; i++) {\n                stereoMixer4_").concat(o,"_pan_target[i] = stereoMixer4_").concat(o,"_pan_saved[i]; // Load saved value as target\n                stereoMixer4_").concat(o,"_pan_taken_over[i] = false; // Require soft takeover\n            }\n            stereoMixer4_").concat(o,"_last_bank = 1;\n        }\n\n        // Read and smooth hardware pots for pan control\n        float pot_raw[4];\n        pot_raw[0] = analogRead(4) / 4095.0; // GPIO4 - POT1\n        pot_raw[1] = analogRead(5) / 4095.0; // GPIO5 - POT2\n        pot_raw[2] = analogRead(6) / 4095.0; // GPIO6 - POT3\n        pot_raw[3] = analogRead(7) / 4095.0; // GPIO7 - POT4\n\n        // Apply exponential smoothing and soft takeover\n        for (int i = 0; i < 4; i++) {\n            // Smooth physical pot reading\n            stereoMixer4_").concat(o,"_pan_physical[i] = stereoMixer4_").concat(o,"_pan_physical[i] * stereoMixer4_").concat(o,"_pot_smooth_factor +\n                                                          pot_raw[i] * (1.0 - stereoMixer4_").concat(o,"_pot_smooth_factor);\n\n            // Soft takeover logic\n            if (!stereoMixer4_").concat(o,"_pan_taken_over[i]) {\n                // Check if physical pot has crossed within threshold of target\n                float diff = fabsf(stereoMixer4_").concat(o,"_pan_physical[i] - stereoMixer4_").concat(o,"_pan_target[i]);\n                if (diff < 0.05 ||\n                    (stereoMixer4_").concat(o,"_pan_physical[i] < stereoMixer4_").concat(o,"_pan_target[i] && stereoMixer4_").concat(o,"_pan_physical[i] > pot_raw[i]) ||\n                    (stereoMixer4_").concat(o,"_pan_physical[i] > stereoMixer4_").concat(o,"_pan_target[i] && stereoMixer4_").concat(o,"_pan_physical[i] < pot_raw[i])) {\n                    // Pot has crossed the target value - TAKEOVER\n                    stereoMixer4_").concat(o,"_pan_taken_over[i] = true;\n                } else {\n                    // Not taken over - maintain target value\n                    stereoMixer4_").concat(o,"_smoothed_pan[i] = stereoMixer4_").concat(o,"_pan_target[i];\n                    continue; // Skip to next channel\n                }\n            }\n\n            // Taken over - follow physical pot\n            stereoMixer4_").concat(o,"_smoothed_pan[i] = stereoMixer4_").concat(o,"_pan_physical[i];\n        }\n\n        // Apply pot values to pan controls\n        stereoMixer4_").concat(o,"_pan[0] = stereoMixer4_").concat(o,"_smoothed_pan[0];\n        stereoMixer4_").concat(o,"_pan[1] = stereoMixer4_").concat(o,"_smoothed_pan[1];\n        stereoMixer4_").concat(o,"_pan[2] = stereoMixer4_").concat(o,"_smoothed_pan[2];\n        stereoMixer4_").concat(o,"_pan[3] = stereoMixer4_").concat(o,"_smoothed_pan[3];\n\n        // Save current pan values for this bank (for recall when switching back)\n        for (int i = 0; i < 4; i++) {\n            stereoMixer4_").concat(o,"_pan_saved[i] = stereoMixer4_").concat(o,"_smoothed_pan[i];\n        }\n\n        // Pre-calculate pan coefficients (equal-power panning law)\n        // Calculate at control rate (100Hz) to avoid expensive cos/sin in audio loop (44.1kHz)\n        for (int ch = 0; ch < 4; ch++) {\n            float panPos = stereoMixer4_").concat(o,"_pan[ch];\n            stereoMixer4_").concat(o,"_panL[ch] = cos(panPos * 1.5708); // 0.0=1.0, 0.5=0.707, 1.0=0.0\n            stereoMixer4_").concat(o,"_panR[ch] = sin(panPos * 1.5708); // 0.0=0.0, 0.5=0.707, 1.0=1.0\n        }\n\n        // Rate-limited MCP23017 I2C read to prevent audio interference\n        static unsigned long lastMcpRead_panmixer").concat(o," = 0;\n        static bool btn_current_panmixer").concat(o,"[4] = {false, false, false, false};\n        if (currentTime - lastMcpRead_panmixer").concat(o," > 20) { // Read every 20ms to avoid I2S interference\n            lastMcpRead_panmixer").concat(o," = currentTime;\n            uint16_t mcpInputs = mcp.readGPIOAB();\n            btn_current_panmixer").concat(o,"[0] = !(mcpInputs & (1 << 2)); // GPA2 - Btn1 - active low\n            btn_current_panmixer").concat(o,"[1] = !(mcpInputs & (1 << 1)); // GPA1 - Btn2 - active low\n            btn_current_panmixer").concat(o,"[2] = !(mcpInputs & (1 << 0)); // GPA0 - Btn3 - active low\n            btn_current_panmixer").concat(o,"[3] = !(mcpInputs & (1 << 3)); // GPA3 - Btn4 - active low\n        }\n\n        // SOLO MODE: Button press toggles solo on that channel\n        for (int i = 0; i < 4; i++) {\n            if (btn_current_panmixer").concat(o,"[i] && !stereoMixer4_").concat(o,"_btn_last[i]) {\n                // Toggle solo: if already soloed, turn off; otherwise solo this channel\n                if (stereoMixer4_").concat(o,"_solo_channel == (i + 1)) {\n                    stereoMixer4_").concat(o,"_solo_channel = 0; // Turn off solo\n                } else {\n                    stereoMixer4_").concat(o,"_solo_channel = i + 1; // Solo this channel (1-4)\n                }\n            }\n            stereoMixer4_").concat(o,"_btn_last[i] = btn_current_panmixer").concat(o,"[i];\n        }\n    } // End Bank ").concat(ke,"\n                    ")),["g1","g2","g3","g4"].forEach(function(t,a){var r=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&e.to.port===t});if(r){var c=r.from.id.split(":")[0],i=e.modules.find(function(e){return e.id===c});if(i&&"Pot"===i.type){var l=e.getPotReference(i.id);e.loopCode.push("    // StereoMixer4 ".concat(o," ").concat(t," from ").concat(i.id)),e.loopCode.push(e.generateBankAwareAssignment(i.id,"stereoMixer4_".concat(o,"_gain").concat(a+1," = ").concat(l,"_value;")))}}});break;case"Clock":var Se=n.params.bank||0,xe=n.params.use_outputs_5_8||!1,Ee=Se+1;e.loopCode.push("\n    // Clock ".concat(o," banking controls (Bank ").concat(Se).concat(xe?" and ".concat(Ee):"",")\n\n    // Discrete musical rate values (16, 12, 8, 6, 4, 3, 2, 1, 2, 3, 4, 6, 8, 12, 16)\n    static const float clock").concat(o,"_rate_values[15] = {\n        0.0625, 0.08333, 0.125, 0.16667, 0.25, 0.33333, 0.5, // Divisions (16 to 2)\n        1.0,                                                    // Center (1)\n        2.0, 3.0, 4.0, 6.0, 8.0, 12.0, 16.0                   // Multiplications (2 to 16)\n    };\n\n    // BANK ").concat(Se,": Outputs 1-4 (pot=rate, button=fill) with SOFT TAKEOVER\n    if (currentBank == ").concat(Se,") {\n        // Detect bank change for soft takeover\n        if (clock").concat(o,"_last_bank == -1) {\n            // First time entering Clock bank - initialize to physical position immediately\n            for (int i = 0; i < 4; i++) {\n                float pot_raw = analogRead(4 + i) / 4095.0;\n                clock").concat(o,"_rate_physical[i] = pot_raw;\n\n                // Map to discrete rate\n                int rateIndex = (int)(pot_raw * 14.999);\n                if (rateIndex < 0) rateIndex = 0;\n                if (rateIndex > 14) rateIndex = 14;\n                float rate = clock").concat(o,"_rate_values[rateIndex];\n\n                clock").concat(o,"_rate_target[i] = rate;\n                clock").concat(o,"_rate_saved[i] = rate;\n                clock").concat(o,"_rate_taken_over[i] = true; // Taken over immediately on first entry\n            }\n            clock").concat(o,"_last_bank = ").concat(Se,";\n        } else if (clock").concat(o,"_last_bank != ").concat(Se,") {\n            // Switching FROM different bank TO Clock bank - load saved rates as targets\n            for (int i = 0; i < 4; i++) {\n                clock").concat(o,"_rate_target[i] = clock").concat(o,"_rate_saved[i]; // Load saved value as target\n                clock").concat(o,"_rate_taken_over[i] = false; // Require soft takeover\n            }\n            clock").concat(o,"_last_bank = ").concat(Se,";\n        }\n\n        // Read and smooth hardware pots to reduce noise\n        float pot_raw[4];\n        pot_raw[0] = analogRead(4) / 4095.0; // GPIO4 - POT1\n        pot_raw[1] = analogRead(5) / 4095.0; // GPIO5 - POT2\n        pot_raw[2] = analogRead(6) / 4095.0; // GPIO6 - POT3\n        pot_raw[3] = analogRead(7) / 4095.0; // GPIO7 - POT4\n\n        // Apply exponential smoothing and soft takeover\n        const float pot_smooth_factor = 0.8; // Smoothing factor (0.8 = smooth, 0.0 = instant)\n        const float takeover_threshold = 0.05; // 5% threshold for soft takeover\n\n        for (int i = 0; i < 4; i++) {\n            // Smooth physical pot reading\n            clock").concat(o,"_rate_physical[i] = clock").concat(o,"_rate_physical[i] * pot_smooth_factor +\n                                                           pot_raw[i] * (1.0 - pot_smooth_factor);\n\n            // Map to discrete rate\n            int rateIndex = (int)(clock").concat(o,"_rate_physical[i] * 14.999);\n            if (rateIndex < 0) rateIndex = 0;\n            if (rateIndex > 14) rateIndex = 14;\n            float physical_rate = clock").concat(o,"_rate_values[rateIndex];\n\n            // Soft takeover check - has pot crossed within threshold of target?\n            if (!clock").concat(o,"_rate_taken_over[i]) {\n                // Check if physical rate is within threshold of target rate\n                float rate_diff = fabsf(physical_rate - clock").concat(o,"_rate_target[i]);\n                if (rate_diff <= takeover_threshold ||\n                    (physical_rate < clock").concat(o,"_rate_target[i] && clock").concat(o,"_rate_physical[i] > pot_raw[i]) ||\n                    (physical_rate > clock").concat(o,"_rate_target[i] && clock").concat(o,"_rate_physical[i] < pot_raw[i])) {\n                    // Pot has crossed the target value - TAKEOVER\n                    clock").concat(o,"_rate_taken_over[i] = true;\n                }\n            }\n\n            // Apply rate based on takeover state\n            float final_rate;\n            if (clock").concat(o,"_rate_taken_over[i]) {\n                // Pot has control - use physical position\n                final_rate = physical_rate;\n            } else {\n                // Waiting for takeover - maintain target value\n                final_rate = clock").concat(o,"_rate_target[i];\n            }\n\n            // Apply rate and store pot value (for probability attenuation during fill)\n            switch(i) {\n                case 0:\n                    clock").concat(o,"_rate1 = final_rate;\n                    clock").concat(o,"_pot_value1 = clock").concat(o,"_rate_physical[i];\n                    clock").concat(o,"_rate_saved[0] = final_rate; // Save for recall\n                    break;\n                case 1:\n                    clock").concat(o,"_rate2 = final_rate;\n                    clock").concat(o,"_pot_value2 = clock").concat(o,"_rate_physical[i];\n                    clock").concat(o,"_rate_saved[1] = final_rate;\n                    break;\n                case 2:\n                    clock").concat(o,"_rate3 = final_rate;\n                    clock").concat(o,"_pot_value3 = clock").concat(o,"_rate_physical[i];\n                    clock").concat(o,"_rate_saved[2] = final_rate;\n                    break;\n                case 3:\n                    clock").concat(o,"_rate4 = final_rate;\n                    clock").concat(o,"_pot_value4 = clock").concat(o,"_rate_physical[i];\n                    clock").concat(o,"_rate_saved[3] = final_rate;\n                    break;\n            }\n        }\n\n        // Read buttons for fill (momentary)\n        static unsigned long lastBtnRead_clock").concat(o,"_bank1 = 0;\n        static bool btn_current_clock").concat(o,"_bank1[4] = {false, false, false, false};\n        if (millis() - lastBtnRead_clock").concat(o,"_bank1 > 20) { // Rate-limited\n            lastBtnRead_clock").concat(o,"_bank1 = millis();\n            uint16_t mcpInputs = mcp.readGPIOAB();\n            btn_current_clock").concat(o,"_bank1[0] = !(mcpInputs & (1 << 2)); // GPA2 - Btn1\n            btn_current_clock").concat(o,"_bank1[1] = !(mcpInputs & (1 << 1)); // GPA1 - Btn2\n            btn_current_clock").concat(o,"_bank1[2] = !(mcpInputs & (1 << 0)); // GPA0 - Btn3\n            btn_current_clock").concat(o,"_bank1[3] = !(mcpInputs & (1 << 3)); // GPA3 - Btn4\n        }\n\n        // Update fill states (momentary - active while held)\n        clock").concat(o,"_fill1 = btn_current_clock").concat(o,"_bank1[0];\n        clock").concat(o,"_fill2 = btn_current_clock").concat(o,"_bank1[1];\n        clock").concat(o,"_fill3 = btn_current_clock").concat(o,"_bank1[2];\n        clock").concat(o,"_fill4 = btn_current_clock").concat(o,'_bank1[3];\n\n        // While fill button held, pot value also attenuates probability (expressive control)\n        // This allows "thinning out" the fill rhythmically\n        // Note: pot value is 0.0-1.0, directly usable as probability multiplier\n    }\n    ').concat(xe?"\n    // BANK ".concat(Ee,": Outputs 5-8 (pot=rate, button=fill)\n    if (currentBank == ").concat(Ee,") {\n        // Read hardware pots (GPIO4-7)\n        float clock").concat(o,"_pot_raw[4];\n        clock").concat(o,"_pot_raw[0] = analogRead(4) / 4095.0; // POT1\n        clock").concat(o,"_pot_raw[1] = analogRead(5) / 4095.0; // POT2\n        clock").concat(o,"_pot_raw[2] = analogRead(6) / 4095.0; // POT3\n        clock").concat(o,"_pot_raw[3] = analogRead(7) / 4095.0; // POT4\n\n        // Map pot values to discrete musical rate values\n        for (int i = 0; i < 4; i++) {\n            float sliderValue = clock").concat(o,"_pot_raw[i];\n\n            // Map slider (0.0-1.0) to discrete rate index (0-14)\n            int rateIndex = (int)(sliderValue * 14.999); // 0-14 range\n            if (rateIndex < 0) rateIndex = 0;\n            if (rateIndex > 14) rateIndex = 14;\n            float rate = clock").concat(o,"_rate_values[rateIndex];\n\n            // Apply rate and store raw pot value for outputs 5-8\n            switch(i) {\n                case 0:\n                    clock").concat(o,"_rate5 = rate;\n                    clock").concat(o,"_pot_value5 = sliderValue;\n                    break;\n                case 1:\n                    clock").concat(o,"_rate6 = rate;\n                    clock").concat(o,"_pot_value6 = sliderValue;\n                    break;\n                case 2:\n                    clock").concat(o,"_rate7 = rate;\n                    clock").concat(o,"_pot_value7 = sliderValue;\n                    break;\n                case 3:\n                    clock").concat(o,"_rate8 = rate;\n                    clock").concat(o,"_pot_value8 = sliderValue;\n                    break;\n            }\n        }\n\n        // Read buttons for fill\n        static unsigned long lastBtnRead_clock").concat(o,"_bank2 = 0;\n        static bool btn_current_clock").concat(o,"_bank2[4] = {false, false, false, false};\n        if (millis() - lastBtnRead_clock").concat(o,"_bank2 > 20) {\n            lastBtnRead_clock").concat(o,"_bank2 = millis();\n            uint16_t mcpInputs = mcp.readGPIOAB();\n            btn_current_clock").concat(o,"_bank2[0] = !(mcpInputs & (1 << 2));\n            btn_current_clock").concat(o,"_bank2[1] = !(mcpInputs & (1 << 1));\n            btn_current_clock").concat(o,"_bank2[2] = !(mcpInputs & (1 << 0));\n            btn_current_clock").concat(o,"_bank2[3] = !(mcpInputs & (1 << 3));\n        }\n\n        // Update fill states for outputs 5-8\n        clock").concat(o,"_fill5 = btn_current_clock").concat(o,"_bank2[0];\n        clock").concat(o,"_fill6 = btn_current_clock").concat(o,"_bank2[1];\n        clock").concat(o,"_fill7 = btn_current_clock").concat(o,"_bank2[2];\n        clock").concat(o,"_fill8 = btn_current_clock").concat(o,"_bank2[3];\n    }\n    "):"","\n                    "))}}),this.modules.forEach(function(n,t){if("KickDrum"===n.type){var a=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"gate"===e.to.port});if(a){var o,r=a.from.id.split(":")[0],c=e.modules.find(function(e){return e.id===r}),i=(null===(o=r.match(/\d+$/))||void 0===o?void 0:o[0])||"1";c&&"LEDButton"===c.type?e.loopCode.push("\n    // Kick Drum ".concat(t," trigger detection from LEDButton\n    if (btn").concat(i,"_pressed) {\n        // Start all envelopes for kick").concat(t,"\n        kick").concat(t,"_osc_amp_stage = 1;\n        kick").concat(t,"_osc_amp_time = 0.0;\n        kick").concat(t,"_osc_pitch_stage = 1;\n        kick").concat(t,"_osc_pitch_time = 0.0;\n        kick").concat(t,"_noise_amp_stage = 1;\n        kick").concat(t,'_noise_amp_time = 0.0;\n        Serial.println("KICK ').concat(t,' TRIGGERED!");\n        Serial.print("  Osc muted: ");\n        Serial.println(kick').concat(t,'_osc_mute ? "YES" : "NO");\n        Serial.print("  Noise muted: ");\n        Serial.println(kick').concat(t,'_noise_mute ? "YES" : "NO");\n        Serial.print("  Osc level: ");\n        Serial.println(kick').concat(t,'_osc_level);\n        Serial.print("  Noise level: ");\n        Serial.println(kick').concat(t,"_noise_level);\n    }\n                        ")):c&&"GateGen"===c.type&&e.loopCode.push("\n    // Kick Drum ".concat(t," trigger detection from Gate Generator\n    static bool kick").concat(t,"_lastGateState = false;\n    if (gate").concat(i,"_output > 0.5 && !kick").concat(t,"_lastGateState) {\n        // Rising edge trigger from Gate Generator\n        kick").concat(t,"_osc_amp_stage = 1;\n        kick").concat(t,"_osc_amp_time = 0.0;\n        kick").concat(t,"_osc_pitch_stage = 1;\n        kick").concat(t,"_osc_pitch_time = 0.0;\n        kick").concat(t,"_noise_amp_stage = 1;\n        kick").concat(t,'_noise_amp_time = 0.0;\n        Serial.println("KICK ').concat(t,' TRIGGERED BY GATE GENERATOR!");\n        Serial.print("  Gate signal: ");\n        Serial.println(gate').concat(i,'_output);\n        Serial.print("  Osc muted: ");\n        Serial.println(kick').concat(t,'_osc_mute ? "YES" : "NO");\n        Serial.print("  Noise muted: ");\n        Serial.println(kick').concat(t,'_noise_mute ? "YES" : "NO");\n    }\n    kick').concat(t,"_lastGateState = (gate").concat(i,"_output > 0.5);\n                        "))}}});var o=new Map;this.modules.forEach(function(e){if("Pot"===e.type){var n=e.params.index||1,t=e.params.bank||1,a=e.params.locked||!1;o.has(n)||o.set(n,[]),o.get(n).push({bank:t,locked:a})}}),this.modules.forEach(function(e){if("BPMLooper"===e.type)for(var n=e.params.start_bank||1,t=n+1,a=1;a<=4;a++)o.has(a)||o.set(a,[]),o.get(a).push({bank:n,locked:!1}),o.get(a).push({bank:t,locked:!1})}),o.forEach(function(n,t){var a,o=K.ANALOG_PINS[t-1]||K.ANALOG_PINS[0],r=n.map(function(e){return e.bank}).filter(function(e,n,t){return t.indexOf(e)===n}),c=n.some(function(e){return e.locked});a=c?"true":1===r.length?"currentBank == ".concat(r[0]):r.map(function(e){return"currentBank == ".concat(e)}).join(" || "),e.loopCode.push("\n    // Pot ".concat(t," (Physical ").concat(t,", Banks: ").concat(r.join(", ")).concat(c?" - LOCKED":"",") - SOFT TAKEOVER\n    static int pot").concat(t,"_last_bank = -1;\n    static float pot").concat(t,"_bank_values[6] = {0}; // Store value per bank (MAX_BANKS)\n    static float pot").concat(t,"_smoothed = 0.0; // Smoothed ADC reading to reduce jitter\n    int pot").concat(t,"_raw = analogRead(").concat(o,");\n    float pot").concat(t,"_raw_normalized = pot").concat(t,"_raw / 4095.0;\n\n    // Exponential smoothing filter (alpha=0.2) to reduce ESP32 ADC noise\n    pot").concat(t,"_smoothed = pot").concat(t,"_smoothed * 0.8 + pot").concat(t,"_raw_normalized * 0.2;\n    pot").concat(t,"_physical = pot").concat(t,"_smoothed; // Use smoothed value\n\n    if (").concat(a,") {\n        // Pot is active in current bank\n\n        // Check for first-time initialization or bank change\n        if (pot").concat(t,"_last_bank == -1) {\n            // First time entering any bank - initialize to physical position immediately\n            pot").concat(t,"_value = pot").concat(t,"_physical;\n            pot").concat(t,"_target = pot").concat(t,"_physical;\n            pot").concat(t,"_taken_over = true;\n            pot").concat(t,"_bank_values[currentBank - 1] = pot").concat(t,'_physical;\n            Serial.print("Pot').concat(t,' INITIAL in Bank ");\n            Serial.print(currentBank);\n            Serial.print(", Value: ");\n            Serial.println(pot').concat(t,"_physical);\n        } else if (pot").concat(t,"_last_bank != currentBank) {\n            // Bank just changed - save old bank's value, load new bank's target\n            pot").concat(t,"_bank_values[pot").concat(t,"_last_bank - 1] = pot").concat(t,"_value; // Save old bank value\n            pot").concat(t,"_target = pot").concat(t,"_bank_values[currentBank - 1]; // Load new bank's last value as target\n            pot").concat(t,"_taken_over = false;\n            pot").concat(t,'_last_bank_change = millis();\n            Serial.print("Pot').concat(t,' Bank Change: ");\n            Serial.print(pot').concat(t,'_last_bank);\n            Serial.print(" -> ");\n            Serial.print(currentBank);\n            Serial.print(", Target: ");\n            Serial.print(pot').concat(t,'_target);\n            Serial.print(", Physical: ");\n            Serial.println(pot').concat(t,"_physical);\n        }\n\n        // Soft takeover logic (only if not already taken over)\n        if (!pot").concat(t,"_taken_over) {\n            // Check if physical pot is close enough to target (within 5%)\n            float takeover_threshold = 0.05;\n            if (abs(pot").concat(t,"_physical - pot").concat(t,"_target) < takeover_threshold) {\n                pot").concat(t,'_taken_over = true;\n                Serial.print("Pot').concat(t,' TAKEOVER at physical=");\n                Serial.print(pot').concat(t,'_physical);\n                Serial.print(", target=");\n                Serial.println(pot').concat(t,"_target);\n            } else {\n                // Not taken over yet - maintain target value\n                pot").concat(t,"_value = pot").concat(t,"_target;\n            }\n        }\n\n        if (pot").concat(t,"_taken_over) {\n            // Pot has taken over - follow physical position\n            pot").concat(t,"_value = pot").concat(t,"_physical;\n        }\n\n        // Save current value to this bank's storage\n        pot").concat(t,"_bank_values[currentBank - 1] = pot").concat(t,"_value;\n        pot").concat(t,"_last_bank = currentBank;\n\n        // Debug: Print pot value periodically (disabled for cleaner serial output)\n        // static unsigned long pot").concat(t,"_lastDebug = 0;\n        // if (millis() - pot").concat(t,"_lastDebug > 1000) {\n        //     pot").concat(t,'_lastDebug = millis();\n        //     Serial.print("Pot').concat(t," (Banks: ").concat(r.join(","),') - Physical: ");\n        //     Serial.print(pot').concat(t,'_physical);\n        //     Serial.print(", Value: ");\n        //     Serial.print(pot').concat(t,'_value);\n        //     Serial.print(", TakenOver: ");\n        //     Serial.print(pot').concat(t,'_taken_over ? "YES" : "NO");\n        //     Serial.print(", CurrentBank: ");\n        //     Serial.println(currentBank);\n        // }\n    } else {\n        // Pot not in current bank - maintain last value and update bank tracking\n        pot').concat(t,"_last_bank = currentBank;\n        // pot").concat(t,"_value remains unchanged\n    }\n                    "))}),this.connections.forEach(function(n){var t=n.from.id.split(":")[0],a=n.to.id.split(":")[0],o=e.modules.find(function(e){return e.id===t}),r=e.modules.find(function(e){return e.id===a});if(o&&r&&("HarmonicSequencer"!==o.type||!n.from.port.includes("step"))){if(n.from&&n.to&&("value"===n.from.port||"pitch_hz"===n.from.port))if(o&&r&&"Pot"===o.type){var c,i=o.params.index||1,l=o.params.bank||1,s=o.params.locked||!1,u=(null===(c=a.match(/\d+$/))||void 0===c?void 0:c[0])||"1";if("Oscillator"===r.type&&"freq"===n.to.port)e.potConnectionCode.push("\n    // Oscillator ".concat(u," frequency from Pot").concat(i,"\n        if (").concat(s?"true":"currentBank == ".concat(l),") { osc").concat(u,"_freq = (pot").concat(i,"_value * 2000.0 + 20.0); } // Pot").concat(i," Bank ").concat(l,"\n                        "));else if("Filter"===r.type&&"cutoff_hz"===n.to.port)e.potConnectionCode.push("\n    // Filter ".concat(u," cutoff from Pot").concat(i," (logarithmic response)\n        if (").concat(s?"true":"currentBank == ".concat(l),") {\n            // Logarithmic frequency mapping: 20Hz to 20kHz (3 decades)\n            filter").concat(u,"_cutoff = 20.0 * pow(1000.0, pot").concat(i,"_value);\n        } // Pot").concat(i," Bank ").concat(l," (logarithmic 20Hz-20kHz)\n                        "));else if("LFO"===r.type&&"rate_hz"===n.to.port){var d,p,f=(null===(d=r.params)||void 0===d?void 0:d.rate_min_hz)||.01,m=(null===(p=r.params)||void 0===p?void 0:p.rate_max_hz)||40,_=m-f;e.potConnectionCode.push("\n    // LFO ".concat(u," rate from Pot").concat(i," (configurable range: ").concat(f,"-").concat(m," Hz)\n        if (").concat(s?"true":"currentBank == ".concat(l),") { lfo").concat(u,"_rate_hz = ").concat(f," + pot").concat(i,"_value * ").concat(_,"; } // Pot").concat(i," Bank ").concat(l,"\n                        "))}}else if(o&&r&&"HarmonicSequencer"===o.type&&"pitch_hz"===n.from.port){var g,h,v=(null===(g=t.match(/\d+$/))||void 0===g?void 0:g[0])||"1",b=(null===(h=a.match(/\d+$/))||void 0===h?void 0:h[0])||"1";"Oscillator"===r.type&&"freq"===n.to.port&&e.loopCode.push("\n    // Oscillator ".concat(b," frequency from HarmonicSequencer").concat(v," Hz output\n        osc").concat(b,"_freq = seq").concat(v,"_pitch_hz; // Direct Hz from HarmonicSequencer\n                        "))}if(n.from&&n.to&&"env"===n.from.port&&"pitch_cv"===n.to.port&&o&&r&&"ADSR"===o.type&&"Oscillator"===r.type){var y,k,S=(null===(y=t.match(/\d+$/))||void 0===y?void 0:y[0])||"1",x=(null===(k=a.match(/\d+$/))||void 0===k?void 0:k[0])||"1";e.controlConnectionCode.push("\n    // Oscillator ".concat(x," pitch modulation from ADSR ").concat(S,"\n        osc").concat(x,"_freq *= pow(2.0, (adsr").concat(S,"_output - 0.5) * (osc").concat(x,"_pitch_amount / 12.0)); // ADSR pitch CV (pitch_amount semitones, use negative for kick drop)\n                    "))}if(n.from&&n.to&&"press"===n.from.port&&"bypass"===n.to.port&&o&&r&&"LEDButton"===o.type&&"Distortion"===r.type){var E,P,w=(null===(E=t.match(/\d+$/))||void 0===E?void 0:E[0])||"1",C=(null===(P=a.match(/\d+$/))||void 0===P?void 0:P[0])||"1";e.controlConnectionCode.push("\n    // Distortion ".concat(C," bypass from Button ").concat(w,"\n        dist").concat(C,"_bypass = btn").concat(w,"_pressed ? 1.0 : 0.0;\n                    "))}if(n.from&&n.to&&"gate"===n.from.port&&"record_trigger"===n.to.port&&o&&r&&"LEDButton"===o.type&&"Automation"===r.type){var R,L=o.params.index||1,I=(null===(R=a.match(/\d+$/))||void 0===R?void 0:R[0])||"1";e.controlConnectionCode.push("\n    // Automation ".concat(I," record trigger from Button ").concat(L,"\n        automation").concat(I,"_record_trigger = btn").concat(L,"_gate;\n                    "))}if(n.from&&n.to&&("press"===n.from.port||"gate"===n.from.port)&&"mode_select"===n.to.port&&o&&r&&"Automation"===r.type){var M,D,A=(null===(M=t.match(/\d+$/))||void 0===M?void 0:M[0])||"1",O=(null===(D=a.match(/\d+$/))||void 0===D?void 0:D[0])||"1";if("Encoder"===o.type)e.controlConnectionCode.push("\n    // Automation ".concat(O," mode select from Encoder ").concat(A," button\n    automation").concat(O,"_mode_select = enc").concat(A,"_buttonPressed;\n                        "));else if("LEDButton"===o.type){var T=o.params.index||1;e.controlConnectionCode.push("\n    // Automation ".concat(O," mode select from Button ").concat(T,"\n    automation").concat(O,"_mode_select = btn").concat(T,"_gate;\n                        "))}}if(n.from&&n.to&&n.from.port&&"clock"===n.to.port&&o&&r&&"Clock"===o.type&&"Automation"===r.type){var B,z,F=(null===(B=t.match(/\d+$/))||void 0===B?void 0:B[0])||"1",N=(null===(z=a.match(/\d+$/))||void 0===z?void 0:z[0])||"1";e.controlConnectionCode.push("\n    // Automation ".concat(N," clock sync from Clock ").concat(F,"\n        automation").concat(N,"_clock_input = clock").concat(F,"_output").concat(n.from.port.replace("out","")," > 0.5 ? 1.0 : 0.0;\n                    "))}if(n.from&&n.to&&"preset_cv"===n.to.port&&r&&"Distortion"===r.type){var G,q,U=(null===(G=t.match(/\d+$/))||void 0===G?void 0:G[0])||"1",W=(null===(q=a.match(/\d+$/))||void 0===q?void 0:q[0])||"1";if("Pot"===o.type&&"value"===n.from.port)e.controlConnectionCode.push("\n    // Distortion ".concat(W," preset CV from Pot ").concat(U,"\n        dist").concat(W,"_preset_cv = pot").concat(U,"_value; // 0-1 maps to presets 0-5\n                        "));else if("ADSR"===o.type&&"env"===n.from.port)e.controlConnectionCode.push("\n    // Distortion ".concat(W," preset CV from ADSR ").concat(U,"\n        dist").concat(W,"_preset_cv = adsr").concat(U,"_output; // 0-1 maps to presets 0-5\n                        "));else if("Modulation"===o.type&&["lfo1","lfo2","lfo3","lfo4"].includes(n.from.port)){var V=n.from.port.replace("lfo","");e.controlConnectionCode.push("\n    // Distortion ".concat(W," preset CV from Modulation ").concat(U," LFO").concat(V,"\n        dist").concat(W,"_preset_cv = mod").concat(U,"_lfo").concat(V,"_output; // 0-1 maps to presets 0-5\n                        "))}else"HarmonicSequencer"===o.type&&"cv1"===n.from.port?e.controlConnectionCode.push("\n    // Distortion ".concat(W," preset CV from HarmonicSequencer ").concat(U,"\n        dist").concat(W,"_preset_cv = seq").concat(U,"_cv1; // 0-1 maps to presets 0-5\n                        ")):"LFO"===o.type&&"out"===n.from.port&&e.controlConnectionCode.push("\n    // Distortion ".concat(W," preset CV from LFO ").concat(U,"\n        dist").concat(W,"_preset_cv = lfo").concat(U,"_output; // 0-1 maps to presets 0-5\n                        "))}}});var r=this.modules.filter(function(e){return"Automation"===e.type});r.length>0&&r.forEach(function(n){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";e.controlConnectionCode.push("\n    // Automation ".concat(a," mode select from encoder button (built-in auto-wiring)\n    // Hold encoder button (>1s) + move pot to select playback mode (0=normal, 1=reverse, 2=2x, 3=0.5x, 4=pingpong)\n    automation").concat(a,"_mode_select = enc1_buttonLongPressed;\n                "))}),this.modularInstances.forEach(function(n,t){var a=e.modules.find(function(e){return e.id===n.moduleId});if(a&&"BPMLooper"===a.type)for(var o=a.params.start_bank||1,r=o+1,c=0;c<4;c++){var i=c+1;e.potConnectionCode.push("\n    // BPM Looper pot control - Bank ".concat(o," (volume/offset) and Bank ").concat(r," (randomization/pitch)\n    if (currentBank == ").concat(o,") {\n        // Bank 1: Volume or loop start offset (when encoder held)\n        ").concat(n.instanceName,".setPotValue(").concat(c,", pot").concat(i,"_value);\n    } else if (currentBank == ").concat(r,") {\n        // Bank 2: Randomization or pitch (when button held)\n        ").concat(n.instanceName,".setBank2PotValue(").concat(c,", pot").concat(i,"_value);\n    }"))}}),this.potConnectionCode.forEach(function(n){e.loopCode.push(n)}),this.controlConnectionCode.forEach(function(n){e.loopCode.push(n)}),this.modules.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";switch(n.type){case"Pot":case"Scale":break;case"ADSR":var r=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&("gate"===e.to.port||"trigger"===e.to.port)});e.loopCode.push("\n    // ADSR ".concat(o,"\n    float adsr").concat(o,"_currentTimescale = adsr").concat(o,"_timescale; // Default timescale\n    "));var c=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"attack_ms"===e.to.port}),i=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"decay_ms"===e.to.port}),l=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"sustain"===e.to.port}),s=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"release_ms"===e.to.port});if(c){var u=c.from.id.split(":")[0],d=e.modules.find(function(e){return e.id===u});if(d&&"Pot"===d.type){var p=e.getPotReference(d.id);e.loopCode.push("    adsr".concat(o,"_attack = 0.001 + ").concat(p,"_value * 1.999; // Attack 1ms to 2000ms (2s)"))}}if(i){var f=i.from.id.split(":")[0],m=e.modules.find(function(e){return e.id===f});if(m&&"Pot"===m.type){var _=e.getPotReference(m.id);e.loopCode.push("    adsr".concat(o,"_decay = 0.001 + ").concat(_,"_value * 2.999; // Decay 1ms to 3000ms (3s)"))}}if(l){var g=l.from.id.split(":")[0],h=e.modules.find(function(e){return e.id===g});if(h&&"Pot"===h.type){var v=e.getPotReference(h.id);e.loopCode.push("    adsr".concat(o,"_sustain = ").concat(v,"_value; // Sustain 0.0 to 1.0"))}}if(s){var b=s.from.id.split(":")[0],y=e.modules.find(function(e){return e.id===b});if(y&&"Pot"===y.type){var k=e.getPotReference(y.id);e.loopCode.push("    adsr".concat(o,"_release = 0.001 + ").concat(k,"_value * 4.999; // Release 1ms to 5000ms (5s)"))}}var S=e.connections.find(function(e){return e.to.id.includes("".concat(n.id,":"))&&"timescale"===e.to.port});if(S){var x,E=S.from.id.split(":")[0],P=e.modules.find(function(e){return e.id===E});if(null===(x=E.match(/\d+$/))||void 0===x||x[0],P&&"Pot"===P.type){var w=e.getPotReference(P.id);e.loopCode.push("    adsr".concat(o,"_currentTimescale = 0.1 + ").concat(w,"_value * 9.9; // Timescale from pot (0.1x to 10x)"))}}if(r){var C,R=r.from.id.split(":")[0],L=e.modules.find(function(e){return e.id===R}),I=(null===(C=R.match(/\d+$/))||void 0===C?void 0:C[0])||"1";if(L&&"LEDButton"===L.type){var M=L.params.index||1;e.loopCode.push("    adsr".concat(o,"_gate = btn").concat(M,"_state;"))}else L&&"GateGen"===L.type?e.loopCode.push("    adsr".concat(o,"_gate = gate").concat(I,"_output > 0.5; // Gate from GateGen")):L&&"GateIn"===L.type&&e.loopCode.push("    adsr".concat(o,"_gate = gatein").concat(I,"_trigger; // Trigger from Gate In"))}}}),this.loopCode.push("\n\n    // Control module processing (HarmonicSequencer, Scale, LFO) - runs on Core 0\n        "),this.controlChain.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";if("ADSR"!==n.type){if("HarmonicSequencer"===n.type){e.globalFunctions=e.globalFunctions||[];var r=e.controlModules.generateQuantizationFunction(n,o);r&&!e.globalFunctions.some(function(e){return e.includes("quantizePitch".concat(o))})&&e.globalFunctions.push(r);var c=e.controlModules.generateGlissandoFunction(n,o);c&&!e.globalFunctions.some(function(e){return e.includes("glissandoInterpolate".concat(o))})&&e.globalFunctions.push(c)}var i=e.controlModules.generateProcessingCode(n,o,e.connections);i&&(e.loopCode.push(i),"HarmonicSequencer"===n.type&&e.connections.forEach(function(n){var t=n.from.id.split(":")[0],a=n.to.id.split(":")[0],o=e.modules.find(function(e){return e.id===t}),r=e.modules.find(function(e){return e.id===a});if(o&&r&&"HarmonicSequencer"===o.type&&n.from.port.includes("step")){var c,i,l=(null===(c=t.match(/\d+$/))||void 0===c?void 0:c[0])||"1",s=(null===(i=a.match(/\d+$/))||void 0===i?void 0:i[0])||"1",u=n.from.port;u.includes("pitch")&&u.includes("_hz")&&"Oscillator"===r.type&&"freq"===n.to.port?e.loopCode.push("\n    // Oscillator ".concat(s," frequency from HarmonicSequencer").concat(l," ").concat(u,"\n        osc").concat(s,"_freq = seq").concat(l,"_").concat(u,"; // Direct Hz from HarmonicSequencer step\n                                ")):u.includes("gate")&&"ADSR"===r.type&&"gate"===n.to.port&&e.loopCode.push("\n    // ADSR ".concat(s," gate from HarmonicSequencer").concat(l," ").concat(u,"\n        adsr").concat(s,"_gate = (seq").concat(l,"_").concat(u," > 0.5); // Gate from HarmonicSequencer step\n                                "))}}))}}),this.modules.forEach(function(n,t){if("USBMIDIOut"===n.type){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1",r=e.hardwareModules.generateControlCode(n,o,e.connections);r&&e.loopCode.push(r)}}),this.loopCode.push("\n}\n        "),this.loopCode.push("\nvoid processAudio() {\n    // CPU load monitoring\n    static unsigned long processingStartMicros = 0;\n    static unsigned long lastCpuReportTime = 0;\n    static float maxCpuLoad = 0.0;\n    static float avgCpuLoad = 0.0;\n    static int cpuSampleCount = 0;\n\n    processingStartMicros = micros();\n    unsigned long currentTime = millis(); // Shared time for processAudio function\n\n    // Set control inputs for modular instances ONCE per buffer (not per sample)\n    "),this.modularInstances.forEach(function(n,t){var a=e.modules.find(function(n){return(n.id||"".concat(n.type).concat(e.modules.indexOf(n)))===t});if(a)if(console.log("Looking for connections to module: ".concat(a.id)),"Looper"===n.type)Object.entries({record:0,decay:1,reverse:2,speed:3}).forEach(function(t){var o=Re(t,2),r=o[0],c=o[1],i=e.connections.find(function(e){return e.to.id==="".concat(a.id,":").concat(r)});if(i){var l=e.modules.find(function(e){return e.id===i.from.id.split(":")[0]});if(l){var s,u=(null===(s=l.params)||void 0===s?void 0:s.index)||1;"LEDButton"===l.type?(e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(c,", btn").concat(u,"_state ? 1.0f : 0.0f);  // ").concat(r," button")),console.log("Generated setControl(".concat(c,") for ").concat(n.instanceName,".").concat(r," from btn").concat(u,"_state"))):"Pot"===l.type?(e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(c,", pot").concat(u,"_value);  // ").concat(r," pot")),console.log("Generated setControl(".concat(c,") for ").concat(n.instanceName,".").concat(r," from pot").concat(u,"_value"))):"LFO"===l.type&&(e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(c,", lfo").concat(u,"_output);  // ").concat(r," LFO")),console.log("Generated setControl(".concat(c,") for ").concat(n.instanceName,".").concat(r," from lfo").concat(u,"_output")))}}});else if("BPMLooper"===n.type){Object.entries({clock:0,slot1_trig:1,slot2_trig:2,slot3_trig:3,slot4_trig:4,slot1_pitch:5,slot2_pitch:6,slot3_pitch:7,slot4_pitch:8}).forEach(function(t){var o=Re(t,2),r=o[0],c=o[1],i=e.connections.find(function(e){return e.to.id==="".concat(a.id,":").concat(r)});if(i){var l=e.modules.find(function(e){return e.id===i.from.id.split(":")[0]});if(l){var s,u=(null===(s=l.params)||void 0===s?void 0:s.index)||1;"LEDButton"===l.type?e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(c,", btn").concat(u,"_state ? 1.0f : 0.0f);  // ").concat(r," button")):"Pot"===l.type?e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(c,", pot").concat(u,"_value);  // ").concat(r," pot")):"LFO"===l.type?e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(c,", lfo").concat(u,"_output);  // ").concat(r," LFO")):"Clock"===l.type&&e.loopCode.push("    ".concat(n.instanceName,".setControl(").concat(c,", clock").concat(u,"_output);  // ").concat(r," clock"))}}});for(var o=1;o<=4;o++)e.declaredButtons.has(o)||(e.declaredButtons.add(o),e.globalVariables.push("\n// Button ".concat(o," state (auto-declared for BPM Looper)\nbool btn").concat(o,"_state = false;\nbool btn").concat(o,"_lastState = false;\nbool btn").concat(o,"_pressed = false;\n                        ")));var r=a.params.start_bank||1,c=r+1;e.loopCode.push("\n    // BPMLooper ".concat(n.instanceName," - 2-Bank system (Banks ").concat(r,"-").concat(c,")\n    // Read button states from MCP23017 (rate-limited to avoid I2S interference)\n    {\n        static unsigned long lastBtnRead = 0;\n        if (millis() - lastBtnRead > 20) { // Read every 20ms\n            lastBtnRead = millis();\n            uint16_t mcpInputs = mcp.readGPIOAB();\n            btn1_state = !(mcpInputs & (1 << 2)); // GPA2 - active low (v1.0 mapping)\n            btn2_state = !(mcpInputs & (1 << 1)); // GPA1 - active low\n            btn3_state = !(mcpInputs & (1 << 0)); // GPA0 - active low\n            btn4_state = !(mcpInputs & (1 << 3)); // GPA3 - active low\n        }\n    }"));for(var i=0;i<4;i++){var l=i+1;e.loopCode.push("\n    // Button ".concat(l," routing\n    if (currentBank == ").concat(r,") {\n        // Bank 1: Record/play control\n        ").concat(n.instanceName,".setButtonState(").concat(i,", btn").concat(l,"_state ? 1.0f : 0.0f, encoderBtn);\n    } else if (currentBank == ").concat(c,") {\n        // Bank 2: Momentary pitch control toggle\n        ").concat(n.instanceName,".setBank2ButtonState(").concat(i,", btn").concat(l,"_state);\n    }"))}for(var s=1;s<=4;s++)if(!e.declaredPots.has(s)){e.declaredPots.add(s);var u=[4,5,6,7][s-1];e.globalVariables.push("\n// Pot ".concat(s," (auto-declared for BPM Looper)\nconst int pot").concat(s,"_pin = ").concat(u,";\nfloat pot").concat(s,"_value = 0.0;\nfloat pot").concat(s,"_physical = 0.0;\nfloat pot").concat(s,"_target = 0.0;\nbool pot").concat(s,"_taken_over = false;\nfloat pot").concat(s,"_last_bank_change = 0.0;\n                        "))}}else e.connections.forEach(function(t){if(console.log("Checking connection: ".concat(t.from.id,"  ").concat(t.to.id)),t.to.id.startsWith("".concat(a.id,":"))){var o=e.modules.find(function(e){return e.id===t.from.id.split(":")[0]});if(o&&"LEDButton"===o.type){var r=o.params.index||1,c="btn".concat(r,"_state");e.loopCode.push("    ".concat(n.instanceName,".setControl(0, ").concat(c," ? 1.0f : 0.0f);")),console.log("Generated setControl for ".concat(n.instanceName," with ").concat(c))}}})}),this.loopCode.push("\n    // Set control inputs for modular instances ONCE per buffer (not per sample)\n    "),this.audioChain.forEach(function(n,t){var a=e.modules.findIndex(function(e){return e.id===n.id});"SamplePlayer"===n.type&&(console.log("Processing Sample Player ".concat(n.id," connections (preprocessing)...")),e.generateSamplePlayerPreProcessing(n,a)),"DrumDesigner"===n.type&&(console.log("Processing DrumDesigner ".concat(n.id," body filter coefficients (preprocessing)...")),e.generateDrumDesignerPreProcessing(n,a))}),this.loopCode.push("\n        // ADSR envelope processing (buffer-rate timing on Core 1)\n        "),this.controlChain.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";if("ADSR"===n.type){var r=e.controlModules.generateProcessingCode(n,o,e.connections);r&&e.loopCode.push(r)}}),this.loopCode.push("\n".concat(this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)})?"\n    // Read I2S input buffer from PCM1802 ADC\n    size_t bytes_read = 0;\n    esp_err_t read_result = i2s_read(I2S_NUM_0, i2sInputBuffer, sizeof(i2sInputBuffer), &bytes_read, portMAX_DELAY);\n    if (read_result != ESP_OK || bytes_read == 0) {\n        // Clear input buffer on read failure\n        memset(i2sInputBuffer, 0, sizeof(i2sInputBuffer));\n    }\n":"","\n    for (int i = 0; i < BUFFER_SIZE; i++) {\n        // Clear buffers for this sample\n        leftBuffer[i] = 0.0;\n        rightBuffer[i] = 0.0;\n\n        // Interpolate ADSR envelopes within buffer to prevent zipper noise\n        float interpFactor = (float)i / (float)BUFFER_SIZE;")),this.modules.forEach(function(n){if("ADSR"===n.type){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";e.loopCode.push("\n        adsr".concat(a,"_output = adsr").concat(a,"_prevOutput + (adsr").concat(a,"_targetOutput - adsr").concat(a,"_prevOutput) * interpFactor;"))}}),this.loopCode.push("\n\n        // Audio processing chain\n        "),this.audioChain.forEach(function(n,t){var a,o=(null===(a=n.id.match(/\d+$/))||void 0===a?void 0:a[0])||"1";if(!["Scale","ADSR","LFO","Clock"].includes(n.type)&&!["CleanReverb","Delay","Filter","VCA","Distortion","AudioRecorder","I2SOut","StereoMixer4","Matrix2x2","Panner"].includes(n.type)){"Oscillator"===n.type&&console.log("Processing Oscillator ".concat(n.id," (").concat(o,") in audio loop"));var r=null;(r=e.audioModules.generateProcessingCode(n,o,e.connections))||(r=e.sampleModules.generateProcessingCode(n,o,e.connections))||(r=e.hardwareModules.generateProcessingCode(n,o,e.connections))?e.loopCode.push(r):(console.warn("No modular processor found for audio module: ".concat(n.type)),e.loopCode.push("        // TODO: Implement ".concat(n.type," in modular system")))}}),this.audioChain.forEach(function(n){if(["CleanReverb","Delay","Filter","VCA","Distortion","AudioRecorder"].includes(n.type)){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";"CleanReverb"===n.type?e.loopCode.push("        cleanreverb".concat(a,"_inputL = 0.0; cleanreverb").concat(a,"_inputR = 0.0; // Clear inputs")):"Delay"===n.type?e.loopCode.push("        delay".concat(a,"_inputL = 0.0; delay").concat(a,"_inputR = 0.0; // Clear inputs")):"VCA"===n.type?e.loopCode.push("        vca".concat(a,"_inputL = 0.0; vca").concat(a,"_inputR = 0.0; // Clear inputs")):"Filter"===n.type?e.loopCode.push("        filter".concat(a,"_inputL = 0.0; filter").concat(a,"_inputR = 0.0; // Clear inputs")):"Distortion"===n.type?e.loopCode.push("        dist".concat(a,"_inputL = 0.0; dist").concat(a,"_inputR = 0.0; // Clear inputs")):"AudioRecorder"===n.type&&e.loopCode.push("        // AudioRecorder".concat(a," - No input clearing needed (handled internally)"));var o=e.generateConnectionsToModule(n.id);o&&e.loopCode.push(o);var r=e.audioModules.generateProcessingCode(n,a,e.connections);r&&e.loopCode.push(r)}}),this.audioChain.forEach(function(n){if(["StereoMixer4","Matrix2x2","Panner"].includes(n.type)){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1";"StereoMixer4"===n.type&&(e.loopCode.push("        stereoMixer4_".concat(a,"_input1L = 0.0; stereoMixer4_").concat(a,"_input1R = 0.0; // Clear inputs")),e.loopCode.push("        stereoMixer4_".concat(a,"_input2L = 0.0; stereoMixer4_").concat(a,"_input2R = 0.0;")),e.loopCode.push("        stereoMixer4_".concat(a,"_input3L = 0.0; stereoMixer4_").concat(a,"_input3R = 0.0;")),e.loopCode.push("        stereoMixer4_".concat(a,"_input4L = 0.0; stereoMixer4_").concat(a,"_input4R = 0.0;")));var o=e.generateConnectionsToModule(n.id);o&&e.loopCode.push(o);var r=e.audioModules.generateProcessingCode(n,a,e.connections);r&&e.loopCode.push(r)}}),this.audioChain.forEach(function(n){if("I2SOut"===n.type||"PCM5102A Out"===n.type){var t,a=(null===(t=n.id.match(/\d+$/))||void 0===t?void 0:t[0])||"1",o=e.generateConnectionsToModule(n.id);o&&e.loopCode.push(o);var r=e.audioModules.generateProcessingCode(n,a,e.connections);r&&e.loopCode.push(r)}}),this.loopCode.push("\n        // Initialize buffers (only if no I2S module has written to them)\n        // Note: I2S modules write directly to buffers, other modules add to them\n        ");var c=this.modules.some(function(e){return"I2SOut"===e.type}),i=this.modules.find(function(e){return"I2SOut"===e.type});if(i&&!c){var l=this.connections.filter(function(e){return e.to.id==="".concat(i.id,":L")}),s=this.connections.filter(function(e){return e.to.id==="".concat(i.id,":R")});l.length>0&&l.forEach(function(n){var t=n.from.id.split(":")[0],a=e.modules.find(function(e){return e.id===t});if(a){var o,r=(null===(o=t.match(/\d+$/))||void 0===o?void 0:o[0])||"1";"KickDrum"===a.type?e.loopCode.push("        leftBuffer[i] += kick".concat(r,"_output;")):"Oscillator"===a.type?e.loopCode.push("        leftBuffer[i] += osc".concat(r,"_outputL;")):"Wavetable"===a.type?e.loopCode.push("        leftBuffer[i] += wavetable".concat(r,"_outputL;")):"VCA"===a.type?e.loopCode.push("        leftBuffer[i] += vca".concat(r,"_outputL;")):"GranularSynth"===a.type||"GranularPSRAM"===a.type||"GranularDense"===a.type?e.loopCode.push("        leftBuffer[i] += granular".concat(r,"_outputL;")):"SDPlayer"===a.type||"SamplePlayer"===a.type?e.loopCode.push("        leftBuffer[i] += sdPlayer".concat(r,"_outputL;")):"StereoMixer4"===a.type?e.loopCode.push("        leftBuffer[i] += stereoMixer4_".concat(r,"_outputL;")):"Filter"===a.type?e.loopCode.push("        leftBuffer[i] += filter".concat(r,"_outputL;")):"Delay"===a.type?e.loopCode.push("        leftBuffer[i] += delay".concat(r,"_outputL;")):"AudioMath"===a.type?e.loopCode.push("        leftBuffer[i] += audioMath".concat(r,"_output;")):"Panner"===a.type?e.loopCode.push("        leftBuffer[i] += panner".concat(r,"_outputL;")):"AdvancedLooper"===a.type?e.loopCode.push("        leftBuffer[i] += advancedLooper".concat(r,"_outputL;")):"SnareDrum"===a.type?e.loopCode.push("        leftBuffer[i] += snareDrum".concat(r,"_output;")):a.type}}),s.length>0&&s.forEach(function(n){var t=n.from.id.split(":")[0],a=e.modules.find(function(e){return e.id===t});if(a){var o,r=(null===(o=t.match(/\d+$/))||void 0===o?void 0:o[0])||"1";"KickDrum"===a.type?e.loopCode.push("        rightBuffer[i] += kick".concat(r,"_output;")):"Oscillator"===a.type?e.loopCode.push("        rightBuffer[i] += osc".concat(r,"_outputR;")):"Wavetable"===a.type?e.loopCode.push("        rightBuffer[i] += wavetable".concat(r,"_outputR;")):"VCA"===a.type?e.loopCode.push("        rightBuffer[i] += vca".concat(r,"_outputR;")):"GranularSynth"===a.type||"GranularPSRAM"===a.type||"GranularDense"===a.type?e.loopCode.push("        rightBuffer[i] += granular".concat(r,"_outputR;")):"SDPlayer"===a.type||"SamplePlayer"===a.type?e.loopCode.push("        rightBuffer[i] += sdPlayer".concat(r,"_outputR;")):"StereoMixer4"===a.type?e.loopCode.push("        rightBuffer[i] += stereoMixer4_".concat(r,"_outputR;")):"Filter"===a.type?e.loopCode.push("        rightBuffer[i] += filter".concat(r,"_outputR;")):"Delay"===a.type?e.loopCode.push("        rightBuffer[i] += delay".concat(r,"_outputR;")):"AudioMath"===a.type?e.loopCode.push("        rightBuffer[i] += audioMath".concat(r,"_output;")):"Panner"===a.type?e.loopCode.push("        rightBuffer[i] += panner".concat(r,"_outputR;")):"AdvancedLooper"===a.type?e.loopCode.push("        rightBuffer[i] += advancedLooper".concat(r,"_outputR;")):"SnareDrum"===a.type?e.loopCode.push("        rightBuffer[i] += snareDrum".concat(r,"_output;")):a.type}}),0===l.length&&0===s.length&&this.loopCode.push("\n        // DEBUG FALLBACK: No I2S connections found, but modules should be explicitly connected\n        // Fallback disabled to prevent double-adding signals\n        ")}else this.loopCode.push("\n        // DEBUG FALLBACK: No I2S module found - modules should be explicitly connected\n        // Fallback disabled to prevent double-adding signals\n        ");this.modularInstances.forEach(function(n,t){var a=e.modules.find(function(n){return(n.id||"".concat(n.type).concat(e.modules.indexOf(n)))===t});a&&(e.loopCode.push("\n        \n        // Process modular ".concat(n.type," instance ").concat(n.instanceName,"\n        ").concat(n.instanceName,"_inputL = 0.0f;\n        ").concat(n.instanceName,"_inputR = 0.0f;")),e.connections.forEach(function(t){if(t.to.id.startsWith("".concat(a.id,":"))){var o=e.modules.find(function(e){return e.id===t.from.id.split(":")[0]});if(o){var r,c=(null===(r=o.id.match(/\d+$/))||void 0===r?void 0:r[0])||"1";o.type.toLowerCase(),t.to.id.includes("inL")&&("Oscillator"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputL = osc").concat(c,"_outputL;")):"LineIn"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputL = linein").concat(c,"_outputL;")):"Piezo"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputL = piezo").concat(c,"_outputL;")):"Coil"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputL = coil").concat(c,"_outputL;")):"CleanReverb"!==o.type&&"Reverb"!==o.type||e.loopCode.push("        ".concat(n.instanceName,"_inputL = cleanreverb").concat(c,"_outputL;"))),t.to.id.includes("inR")&&("Oscillator"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputR = osc").concat(c,"_outputR;")):"LineIn"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputR = linein").concat(c,"_outputR;")):"Piezo"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputR = piezo").concat(c,"_outputR;")):"Coil"===o.type?e.loopCode.push("        ".concat(n.instanceName,"_inputR = coil").concat(c,"_outputR;")):"CleanReverb"!==o.type&&"Reverb"!==o.type||e.loopCode.push("        ".concat(n.instanceName,"_inputR = cleanreverb").concat(c,"_outputR;")))}}}),e.loopCode.push("        ".concat(n.instanceName,".process(").concat(n.instanceName,"_inputL, ").concat(n.instanceName,"_inputR);")),e.connections.forEach(function(t){if(t.from.id.startsWith("".concat(a.id,":"))){var o=e.modules.find(function(e){return e.id===t.to.id.split(":")[0]});o&&"I2SOut"===o.type&&(t.from.id.includes("outL")&&t.to.id.includes("L")&&e.loopCode.push("        leftBuffer[i] += ".concat(n.instanceName,".outL;")),t.from.id.includes("outR")&&t.to.id.includes("R")&&e.loopCode.push("        rightBuffer[i] += ".concat(n.instanceName,".outR;")))}}))}),this.loopCode.push('\n    }\n\n    // CPU load monitoring - calculate processing time\n    unsigned long processingTimeMicros = micros() - processingStartMicros;\n    float availableTimeMicros = (BUFFER_SIZE * 1000000.0) / SAMPLE_RATE; // Time available for this buffer\n    float cpuLoad = (processingTimeMicros / availableTimeMicros) * 100.0;\n\n    // Track statistics\n    if (cpuLoad > maxCpuLoad) maxCpuLoad = cpuLoad;\n    avgCpuLoad = (avgCpuLoad * cpuSampleCount + cpuLoad) / (cpuSampleCount + 1);\n    cpuSampleCount++;\n\n    // Print CPU load report every second\n    if (millis() - lastCpuReportTime > 1000) {\n        lastCpuReportTime = millis();\n\n        Serial.print("CPU Load - Current: ");\n        Serial.print(cpuLoad, 1);\n        Serial.print("%, Avg: ");\n        Serial.print(avgCpuLoad, 1);\n        Serial.print("%, Max: ");\n        Serial.print(maxCpuLoad, 1);\n        Serial.print("% (");\n        Serial.print(processingTimeMicros);\n        Serial.print("us / ");\n        Serial.print((int)availableTimeMicros);\n        Serial.print("us) @ ");\n        Serial.print(getCpuFrequencyMhz());\n        Serial.print("MHz");\n\n        if (cpuLoad > 90.0) {\n            Serial.print("  WARNING: CPU OVERLOAD!");\n        }\n        Serial.println();\n\n        // Debug: Print buffer contents periodically\n        float maxLeft = 0.0, maxRight = 0.0;\n        for (int i = 0; i < BUFFER_SIZE; i++) {\n            if (abs(leftBuffer[i]) > maxLeft) maxLeft = abs(leftBuffer[i]);\n            if (abs(rightBuffer[i]) > maxRight) maxRight = abs(rightBuffer[i]);\n        }\n        if (maxLeft > 0.0 || maxRight > 0.0) {\n            Serial.print("Audio buffer peaks - L: ");\n            Serial.print(maxLeft);\n            Serial.print(", R: ");\n            Serial.println(maxRight);\n        }\n\n        // Reset max for next period\n        maxCpuLoad = 0.0;\n        avgCpuLoad = 0.0;\n        cpuSampleCount = 0;\n    }\n}\n        ');var u=this.modules.some(function(e){return["LineIn","Piezo","Coil"].includes(e.type)});this.loopCode.push("\nvoid outputAudio() {\n    // Convert float samples to ".concat(u?"32":"16","-bit integers and interleave with clipping protection\n    for (int i = 0; i < BUFFER_SIZE; i++) {\n        // Clamp float values to [-1.0, 1.0] range to prevent harsh clipping\n        float leftSample = leftBuffer[i];\n        float rightSample = rightBuffer[i];\n        if (leftSample > 1.0) leftSample = 1.0;\n        if (leftSample < -1.0) leftSample = -1.0;\n        if (rightSample > 1.0) rightSample = 1.0;\n        if (rightSample < -1.0) rightSample = -1.0;\n\n").concat(u?"        // 32-bit output (24-bit in 32-bit slot for PCM5102A compatibility)\n        i2sBuffer[i * 2] = ((int32_t)(leftSample * 8388608.0f)) << 8;      // Left channel\n        i2sBuffer[i * 2 + 1] = ((int32_t)(rightSample * 8388608.0f)) << 8;  // Right channel":"        i2sBuffer[i * 2] = (int16_t)(leftSample * 16000.0);     // Left channel\n        i2sBuffer[i * 2 + 1] = (int16_t)(rightSample * 16000.0); // Right channel","\n    }\n\n    // Write to I2S\n    size_t bytesWritten;\n    i2s_write(I2S_NUM_0, i2sBuffer, BUFFER_SIZE * ").concat(u?"8":"4",", &bytesWritten, portMAX_DELAY);\n}\n        "))}},{key:"generateSamplePlayerPreProcessing",value:function(e,n){var t=this.connections.find(function(n){return n.to.id==="".concat(e.id,":trig")||n.to.id==="".concat(e.id,":gate")}),a=this.connections.find(function(n){return n.to.id==="".concat(e.id,":gain")}),o=this.connections.find(function(n){return n.to.id==="".concat(e.id,":file_index")||n.to.id==="".concat(e.id,":sample_select")}),r=this.connections.find(function(n){return n.to.id==="".concat(e.id,":pitch")}),c=this.connections.find(function(n){return n.to.id==="".concat(e.id,":pitch_env")}),i=this.connections.find(function(n){return n.to.id==="".concat(e.id,":start_pos")}),l=this.connections.find(function(n){return n.to.id==="".concat(e.id,":end_pos")});if(console.log("Sample Player ".concat(n," connection debug:")),console.log("- trigConnection: ".concat(t?"FOUND":"NOT FOUND")),console.log("- fileIndexConnection: ".concat(o?"FOUND":"NOT FOUND")),console.log("- samplePitchConnection: ".concat(r?"FOUND":"NOT FOUND")),console.log("- startPosConnection: ".concat(i?"FOUND":"NOT FOUND")),console.log("- endPosConnection: ".concat(l?"FOUND":"NOT FOUND")),console.log("Module ID: ".concat(e.id)),console.log("All connections to this module:"),this.connections.filter(function(n){return n.to.id.startsWith(e.id)}).forEach(function(e){console.log("  ".concat(e.from.id,"  ").concat(e.to.id))}),this.loopCode.push("\n    // Sample Player ".concat(n," - Pre-processing (trigger detection)\n    float sdPlayer").concat(n,"_trigger = 0.0;\n    float sdPlayer").concat(n,"_currentGain = sdPlayer").concat(n,"_gain;\n    float sdPlayer").concat(n,"_currentPitch = sdPlayer").concat(n,"_pitch;\n    int sdPlayer").concat(n,"_targetFile = sdPlayer").concat(n,"_currentFile;\n    float sdPlayer").concat(n,"_startPos = ").concat(e.params.start_pos||0,";\n    float sdPlayer").concat(n,"_endPos = ").concat(e.params.end_pos||1,";\n    \n    // Track loaded sample to avoid unnecessary reloads (declared globally)\n        ")),t){var s=t.from.id.split(":")[0],u=this.modules.find(function(e){return e.id===s});if(u&&"LEDButton"===u.type){var d=this.getButtonReference(u.id);this.loopCode.push("    sdPlayer".concat(n,"_trigger = ").concat(d,"_output;"))}else if(u&&"GateGen"===u.type){var p,f=(null===(p=s.match(/\d+$/))||void 0===p?void 0:p[0])||"1";this.loopCode.push("    sdPlayer".concat(n,"_trigger = gate").concat(f,"_output;"))}else if(u){var m,_=(null===(m=s.match(/\d+$/))||void 0===m?void 0:m[0])||"1";this.loopCode.push("    sdPlayer".concat(n,"_trigger = ").concat(u.type.toLowerCase()).concat(_,"_output;"))}}if(a){var g=a.from.id.split(":")[0],h=this.modules.find(function(e){return e.id===g});if(h&&"Pot"===h.type){var v=this.getPotReference(h.id);this.loopCode.push("    sdPlayer".concat(n,"_currentGain = ").concat(v,"_value;"))}else if(h&&"ADSR"===h.type){var b,y=(null===(b=g.match(/\d+$/))||void 0===b?void 0:b[0])||"1";this.loopCode.push("    sdPlayer".concat(n,"_currentGain = adsr").concat(y,"_output; // Gain from ADSR envelope"))}}if(o){var k=o.from.id.split(":")[0],S=this.modules.find(function(e){return e.id===k});if(S&&"Pot"===S.type){var x=this.getPotReference(S.id);this.loopCode.push("    // Dynamic sample selection: pot maps to actual sample count\n    if (sdPlayer".concat(n,"_sampleCount > 0) {\n        int oldTargetFile = sdPlayer").concat(n,"_targetFile;\n        sdPlayer").concat(n,"_targetFile = 1 + (int)(").concat(x,"_value * sdPlayer").concat(n,"_sampleCount);\n        if (sdPlayer").concat(n,"_targetFile > sdPlayer").concat(n,"_sampleCount) {\n            sdPlayer").concat(n,"_targetFile = sdPlayer").concat(n,"_sampleCount;\n        }\n        \n        // Debug sample selection changes\n        if (sdPlayer").concat(n,'_targetFile != oldTargetFile) {\n            Serial.printf("Sample selection changed: pot=%.3f, sampleCount=%d, targetFile=%d\\n", \n                         ').concat(x,"_value, sdPlayer").concat(n,"_sampleCount, sdPlayer").concat(n,"_targetFile);\n        }\n    } else {\n        sdPlayer").concat(n,'_targetFile = 1; // Default if no samples found\n        Serial.println("Warning: No samples found for selection!");\n    }'))}}else this.loopCode.push("    sdPlayer".concat(n,"_targetFile = 1; // Default to sample1.wav"));if(r){var E=r.from.id.split(":")[0],P=this.modules.find(function(e){return e.id===E});if(P&&"Pot"===P.type){var w=this.getPotReference(P.id);this.loopCode.push("    sdPlayer".concat(n,"_currentPitch = 0.5 + (").concat(w,"_value * 1.5); // Coarse pitch: 0.5x to 2.0x speed"))}else if(P&&"ADSR"===P.type){var C,R=(null===(C=E.match(/\d+$/))||void 0===C?void 0:C[0])||"1";this.loopCode.push("    sdPlayer".concat(n,"_currentPitch = adsr").concat(R,"_output; // Pitch from ADSR envelope"))}else if(P&&"Scale"===P.type){var L,I=(null===(L=E.match(/\d+$/))||void 0===L?void 0:L[0])||"1";this.loopCode.push("    // Convert Scale output (frequency Hz) to pitch ratio\n    float scaleFreq = scale".concat(I,"_output;\n    float scalePitchRatio = scaleFreq / 440.0; // Convert frequency to pitch ratio (440Hz = 1.0x)\n    scalePitchRatio = constrain(scalePitchRatio, 0.25, 4.0); // Limit to reasonable range\n    sdPlayer").concat(n,"_currentPitch = scalePitchRatio; // Musical pitch from Scale quantizer"))}else if(P){var M,D=(null===(M=E.match(/\d+$/))||void 0===M?void 0:M[0])||"1";this.loopCode.push("    sdPlayer".concat(n,"_currentPitch = 0.5 + (").concat(P.type.toLowerCase()).concat(D,"_output * 1.5); // Coarse pitch from ").concat(P.type))}}if(c){var A=c.from.id.split(":")[0],O=this.modules.find(function(e){return e.id===A});if(O&&"ADSR"===O.type){var T,B=(null===(T=A.match(/\d+$/))||void 0===T?void 0:T[0])||"1";this.loopCode.push("    // Pitch envelope modulation: 2 semitones, center offset: 0\n    float pitchEnvMod = adsr".concat(B,"_output; // 0.0 to 1.0\n    float envSemitoneOffset = 0 + ((pitchEnvMod - 0.5) * 2.0 * 2); // range around center\n    float pitchEnvRatio = pow(2.0, envSemitoneOffset / 12.0); // Convert semitones to pitch ratio\n    sdPlayer").concat(n,"_currentPitch *= pitchEnvRatio; // Apply envelope modulation"))}}if(this.loopCode.push("    sdPlayer".concat(n,"_currentPitch = constrain(sdPlayer").concat(n,"_currentPitch, 0.1, 8.0); // Final safety limit")),i){var z=i.from.id.split(":")[0],F=this.modules.find(function(e){return e.id===z});if(F&&"Pot"===F.type){var N=this.getPotReference(F.id);this.loopCode.push("    sdPlayer".concat(n,"_startPos = ").concat(N,"_value; // 0.0 to 1.0"))}}if(l){var G=l.from.id.split(":")[0],q=this.modules.find(function(e){return e.id===G});if(q&&"Pot"===q.type){var U=this.getPotReference(q.id);this.loopCode.push("    sdPlayer".concat(n,"_endPos = ").concat(U,"_value; // 0.0 to 1.0"))}}this.loopCode.push("\n    // Single-voice MinimalWAVPlayer trigger detection (rising edge)\n    if (sdPlayer".concat(n,"_trigger > sdPlayer").concat(n,"_triggerThreshold && !sdPlayer").concat(n,'_lastTrigger) {\n        Serial.printf("Single-voice trigger: sample %d, pitch %.2f\\n", \n                     sdPlayer').concat(n,"_targetFile, sdPlayer").concat(n,"_currentPitch);\n        \n        // CRITICAL: No SD I/O during audio processing!\n        // Just flag that we need a different sample - let setup() or background task handle loading\n        if (sdPlayer").concat(n,"_targetFile != sdPlayer").concat(n,'_lastLoadedFile) {\n            Serial.println("Sample change requested - SD loading handled elsewhere");\n            // For now, keep using the currently loaded sample to avoid crashes\n        }\n        \n        // Apply position controls to current sample (safe during audio processing)\n        if (sdPlayer').concat(n,"_lastLoadedFile != -1) {\n            sdPlayer").concat(n,"_player.setStartPosition(sdPlayer").concat(n,"_startPos);\n            sdPlayer").concat(n,"_player.setEndPosition(sdPlayer").concat(n,"_endPos);\n            \n            // Always restart playback from beginning\n            sdPlayer").concat(n,"_player.play();\n            sdPlayer").concat(n,"_playing = true;\n        }\n    }\n    \n    // Stop playback on falling edge (button release)\n    if (sdPlayer").concat(n,"_trigger <= sdPlayer").concat(n,"_triggerThreshold && sdPlayer").concat(n,"_lastTrigger) {\n        if (sdPlayer").concat(n,'_playing) {\n            Serial.println("Single-voice release: stopping playback");\n            sdPlayer').concat(n,"_player.stop();\n            sdPlayer").concat(n,"_playing = false;\n        }\n    }\n    \n    sdPlayer").concat(n,"_lastTrigger = sdPlayer").concat(n,"_trigger > sdPlayer").concat(n,"_triggerThreshold;\n            "))}},{key:"generateDrumDesignerPreProcessing",value:function(e,n){}},{key:"generateAudioConnections",value:function(){var e=this;if(!this.connections||0===this.connections.length)return"// No audio connections to resolve";var n=[];return this.connections.forEach(function(t,a){var o,r,c,i,l,s;if(t.from&&"string"==typeof t.from)c=t.from,i=t.fromPort;else{if(!t.from||!t.from.id)return;c=t.from.id.split(":")[0],i=t.from.port||t.from.id.split(":")[1]}if(t.to&&"string"==typeof t.to)l=t.to,s=t.toPort;else{if(!t.to||!t.to.id)return;l=t.to.id.split(":")[0],s=t.to.port||t.to.id.split(":")[1]}var u=e.modules.find(function(e){return e.id===c}),d=e.modules.find(function(e){return e.id===l});if(u&&d){var p=(null===(o=c.match(/\d+$/))||void 0===o?void 0:o[0])||"1",f=(null===(r=l.match(/\d+$/))||void 0===r?void 0:r[0])||"1";if(e.isAudioPort(u.type,i)&&e.isAudioPort(d.type,s)){var m=e.getAudioOutputVariable(u.type,p,i),_=e.getAudioInputVariable(d.type,f,s);m&&_&&n.push("        ".concat(_," = ").concat(m,"; // ").concat(u.type).concat(p,":").concat(i," -> ").concat(d.type).concat(f,":").concat(s))}}}),n.join("\n")}},{key:"generateConnectionsToModule",value:function(e){var n=this;if(!this.connections||0===this.connections.length)return"";var t=[];return this.connections.forEach(function(a){var o,r,c,i,l,s;if(a.from&&"string"==typeof a.from)c=a.from,i=a.fromPort;else{if(!a.from||!a.from.id)return;c=a.from.id.split(":")[0],i=a.from.port||a.from.id.split(":")[1]}if(a.to&&"string"==typeof a.to)l=a.to,s=a.toPort;else{if(!a.to||!a.to.id)return;l=a.to.id.split(":")[0],s=a.to.port||a.to.id.split(":")[1]}if(l===e){var u=n.modules.find(function(e){return e.id===c}),d=n.modules.find(function(e){return e.id===l});if(u&&d){var p=(null===(o=c.match(/\d+$/))||void 0===o?void 0:o[0])||"1",f=(null===(r=l.match(/\d+$/))||void 0===r?void 0:r[0])||"1";if(n.isAudioPort(u.type,i)&&n.isAudioPort(d.type,s)){var m=n.getAudioOutputVariable(u.type,p,i),_=n.getAudioInputVariable(d.type,f,s);m&&_&&t.push("        ".concat(_," = ").concat(m,"; // ").concat(u.type).concat(p,":").concat(i," -> ").concat(d.type).concat(f,":").concat(s))}}}}),t.join("\n")}},{key:"isAudioPort",value:function(e,n){var t;return(null===(t={Oscillator:["outL","outR","L","R"],Wavetable:["outL","outR","L","R"],Noise:["out"],NoiseGenerator:["out"],LineIn:["L","R","outL","outR"],Filter:["in","out","inL","inR","outL","outR"],VCA:["inL","inR","outL","outR"],Distortion:["inL","inR","outL","outR"],Delay:["inL","inR","outL","outR"],Reverb:["inL","inR","outL","outR"],CleanReverb:["inL","inR","outL","outR"],Looper:["inL","inR","outL","outR","L","R"],BPMLooper:["inL","inR","outL","outR","L","R"],StereoMixer4:["in1L","in1R","in2L","in2R","in3L","in3R","in4L","in4R","outL","outR","1L","1R","2L","2R","3L","3R","4L","4R"],DrumDesigner:["outL","outR"],KickDrum:["outL","outR"],SnareDrum:["outL","outR"],AudioRecorder:["outL","outR"],I2SOut:["inL","inR","L","R"],"PCM5102A Out":["inL","inR","L","R"]}[e])||void 0===t?void 0:t.includes(n))||!1}},{key:"getAudioOutputVariable",value:function(e,n,t){switch(e){case"Oscillator":if("outL"===t||"L"===t)return"osc".concat(n,"_outputL");if("outR"===t||"R"===t)return"osc".concat(n,"_outputR");break;case"Wavetable":if("outL"===t||"L"===t)return"wt".concat(n,"_outputL");if("outR"===t||"R"===t)return"wt".concat(n,"_outputR");break;case"Noise":case"NoiseGenerator":if("out"===t)return"noise".concat(n,"_output");break;case"LineIn":if("L"===t||"outL"===t)return"linein".concat(n,"_outputL");if("R"===t||"outR"===t)return"linein".concat(n,"_outputR");break;case"Piezo":if("L"===t||"outL"===t)return"piezo".concat(n,"_outputL");if("R"===t||"outR"===t)return"piezo".concat(n,"_outputR");break;case"Coil":if("L"===t||"outL"===t)return"coil".concat(n,"_outputL");if("R"===t||"outR"===t)return"coil".concat(n,"_outputR");break;case"Filter":if("out"===t)return"filter".concat(n,"_output");if("outL"===t)return"filter".concat(n,"_outputL");if("outR"===t)return"filter".concat(n,"_outputR");break;case"VCA":if("outL"===t)return"vca".concat(n,"_outputL");if("outR"===t)return"vca".concat(n,"_outputR");break;case"Distortion":if("outL"===t)return"dist".concat(n,"_outputL");if("outR"===t)return"dist".concat(n,"_outputR");break;case"Delay":if("outL"===t)return"delay".concat(n,"_outputL");if("outR"===t)return"delay".concat(n,"_outputR");break;case"Reverb":if("outL"===t)return"reverb".concat(n,"_outputL");if("outR"===t)return"reverb".concat(n,"_outputR");break;case"CleanReverb":if("outL"===t)return"cleanreverb".concat(n,"_outputL");if("outR"===t)return"cleanreverb".concat(n,"_outputR");break;case"Looper":if("outL"===t||"L"===t)return"looper".concat(n,".outL");if("outR"===t||"R"===t)return"looper".concat(n,".outR");break;case"BPMLooper":if("outL"===t||"L"===t)return"bpmlooper".concat(n,".outL");if("outR"===t||"R"===t)return"bpmlooper".concat(n,".outR");break;case"AudioRecorder":if("outL"===t)return"rec".concat(n,"_outputL");if("outR"===t)return"rec".concat(n,"_outputR");break;case"DrumDesigner":if("outL"===t)return"ks".concat(n,"_outputL");if("outR"===t)return"ks".concat(n,"_outputR");break;case"DrumDesigner4":if("mixL"===t)return"dd4".concat(n,"_outputMixL");if("mixR"===t)return"dd4".concat(n,"_outputMixR");if("voice1_outL"===t)return"dd4".concat(n,"_v1_outL");if("voice1_outR"===t)return"dd4".concat(n,"_v1_outR");if("voice2_outL"===t)return"dd4".concat(n,"_v2_outL");if("voice2_outR"===t)return"dd4".concat(n,"_v2_outR");if("voice3_outL"===t)return"dd4".concat(n,"_v3_outL");if("voice3_outR"===t)return"dd4".concat(n,"_v3_outR");if("voice4_outL"===t)return"dd4".concat(n,"_v4_outL");if("voice4_outR"===t)return"dd4".concat(n,"_v4_outR");break;case"KickDrum":if("outL"===t)return"kick".concat(n,"_outputL");if("outR"===t)return"kick".concat(n,"_outputR");break;case"SnareDrum":if("outL"===t)return"snare".concat(n,"_outputL");if("outR"===t)return"snare".concat(n,"_outputR");break;case"StereoMixer4":if("outL"===t)return"stereoMixer4_".concat(n,"_outputL");if("outR"===t)return"stereoMixer4_".concat(n,"_outputR")}return null}},{key:"getAudioInputVariable",value:function(e,n,t){switch(e){case"Filter":if("in"===t)return"filter".concat(n,"_input");if("inL"===t)return"filter".concat(n,"_inputL");if("inR"===t)return"filter".concat(n,"_inputR");break;case"VCA":if("inL"===t)return"vca".concat(n,"_inputL");if("inR"===t)return"vca".concat(n,"_inputR");break;case"Distortion":if("inL"===t)return"dist".concat(n,"_inputL");if("inR"===t)return"dist".concat(n,"_inputR");break;case"Delay":if("inL"===t)return"delay".concat(n,"_inputL");if("inR"===t)return"delay".concat(n,"_inputR");break;case"Reverb":if("inL"===t)return"reverb".concat(n,"_inputL");if("inR"===t)return"reverb".concat(n,"_inputR");break;case"CleanReverb":if("inL"===t)return"cleanreverb".concat(n,"_inputL");if("inR"===t)return"cleanreverb".concat(n,"_inputR");break;case"StereoMixer4":if("in1L"===t||"1L"===t)return"stereoMixer4_".concat(n,"_input1L");if("in1R"===t||"1R"===t)return"stereoMixer4_".concat(n,"_input1R");if("in2L"===t||"2L"===t)return"stereoMixer4_".concat(n,"_input2L");if("in2R"===t||"2R"===t)return"stereoMixer4_".concat(n,"_input2R");if("in3L"===t||"3L"===t)return"stereoMixer4_".concat(n,"_input3L");if("in3R"===t||"3R"===t)return"stereoMixer4_".concat(n,"_input3R");if("in4L"===t||"4L"===t)return"stereoMixer4_".concat(n,"_input4L");if("in4R"===t||"4R"===t)return"stereoMixer4_".concat(n,"_input4R");break;case"AudioRecorder":if("inL"===t)return"rec".concat(n,"_inputL");if("inR"===t)return"rec".concat(n,"_inputR");break;case"I2SOut":case"PCM5102A Out":if("inL"===t||"L"===t)return"i2sout".concat(n,"_inputL");if("inR"===t||"R"===t)return"i2sout".concat(n,"_inputR")}return null}},{key:"generateNetlist",value:function(){var e=["/*"," * PATCH NETLIST"," * ============"],n=this.connections.filter(function(e){return"audio"===e.from.kind}),t=this.connections.filter(function(e){return"ctrl"===e.from.kind||"control"===e.from.kind});return n.length>0&&(e.push(" *"," * AUDIO CONNECTIONS:"),n.forEach(function(n){var t=n.from.id.split(":"),a=n.to.id.split(":");e.push(" * [audio] ".concat(t[0],":").concat(n.from.port,"  ").concat(a[0],":").concat(n.to.port))})),t.length>0&&(e.push(" *"," * CONTROL CONNECTIONS:"),t.forEach(function(n){var t=n.from.id.split(":"),a=n.to.id.split(":");e.push(" * [ctrl] ".concat(t[0],":").concat(n.from.port,"  ").concat(a[0],":").concat(n.to.port))})),e.push(" */"),e.join("\n")}},{key:"assembleCode",value:function(){return["// Generated ESP32-S3 Patcher Code","// Target: ESP32-S3 with PCM5102A DAC and MCP23017 I/O Expander","// Generated on: "+(new Date).toISOString(),this.modules.some(function(e){return"SDPlayer"===e.type||"SamplePlayer"===e.type||"KickDrum"===e.type||"SnareDrum"===e.type})?"// File transfer functionality is built-in - no external libraries required":"","",this.generateNetlist(),""].concat(Le(Array.from(this.includes)),[""],Le(this.moduleClasses),[""],Le(this.globalVariables),[""],Le(this.globalFunctions||[]),[""],Le(this.setupCode),[""],Le(this.loopCode)).join("\n")}},{key:"estimateCPU",value:function(){var e=new Set(["HarmonicSequencer","BankSequencer","Scale","Modulation","Clock","GateGen","Pot","LEDButton","Encoder","MIDIIn","MIDIOut","GateOut"]),n={Oscillator:10,Wavetable:10,Noise:2,NoiseGenerator:2,ADSR:3,VCA:2,Filter:15,Delay:10,Reverb:40,CleanReverb:30,StereoMixer4:2,Matrix2x2:4,Panner:2,SamplePlayer:12,GranularDense:50,Looper:22,KickDrum:18,SnareDrum:18,SDPlay:10,I2SOut:2,"PCM5102A Out":2,HarmonicSequencer:0,BankSequencer:0,Scale:0,Modulation:0,Clock:0,GateGen:0,Pot:0,LEDButton:0,Encoder:0,MIDIIn:0,MIDIOut:0,GateOut:0},t=0,a=0,o=[];this.modules.forEach(function(r){var c=void 0!==n[r.type]?n[r.type]:5;e.has(r.type)?a++:t+=c,o.push({id:r.id,type:r.type,cost:c,core:e.has(r.type)?0:1})});var r=55*(t+=10),c=r/5442*100;return{percentage:Math.round(10*c)/10,breakdown:o,total:t,core0ModuleCount:a,estimatedCycles:r,availableCycles:5442,dualCore:!0}}},{key:"checkAudioRecorderButton",value:function(e,n){var t,a=Ce(this.modules.filter(function(e){return"AudioRecorder"===e.type}));try{for(a.s();!(t=a.n()).done;){var o=t.value.params.bank||1,r=e.params.bank||1,c=e.params.index||1;if(o===r&&(1===c||2===c))return!0}}catch(e){a.e(e)}finally{a.f()}return!1}},{key:"getAudioRecorderForButton",value:function(e,n){var t,a=Ce(this.modules.filter(function(e){return"AudioRecorder"===e.type}));try{for(a.s();!(t=a.n()).done;){var o=t.value,r=o.params.bank||1,c=e.params.bank||1,i=e.params.index||1;if(r===c){var l,s=(null===(l=o.id.match(/\d+$/))||void 0===l?void 0:l[0])||"1";if(1===i)return{instanceIndex:s,buttonRole:"record"};if(2===i)return{instanceIndex:s,buttonRole:"play"}}}}catch(e){a.e(e)}finally{a.f()}return null}}],n&&Oe(e.prototype,n),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,n}();const ze=t.p+"assets/soniphormLogo.png";function Fe(){var e,n,t="function"==typeof Symbol?Symbol:{},a=t.iterator||"@@iterator",o=t.toStringTag||"@@toStringTag";function r(t,a,o,r){var l=a&&a.prototype instanceof i?a:i,s=Object.create(l.prototype);return Ne(s,"_invoke",function(t,a,o){var r,i,l,s=0,u=o||[],d=!1,p={p:0,n:0,v:e,a:f,f:f.bind(e,4),d:function(n,t){return r=n,i=0,l=e,p.n=t,c}};function f(t,a){for(i=t,l=a,n=0;!d&&s&&!o&&n<u.length;n++){var o,r=u[n],f=p.p,m=r[2];t>3?(o=m===a)&&(l=r[(i=r[4])?5:(i=3,3)],r[4]=r[5]=e):r[0]<=f&&((o=t<2&&f<r[1])?(i=0,p.v=a,p.n=r[1]):f<m&&(o=t<3||r[0]>a||a>m)&&(r[4]=t,r[5]=a,p.n=m,i=0))}if(o||t>1)return c;throw d=!0,a}return function(o,u,m){if(s>1)throw TypeError("Generator is already running");for(d&&1===u&&f(u,m),i=u,l=m;(n=i<2?e:l)||!d;){r||(i?i<3?(i>1&&(p.n=-1),f(i,l)):p.n=l:p.v=l);try{if(s=2,r){if(i||(o="next"),n=r[o]){if(!(n=n.call(r,l)))throw TypeError("iterator result is not an object");if(!n.done)return n;l=n.value,i<2&&(i=0)}else 1===i&&(n=r.return)&&n.call(r),i<2&&(l=TypeError("The iterator does not provide a '"+o+"' method"),i=1);r=e}else if((n=(d=p.n<0)?l:t.call(a,p))!==c)break}catch(n){r=e,i=1,l=n}finally{s=1}}return{value:n,done:d}}}(t,o,r),!0),s}var c={};function i(){}function l(){}function s(){}n=Object.getPrototypeOf;var u=[][a]?n(n([][a]())):(Ne(n={},a,function(){return this}),n),d=s.prototype=i.prototype=Object.create(u);function p(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,s):(e.__proto__=s,Ne(e,o,"GeneratorFunction")),e.prototype=Object.create(d),e}return l.prototype=s,Ne(d,"constructor",s),Ne(s,"constructor",l),l.displayName="GeneratorFunction",Ne(s,o,"GeneratorFunction"),Ne(d),Ne(d,o,"Generator"),Ne(d,a,function(){return this}),Ne(d,"toString",function(){return"[object Generator]"}),(Fe=function(){return{w:r,m:p}})()}function Ne(e,n,t,a){var o=Object.defineProperty;try{o({},"",{})}catch(e){o=0}Ne=function(e,n,t,a){function r(n,t){Ne(e,n,function(e){return this._invoke(n,t,e)})}n?o?o(e,n,{value:t,enumerable:!a,configurable:!a,writable:!a}):e[n]=t:(r("next",0),r("throw",1),r("return",2))},Ne(e,n,t,a)}function Ge(e,n,t,a,o,r,c){try{var i=e[r](c),l=i.value}catch(e){return void t(e)}i.done?n(l):Promise.resolve(l).then(a,o)}function qe(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,r,c,i=[],l=!0,s=!1;try{if(r=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=r.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(c=t.return(),Object(c)!==c))return}finally{if(s)throw o}}return i}}(e,n)||function(e,n){if(e){if("string"==typeof e)return Ue(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Ue(e,n):void 0}}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Ue(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}const We=function(e){var n=e.module,t=e.onUpdateParam,o=e.onClose,r=e.embedded,c=void 0!==r&&r,i=e.activeLayer,l=void 0===i?"oscillator":i,s=e.setActiveLayer,u=e.onAudioLoaded,d=e.preloadedAudio,p=e.fixedEnvelopeType,f=void 0===p?null:p;console.log(" EnvelopeWaveformEditor rendered with embedded =",c);var m=(0,a.useRef)(),_=(0,a.useRef)(),g=qe((0,a.useState)(null),2),h=g[0],v=g[1],b=qe((0,a.useState)({x:0,y:0}),2),y=(b[0],b[1]),k=qe((0,a.useState)(null),2),S=k[0],x=k[1],E=qe((0,a.useState)(null),2),P=E[0],w=E[1],C=qe((0,a.useState)(!1),2),R=C[0],L=C[1],I=qe((0,a.useState)(f||"amplitude"),2),M=I[0],D=I[1];(0,a.useEffect)(function(){if(d){var e=d.originalBuffer||d.audioBuffer;e&&(console.log(" Using preloaded trimmed audio in EnvelopeWaveformEditor:",e),x(e),setTimeout(function(){$()},100))}},[d]);var A,O,T,B,z=function(e){var n=440*Math.pow(2,-4.75);if(e<=0)return"---";var t=Math.round(12*Math.log2(e/n)),a=Math.floor(t/12);return"".concat(["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][t%12]).concat(a)},F=200,N=40,G=720,q=320,U=function(){var e,a=(e=Fe().m(function e(a){var o,r,c,i,l,s;return Fe().w(function(e){for(;;)switch(e.p=e.n){case 0:if(a){e.n=1;break}return e.a(2);case 1:if(L(!0),e.p=2,(o=P)&&"closed"!==o.state||(o=new(window.AudioContext||window.webkitAudioContext),w(o)),"suspended"!==o.state){e.n=3;break}return e.n=3,o.resume();case 3:return e.n=4,a.arrayBuffer();case 4:return r=e.v,e.n=5,o.decodeAudioData(r);case 5:c=e.v,console.log("Loaded audio file:",{name:a.name,duration:c.duration,sampleRate:c.sampleRate,channels:c.numberOfChannels}),x(c),u&&(console.log(" Calling onAudioLoaded with decodedBuffer"),i=c.getChannelData(0),l=new Float32Array(i),u(l,c)),n.params.sample_name&&""!==n.params.sample_name||t("sample_name",a.name.replace(/\.[^/.]+$/,"")),e.n=7;break;case 6:e.p=6,s=e.v,console.error("Failed to load audio file:",s),alert("Failed to load audio file: ".concat(a.name,"\n\nError: ").concat(s.message,"\n\nPlease try a different audio format (WAV, MP3, or OGG)."));case 7:return e.p=7,L(!1),e.f(7);case 8:return e.a(2)}},e,null,[[2,6,7,8]])}),function(){var n=this,t=arguments;return new Promise(function(a,o){var r=e.apply(n,t);function c(e){Ge(r,a,o,c,i,"next",e)}function i(e){Ge(r,a,o,c,i,"throw",e)}c(void 0)})});return function(e){return a.apply(this,arguments)}}(),W=function(e){var n=e.target.files[0];n&&U(n)},V=function(e){e.preventDefault();var n=Array.from(e.dataTransfer.files).find(function(e){return e.type.startsWith("audio/")||e.name.toLowerCase().match(/\.(wav|mp3|ogg|flac|aac)$/)});n&&U(n)},H=function(e){e.preventDefault()},j=function(e,n){var t=n.attack_ms,a=n.decay_ms,o=n.sustain,r=n.release_ms,c=n.attack_curve,i=n.decay_curve,l=n.release_curve,s=e*(t+a+200+r),u=0;if(s<=t){var d=s/t,p=d;switch(c){case"exp":p=(1-Math.exp(-5*d))/(1-Math.exp(-5));break;case"log":p=Math.log(1+9*d)/Math.log(10);break;case"sine":p=Math.sin(d*Math.PI/2);break;case"quad":p=d*d}u=p}else if(s<=t+a){var f=(s-t)/a,m=f;switch(i){case"exp":m=1-(1-Math.exp(-5*(1-f)))/(1-Math.exp(-5));break;case"log":m=1-Math.log(1+9*(1-f))/Math.log(10);break;case"sine":m=1-Math.sin((1-f)*Math.PI/2);break;case"quad":m=1-(1-f)*(1-f)}u=1-(1-o)*m}else if(s<=t+a+200)u=o;else{var _=(s-t-a-200)/r;if(_>=1)u=0;else{var g=_;switch(l){case"exp":g=1-(1-Math.exp(-5*(1-_)))/(1-Math.exp(-5));break;case"log":g=1-Math.log(1+9*(1-_))/Math.log(10);break;case"sine":g=1-Math.sin((1-_)*Math.PI/2);break;case"quad":g=1-(1-_)*(1-_)}u=o*(1-g)}}return Math.max(0,Math.min(1,u))},K=function(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"amplitude";e="sample"===l?"sample_".concat("filter"===t?"filter":"pitch"===t?"pitch":"amp"):"noise"===l?"noise_".concat("filter"===t?"filter":"amp"):"osc_".concat("pitch"===t?"pitch":"amp");var a={attack_ms:n.params["".concat(e,"_attack_ms")]||10,decay_ms:n.params["".concat(e,"_decay_ms")]||120,sustain:n.params["".concat(e,"_sustain")]||.6,release_ms:n.params["".concat(e,"_release_ms")]||200,attack_curve:n.params["".concat(e,"_attack_curve")]||"linear",decay_curve:n.params["".concat(e,"_decay_curve")]||"exp",release_curve:n.params["".concat(e,"_release_curve")]||"exp"};return console.log(" getCurrentLayerParams: envelopeTab=".concat(t,", prefix=").concat(e,", result:"),a),a},$=function(){var e=m.current;if(e){var t,a,o=e.getContext("2d"),r=K(M);console.log(" Drawing with params:",r,"activeEnvelopeTab:",M),o.fillStyle="#0f172a",o.fillRect(0,0,800,400),o.strokeStyle="#374151",o.lineWidth=1,o.setLineDash([2,2]);for(var c=0;c<=4;c++){var i=N+c*q/4;o.beginPath(),o.moveTo(N,i),o.lineTo(760,i),o.stroke();var s=N+c*G/4;o.beginPath(),o.moveTo(s,N),o.lineTo(s,360),o.stroke()}switch(o.setLineDash([]),l){case"oscillator":t=function(e,n,t){for(var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:44100,o=[],r=Math.floor(t*a),c=0;c<r;c++){var i=c/a,l=2*Math.PI*n*i;switch(e){case"sine":default:o[c]=Math.sin(l);break;case"saw":o[c]=l%(2*Math.PI)/(2*Math.PI)*2-1;break;case"square":o[c]=Math.sign(Math.sin(l));break;case"triangle":o[c]=2/Math.PI*Math.asin(Math.sin(l))}}return o}("sine",n.params.osc_freq||60,1);break;case"noise":t=function(e,n){for(var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:44100,a=[],o=Math.floor(n*t),r=0,c=0;c<o;c++){var i=void 0;switch(e){case"white":default:i=2*Math.random()-1;break;case"brown":i=r+.1*(2*Math.random()-1),r=i=Math.max(-1,Math.min(1,i));break;case"pink":i=(2*Math.random()-1)*Math.pow(Math.random(),.5)}a[c]=i}return a}(n.params.noise_type||"white",1);break;case"sample":t=function(){if(console.log("getRealSampleWaveform called, audioBuffer:",S),S&&S.getChannelData){var e=S.getChannelData(0),n=e.length,t=4e3;if(n-0>t){for(var a=(n-0)/t,o=[],r=0;r<t;r++){var c=Math.floor(0+r*a);o[r]=e[c]}return o}return Array.from(e.slice(0,n))}if(S&&S.length){console.log("Using Float32Array audioBuffer:",S.length,"samples");var i=4e3;if(S.length>i){for(var l=S.length/i,s=[],u=0;u<i;u++){var d=Math.floor(u*l);s[u]=S[d]}return s}return Array.from(S)}for(var p=[],f=Math.floor(44100),m=0;m<f;m++){var _=m/44100,g=Math.exp(8*-_),h=1+2*Math.exp(15*-_),v=2*Math.PI*60*h*_;p[m]=Math.sin(v)*g}return p}()}a="pitch"===M?function(e,t,a){for(var o="sample"===l?n.params.sample_pitch_amount||12:n.params.osc_pitch_amount||.5,r=[],c=0,i=0;i<e.length;i++){var s=i/(e.length-1),u=j(s,t),d=void 0;if("sample"===l){var p=u*o;d=a*Math.pow(2,p/12)}else d=a*Math.pow(2,u*o);e.length,(c+=2*Math.PI*d/44100)>=2*Math.PI&&(c-=2*Math.PI),r[i]=Math.sin(c)}return r}(t,r,n.params.osc_frequency||60):function(e,n){return e&&e.map?e.map(function(t,a){var o=a/(e.length-1);return t*j(o,n)}):(console.warn("applyEnvelopeToWaveform: waveform is undefined or not array-like"),[])}(t,r),o.strokeStyle="#4b5563",o.lineWidth=1,o.globalAlpha=.3,o.beginPath();for(var u=0;u<t.length;u+=Math.ceil(t.length/G)){var d=N+u/t.length*G,p=200+t[u]*q/4;0===u?o.moveTo(d,p):o.lineTo(d,p)}o.stroke(),o.globalAlpha=1;var f={oscillator:"#10b981",noise:"#f59e0b",sample:"#8b5cf6"};o.strokeStyle=f[l],o.lineWidth=2,o.beginPath();for(var _=0;_<a.length;_+=Math.ceil(a.length/G)){var g=N+_/a.length*G,v=200+a[_]*q/4;0===_?o.moveTo(g,v):o.lineTo(g,v)}o.stroke(),o.strokeStyle="#ef4444",o.lineWidth=3,o.globalAlpha=.8,o.beginPath();for(var b=0;b<=G;b+=2){var y=j(b/G,r),k=N+b,x=N+(1-y)*q;0===b?o.moveTo(k,x):o.lineTo(k,x)}o.stroke(),o.globalAlpha=1;var E=r.attack_ms+r.decay_ms+200+r.release_ms,P=N+r.attack_ms/E*G,w=N+(r.attack_ms+r.decay_ms)/E*G,C=N+(r.attack_ms+r.decay_ms+200)/E*G,R=N+(1-r.sustain)*q,L=R,I=function(e,n,t,a){o.fillStyle=t?"#fbbf24":"#ef4444",o.strokeStyle="#000",o.lineWidth=2,o.beginPath(),o.arc(e,n,8,0,2*Math.PI),o.fill(),o.stroke(),o.fillStyle="#fff",o.font="bold 12px sans-serif",o.textAlign="center",o.fillText(a,e,n-12)};I(P,40,"attack"===h,"A"),I(w,R,"decay"===h,"D"),I(C,L,"sustain"===h,"S"),I(760,360,"release"===h,"R"),o.fillStyle=f[l],o.font="bold 16px sans-serif",o.textAlign="left",o.fillText("".concat(l.toUpperCase()," LAYER"),45,60),"sample"!==l||S||(o.fillStyle="#8b5cf6",o.font="bold 14px sans-serif",o.textAlign="center",o.fillText("Drag & drop audio file here or use Load button",400,200),o.font="12px sans-serif",o.fillStyle="#a855f7",o.fillText("Supports: WAV, MP3, OGG, FLAC, AAC",400,220))}},Y=function(e){console.log(" EnvelopeWaveformEditor handleMouseDown fired!",e);var n=m.current;if(n){var t=n.getBoundingClientRect(),a=n.width/t.width,o=n.height/t.height,r=(e.clientX-t.left)*a,c=(e.clientY-t.top)*o,i=K(M);console.log(" activeLayer:",l,"activeEnvelopeTab:",M),console.log(" params:",i);var s=i.attack_ms+i.decay_ms+200+i.release_ms,u=N+i.attack_ms/s*G,d=N+(i.attack_ms+i.decay_ms)/s*G,p=N+(i.attack_ms+i.decay_ms+200)/s*G,f=N+(1-i.sustain)*q,_=f;Math.sqrt(Math.pow(r-u,2)+Math.pow(c-40,2))<15?(v("attack"),e.preventDefault(),e.stopPropagation()):Math.sqrt(Math.pow(r-d,2)+Math.pow(c-f,2))<15?(v("decay"),e.preventDefault(),e.stopPropagation()):Math.sqrt(Math.pow(r-p,2)+Math.pow(c-_,2))<15?(v("sustain"),e.preventDefault(),e.stopPropagation()):Math.sqrt(Math.pow(r-760,2)+Math.pow(c-360,2))<15&&(v("release"),e.preventDefault(),e.stopPropagation()),y({x:r,y:c})}else console.log(" No canvas ref!")},X=function(e){if(h){var n=m.current;if(n){var a,o=n.getBoundingClientRect(),r=n.width/o.width,c=n.height/o.height,i=(e.clientX-o.left)*r,s=(e.clientY-o.top)*c;if(K(M),a="sample"===l?"sample_".concat("filter"===M?"filter":"pitch"===M?"pitch":"amp"):"noise"===l?"noise_".concat("filter"===M?"filter":"amp"):"osc_".concat("pitch"===M?"pitch":"amp"),"attack"===h){var u=Math.max(0,Math.min(1,(i-N)/G)),d=Math.max(1,Math.min(1e3,500*u));t("".concat(a,"_attack_ms"),Math.round(d))}else if("decay"===h){var p=Math.max(0,Math.min(1,(i-N)/G)),f=Math.max(1,Math.min(2e3,800*p));t("".concat(a,"_decay_ms"),Math.round(f))}else if("sustain"===h){var _=Math.max(0,Math.min(1,1-(s-N)/q));t("".concat(a,"_sustain"),_)}else if("release"===h){var g=Math.max(0,Math.min(1,(i-N)/G)),v=Math.max(10,Math.min(3e3,1500*g));t("".concat(a,"_release_ms"),Math.round(v))}y({x:i,y:s}),e.preventDefault()}}},Z=function(){v(null)};return(0,a.useEffect)(function(){$()},[l,M,n.params,h,S]),c?(console.log(" EMBEDDED MODE ACTIVATED - No left panel, knobs handled by parent"),console.log(" activeLayer:",l,"activeEnvelopeTab:",M),console.log(" module.params:",n.params),a.createElement("div",{style:{width:"100%",height:"100%",display:"flex",flexDirection:"column",backgroundColor:"#0c1428"}},("oscillator"===l||"noise"===l||"sample"===l)&&!f&&a.createElement("div",{style:{padding:"8px 16px",borderBottom:"1px solid #334155",display:"flex",alignItems:"center",gap:"8px"}},a.createElement("div",{style:{display:"flex",gap:"2px",border:"1px solid #374151",borderRadius:"4px",overflow:"hidden"}},a.createElement("button",{onClick:function(){return D("amplitude")},style:{padding:"4px 12px",background:"amplitude"===M?"#ef4444":"#374151",color:"amplitude"===M?"#000":"#cbd5e1",border:"none",fontSize:"11px",fontWeight:"600",cursor:"pointer"}},"Amplitude"),("oscillator"===l||"sample"===l)&&a.createElement("button",{onClick:function(){return D("pitch")},style:{padding:"4px 12px",background:"pitch"===M?"#3b82f6":"#374151",color:"pitch"===M?"#000":"#cbd5e1",border:"none",fontSize:"11px",fontWeight:"600",cursor:"pointer"}},"Pitch"),("noise"===l||"sample"===l)&&a.createElement("button",{onClick:function(){return D("filter")},style:{padding:"4px 12px",background:"filter"===M?"#10b981":"#374151",color:"filter"===M?"#000":"#cbd5e1",border:"none",fontSize:"11px",fontWeight:"600",cursor:"pointer"}},"Filter"))),a.createElement("div",{style:{flex:1,display:"flex",alignItems:"center",justifyContent:"flex-start",padding:"16px"}},"sample"!==l||S?a.createElement("canvas",{ref:m,width:800,height:400,onMouseDown:Y,onMouseMove:X,onMouseUp:Z,onMouseLeave:Z,style:{border:"2px solid #374151",borderRadius:"8px",backgroundColor:"#0f172a",maxWidth:"100%",maxHeight:"100%",cursor:h?"grabbing":"grab"}}):a.createElement("div",{style:{width:"100%",height:"100%",border:"2px dashed #8b5cf6",borderRadius:"8px",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",backgroundColor:"#0f172a"},onClick:function(){var e;return null===(e=_.current)||void 0===e?void 0:e.click()},onDragOver:H,onDrop:V},a.createElement("div",{style:{textAlign:"center",color:"#8b5cf6"}},a.createElement("div",{style:{fontSize:"48px",marginBottom:"12px"}},""),a.createElement("div",{style:{fontSize:"16px",fontWeight:"600"}},"Drop audio file here"),a.createElement("div",{style:{fontSize:"13px",marginTop:"6px"}},"or click to browse")),a.createElement("input",{ref:_,type:"file",accept:".wav,.mp3,.ogg,.flac,.aac",onChange:W,style:{display:"none"}}))),a.createElement("div",{style:{backgroundColor:"#0f172a",padding:"16px",borderTop:"1px solid #334155",display:"flex",alignItems:"flex-start",gap:"20px",flexWrap:"wrap",minHeight:"120px"}},a.createElement("div",{style:{color:{oscillator:"#10b981",noise:"#f59e0b",sample:"#8b5cf6"}[l],fontSize:"12px",fontWeight:"600",textTransform:"uppercase",letterSpacing:"0.5px",minWidth:"80px"}},l),"oscillator"===l&&a.createElement("div",{style:{display:"flex",flexWrap:"wrap",gap:"16px",alignItems:"center",border:"1px solid #334155",borderRadius:"6px",padding:"12px",backgroundColor:"#0c1428"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#10b981",fontSize:"12px",fontWeight:"600",minWidth:"70px"}},"Waveform:"),a.createElement("select",{value:n.params.osc_waveform||"sine",onChange:function(e){return t("osc_waveform",e.target.value)},style:{padding:"6px 8px",borderRadius:"4px",border:"1px solid #10b981",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px",minWidth:"100px"}},a.createElement("option",{value:"sine"},"Sine"),a.createElement("option",{value:"square"},"Square"),a.createElement("option",{value:"saw"},"Sawtooth"),a.createElement("option",{value:"triangle"},"Triangle"))),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px",flexWrap:"wrap"}},a.createElement("label",{style:{color:"#10b981",fontSize:"12px",fontWeight:"600",minWidth:"70px"}},"pitch"===M?"Start Freq:":"Frequency:"),a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"4px",cursor:"pointer"}},a.createElement("input",{type:"checkbox",checked:n.params.osc_snap_to_note||!1,onChange:function(e){return t("osc_snap_to_note",e.target.checked)},style:{accentColor:"#10b981"}}),a.createElement("span",{style:{color:"#10b981",fontSize:"10px",fontWeight:"500"}},"Snap to Note")),a.createElement("input",{type:"range",min:"0",max:"100",step:n.params.osc_snap_to_note?"1":"0.1",value:(A=n.params.osc_freq||60,O=Math.max(30,Math.min(F,A)),T=Math.log(30),B=Math.log(F),(Math.log(O)-T)/(B-T)*100),onChange:function(e){var a=function(e){var n=e/100,t=Math.log(30),a=Math.log(F);return Math.exp(t+n*(a-t))}(parseFloat(e.target.value));n.params.osc_snap_to_note&&(a=function(e){var n=440*Math.pow(2,-4.75),t=Math.round(12*Math.log2(e/n)),a=n*Math.pow(2,t/12);return Math.max(30,Math.min(F,a))}(a)),t("osc_freq",Math.round(10*a)/10)},style:{width:"120px",accentColor:"#10b981"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px",fontWeight:"500",minWidth:"120px"}},(n.params.osc_freq||60).toFixed(1),"Hz (",z(n.params.osc_freq||60),")")),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#10b981",fontSize:"12px",fontWeight:"600",minWidth:"70px"}},"Distortion:"),a.createElement("input",{type:"range",min:"0",max:"10",step:"0.1",value:n.params.osc_distortion||0,onChange:function(e){return t("osc_distortion",parseFloat(e.target.value))},style:{width:"120px",accentColor:"#10b981"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px",fontWeight:"500",minWidth:"40px"}},(n.params.osc_distortion||0).toFixed(1))),"pitch"===M&&a.createElement(a.Fragment,null,"oscillator"===l&&a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px",padding:"4px",backgroundColor:"rgba(59, 130, 246, 0.1)",borderRadius:"4px",position:"relative",zIndex:10}},a.createElement("label",{style:{color:"#3b82f6",fontSize:"12px",fontWeight:"600",minWidth:"80px"}},"Pitch Range:"),a.createElement("input",{type:"range",min:"1",max:"24",step:"1",value:n.params.osc_pitch_amount||12,onChange:function(e){console.log("OSC PITCH AMOUNT CHANGE:",e.target.value),t("osc_pitch_amount",parseInt(e.target.value))},style:{width:"120px",accentColor:"#3b82f6",cursor:"pointer",height:"20px",pointerEvents:"auto"}}),a.createElement("span",{style:{color:"#3b82f6",fontSize:"11px",fontWeight:"500",minWidth:"120px"}},"",n.params.osc_pitch_amount||12," semitones")),"sample"===l&&a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#3b82f6",fontSize:"12px",fontWeight:"600",minWidth:"80px"}},"Pitch Range:"),a.createElement("input",{type:"range",min:"1",max:"24",step:"1",value:n.params.sample_pitch_amount||12,onChange:function(e){return t("sample_pitch_amount",parseInt(e.target.value))},style:{width:"120px",accentColor:"#3b82f6"}}),a.createElement("span",{style:{color:"#3b82f6",fontSize:"11px",fontWeight:"500",minWidth:"120px"}},"",n.params.sample_pitch_amount||12," semitones")),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px",width:"100%"}},a.createElement("label",{style:{color:"#3b82f6",fontSize:"12px",fontWeight:"600",minWidth:"70px"}},"End Freq:"),a.createElement("span",{style:{color:"#3b82f6",fontSize:"11px",minWidth:"120px",fontWeight:"500"}},Math.round((n.params.osc_freq||60)*Math.pow(2,0*(n.params.osc_pitch_amount||12)/12)),"Hz (",z(Math.round((n.params.osc_freq||60)*Math.pow(2,0*(n.params.osc_pitch_amount||12)/12))),")"),a.createElement("span",{style:{color:"#94a3b8",fontSize:"10px"}}," Max: ",Math.round((n.params.osc_freq||60)*Math.pow(2,1*(n.params.osc_pitch_amount||12)/12)),"Hz (",z(Math.round((n.params.osc_freq||60)*Math.pow(2,1*(n.params.osc_pitch_amount||12)/12))),")")))),"noise"===l&&a.createElement("div",{style:{display:"flex",flexWrap:"wrap",gap:"16px",alignItems:"center",border:"1px solid #334155",borderRadius:"6px",padding:"12px",backgroundColor:"#0c1428"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#f59e0b",fontSize:"12px",fontWeight:"600",minWidth:"50px"}},"Type:"),a.createElement("select",{value:n.params.noise_type||"white",onChange:function(e){return t("noise_type",e.target.value)},style:{padding:"6px 8px",borderRadius:"4px",border:"1px solid #f59e0b",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px",minWidth:"100px"}},a.createElement("option",{value:"white"},"White"),a.createElement("option",{value:"pink"},"Pink"),a.createElement("option",{value:"brown"},"Brown"))),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#f59e0b",fontSize:"12px",fontWeight:"600",minWidth:"50px"}},"Filter:"),a.createElement("input",{type:"range",min:"100",max:"8000",step:"100",value:n.params.noise_filter||2e3,onChange:function(e){return t("noise_filter",parseInt(e.target.value))},style:{width:"120px",accentColor:"#f59e0b"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px",fontWeight:"500",minWidth:"80px"}},n.params.noise_filter||2e3,"Hz"))),"sample"===l&&a.createElement("div",{style:{display:"flex",flexWrap:"wrap",gap:"16px",alignItems:"center",border:"1px solid #334155",borderRadius:"6px",padding:"12px",backgroundColor:"#0c1428"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#8b5cf6",fontSize:"12px",fontWeight:"600"}},"File:"),a.createElement("input",{ref:_,type:"file",accept:".wav,.mp3,.ogg,.flac,.aac",onChange:W,style:{fontSize:"12px",color:"#cbd5e1",backgroundColor:"#0f172a",border:"1px solid #8b5cf6",borderRadius:"4px",padding:"6px 8px"}})),S&&a.createElement("div",{style:{color:"#8b5cf6",fontSize:"11px",fontWeight:"500"}},"Loaded: ",(S.duration||0).toFixed(2),"s @ ",S.sampleRate,"Hz"),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"4px",cursor:"pointer"}},a.createElement("input",{type:"checkbox",checked:n.params.sample_pitch_enabled||!1,onChange:function(e){return t("sample_pitch_enabled",e.target.checked)},style:{accentColor:"#8b5cf6"}}),a.createElement("span",{style:{color:"#8b5cf6",fontSize:"12px",fontWeight:"500"}},"Enable Pitch Envelope")))),a.createElement("div",{style:{display:"flex",flexWrap:"wrap",gap:"16px",alignItems:"center",border:"1px solid #334155",borderRadius:"6px",padding:"12px",backgroundColor:"#0c1428",width:"100%"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:{oscillator:"#10b981",noise:"#f59e0b",sample:"#8b5cf6"}[l],fontSize:"12px",fontWeight:"600",minWidth:"80px"}},"Duration:"),"oscillator"===l&&a.createElement(a.Fragment,null,a.createElement("input",{type:"range",min:"0.1",max:"2.0",step:"0.01",value:n.params.osc_time||.8,onChange:function(e){return t("osc_time",parseFloat(e.target.value))},style:{width:"120px",accentColor:"#10b981"}}),a.createElement("span",{style:{color:"#10b981",fontSize:"11px",fontWeight:"500",minWidth:"60px"}},(n.params.osc_time||.8).toFixed(2),"s")),"noise"===l&&a.createElement(a.Fragment,null,a.createElement("input",{type:"range",min:"0.05",max:"0.5",step:"0.005",value:n.params.noise_time||.15,onChange:function(e){return t("noise_time",parseFloat(e.target.value))},style:{width:"120px",accentColor:"#f59e0b"}}),a.createElement("span",{style:{color:"#f59e0b",fontSize:"11px",fontWeight:"500",minWidth:"60px"}},Math.round(1e3*(n.params.noise_time||.15)),"ms")),"sample"===l&&a.createElement(a.Fragment,null,a.createElement("input",{type:"range",min:"0.2",max:"3.0",step:"0.01",value:n.params.sample_time||1.2,onChange:function(e){return t("sample_time",parseFloat(e.target.value))},style:{width:"120px",accentColor:"#8b5cf6"}}),a.createElement("span",{style:{color:"#8b5cf6",fontSize:"11px",fontWeight:"500",minWidth:"60px"}},(n.params.sample_time||1.2).toFixed(2),"s"))),a.createElement("div",{style:{color:"#6b7280",fontSize:"10px",fontStyle:"italic"}},"Controls the overall duration of the ",l," layer"))))):a.createElement("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(0, 0, 0, 0.9)",zIndex:2e3,display:"flex",alignItems:"center",justifyContent:"center"}},a.createElement("div",{style:{backgroundColor:"#0c1428",border:"1px solid #1f2937",borderRadius:"12px",width:"95vw",height:"90vh",padding:"20px",display:"flex",flexDirection:"column",overflow:"auto"}},a.createElement("div",{style:{display:"flex",alignItems:"center",justifyContent:"space-between",marginBottom:"20px",paddingBottom:"12px",borderBottom:"1px solid #334155"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"20px"}},a.createElement("h2",{style:{color:"#22c55e",fontWeight:"bold",fontSize:"24px",margin:0}}," Waveform + Envelope Editor"),a.createElement("div",{style:{display:"flex",gap:"2px",border:"1px solid #374151",borderRadius:"6px",overflow:"hidden"}},["oscillator","noise","sample"].map(function(e){return a.createElement("button",{key:e,onClick:function(){return s(e)},style:{padding:"8px 16px",background:l===e?{oscillator:"#10b981",noise:"#f59e0b",sample:"#8b5cf6"}[e]:"#374151",color:l===e?"#000":"#cbd5e1",border:"none",fontSize:"14px",fontWeight:"700",cursor:"pointer",textTransform:"capitalize"}},e)})),"sample"===l&&a.createElement("div",{style:{display:"flex",gap:"8px",alignItems:"center"}},a.createElement("input",{ref:_,type:"file",accept:".wav,.mp3,.ogg,.flac,.aac",onChange:W,style:{display:"none"}}),a.createElement("button",{onClick:function(){var e;return null===(e=_.current)||void 0===e?void 0:e.click()},disabled:R,style:{padding:"6px 12px",background:R?"#6b7280":"#8b5cf6",color:"#fff",border:"none",borderRadius:"4px",fontSize:"12px",fontWeight:"600",cursor:R?"not-allowed":"pointer"}},R?" Loading...":" Load Audio File"),S&&a.createElement("span",{style:{color:"#8b5cf6",fontSize:"12px"}}," ",S.duration.toFixed(1),"s @ ",S.sampleRate,"Hz"))),a.createElement("button",{onClick:o,style:{background:"#dc2626",color:"#fff",border:"none",borderRadius:"6px",padding:"8px 16px",cursor:"pointer",fontSize:"14px",fontWeight:"700"}},"Close Editor")),a.createElement("div",{style:{flex:1,display:"flex",justifyContent:"center",alignItems:"center"}},a.createElement("canvas",{ref:m,width:800,height:400,onMouseDown:Y,onMouseMove:X,onMouseUp:Z,onMouseLeave:Z,onDragOver:H,onDrop:V,style:{border:"sample"!==l||S?"2px solid #374151":"2px dashed #8b5cf6",borderRadius:"8px",backgroundColor:"#0f172a",maxWidth:"100%",maxHeight:"100%",cursor:h?"grabbing":"grab"}})),a.createElement("div",{style:{marginTop:"20px",padding:"16px",background:"#111827",borderRadius:"8px",fontSize:"12px",color:"#94a3b8"}},a.createElement("strong",null,"Legend:"),a.createElement("span",{style:{color:"#4b5563",marginLeft:"12px"}}," Original Waveform"),a.createElement("span",{style:{color:{oscillator:"#10b981",noise:"#f59e0b",sample:"#8b5cf6"}[l],marginLeft:"12px"}}," Enveloped Waveform"),a.createElement("span",{style:{color:"#ef4444",marginLeft:"12px"}}," Envelope Shape"))))};function Ve(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,r,c,i=[],l=!0,s=!1;try{if(r=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=r.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(c=t.return(),Object(c)!==c))return}finally{if(s)throw o}}return i}}(e,n)||function(e,n){if(e){if("string"==typeof e)return He(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?He(e,n):void 0}}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function He(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}var je=(0,a.createContext)(),Ke=function(){var e=(0,a.useContext)(je);if(!e)throw new Error("useTransfer must be used within a TransferProvider");return e},$e=function(e){var n=e.children,t=Ve((0,a.useState)([]),2),o=t[0],r=t[1],c=Ve((0,a.useState)(null),2),i=c[0],l=c[1],s={transferQueue:o,setTransferQueue:r,currentTransfer:i,setCurrentTransfer:l,getOverallProgress:function(){if(0===o.length)return{current:0,total:0,percentage:0};var e=o.filter(function(e){return"completed"===e.status}).length,n=o.length,t=0,a=o.find(function(e){return"transferring"===e.status});a&&(t=a.progress/100);var r=(e+t)/n*100;return{current:e+(a?1:0),total:n,percentage:Math.min(100,Math.max(0,r)),currentFile:a?a.filename:null,currentFileProgress:a?a.progress:0}},hasActiveTransfers:function(){return o.some(function(e){return"transferring"===e.status||"queued"===e.status})}};return a.createElement(je.Provider,{value:s},n)};function Ye(e){return Ye="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Ye(e)}function Xe(e){return function(e){if(Array.isArray(e))return ln(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||cn(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Ze(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function Qe(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?Ze(Object(t),!0).forEach(function(n){Je(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):Ze(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function Je(e,n,t){return(n=function(e){var n=function(e){if("object"!=Ye(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=Ye(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==Ye(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function en(e,n){var t="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=cn(e))||n&&e&&"number"==typeof e.length){t&&(e=t);var a=0,o=function(){};return{s:o,n:function(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function(e){throw e},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,c=!0,i=!1;return{s:function(){t=t.call(e)},n:function(){var e=t.next();return c=e.done,e},e:function(e){i=!0,r=e},f:function(){try{c||null==t.return||t.return()}finally{if(i)throw r}}}}function nn(){var e,n,t="function"==typeof Symbol?Symbol:{},a=t.iterator||"@@iterator",o=t.toStringTag||"@@toStringTag";function r(t,a,o,r){var l=a&&a.prototype instanceof i?a:i,s=Object.create(l.prototype);return tn(s,"_invoke",function(t,a,o){var r,i,l,s=0,u=o||[],d=!1,p={p:0,n:0,v:e,a:f,f:f.bind(e,4),d:function(n,t){return r=n,i=0,l=e,p.n=t,c}};function f(t,a){for(i=t,l=a,n=0;!d&&s&&!o&&n<u.length;n++){var o,r=u[n],f=p.p,m=r[2];t>3?(o=m===a)&&(l=r[(i=r[4])?5:(i=3,3)],r[4]=r[5]=e):r[0]<=f&&((o=t<2&&f<r[1])?(i=0,p.v=a,p.n=r[1]):f<m&&(o=t<3||r[0]>a||a>m)&&(r[4]=t,r[5]=a,p.n=m,i=0))}if(o||t>1)return c;throw d=!0,a}return function(o,u,m){if(s>1)throw TypeError("Generator is already running");for(d&&1===u&&f(u,m),i=u,l=m;(n=i<2?e:l)||!d;){r||(i?i<3?(i>1&&(p.n=-1),f(i,l)):p.n=l:p.v=l);try{if(s=2,r){if(i||(o="next"),n=r[o]){if(!(n=n.call(r,l)))throw TypeError("iterator result is not an object");if(!n.done)return n;l=n.value,i<2&&(i=0)}else 1===i&&(n=r.return)&&n.call(r),i<2&&(l=TypeError("The iterator does not provide a '"+o+"' method"),i=1);r=e}else if((n=(d=p.n<0)?l:t.call(a,p))!==c)break}catch(n){r=e,i=1,l=n}finally{s=1}}return{value:n,done:d}}}(t,o,r),!0),s}var c={};function i(){}function l(){}function s(){}n=Object.getPrototypeOf;var u=[][a]?n(n([][a]())):(tn(n={},a,function(){return this}),n),d=s.prototype=i.prototype=Object.create(u);function p(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,s):(e.__proto__=s,tn(e,o,"GeneratorFunction")),e.prototype=Object.create(d),e}return l.prototype=s,tn(d,"constructor",s),tn(s,"constructor",l),l.displayName="GeneratorFunction",tn(s,o,"GeneratorFunction"),tn(d),tn(d,o,"Generator"),tn(d,a,function(){return this}),tn(d,"toString",function(){return"[object Generator]"}),(nn=function(){return{w:r,m:p}})()}function tn(e,n,t,a){var o=Object.defineProperty;try{o({},"",{})}catch(e){o=0}tn=function(e,n,t,a){function r(n,t){tn(e,n,function(e){return this._invoke(n,t,e)})}n?o?o(e,n,{value:t,enumerable:!a,configurable:!a,writable:!a}):e[n]=t:(r("next",0),r("throw",1),r("return",2))},tn(e,n,t,a)}function an(e,n,t,a,o,r,c){try{var i=e[r](c),l=i.value}catch(e){return void t(e)}i.done?n(l):Promise.resolve(l).then(a,o)}function on(e){return function(){var n=this,t=arguments;return new Promise(function(a,o){var r=e.apply(n,t);function c(e){an(r,a,o,c,i,"next",e)}function i(e){an(r,a,o,c,i,"throw",e)}c(void 0)})}}function rn(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,r,c,i=[],l=!0,s=!1;try{if(r=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=r.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(c=t.return(),Object(c)!==c))return}finally{if(s)throw o}}return i}}(e,n)||cn(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function cn(e,n){if(e){if("string"==typeof e)return ln(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?ln(e,n):void 0}}function ln(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}function sn(e){var n,t,a,o=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,a=Symbol.iterator);o--;){if(t&&null!=(n=e[t]))return n.call(e);if(a&&null!=(n=e[a]))return new un(n.call(e));t="@@asyncIterator",a="@@iterator"}throw new TypeError("Object is not async iterable")}function un(e){function n(e){if(Object(e)!==e)return Promise.reject(new TypeError(e+" is not an object."));var n=e.done;return Promise.resolve(e.value).then(function(e){return{value:e,done:n}})}return un=function(e){this.s=e,this.n=e.next},un.prototype={s:null,n:null,next:function(){return n(this.n.apply(this.s,arguments))},return:function(e){var t=this.s.return;return void 0===t?Promise.resolve({value:e,done:!0}):n(t.apply(this.s,arguments))},throw:function(e){var t=this.s.return;return void 0===t?Promise.reject(e):n(t.apply(this.s,arguments))}},new un(e)}const dn=function(e){var n=e.module,t=e.onUpdateParam,o=e.onClose,r=(e.modules,(0,a.useRef)()),c=(0,a.useRef)(),i=rn((0,a.useState)(null),2),l=i[0],s=i[1],u=rn((0,a.useState)(null),2),d=u[0],p=u[1],f=rn((0,a.useState)(!1),2),m=(f[0],f[1],rn((0,a.useState)(0),2)),_=m[0],g=m[1],h=rn((0,a.useState)(!1),2),v=h[0],b=h[1],y=rn((0,a.useState)(.2),2),k=y[0],S=y[1],x=rn((0,a.useState)(.8),2),E=x[0],P=x[1],w=rn((0,a.useState)(0),2),C=w[0],R=w[1],L=rn((0,a.useState)(0),2),I=L[0],M=L[1],D=rn((0,a.useState)(1),2),A=D[0],O=D[1],T=rn((0,a.useState)(44100),2),B=T[0],z=T[1],F=rn((0,a.useState)(null),2),N=F[0],G=F[1],q=rn((0,a.useState)(0),2),U=(q[0],q[1]),W=rn((0,a.useState)(0),2),V=W[0],H=W[1],j=rn((0,a.useState)(0),2),K=j[0],$=j[1],Y=rn((0,a.useState)(60),2),X=Y[0],Z=Y[1],Q=rn((0,a.useState)(1),2),J=Q[0],ee=(Q[1],rn((0,a.useState)(1),2)),ne=ee[0],te=ee[1],ae=rn((0,a.useState)(0),2),oe=ae[0],re=ae[1],ce=rn((0,a.useState)(.8),1)[0],ie=rn((0,a.useState)("normal"),2),le=ie[0],se=ie[1],ue=rn((0,a.useState)("manual"),2),de=ue[0],pe=ue[1],fe=rn((0,a.useState)("stopped"),2),me=fe[0],_e=fe[1],ge=rn((0,a.useState)(null),2),he=ge[0],ve=ge[1],be=rn((0,a.useState)("disconnected"),2),ye=be[0],ke=be[1],Se=rn((0,a.useState)(null),2),xe=Se[0],Ee=Se[1],Pe=Ke(),we=Pe.transferQueue,Ce=Pe.setTransferQueue,Re=rn((0,a.useState)([]),2),Le=Re[0],Ie=Re[1],Me=rn((0,a.useState)(null),2),De=Me[0],Ae=Me[1],Oe=(0,a.useRef)(null),Te=rn((0,a.useState)(0),2),Be=Te[0],ze=Te[1],Fe=rn((0,a.useState)(""),2),Ne=(Fe[0],Fe[1]);(0,a.useEffect)(function(){console.log("useEffect triggered - localTransferQueue.length:",Le.length,"localCurrentTransfer:",De),Le.length>0&&!De?(console.log("useEffect: Local queue has items and no current transfer, processing queue..."),Kn()):console.log("useEffect: Not processing local queue - length:",Le.length,"localCurrentTransfer:",!!De)},[Le,De]),(0,a.useEffect)(function(){console.log("localCurrentTransfer changed to:",De)},[De]);var Ge=rn((0,a.useState)(null),2),qe=Ge[0],Ue=Ge[1],Ve=rn((0,a.useState)("not_connected"),2),He=Ve[0],je=Ve[1],$e=rn((0,a.useState)(!1),2),Ye=($e[0],$e[1],rn((0,a.useState)("oscillator"),2)),Ze=Ye[0],tn=Ye[1],an=rn((0,a.useState)(null),2),cn=(an[0],an[1],rn((0,a.useState)(0),2)),ln=(cn[0],cn[1],rn((0,a.useState)(0),2)),un=(ln[0],ln[1],rn((0,a.useState)({osc_level:n.params.osc_level||.7,noise_level:n.params.noise_level||.3,sample_level:n.params.sample_level||0,osc_mute:n.params.osc_mute||!1,noise_mute:n.params.noise_mute||!1,sample_mute:n.params.sample_mute||!1}),2)),dn=un[0],pn=un[1],fn=rn((0,a.useState)(!1),2),mn=fn[0],_n=fn[1],gn=rn((0,a.useState)(0),2),hn=gn[0],vn=gn[1],bn=rn((0,a.useState)(0),2),yn=bn[0],kn=bn[1],Sn=(0,a.useRef)(null),xn=(0,a.useRef)([]),En=(0,a.useRef)(null),Pn=(0,a.useRef)(null),wn=(0,a.useRef)(null);(0,a.useEffect)(function(){pn({osc_level:n.params.osc_level||.7,noise_level:n.params.noise_level||.3,sample_level:n.params.sample_level||0,osc_mute:n.params.osc_mute||!1,noise_mute:n.params.noise_mute||!1,sample_mute:n.params.sample_mute||!1})},[n.params.osc_level,n.params.noise_level,n.params.sample_level,n.params.osc_mute,n.params.noise_mute,n.params.sample_mute]);var Cn=(0,a.useCallback)(function(e,a){try{t.length>=3&&void 0!==(null==n?void 0:n.id)?(console.log(" Sending param with 3-arg signature:",n.id,e,a),t(n.id,e,a)):(console.log(" Sending param with 2-arg signature:",e,a),t(e,a))}catch(n){console.warn(" Error sending param, falling back to 2-arg:",n),t(e,a)}},[t,null==n?void 0:n.id]),Rn=rn((0,a.useState)(null),2),Ln=Rn[0],In=Rn[1],Mn=rn((0,a.useState)(null),2),Dn=Mn[0],An=Mn[1],On=rn((0,a.useState)(null),2),Tn=On[0],Bn=On[1];(0,a.useEffect)(function(){l&&zn(l)},[ne,oe,l,k,E,C,I,_,me,N]);var zn=function(e){var n=r.current;if(n&&e){var t=n.getContext("2d"),a=n.width,o=n.height;t.clearRect(0,0,a,o),t.fillStyle="#0b1220",t.fillRect(0,0,a,o);var c=e.getChannelData?e.getChannelData(0):e,i=c.length,l=Math.floor(i/ne),s=Math.floor(oe*(i-l)),u=Math.max(0,s),d=Math.min(i,u+l),p=d-u,f=Math.max(1,Math.floor(p/a));if(t.strokeStyle="#10b981",t.lineWidth=1,f>1){t.fillStyle="#10b981";for(var m=0;m<a;m++){for(var g=u+Math.floor(m*f),h=Math.min(d,u+Math.floor((m+1)*f)),v=0,b=0,y=g;y<h;y++)y<c.length&&(v=Math.min(v,c[y]),b=Math.max(b,c[y]));var S=o/2-v*o*ce*.45,x=o/2-b*o*ce*.45;t.fillRect(m,Math.min(S,x),1,Math.abs(x-S)||1)}}else{t.beginPath();for(var P=0;P<a;P++){var w=u+Math.floor(P*f);if(w<c.length){var R=o/2-c[w]*o*ce*.45;0===P?t.moveTo(P,R):t.lineTo(P,R)}}t.stroke()}var L=u/i,M=d/i,D=M-L,A=(k-L)/D*a,O=(E-L)/D*a;if(A<a&&O>0&&A<O){var T=Math.max(0,A),B=Math.min(a,O);t.fillStyle="rgba(34, 197, 94, 0.1)",t.fillRect(T,0,B-T,o)}if(A>=-20&&A<=a+20){t.strokeStyle="loopStart"===N?"#34d399":"#22c55e",t.lineWidth="loopStart"===N?4:2,t.beginPath(),t.moveTo(A,0),t.lineTo(A,o),t.stroke();t.fillStyle="loopStart"===N?"#34d399":"#22c55e",t.fillRect(A-8,0,16,18),t.strokeStyle="#000000",t.lineWidth=2,t.strokeRect(A-8,0,16,18),t.strokeStyle="#ffffff",t.lineWidth=1,t.strokeRect(A-8+1,1,14,16),t.fillStyle="#000000",t.font="bold 12px monospace",t.textAlign="center",t.fillText("S",A,13)}if(O>=-20&&O<=a+20){t.strokeStyle="loopEnd"===N?"#f87171":"#dc2626",t.lineWidth="loopEnd"===N?4:2,t.beginPath(),t.moveTo(O,0),t.lineTo(O,o),t.stroke();t.fillStyle="loopEnd"===N?"#f87171":"#dc2626",t.fillRect(O-8,0,16,18),t.strokeStyle="#000000",t.lineWidth=2,t.strokeRect(O-8,0,16,18),t.strokeStyle="#ffffff",t.lineWidth=1,t.strokeRect(O-8+1,1,14,16),t.fillStyle="#000000",t.font="bold 12px monospace",t.textAlign="center",t.fillText("E",O,13)}var z=E-k,F=k+C*z,G=E-I*z;if(C>0&&F>=L&&k<=M){var q=Math.max(0,(k-L)/D*a),U=Math.min(a,(F-L)/D*a);U>q&&(t.fillStyle="rgba(34, 197, 94, 0.2)",t.fillRect(q,0,U-q,o))}if(I>0&&G<=M&&E>=L){var W=Math.max(0,(G-L)/D*a),V=Math.min(a,(E-L)/D*a);V>W&&(t.fillStyle="rgba(239, 68, 68, 0.2)",t.fillRect(W,0,V-W,o))}if("playing"===me&&_>=L&&_<=M){var H=(_-L)/D*a;t.strokeStyle="#f59e0b",t.lineWidth=3,t.beginPath(),t.moveTo(H,0),t.lineTo(H,o),t.stroke()}}},Fn=function(e){console.log("Processing file:",e.name,"Type:",e.type,"Size:",e.size);var n=new FileReader;n.onload=function(){var n=on(nn().m(function n(t){var a,o,r,c,i,l,u;return nn().w(function(n){for(;;)switch(n.p=n.n){case 0:if(n.p=0,(a=Ln)&&"closed"!==a.state||(a=new(window.AudioContext||window.webkitAudioContext),In(a)),"suspended"!==a.state){n.n=1;break}return n.n=1,a.resume();case 1:return o=t.target.result,console.log("ArrayBuffer size:",o.byteLength),n.n=2,a.decodeAudioData(o);case 2:r=n.v,console.log("Decoded buffer:",{duration:r.duration,sampleRate:r.sampleRate,numberOfChannels:r.numberOfChannels,length:r.length}),p(r),c=r.getChannelData(0),i=new Float32Array(c),s(i),S(.2),P(.8),g(.2),(l=a.createGain()).connect(a.destination),Bn(l),z(r.sampleRate),Cn("sample_name",e.name.replace(/\.[^/.]+$/,"")),console.log("File processed successfully"),n.n=4;break;case 3:n.p=3,u=n.v,console.error("Failed to decode audio file:",u),alert("Failed to load audio file: ".concat(e.name,"\n\nError: ").concat(u.message,"\n\nPlease try a different file format (WAV, MP3, or OGG)."));case 4:return n.a(2)}},n,null,[[0,3]])}));return function(e){return n.apply(this,arguments)}}(),n.readAsArrayBuffer(e)},Nn=function(){var e=on(nn().m(function e(){var n,t,a,o,r,c,i,l,s;return nn().w(function(e){for(;;)switch(e.p=e.n){case 0:return e.p=0,e.n=1,navigator.mediaDevices.getUserMedia({audio:{sampleRate:44100,channelCount:1,echoCancellation:!1,noiseSuppression:!1,autoGainControl:!1}});case 1:n=e.v,wn.current=n,t=new(window.AudioContext||window.webkitAudioContext),a=t.createAnalyser(),o=t.createMediaStreamSource(n),a.fftSize=256,o.connect(a),Pn.current={analyser:a,audioCtx:t},r=function(){if(mn){var e=new Uint8Array(a.frequencyBinCount);a.getByteTimeDomainData(e);for(var n=0,t=0;t<e.length;t++){var o=Math.abs((e[t]-128)/128);o>n&&(n=o)}kn(n),requestAnimationFrame(r)}},c=MediaRecorder.isTypeSupported("audio/webm;codecs=opus")?"audio/webm;codecs=opus":"audio/webm",i=new MediaRecorder(n,{mimeType:c}),xn.current=[],i.ondataavailable=function(e){e.data.size>0&&xn.current.push(e.data)},i.onstop=on(nn().m(function e(){var t,a;return nn().w(function(e){for(;;)switch(e.p=e.n){case 0:return n.getTracks().forEach(function(e){return e.stop()}),t=new Blob(xn.current,{type:c}),e.p=1,e.n=2,Gn(t);case 2:e.n=4;break;case 3:e.p=3,a=e.v,console.error("Failed to convert recording:",a),alert("Failed to process recording. Please try again.");case 4:Pn.current&&(Pn.current.audioCtx.close(),Pn.current=null),wn.current=null,kn(0),vn(0),En.current&&(clearInterval(En.current),En.current=null);case 5:return e.a(2)}},e,null,[[1,3]])})),Sn.current=i,i.start(),_n(!0),l=Date.now(),En.current=setInterval(function(){vn((Date.now()-l)/1e3)},100),r(),e.n=3;break;case 2:e.p=2,s=e.v,console.error("Failed to start recording:",s),alert("Failed to access microphone.\n\nError: ".concat(s.message,"\n\nPlease grant microphone permissions."));case 3:return e.a(2)}},e,null,[[0,2]])}));return function(){return e.apply(this,arguments)}}(),Gn=function(){var e=on(nn().m(function e(n){var a,o,r,c,i,l,u,d,f,m,_,g,h,v,b,y,k,S;return nn().w(function(e){for(;;)switch(e.n){case 0:return e.n=1,n.arrayBuffer();case 1:return a=e.v,e.n=2,Ln.decodeAudioData(a);case 2:if(o=e.v,r=44100,c=Math.floor(o.duration*r),i=Ln.createBuffer(1,c,r),l=i.getChannelData(0),1===o.numberOfChannels)for(u=o.getChannelData(0),d=o.sampleRate/r,f=0;f<c;f++)m=Math.floor(f*d),l[f]=u[Math.min(m,u.length-1)];else for(_=o.getChannelData(0),g=o.getChannelData(1),h=o.sampleRate/r,v=0;v<c;v++)b=Math.floor(v*h),y=Math.min(b,_.length-1),l[v]=(_[y]+g[y])/2;s(i),p(i),k=(new Date).toISOString().slice(11,19).replace(/:/g,"-"),S="recorded_".concat(k,".wav"),t("sample_name",S),console.log("Recording converted: ".concat(c," samples, ").concat(r,"Hz, mono")),alert("Recording captured!\n\nDuration: ".concat(o.duration.toFixed(1),"s\nName: ").concat(S,"\n\nYou can now edit and save to SD card."));case 3:return e.a(2)}},e)}));return function(n){return e.apply(this,arguments)}}(),qn=function(){var e=on(nn().m(function e(){var n,t,a,o,r,c,i,l,s,u,p,f;return nn().w(function(e){for(;;)switch(e.p=e.n){case 0:if(d&&Ln){e.n=1;break}return console.warn("No audio buffer or context available"),d||alert("Please load an audio file first."),e.a(2);case 1:if("playing"!==me){e.n=2;break}if(Dn){try{Dn.stop()}catch(e){console.warn("Error stopping audio source:",e)}An(null)}return he&&(clearInterval(he),ve(null)),_e("stopped"),e.a(2);case 2:if(e.p=2,"suspended"!==Ln.state){e.n=4;break}return e.n=3,Ln.resume();case 3:console.log("Audio context resumed");case 4:n=d,t=100*V+K,a=Math.pow(2,t/1200)*J,console.log("Starting playback with:",{pitchRatio:a,loopStart:k,loopEnd:E,playbackMode:le,volume:A,bufferDuration:n.duration}),(o=Ln.createBufferSource()).buffer=n,o.playbackRate.value=a,(r=Ln.createGain()).gain.value=.5*A,Bn(r),o.connect(r),r.connect(Ln.destination),c=k*n.duration,i=E*n.duration,l=i-c,"loop"!==le&&"sustain"!==le||(o.loop=!0,o.loopStart=c,o.loopEnd=i,console.log("Loop enabled:",{startTime:c,endTime:i})),"loop"===le||"sustain"===le?o.start(0,c):o.start(0,c,l),An(o),_e("playing"),g("reverse"===le?E:k),s=Date.now(),u=E-k,p=setInterval(function(){var e=(Date.now()-s)/1e3;g(function(n){var t;if("reverse"===le){if((t=E-e*a/(i-c)*u)<=k)return"loop"===le||"sustain"===le?E:k}else if((t=k+e*a/(i-c)*u)>=E)return"loop"===le||"sustain"===le?k+(t-k)%u:E;return t})},50),ve(p),o.onended=function(){console.log("Playback ended"),_e("stopped"),g(k),p&&(clearInterval(p),ve(null)),An(null),Bn(null)},console.log("Playback started successfully"),e.n=6;break;case 5:e.p=5,f=e.v,console.error("Error playing audio:",f),alert("Could not play audio: ".concat(f.message,"\n\nPlease check that your browser supports Web Audio API and audio is not muted."));case 6:return e.a(2)}},e,null,[[2,5]])}));return function(){return e.apply(this,arguments)}}();(0,a.useEffect)(function(){"auto"===de&&(R(.1),M(.1))},[de,k,E]),(0,a.useEffect)(function(){if("playing"===me&&Dn&&Ln){var e=100*V+K,n=Math.pow(2,e/1200)*J;Dn.playbackRate.value=n,Tn&&(Tn.gain.value=.5*A),console.log("Updated real-time params:",{pitchRatio:n,volume:.5*A})}},[V,K,J,A,me,Dn,Tn,Ln]),(0,a.useEffect)(function(){if("playing"===me&&Dn&&d&&("loop"===le||"sustain"===le)){var e=k*d.duration,n=E*d.duration;Dn.loopStart=e,Dn.loopEnd=n,console.log("Updated loop points in real-time:",{loopStart:e,loopEnd:n})}},[k,E,me,Dn,d,le]),(0,a.useEffect)(function(){return function(){he&&clearInterval(he)}},[he]);var Un=function(){if(!l)return null;var e=l;if(0!==V||0!==K||1!==J){var n=100*V+K,t=Math.pow(2,n/1200)*J,a=Math.floor(l.length/t);e=new Float32Array(a);for(var o=0;o<a;o++){var r=o*t,c=Math.floor(r),i=Math.min(c+1,l.length-1),s=r-c;e[o]=l[c]*(1-s)+l[i]*s}}1!==A&&(e=e.map(function(e){return e*A}));for(var u=0;u<e.length;u++){var d=u/e.length,p=1;C>0&&d<C&&(p*=d/C),I>0&&d>1-I&&(p*=(1-d)/I),e[u]*=p}var f=e.length,m=1*B*2,_=2*f,g=44+_,h=new ArrayBuffer(g),v=new DataView(h),b=function(e,n){for(var t=0;t<n.length;t++)v.setUint8(e+t,n.charCodeAt(t))};b(0,"RIFF"),v.setUint32(4,g-8,!0),b(8,"WAVE"),b(12,"fmt "),v.setUint32(16,16,!0),v.setUint16(20,1,!0),v.setUint16(22,1,!0),v.setUint32(24,B,!0),v.setUint32(28,m,!0),v.setUint16(32,2,!0),v.setUint16(34,16,!0),b(36,"data"),v.setUint32(40,_,!0);for(var y=44,k=0;k<f;k++){var S=e[k];S=Math.max(-1,Math.min(1,S)),S*=32767,v.setInt16(y,S,!0),y+=2}return h},Wn=function(){var e=on(nn().m(function e(){var n,t,a;return nn().w(function(e){for(;;)switch(e.p=e.n){case 0:if(!("serial"in navigator)){e.n=7;break}return e.p=1,e.n=2,navigator.serial.requestPort();case 2:return n=e.v,e.n=3,n.open({baudRate:921600});case 3:return Ee(n),ke("synth"),t=n.writable.getWriter(),e.n=4,t.write((new TextEncoder).encode("STATUS\n"));case 4:t.releaseLock(),Vn(n),e.n=6;break;case 5:e.p=5,a=e.v,console.error("Failed to connect to hardware:",a),alert("Failed to connect to ESP32. Make sure it's plugged in and the correct port is selected.");case 6:e.n=8;break;case 7:alert("Web Serial API not supported. Please use Chrome/Edge browser.");case 8:return e.a(2)}},e,null,[[1,5]])}));return function(){return e.apply(this,arguments)}}(),Vn=function(){var e=on(nn().m(function e(n){var t,a,o,r,c,i,l,s,u,d,p,f,m;return nn().w(function(e){for(;;)switch(e.p=e.n){case 0:t=n.readable.getReader(),a=new TextDecoder,o="",e.p=1;case 2:return e.n=3,t.read();case 3:if(r=e.v,c=r.value,!r.done){e.n=4;break}return e.a(3,13);case 4:o+=a.decode(c,{stream:!0}),i=o.split("\n"),o=i.pop()||"",l=en(i),e.p=5,l.s();case 6:if((s=l.n()).done){e.n=9;break}if(u=s.value,0!==(d=u.trim()).length){e.n=7;break}return e.a(3,8);case 7:console.log("Received from ESP32:",d),"MODE:SYNTH"===d?ke("synth"):"MODE:USB"===d?ke("usb"):"MODE:SWITCHING"===d?ke("switching"):d.startsWith("SD:FILE:READY")?(console.log("ESP32 ready - uploading current transfer from queue"),Hn(n)):d.startsWith("SD:SAVE:COMPLETE")?Yn(d):d.startsWith("SD:PROGRESS:")?(p=parseFloat(d.split(":")[2]),console.log("Progress update:",p),Zn(p)):(d.startsWith("SD:LIST:")||d.startsWith("SD:FILE:"))&&window.sdFileListHandler&&window.sdFileListHandler(d);case 8:e.n=6;break;case 9:e.n=11;break;case 10:e.p=10,f=e.v,l.e(f);case 11:return e.p=11,l.f(),e.f(11);case 12:e.n=2;break;case 13:e.n=15;break;case 14:e.p=14,m=e.v,console.error("Error reading from hardware:",m);case 15:return e.p=15,t.releaseLock(),e.f(15);case 16:return e.a(2)}},e,null,[[5,10,11,12],[1,14,15,16]])}));return function(n){return e.apply(this,arguments)}}(),Hn=function(){var e=on(nn().m(function e(n){var t,a,o,r,c,i,l;return nn().w(function(e){for(;;)switch(e.p=e.n){case 0:if(console.log("uploadCurrentTransfer - localCurrentTransfer:",De),console.log("uploadCurrentTransfer - currentTransferRef.current:",Oe.current),console.log("uploadCurrentTransfer - localTransferQueue:",Le),console.log("uploadCurrentTransfer - localTransferQueue.length:",Le.length),t=Oe.current||De||Le[0]){e.n=1;break}return console.log("No current transfer to upload - both currentTransfer and transferQueue[0] are null"),e.a(2);case 1:console.log("Uploading current transfer:",t),e.p=2,a=n.writable.getWriter(),o=1024,r=new Uint8Array(t.data),console.log("Sending ".concat(r.length," bytes in ").concat(Math.ceil(r.length/o)," chunks")),c=0;case 3:if(!(c<r.length)){e.n=6;break}return i=r.slice(c,c+o),e.n=4,a.write(i);case 4:return c%102400==0&&console.log("Sent ".concat(c," / ").concat(r.length," bytes")),e.n=5,new Promise(function(e){return setTimeout(e,10)});case 5:c+=o,e.n=3;break;case 6:console.log("Finished sending file data"),a.releaseLock(),e.n=8;break;case 7:e.p=7,l=e.v,console.error("Upload failed:",l),Xn(t.id,"Upload failed: "+l.message);case 8:return e.a(2)}},e,null,[[2,7]])}));return function(n){return e.apply(this,arguments)}}(),jn=function(){var e=on(nn().m(function e(){var n;return nn().w(function(e){for(;;)switch(e.p=e.n){case 0:if(!xe){e.n=5;break}return e.p=1,e.n=2,xe.close();case 2:e.n=4;break;case 3:e.p=3,n=e.v,console.error("Error closing serial port:",n);case 4:Ee(null);case 5:ke("disconnected");case 6:return e.a(2)}},e,null,[[1,3]])}));return function(){return e.apply(this,arguments)}}(),Kn=function(){var e=on(nn().m(function e(){var n,t,a,o;return nn().w(function(e){for(;;)switch(e.p=e.n){case 0:if(console.log("processLocalTransferQueue called - queue length:",Le.length,"localCurrentTransfer:",De),0!==Le.length&&!De){e.n=1;break}return console.log("Local queue empty or transfer in progress, returning"),e.a(2);case 1:return n=Le[0],console.log("Processing local transfer:",n),console.log("Setting localCurrentTransfer and ref to:",n),Ae(n),Oe.current=n,e.p=2,ke("transferring"),t=xe.writable.getWriter(),a="SD:FILE:".concat(n.filename,":").concat(n.size,"\n"),console.log("Sending to ESP32:",a.trim()),e.n=3,t.write((new TextEncoder).encode(a));case 3:t.releaseLock(),e.n=5;break;case 4:e.p=4,o=e.v,console.error("Failed to start local transfer:",o),Ae(null),ke("synth");case 5:return e.a(2)}},e,null,[[2,4]])}));return function(){return e.apply(this,arguments)}}(),$n=function(){var e=on(nn().m(function e(){var n,t,a,o;return nn().w(function(e){for(;;)switch(e.p=e.n){case 0:return console.log("processTransferQueue called - this function is deprecated"),console.log("Queue empty or transfer in progress, returning"),e.a(2);case 1:return n=transferQueue[0],console.log("Processing transfer:",n),setCurrentTransfer(n),Ae(n),setTransferQueue(function(e){return e.map(function(e){return e.id===n.id?Qe(Qe({},e),{},{status:"transferring"}):e})}),e.p=2,ke("transferring"),t=xe.writable.getWriter(),a="SD:FILE:".concat(n.filename,":").concat(n.size,"\n"),console.log("Sending to ESP32:",a.trim()),e.n=3,t.write((new TextEncoder).encode(a));case 3:t.releaseLock(),e.n=5;break;case 4:e.p=4,o=e.v,console.error("Failed to start transfer:",o),Xn(n.id,"Failed to start transfer");case 5:return e.a(2)}},e,null,[[2,4]])}));return function(){return e.apply(this,arguments)}}(),Yn=function(e){De&&(Ie(function(e){return e.filter(function(e){return e.id!==De.id})}),Ae(null),ke("synth"),console.log("Transfer completed:",e),setTimeout(function(){$n()},100))},Xn=function(e,n){setTransferQueue(function(t){return t.map(function(t){return t.id===e?Qe(Qe({},t),{},{status:"error",error:n}):t})}),setCurrentTransfer(null),ke("synth"),setTimeout(function(){$n()},1e3)},Zn=function(e){console.log("updateTransferProgress called:",e,"localCurrentTransfer:",De,"ref:",Oe.current);var n=Oe.current||De;n?Ce(function(t){return t.map(function(t){return t.id===n.id?Qe(Qe({},t),{},{progress:e}):t})}):console.log("No active transfer - ignoring progress update")},Qn=function(){var e=on(nn().m(function e(){return nn().w(function(e){for(;;)switch(e.n){case 0:if(xe){e.n=1;break}return e.a(2,[]);case 1:return e.a(2,new Promise(function(e){var n=[],t=!1,a=window.sdFileListHandler;window.sdFileListHandler=function(o){if("SD:LIST:START"===o)t=!0;else if("SD:LIST:END"===o)t=!1,window.sdFileListHandler=a,e(n);else if(t&&o.startsWith("SD:FILE:")){var r=o.split(":");if(r.length>=3){var c=r[2];n.push(c)}}};var o=xe.writable.getWriter();o.write((new TextEncoder).encode("SD:LIST\n")),o.releaseLock(),setTimeout(function(){window.sdFileListHandler=a,e(n)},5e3)}))}},e)}));return function(){return e.apply(this,arguments)}}(),Jn=function(e,n,t){for(var a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=a?function(e){var n=new Date,t=String(n.getDate()).padStart(2,"0"),a=String(n.getMonth()+1).padStart(2,"0"),o=String(n.getFullYear()).slice(-2),r=String(n.getHours()).padStart(2,"0"),c=String(n.getMinutes()).padStart(2,"0"),i="".concat(t).concat(a).concat(o);return 0===e.filter(function(e){return e.includes("/")}).map(function(e){return e.split("/")[0]}).filter(function(e){return e.startsWith("session_".concat(i))}).map(function(e){return e.replace("session_".concat(i),"")}).filter(function(e){return""===e||e.startsWith("_")}).length?"session_".concat(i):"session_".concat(i,"_").concat(r).concat(c)}(t):"",r=o?"".concat(o,"/"):"",c=e.replace(".wav",""),i=n?"_".concat(n.replace(/[^a-zA-Z0-9-_]/g,"_")):"",l="".concat(c).concat(i,".wav"),s="".concat(r).concat(l),u=1;t.includes(s);){var d=2===++u?"a":String.fromCharCode(96+u-1);l="".concat(c).concat(d).concat(i,".wav"),s="".concat(r).concat(l)}return console.log("Generated unique filename: ".concat(s," (session folder: ").concat(!!a,', custom: "').concat(n,'")')),{filename:s,sessionFolder:o}},et=function(){var e=on(nn().m(function e(){var t,a,o,r,c,i,s,u,d,p,f,m;return nn().w(function(e){for(;;)switch(e.n){case 0:if(console.log("saveToHardwareQueued called"),l){e.n=1;break}return alert("No audio loaded to save"),e.a(2);case 1:if(xe){e.n=3;break}return console.log("No serial port, connecting..."),e.n=2,Wn();case 2:return e.a(2);case 3:if(t=Un()){e.n=4;break}return alert("No audio data to save"),e.a(2);case 4:return console.log("Getting existing files from SD card..."),e.n=5,Qn();case 5:a=e.v,console.log("Existing files on SD:",a),r=(o=Be+1)>=2,c=n.params.sample_name||"sample",i=n.params.sample_number||1,s=n.params.custom_suffix||"",u="SDPlayer"===n.type||"SamplePlayer"===n.type?"sample_".concat(i):c.replace(/[^a-zA-Z0-9-_]/g,"_"),d=Jn(u+".wav",s,a,r),p=d.filename,f=d.sessionFolder,ze(o),f&&Ne(f),m={id:Date.now(),filename:p,data:t,size:t.byteLength,progress:0,status:"queued"},console.log("Adding transfer item to local queue:",m),Ie(function(e){return[].concat(Xe(e),[m])}),Ce(function(e){return[].concat(Xe(e),[m])}),console.log("Transfer item added to local queue, useEffect will process it");case 6:return e.a(2)}},e)}));return function(){return e.apply(this,arguments)}}(),nt=function(){var e=on(nn().m(function e(){var n,t;return nn().w(function(e){for(;;)switch(e.p=e.n){case 0:if(!("showDirectoryPicker"in window)){e.n=6;break}return e.p=1,e.n=2,window.showDirectoryPicker({mode:"readwrite"});case 2:return n=e.v,Ue(n),je("connected"),console.log("SD card connected:",n.name),e.n=3,tt(n);case 3:e.n=5;break;case 4:e.p=4,t=e.v,console.error("Failed to connect to SD card:",t),"AbortError"!==t.name&&alert("Failed to connect to SD card. Make sure you select the SD card root folder.");case 5:e.n=7;break;case 6:alert("Direct SD card access not supported in this browser. Please use Chrome/Edge with File System Access API.");case 7:return e.a(2)}},e,null,[[1,4]])}));return function(){return e.apply(this,arguments)}}(),tt=function(){var e=on(nn().m(function e(n){var t,a,o,r,c,i,l,s,u,d;return nn().w(function(e){for(;;)switch(e.p=e.n){case 0:e.p=0,t=!1,a=!1,e.p=1,r=sn(n.entries());case 2:return e.n=3,r.next();case 3:if(!(t=!(c=e.v).done)){e.n=5;break}i=rn(c.value,2),l=i[0],s=i[1],console.log("Found:",l,s.kind);case 4:t=!1,e.n=2;break;case 5:e.n=7;break;case 6:e.p=6,u=e.v,a=!0,o=u;case 7:if(e.p=7,e.p=8,!t||null==r.return){e.n=9;break}return e.n=9,r.return();case 9:if(e.p=9,!a){e.n=10;break}throw o;case 10:return e.f(9);case 11:return e.f(7);case 12:alert("SD card connected successfully!\nDirectory: ".concat(n.name,"\n\nYou can now save samples directly to the SD card.")),e.n=14;break;case 13:e.p=13,d=e.v,console.warn("Could not verify SD card structure:",d);case 14:return e.a(2)}},e,null,[[8,,9,11],[1,6,7,12],[0,13]])}));return function(n){return e.apply(this,arguments)}}(),at=function(){var e=on(nn().m(function e(){var t,a,o,r,c,i,s,u;return nn().w(function(e){for(;;)switch(e.p=e.n){case 0:if(l&&qe){e.n=3;break}if(qe){e.n=2;break}return e.n=1,nt();case 1:return e.a(2);case 2:return alert("No audio loaded to save"),e.a(2);case 3:if(e.p=3,je("writing"),t=Un()){e.n=4;break}return alert("No audio data to save"),je("connected"),e.a(2);case 4:return a=n.params.sample_name||"sample",o=a.replace(/[^a-zA-Z0-9-_]/g,"_"),"SDPlayer"===n.type||"SamplePlayer"===n.type?(c=n.params.sample_number||1,r="sample".concat(c,".wav")):r="".concat(o,".wav"),e.n=5,qe.getFileHandle(r,{create:!0});case 5:return i=e.v,e.n=6,i.createWritable();case 6:return s=e.v,e.n=7,s.write(t);case 7:return e.n=8,s.close();case 8:je("connected"),alert(" Sample saved to SD card successfully!\n\nFile: ".concat(r,"\nSize: ").concat((t.byteLength/1024).toFixed(1)," KB\nFormat: 16-bit WAV at ").concat(B," Hz\n\nThe file is now ready to use with your ESP32 Sample Player module!")),e.n=10;break;case 9:e.p=9,u=e.v,console.error("Failed to save to SD card:",u),je("connected"),"NotAllowedError"===u.name?alert("Permission denied. Please grant write access to the SD card directory."):alert("Failed to save to SD card: ".concat(u.message));case 10:return e.a(2)}},e,null,[[3,9]])}));return function(){return e.apply(this,arguments)}}();(0,a.useEffect)(function(){return function(){jn()}},[]);var ot=function(){N&&rt(k,E),G(null),U(0)},rt=function(e,n){if(l){var t=Math.abs(n-e);if(t<.02&&t<1/ne*.1){var a=Math.min(20,1/(10*t));te(a);var o=(e+n)/2,r=1/a,c=Math.max(0,Math.min(1-r,o-r/2));re(c)}}},ct=["KickDrum","SnareDrum","Percussion"].includes(n.type),it=(0,a.useRef)({isDragging:!1,param:null,startY:0,startValue:0}),lt=function(e,n,t,a){console.log(" SIMPLE Knob MouseDown:",n,t),e.preventDefault(),e.stopPropagation(),it.current={isDragging:!0,param:n,startY:e.clientY,startValue:t},console.log(" Set drag state:",it.current),a&&(tn(a),console.log(" Set active layer to:",a)),console.log(" Adding global mouse listeners IMMEDIATELY"),document.addEventListener("mousemove",st),document.addEventListener("mouseup",ut)},st=function(e){if(console.log(" SIMPLE MouseMove, isDragging:",it.current.isDragging),it.current.isDragging){var n=it.current.startY-e.clientY,t=.005*n,a=Math.max(0,Math.min(1,it.current.startValue+t));if(console.log(" SIMPLE MouseMove:",it.current.param,"deltaY:",n,"newValue:",a),"volume"===it.current.param)O(a),console.log(" Updated volume to:",a);else{var o=it.current.param;pn(function(e){return Qe(Qe({},e),{},Je({},o,a))}),Cn(o,a),console.log(" Updated param",o,"to:",a)}}else console.log(" Not dragging, ignoring")},ut=function(){console.log(" SIMPLE MouseUp, was dragging:",it.current.param),it.current={isDragging:!1,param:null,startY:0,startValue:0},console.log(" Removing global mouse listeners"),document.removeEventListener("mousemove",st),document.removeEventListener("mouseup",ut)};return a.createElement("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(0, 0, 0, 0.8)",zIndex:2e3,display:"flex",alignItems:"center",justifyContent:"center"}},a.createElement("div",{style:{backgroundColor:"#0c1428",border:"1px solid #1f2937",borderRadius:"12px",width:"90vw",height:"85vh",maxWidth:"1200px",maxHeight:"800px",display:"flex",flexDirection:"column",overflow:"hidden"}},a.createElement("div",{style:{padding:"16px 24px",borderBottom:"1px solid #1f2937",display:"flex",justifyContent:"space-between",alignItems:"center"}},a.createElement("h2",{style:{margin:0,color:"#22c55e",fontSize:"18px"}},n.type," Sample Editor"),a.createElement("button",{className:"btn btn-ghost",onClick:o,style:{fontSize:"18px",padding:"4px 8px"}},"")),a.createElement("div",{style:{flex:1,display:"grid",gridTemplateColumns:ct?"120px 1fr":"120px 1fr 250px",gap:"1px",backgroundColor:"#1f2937",minHeight:0}},a.createElement("div",{style:{backgroundColor:"#0c1428",padding:"16px",display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",gap:"20px",borderRight:"1px solid #334155"}},a.createElement("h3",{style:{color:"#e2e8f0",fontSize:"14px",marginBottom:"8px",textAlign:"center"}},"Layer Volumes"),ct?a.createElement(a.Fragment,null,("KickDrum"===n.type||"SnareDrum"===n.type)&&a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("div",{style:{textAlign:"center"}},a.createElement("div",{style:{width:"60px",height:"60px",borderRadius:"50%",background:"conic-gradient(from 0deg, #334155 0deg, #22c55e "+270*dn.osc_level+"deg, #334155 "+270*dn.osc_level+"deg)",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",border:"oscillator"===Ze?"3px solid #22c55e":"2px solid #1f2937",marginBottom:"8px",opacity:dn.osc_mute?.5:1},onMouseDown:function(e){return lt(e,"osc_level",dn.osc_level,"oscillator")},onMouseEnter:function(){return console.log(" Mouse ENTERED oscillator knob")},onMouseLeave:function(){return console.log(" Mouse LEFT oscillator knob")},onClick:function(e){console.log(" Oscillator knob CLICKED",e);var n=dn.osc_level,t=Math.min(1,n+.1);console.log(" TEST: Updating osc_level from",n,"to",t),pn(function(e){return Qe(Qe({},e),{},{osc_level:t})}),Cn("osc_level",t)}},a.createElement("div",{style:{width:"46px",height:"46px",borderRadius:"50%",backgroundColor:"#0f172a",display:"flex",alignItems:"center",justifyContent:"center",color:"#e2e8f0",fontSize:"10px",fontWeight:"bold"}},Math.round(100*dn.osc_level))),a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block"}},"KickDrum"===n.type?"Sub Osc":"Tone")),a.createElement("button",{style:{width:"24px",height:"24px",borderRadius:"4px",border:"none",backgroundColor:dn.osc_mute?"#dc2626":"#374151",color:dn.osc_mute?"#fff":"#9ca3af",fontSize:"10px",fontWeight:"bold",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center"},onClick:function(){var e=!dn.osc_mute;pn(function(n){return Qe(Qe({},n),{},{osc_mute:e})}),Cn("osc_mute",e)},title:"Mute Oscillator Layer"},"M")),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("div",{style:{textAlign:"center"}},a.createElement("div",{style:{width:"60px",height:"60px",borderRadius:"50%",background:"conic-gradient(from 0deg, #334155 0deg, #f59e0b "+270*dn.noise_level+"deg, #334155 "+270*dn.noise_level+"deg)",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",border:"noise"===Ze?"3px solid #f59e0b":"2px solid #1f2937",marginBottom:"8px",opacity:dn.noise_mute?.5:1},onMouseDown:function(e){return lt(e,"noise_level",dn.noise_level,"noise")}},a.createElement("div",{style:{width:"46px",height:"46px",borderRadius:"50%",backgroundColor:"#0f172a",display:"flex",alignItems:"center",justifyContent:"center",color:"#e2e8f0",fontSize:"10px",fontWeight:"bold"}},Math.round(100*dn.noise_level))),a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block"}},"Noise")),a.createElement("button",{style:{width:"24px",height:"24px",borderRadius:"4px",border:"none",backgroundColor:dn.noise_mute?"#dc2626":"#374151",color:dn.noise_mute?"#fff":"#9ca3af",fontSize:"10px",fontWeight:"bold",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center"},onClick:function(){var e=!dn.noise_mute;pn(function(n){return Qe(Qe({},n),{},{noise_mute:e})}),Cn("noise_mute",e)},title:"Mute Noise Layer"},"M")),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("div",{style:{textAlign:"center"}},a.createElement("div",{style:{width:"60px",height:"60px",borderRadius:"50%",background:"conic-gradient(from 0deg, #334155 0deg, #8b5cf6 "+270*dn.sample_level+"deg, #334155 "+270*dn.sample_level+"deg)",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",border:"sample"===Ze?"3px solid #8b5cf6":"2px solid #1f2937",marginBottom:"8px",opacity:dn.sample_mute?.5:1},onMouseDown:function(e){return lt(e,"sample_level",dn.sample_level,"sample")}},a.createElement("div",{style:{width:"46px",height:"46px",borderRadius:"50%",backgroundColor:"#0f172a",display:"flex",alignItems:"center",justifyContent:"center",color:"#e2e8f0",fontSize:"10px",fontWeight:"bold"}},Math.round(100*dn.sample_level))),a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block"}},"Sample")),a.createElement("button",{style:{width:"24px",height:"24px",borderRadius:"4px",border:"none",backgroundColor:dn.sample_mute?"#dc2626":"#374151",color:dn.sample_mute?"#fff":"#9ca3af",fontSize:"10px",fontWeight:"bold",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center"},onClick:function(){var e=!dn.sample_mute;pn(function(n){return Qe(Qe({},n),{},{sample_mute:e})}),Cn("sample_mute",e)},title:"Mute Sample Layer"},"M"))):a.createElement("div",{style:{textAlign:"center"}},a.createElement("div",{style:{width:"60px",height:"60px",borderRadius:"50%",background:"conic-gradient(from 0deg, #334155 0deg, #22c55e "+270*A+"deg, #334155 "+270*A+"deg)",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",border:"2px solid #1f2937",marginBottom:"8px"},onMouseDown:function(e){return lt(e,"volume",A)}},a.createElement("div",{style:{width:"46px",height:"46px",borderRadius:"50%",backgroundColor:"#0f172a",display:"flex",alignItems:"center",justifyContent:"center",color:"#e2e8f0",fontSize:"10px",fontWeight:"bold"}},Math.round(100*A))),a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block"}},"Volume"))),a.createElement("div",{style:{backgroundColor:"#0c1428",display:"flex",flexDirection:"column"}},a.createElement("div",{style:{padding:"12px",borderBottom:"1px solid #1f2937",display:"flex",justifyContent:"space-between",alignItems:"center"}},a.createElement("div",{style:{display:"flex",gap:"8px",alignItems:"center"}},!ct&&a.createElement(a.Fragment,null,a.createElement("div",{style:{display:"flex",gap:"4px",alignItems:"center",marginRight:"12px"}},a.createElement("button",{className:"btn ".concat("playing"===me?"btn-amber":"btn-green"),onClick:qn,disabled:!l,style:{fontSize:"11px",padding:"6px 12px",minWidth:"70px",fontWeight:"600"}},"playing"===me?" Pause":" Play")),a.createElement("div",{style:{display:"flex",gap:"4px",alignItems:"center",marginRight:"12px"}},a.createElement("span",{style:{color:"#cbd5e1",fontSize:"11px"}},"Mode:"),a.createElement("select",{value:le,onChange:function(e){return se(e.target.value)},style:{padding:"2px 4px",borderRadius:"4px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"11px"}},a.createElement("option",{value:"normal"},"Forward"),a.createElement("option",{value:"reverse"},"Reverse"),a.createElement("option",{value:"loop"},"Loop"),a.createElement("option",{value:"sustain"},"Sustain"))))),a.createElement("div",{style:{display:"flex",gap:"12px",alignItems:"center"}},!ct&&a.createElement("div",{style:{display:"flex",gap:"8px",alignItems:"center"}},a.createElement("span",{style:{color:"#cbd5e1",fontSize:"12px"}},"Zoom:"),a.createElement("button",{className:"btn btn-ghost",onClick:function(){return te(function(e){return Math.max(.1,.5*e)})},style:{fontSize:"11px",padding:"2px 6px"}},"-"),a.createElement("span",{style:{color:"#e2e8f0",fontSize:"11px",minWidth:"40px",textAlign:"center"}},ne.toFixed(1),"x"),a.createElement("button",{className:"btn btn-ghost",onClick:function(){return te(function(e){return Math.min(10,2*e)})},style:{fontSize:"11px",padding:"2px 6px"}},"+")))),ct?a.createElement("div",{style:{flex:1,padding:"12px"}},a.createElement(We,{module:n,onUpdateParam:Cn,embedded:!0,activeLayer:Ze,setActiveLayer:tn})):a.createElement("div",{style:{flex:1,padding:"12px"},onDragOver:function(e){e.preventDefault(),e.stopPropagation(),b(!0)},onDragLeave:function(e){e.preventDefault(),e.stopPropagation(),b(!1)},onDrop:function(e){e.preventDefault(),e.stopPropagation(),b(!1);var n=Array.from(e.dataTransfer.files).find(function(e){return e.type.startsWith("audio/")||e.name.toLowerCase().endsWith(".wav")||e.name.toLowerCase().endsWith(".mp3")||e.name.toLowerCase().endsWith(".ogg")});n&&Fn(n)}},a.createElement("div",{style:{position:"relative",width:"100%",height:"100%",backgroundColor:v?"#1e293b":"#0b1220",border:"2px dashed ".concat(v?"#22c55e":"#334155"),borderRadius:"8px",display:"flex",alignItems:"center",justifyContent:"center",cursor:l?"crosshair":"pointer",transition:"all 0.2s ease"}},l?null:a.createElement("div",{style:{textAlign:"center",color:"#94a3b8",fontSize:"14px",userSelect:"none",pointerEvents:"none"}},v?a.createElement("div",null,a.createElement("div",{style:{fontSize:"24px",marginBottom:"8px"}},""),a.createElement("div",{style:{fontWeight:"600",color:"#22c55e"}},"Drop audio file here"),a.createElement("div",{style:{fontSize:"12px",marginTop:"4px"}},"Supports .wav, .mp3, .ogg")):a.createElement("div",null,a.createElement("div",{style:{fontSize:"32px",marginBottom:"12px",opacity:.5}},""),a.createElement("div",{style:{fontWeight:"600",marginBottom:"4px"}},"No sample loaded"),a.createElement("div",{style:{fontSize:"12px"}},"Click here to browse files"),a.createElement("div",{style:{fontSize:"12px",marginTop:"2px"}},"or drag & drop audio files"))),a.createElement("canvas",{ref:r,width:800,height:300,onMouseDown:function(e){if(console.log(" MOUSE DOWN EVENT:",{type:e.type,button:e.button,buttons:e.buttons,target:e.target.tagName,defaultPrevented:e.defaultPrevented}),l){var n=r.current,t=n.getBoundingClientRect(),a=n.width/t.width,o=(e.clientX-t.left)*a,i=o/n.width,s=l?l.getChannelData?l.getChannelData(0).length:l.length:0,u=Math.floor(s/ne),d=Math.floor(oe*(s-u)),p=d/s,f=(d+u)/s-p,m=(k-p)/f*n.width,_=(E-p)/f*n.width;if(console.log(" MARKER POSITIONS:"),console.log("  mouseX:",o),console.log("  loopStart:",k," loopStartX:",m,"(distance:",Math.abs(o-m),")"),console.log("  loopEnd:",E," loopEndX:",_,"(distance:",Math.abs(o-_),")"),console.log("  clickTolerance:",50),console.log("  startInRange:",Math.abs(o-m)<50),console.log("  endInRange:",Math.abs(o-_)<50),Math.abs(o-_)<50)return console.log(" END MARKER HIT! Setting drag state to loopEnd"),console.log(" Current isDragging state before:",N),G("loopEnd"),U(o),e.preventDefault(),e.stopPropagation(),console.log(" Event prevented and propagation stopped"),void setTimeout(function(){console.log(" isDragging state after timeout:",N)},0);if(Math.abs(o-m)<50)return console.log(" START MARKER HIT! Setting drag state to loopStart"),console.log(" Current isDragging state before:",N),G("loopStart"),U(o),e.preventDefault(),e.stopPropagation(),console.log(" Event prevented and propagation stopped"),void setTimeout(function(){console.log(" isDragging state after timeout:",N)},0);console.log(" No marker hit, normal click behavior");var h=p+i*f;if(e.shiftKey){var v=Math.max(h,k+.01);P(v),rt(k,v)}else if(e.ctrlKey){var b=Math.min(h,E-.01);S(b),rt(b,E)}else g(h)}else!l&&c.current&&c.current.click()},onMouseMove:function(e){if(N&&l){console.log(" Mouse move: isDragging =",N);var n=r.current,t=n.getBoundingClientRect(),a=n.width/t.width,o=(e.clientX-t.left)*a/n.width,c=l.getChannelData?l.getChannelData(0).length:l.length,i=Math.floor(c/ne),s=Math.floor(oe*(c-i)),u=s/c,d=(s+i)/c-u,p=Math.max(0,Math.min(1,u+o*d));if("loopStart"===N){var f=Math.min(p,E-.01);S(f)}else if("loopEnd"===N){var m=Math.max(p,k+.01);P(m)}e.preventDefault()}else N&&console.log(" Mouse move called but no audio buffer")},onMouseUp:ot,onMouseLeave:ot,onWheel:function(e){if(e.preventDefault(),e.ctrlKey){var n=e.deltaY>0?.5:2;te(function(e){return Math.max(.1,Math.min(50,e*n))})}else{var t=e.deltaY>0?.05:-.05;re(function(e){return Math.max(0,Math.min(1,e+t))})}},style:{position:"absolute",width:"100%",height:"100%",cursor:l?N?"grabbing":"crosshair":"pointer",opacity:l?1:0}})))),a.createElement("div",{style:{backgroundColor:"#0c1428",padding:"16px",overflowY:"auto"}},!ct&&a.createElement(a.Fragment,null,a.createElement("h3",{style:{color:"#e2e8f0",fontSize:"14px",marginBottom:"16px"}},"Sample Controls"),a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Load Sample"),a.createElement("div",{style:{display:"flex",gap:"8px"}},a.createElement("input",{ref:c,type:"file",accept:".wav,.mp3,.ogg",onChange:function(e){var n=e.target.files[0];n&&Fn(n)},style:{flex:1,padding:"6px",borderRadius:"8px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px"}}),a.createElement("button",{onClick:mn?function(){Sn.current&&mn&&(Sn.current.stop(),_n(!1))}:Nn,style:{padding:"6px 12px",borderRadius:"8px",border:"none",backgroundColor:mn?"#dc2626":"#22c55e",color:"white",fontSize:"12px",fontWeight:"500",cursor:"pointer",whiteSpace:"nowrap",transition:"all 0.2s"},onMouseEnter:function(e){e.target.style.opacity="0.8"},onMouseLeave:function(e){e.target.style.opacity="1"}},mn?" Stop":" Record")),mn&&a.createElement("div",{style:{marginTop:"8px",padding:"8px",borderRadius:"6px",backgroundColor:"#1e293b",border:"1px solid #dc2626"}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"6px"}},a.createElement("span",{style:{color:"#ef4444",fontSize:"11px",fontWeight:"600"}}," RECORDING"),a.createElement("span",{style:{color:"#cbd5e1",fontSize:"11px",fontFamily:"monospace"}},Math.floor(hn/60),":",String(Math.floor(hn%60)).padStart(2,"0"))),a.createElement("div",{style:{width:"100%",height:"4px",backgroundColor:"#0f172a",borderRadius:"2px",overflow:"hidden"}},a.createElement("div",{style:{width:"".concat(100*yn,"%"),height:"100%",backgroundColor:yn>.9?"#ef4444":yn>.7?"#f59e0b":"#22c55e",transition:"width 0.05s"}})))),a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Sample Name"),a.createElement("input",{type:"text",value:n.params.sample_name||"",onChange:function(e){return Cn("sample_name",e.target.value)},placeholder:"Custom sample name",style:{width:"100%",padding:"6px",borderRadius:"8px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px"}})),("SDPlayer"===n.type||"SamplePlayer"===n.type)&&a.createElement(a.Fragment,null,a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Sample Number (for SDPlayer)"),a.createElement("input",{type:"number",min:"1",max:"32",value:n.params.sample_number||1,onChange:function(e){return Cn("sample_number",parseInt(e.target.value)||1)},style:{width:"100%",padding:"6px",borderRadius:"8px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"Will save as: sample",n.params.sample_number||1,".wav")),a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Custom Suffix (optional)"),a.createElement("input",{type:"text",placeholder:"e.g. kick, snare, lead",value:n.params.custom_suffix||"",onChange:function(e){return Cn("custom_suffix",e.target.value)},style:{width:"100%",padding:"6px",borderRadius:"8px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px"}}),a.createElement("div",{style:{color:"#64748b",fontSize:"10px",marginTop:"2px"}},"Preview: sample_",n.params.sample_number||1,"_",n.params.custom_suffix||"name",".wav"),a.createElement("div",{style:{color:"#64748b",fontSize:"10px",marginTop:"1px"}},Be>=1?" Next file will use session folder: session_[timestamp]":" Will save to root /samples/"))),a.createElement("h4",{style:{color:"#22c55e",fontSize:"12px",marginBottom:"8px",borderTop:"1px solid #334155",paddingTop:"8px"}}," Pitch Controls"),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Root Note (MIDI)"),a.createElement("select",{value:X,onChange:function(e){return Z(parseInt(e.target.value))},style:{width:"100%",padding:"6px",borderRadius:"8px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px"}},Array.from({length:128},function(e,n){var t=Math.floor(n/12)-1,o=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][n%12];return a.createElement("option",{key:n,value:n},o,t," (",n,")")}))),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Pitch Shift (Semitones)"),a.createElement("input",{type:"range",min:"-24",max:"24",step:"1",value:V,onChange:function(e){return H(parseInt(e.target.value))},style:{width:"100%"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px"}},V>0?"+":"",V," semitones")),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Fine Tune (Cents)"),a.createElement("input",{type:"range",min:"-100",max:"100",step:"1",value:K,onChange:function(e){return $(parseInt(e.target.value))},style:{width:"100%"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px"}},K>0?"+":"",K," cents")),a.createElement("h4",{style:{color:"#22c55e",fontSize:"12px",marginBottom:"8px",borderTop:"1px solid #334155",paddingTop:"8px"}}," Loop & Fade Controls"),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Loop Start"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.001",value:k,onChange:function(e){return S(parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px"}},(100*k).toFixed(1),"%")),a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Loop End"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.001",value:E,onChange:function(e){return P(parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px"}},(100*E).toFixed(1),"%")),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"flex",alignItems:"center",gap:"8px"}},a.createElement("span",null,"Fade Mode:"),a.createElement("button",{className:"btn ".concat("auto"===de?"btn-green":"btn-ghost"),onClick:function(){return pe("auto"===de?"manual":"auto")},style:{fontSize:"11px",padding:"2px 6px"}},"auto"===de?" Auto":" Manual"))),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Fade In ","auto"===de?"(Auto)":""),a.createElement("input",{type:"range",min:"0",max:"0.5",step:"0.001",value:C,onChange:function(e){return R(parseFloat(e.target.value))},disabled:"auto"===de,style:{width:"100%",opacity:"auto"===de?.5:1}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px"}},(100*C).toFixed(1),"% of selection ","auto"===de?"(Auto)":"")),a.createElement("div",{style:{marginBottom:"16px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Fade Out"),a.createElement("input",{type:"range",min:"0",max:"0.5",step:"0.001",value:I,onChange:function(e){return M(parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("span",{style:{color:"#94a3b8",fontSize:"11px"}},(100*I).toFixed(1),"% of selection")),a.createElement("h3",{style:{color:"#e2e8f0",fontSize:"14px",marginBottom:"16px",borderTop:"1px solid #334155",paddingTop:"16px"}},"Export Settings"),a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Sample Rate"),a.createElement("select",{value:B,onChange:function(e){return z(parseInt(e.target.value))},style:{width:"100%",padding:"6px",borderRadius:"8px",border:"1px solid #334155",backgroundColor:"#0f172a",color:"#e2e8f0",fontSize:"12px"}},a.createElement("option",{value:44100},"44.1 kHz"),a.createElement("option",{value:22050},"22.05 kHz"),a.createElement("option",{value:16e3},"16 kHz"),a.createElement("option",{value:8e3},"8 kHz"))),a.createElement("button",{className:"btn btn-green",onClick:function(){var e=Un();if(e){var t=new Blob([e],{type:"audio/wav"}),a=URL.createObjectURL(t),o=document.createElement("a");o.href=a;var r=n.params.sample_name||"sample";o.download="".concat(r.replace(/[^a-zA-Z0-9-_]/g,"_"),".wav"),o.click(),URL.revokeObjectURL(a)}},disabled:!l,style:{width:"100%",marginBottom:"8px"}}," Export WAV File"),a.createElement("button",{className:"btn ".concat("connected"===He?"btn-purple":"writing"===He?"btn-amber":"btn-ghost"),onClick:"not_connected"===He?nt:at,disabled:!l||"writing"===He,style:{width:"100%",marginBottom:"8px"}},"not_connected"===He&&" Connect SD Card","connected"===He&&" Save to SD Card","writing"===He&&" Writing to SD..."),"not_connected"!==He&&a.createElement("button",{className:"btn btn-ghost",onClick:function(){Ue(null),je("not_connected")},style:{width:"100%",marginBottom:"8px",fontSize:"11px"}},"Disconnect SD Card"),a.createElement("button",{className:"btn ".concat("synth"===ye?"btn-blue":"transferring"===ye||"switching"===ye?"btn-amber":"btn-ghost"),onClick:"disconnected"===ye?Wn:et,disabled:!l||"switching"===ye,style:{width:"100%",marginBottom:"8px"}},"disconnected"===ye&&" Connect Hardware","synth"===ye&&" Save to Hardware","transferring"===ye&&" Transferring...","usb"===ye&&" USB Mode Active","switching"===ye&&" Switching Mode..."),"disconnected"!==ye&&a.createElement("button",{className:"btn btn-ghost",onClick:jn,style:{width:"100%",marginBottom:"8px",fontSize:"11px"}},"Disconnect Hardware"),(De||we.length>0)&&a.createElement("div",{style:{backgroundColor:"#fbbf24",color:"#92400e",padding:"8px",borderRadius:"4px",marginBottom:"8px",fontSize:"11px",border:"1px solid #f59e0b"}},a.createElement("div",{style:{fontWeight:"bold",marginBottom:"4px"}}," File Transfer Active"),a.createElement("div",null,"Do NOT upload Arduino sketches while transferring files! This will interrupt the transfer and may corrupt files."),we.length>1&&a.createElement("div",{style:{marginTop:"4px",fontSize:"10px"}},"Queue: ",we.length," files waiting")),we.length>0&&a.createElement("div",{style:{marginBottom:"16px"}},a.createElement("div",{style:{color:"#cbd5e1",fontSize:"12px",marginBottom:"8px",display:"flex",justifyContent:"space-between",alignItems:"center"}},a.createElement("span",null,"Transfer Queue (",we.length,")"),we.some(function(e){return"queued"===e.status})&&a.createElement("button",{className:"btn btn-ghost",onClick:function(){Ie([]),Ae(null),Ce([])},style:{fontSize:"10px",padding:"2px 6px"}},"Clear")),a.createElement("div",{style:{maxHeight:"120px",overflowY:"auto"}},we.map(function(e){return a.createElement("div",{key:e.id,style:{backgroundColor:"#374151",padding:"6px",marginBottom:"4px",borderRadius:"4px",fontSize:"11px"}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"2px"}},a.createElement("span",{style:{color:"#cbd5e1"}}," ",e.filename),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"6px"}},a.createElement("span",{style:{color:"transferring"===e.status?"#fbbf24":"completed"===e.status?"#10b981":"error"===e.status?"#ef4444":"#94a3b8"}},"transferring"===e.status&&"","queued"===e.status&&"","completed"===e.status&&"","error"===e.status&&""),"queued"===e.status&&a.createElement("button",{onClick:function(){return n=e.id,Ie(function(e){return e.filter(function(e){return e.id!==n})}),void Ce(function(e){return e.filter(function(e){return e.id!==n})});var n},style:{background:"none",border:"none",color:"#ef4444",cursor:"pointer",fontSize:"10px",padding:"0 2px"}},""))),a.createElement("div",{style:{display:"flex",justifyContent:"space-between",color:"#94a3b8",fontSize:"10px"}},a.createElement("span",null,(e.size/1024).toFixed(1)," KB"),"transferring"===e.status&&a.createElement("span",null,e.progress.toFixed(1),"%")),"transferring"===e.status&&a.createElement("div",{style:{width:"100%",height:"2px",backgroundColor:"#4b5563",borderRadius:"1px",marginTop:"4px",overflow:"hidden"}},a.createElement("div",{style:{width:"".concat(e.progress,"%"),height:"100%",backgroundColor:"#fbbf24",transition:"width 0.3s ease"}})))})))),a.createElement("div",{style:{backgroundColor:"#111827",padding:"8px",borderRadius:"6px",border:"1px solid #334155",marginBottom:"12px"}},a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginBottom:"4px"}},"Total Pitch: ",(12*Math.log2(J)+V+K/100).toFixed(1)," semitones"),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginBottom:"4px"}},"Final Speed: ",(J*Math.pow(2,(100*V+K)/1200)).toFixed(3),"x (",(J*Math.pow(2,(100*V+K)/1200)*100).toFixed(1),"%)"),a.createElement("div",{style:{fontSize:"10px",color:"synth"===ye?"#22c55e":"#94a3b8"}},"Hardware: ","disconnected"===ye?"Not connected":"synth"===ye?"Connected (Synth mode)":"usb"===ye?"USB Storage mode":"Switching..."),a.createElement("div",{style:{fontSize:"10px",color:"connected"===He?"#8b5cf6":"#94a3b8"}},"SD Card: ","not_connected"===He?"Not connected":"connected"===He?"Connected (Direct access)":"Writing...")),!ct&&a.createElement("div",{style:{backgroundColor:"#111827",padding:"12px",borderRadius:"8px",border:"1px solid #334155"}},a.createElement("h4",{style:{color:"#22c55e",fontSize:"12px",margin:"0 0 8px 0"}},"Legend"),a.createElement("div",{style:{fontSize:"11px",color:"#cbd5e1"}},a.createElement("div",{style:{marginBottom:"4px"}},a.createElement("span",{style:{color:"#22c55e"}},"")," Loop Start"),a.createElement("div",{style:{marginBottom:"4px"}},a.createElement("span",{style:{color:"#dc2626"}},"")," Loop End"),a.createElement("div",{style:{marginBottom:"4px"}},a.createElement("span",{style:{color:"#f59e0b"}},"")," Play Position"),a.createElement("div",{style:{marginBottom:"4px"}},a.createElement("span",{style:{color:"#22c55e",opacity:.3}},"")," Loop Region"),a.createElement("div",null,a.createElement("span",{style:{color:"#f59e0b",opacity:.3}},"")," Fade Regions")))))))};function pn(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,r,c,i=[],l=!0,s=!1;try{if(r=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=r.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(c=t.return(),Object(c)!==c))return}finally{if(s)throw o}}return i}}(e,n)||function(e,n){if(e){if("string"==typeof e)return fn(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?fn(e,n):void 0}}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function fn(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}const mn=function(e){e.module;var n,t,o,r,c=e.onUpdateParam,i=e.onClose,l=pn((0,a.useState)(null),2),s=l[0],u=l[1],d=pn((0,a.useState)(null),2),p=d[0],f=d[1],m=(0,a.useRef)();(0,a.useEffect)(function(){var e=function(e){var n;if(e.source===(null===(n=m.current)||void 0===n?void 0:n.contentWindow)){var t=e.data,a=t.type,o=t.data;switch(a){case"ANALYSIS_COMPLETE":u(o),console.log("Received analysis:",o);break;case"PRESET_EXPORT":_(o)}}};return window.addEventListener("message",e),function(){return window.removeEventListener("message",e)}},[]);var _=function(e){var n=function(e){for(var n=e.harmonics,t=(e.meta,[]),a=0;a<257;a++){var o=a/256*2-1,r=o;if(n&&n.length>1){for(var c=0,i=n[0],l=1;l<Math.min(n.length,16);l++){var s=n[l];s&&(c+=Math.pow(10,(s.db-i.db)/20)*Math.sin((l+1)*Math.PI*o))}r=.5*o+.5*c}r=Math.max(-1,Math.min(1,r)),t.push(r.toFixed(6))}return t}(e);f(n),c("preset","custom"),c("customTable",n),alert("Custom preset generated from analysis!\nFundamental: ".concat(e.meta.f0.toFixed(1)," Hz\nTHD: ").concat((100*e.meta.thd).toFixed(1),"%\nHarmonics: ").concat(e.harmonics.length))};return a.createElement("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,background:"rgba(0,0,0,0.9)",zIndex:9999,display:"flex",alignItems:"center",justifyContent:"center"}},a.createElement("div",{style:{width:"95%",height:"95%",background:"#0b0d10",borderRadius:"16px",display:"flex",flexDirection:"column",boxShadow:"0 20px 50px rgba(0,0,0,0.5)"}},a.createElement("div",{style:{padding:"16px 24px",borderBottom:"1px solid #1f2a38",display:"flex",justifyContent:"space-between",alignItems:"center"}},a.createElement("div",null,a.createElement("h2",{style:{margin:0,fontSize:"18px",color:"#e9f1f7"}},"Distortion Editor - Spectral Analyzer"),a.createElement("p",{style:{margin:"4px 0 0",fontSize:"13px",color:"#8aa"}},"Load reference & effected audio  Analyze harmonics  Generate custom waveshaping preset")),a.createElement("div",{style:{display:"flex",gap:"8px"}},p&&a.createElement("button",{onClick:function(){p&&(c("preset","custom"),c("customTable",p))},style:{background:"#1c2a42",border:"1px solid #2f5b9e",color:"#e9f1f7",padding:"8px 16px",borderRadius:"8px",cursor:"pointer",fontSize:"13px"}},"Apply Custom Preset"),a.createElement("button",{onClick:i,style:{background:"#4d1f1f",border:"1px solid #8b1d1d",color:"#e9f1f7",padding:"8px 16px",borderRadius:"8px",cursor:"pointer",fontSize:"13px"}},"Close"))),a.createElement("iframe",{ref:m,src:"/spectral_analyzer_ir_helper.html",style:{flex:1,border:"none",borderRadius:"0 0 16px 16px"},title:"Spectral Analyzer"}),s&&a.createElement("div",{style:{position:"absolute",bottom:"24px",left:"24px",background:"#12161b",border:"1px solid #2a3a4d",borderRadius:"12px",padding:"12px 16px",fontSize:"13px",color:"#8aa",maxWidth:"400px"}},a.createElement("div",{style:{color:"#60a5fa",fontWeight:"bold",marginBottom:"4px"}},"Analysis Complete"),a.createElement("div",null,"f: ",null===(n=s.meta)||void 0===n||null===(n=n.f0)||void 0===n?void 0:n.toFixed(1)," Hz"),a.createElement("div",null,"THD: ",null===(t=100*(null===(o=s.meta)||void 0===o?void 0:o.thd))||void 0===t?void 0:t.toFixed(1),"%"),a.createElement("div",null,"Harmonics detected: ",null===(r=s.harmonics)||void 0===r?void 0:r.length))))};function _n(e){return _n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},_n(e)}function gn(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,hn(a.key),a)}}function hn(e){var n=function(e){if("object"!=_n(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=_n(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==_n(n)?n:n+""}function vn(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(e){}return(vn=function(){return!!e})()}function bn(e){return bn=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},bn(e)}function yn(e,n){return yn=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,n){return e.__proto__=n,e},yn(e,n)}const kn=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=function(e,n,t){return n=bn(n),function(e,n){if(n&&("object"==_n(n)||"function"==typeof n))return n;if(void 0!==n)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}(e,vn()?Reflect.construct(n,t||[],bn(e).constructor):n.apply(e,t))}(this,n,[e])).state={hasError:!1,error:null},t}return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),n&&yn(e,n)}(n,e),t=n,r=[{key:"getDerivedStateFromError",value:function(e){return{hasError:!0,error:e}}}],(o=[{key:"componentDidCatch",value:function(e,n){console.error("ErrorBoundary caught an error:",e,n)}},{key:"render",value:function(){var e,n=this;return this.state.hasError?a.createElement("div",{style:{padding:"20px",backgroundColor:"#fee2e2",border:"1px solid #fecaca",borderRadius:"8px",color:"#991b1b"}},a.createElement("h3",{style:{margin:"0 0 12px 0",color:"#991b1b"}},this.props.componentName||"Component"," Error"),a.createElement("p",{style:{margin:"0 0 12px 0",fontSize:"14px"}},"This component has been temporarily disabled due to an error. The rest of the application should continue to work normally."),a.createElement("details",{style:{fontSize:"12px",color:"#7f1d1d"}},a.createElement("summary",null,"Error details"),a.createElement("pre",{style:{whiteSpace:"pre-wrap",marginTop:"8px"}},null===(e=this.state.error)||void 0===e?void 0:e.toString())),this.props.onRetry&&a.createElement("button",{onClick:function(){n.setState({hasError:!1,error:null}),n.props.onRetry()},style:{marginTop:"12px",padding:"6px 12px",backgroundColor:"#991b1b",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"}},"Retry")):this.props.children}}])&&gn(t.prototype,o),r&&gn(t,r),Object.defineProperty(t,"prototype",{writable:!1}),t;var t,o,r}(a.Component);function Sn(e){return Sn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Sn(e)}function xn(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function En(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?xn(Object(t),!0).forEach(function(n){Pn(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):xn(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function Pn(e,n,t){return(n=function(e){var n=function(e){if("object"!=Sn(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=Sn(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==Sn(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function wn(e){return function(e){if(Array.isArray(e))return Ln(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||Rn(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Cn(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,r,c,i=[],l=!0,s=!1;try{if(r=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=r.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(c=t.return(),Object(c)!==c))return}finally{if(s)throw o}}return i}}(e,n)||Rn(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Rn(e,n){if(e){if("string"==typeof e)return Ln(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Ln(e,n):void 0}}function Ln(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}var In=function(e){var n=e.label,t=e.value,o=e.min,r=e.max,c=e.step,i=void 0===c?1:c,l=e.onChange,s=e.color,u=void 0===s?"#22c55e":s,d=e.unit,p=void 0===d?"":d,f=Cn((0,a.useState)(!1),2),m=f[0],_=f[1],g=Cn((0,a.useState)({x:0,y:0,value:0}),2),h=g[0],v=g[1],b=(0,a.useRef)(null),y=(t-o)/(r-o),k=270*y-135;return(0,a.useEffect)(function(){var e=function(e){if(m){var n=h.y-e.clientY,t=(r-o)/100,a=Math.max(o,Math.min(r,h.value+n*t)),c=Math.round(a/i)*i;l(c)}},n=function(){_(!1)};return m&&(document.addEventListener("mousemove",e),document.addEventListener("mouseup",n)),function(){document.removeEventListener("mousemove",e),document.removeEventListener("mouseup",n)}},[m,h,o,r,i,l]),a.createElement("div",{style:{display:"flex",flexDirection:"column",alignItems:"center",gap:"6px"}},a.createElement("div",{ref:b,onMouseDown:function(e){e.preventDefault(),_(!0),v({x:e.clientX,y:e.clientY,value:t})},style:{width:"40px",height:"40px",borderRadius:"50%",background:"conic-gradient(from 45deg, ".concat(u," ").concat(100*y,"%, #374151 ").concat(100*y,"%)"),border:"2px solid #475569",position:"relative",cursor:m?"grabbing":"grab",transform:"rotate(".concat(k,"deg)"),transition:m?"none":"transform 0.1s ease"}},a.createElement("div",{style:{position:"absolute",width:"2px",height:"12px",backgroundColor:"#ffffff",top:"2px",left:"50%",transform:"translateX(-50%)",borderRadius:"1px"}})),a.createElement("div",{style:{fontSize:"11px",fontWeight:"600",color:u,textAlign:"center",minWidth:"50px"}},n),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",textAlign:"center",fontFamily:"monospace"}},t,p))};const Mn=function(e){var n=e.params,t=e.onUpdateParam,o=e.moduleId,r=e.module,c=e.onClose,i=e.fullscreen,l=void 0!==i&&i,s=n||(null==r?void 0:r.params)||{},u=o||(null==r?void 0:r.id),d=(0,a.useRef)(null),p=Cn((0,a.useState)(null),2),f=p[0],m=p[1],_=Cn((0,a.useState)({x:0,y:0}),2),g=(_[0],_[1]),h=Cn((0,a.useState)(!1),2),v=h[0],b=h[1],y=Cn((0,a.useState)("ADSR"),2),k=y[0],S=y[1],x=Cn((0,a.useState)(!1),2),E=x[0],P=x[1],w=s.attack_ms||10,C=s.decay_ms||120,R=s.sustain||.6,L=s.release_ms||200,I=s.loop_mode||"oneshot",M=s.timescale||1,D=s.trigger_mode||"gate",A=s.attack_curve||"linear",O=s.decay_curve||"exp",T=s.release_curve||"exp",B=s.sustain_mod_enabled||!1,z=s.sustain_lfo_rate||1,F=s.sustain_lfo_depth||.2,N=s.sustain_lfo_wave||"sine",G=s.sustain_mod_source||"internal",q=s.breakpoints||[{time:0,level:0,curve:.5},{time:.1,level:1,curve:.3},{time:.3,level:.6,curve:.7},{time:.8,level:.6,curve:.5},{time:1,level:0,curve:.8}],U=l?800:280,W=l?320:100,V=20,H=200,j=w+C+H,K=Math.max(1e3,j+L);(0,a.useEffect)(function(){$()},[w,C,R,L,f,k,q,I,M,A,O,T]);var $=function(){var e=d.current;if(e){var n=e.getContext("2d"),t=e.getBoundingClientRect(),a=window.devicePixelRatio||1;e.width=t.width*a,e.height=t.height*a,e.style.width=t.width+"px",e.style.height=t.height+"px",n.scale(a,a);var o=t.width,r=t.height,c=o-40,i=r-40,l=V+w/K*c,s=V+(w+C)/K*c,u=V+(w+C+H+L/2e3*200)/K*c,p=V+(w+C+H+L)/K*c,f=V+(1-R)*i,m=r-V;n.textRenderingOptimization="optimizeLegibility",n.imageSmoothingEnabled=!1,n.fillStyle="#0f172a",n.fillRect(0,0,o,r),n.strokeStyle="#374151",n.lineWidth=1,n.setLineDash([2,2]);for(var _=0;_<=4;_++){var g=V+_*i/4;n.beginPath(),n.moveTo(V,g),n.lineTo(o-V,g),n.stroke()}for(var h=0;h<=4;h++){var v=V+h*c/4;n.beginPath(),n.moveTo(v,V),n.lineTo(v,r-V),n.stroke()}n.setLineDash([]),"ADSR"===k?X(n,o,r,c,i,l,s,u,p,20,f,m):Z(n,o,r,c,i),"oneshot"!==I&&(n.strokeStyle="#f59e0b",n.lineWidth=2,n.setLineDash([5,5]),n.strokeRect(V,V,c,i),n.setLineDash([]),n.fillStyle="#f59e0b",n.font="bold 10px monospace",n.textAlign="left",n.fillText("".concat(I.toUpperCase()),25,35));var b=M<.01?"".concat((1e3*M).toFixed(1),"s"):M<1?"".concat((1e3*M).toFixed(0),"ms"):M<60?"".concat(M.toFixed(1),"s"):"".concat((M/60).toFixed(1),"m");n.fillStyle="#94a3b8",n.font="10px monospace",n.textAlign="right",n.fillText("".concat(b),U-V-5,W-V-5)}},Y=function(e,n,t,a,o,r,c){for(var i=0;i<=20;i++){var l=i/20,s=void 0;switch(r){case"linear":default:s=l;break;case"exp":s=c?(1-Math.exp(-5*l))/(1-Math.exp(-5)):1-(1-Math.exp(-5*(1-l)))/(1-Math.exp(-5));break;case"log":s=c?Math.log(1+9*l)/Math.log(10):1-Math.log(1+9*(1-l))/Math.log(10);break;case"sine":s=c?Math.sin(l*Math.PI/2):1-Math.sin((1-l)*Math.PI/2);break;case"quad":s=c?l*l:1-(1-l)*(1-l)}var u=n+(a-n)*l,d=t+(o-t)*s;0===i?e.moveTo(u,d):e.lineTo(u,d)}},X=function(e,n,t,a,o,r,c,i,l,s,u,d){e.strokeStyle="#22c55e",e.lineWidth=3,e.beginPath(),e.moveTo(V,W-V),Y(e,V,W-V,r,s,A,!0),Y(e,r,s,c,u,O,!1),e.lineTo(i,u),Y(e,i,u,l,d,T,!1),e.stroke(),J(e,r,s,0,"#22c55e","A"),J(e,c,s,1,"#f59e0b","D"),J(e,i,u,2,"#3b82f6","S"),J(e,l,d,3,"#ef4444","R"),e.fillStyle="#cbd5e1",e.font='bold 11px "SF Mono", "Monaco", "Inconsolata", "Fira Code", "Droid Sans Mono", "Source Code Pro", monospace',e.textAlign="center",e.textBaseline="alphabetic";var p=w*M,f=C*M,m=L*M;e.fillText("A: ".concat(Q(p)),Math.round(r),Math.round(t-5)),e.fillText("D: ".concat(Q(f)),Math.round((r+c)/2),Math.round(t-5)),e.fillText("S: ".concat(Math.round(100*R),"%"),Math.round((c+i)/2),Math.round(t-5)),e.fillText("R: ".concat(Q(m)),Math.round((i+l)/2),Math.round(t-5))},Z=function(e,n,t,a,o){if(!(q.length<2)){e.strokeStyle="#22c55e",e.lineWidth=3,e.beginPath();for(var r=0;r<q.length;r++){var c=q[r],i=V+c.time*a,l=V+(1-c.level)*o;if(0===r)e.moveTo(i,l);else{var s=q[r-1],u=V+s.time*a,d=V+(1-s.level)*o,p=s.curve,m=u+(i-u)*p,_=d+(l-d)*(1-p);e.quadraticCurveTo(m,_,i,l)}}if(e.stroke(),q.forEach(function(n,t){var r=V+n.time*a,c=V+(1-n.level)*o;J(e,r,c,t,["#22c55e","#f59e0b","#3b82f6","#ef4444","#8b5cf6"][t%5],"".concat(t+1))}),null!==f&&f<q.length-1){var g=q[f],h=q[f+1],v=V+g.time*a,b=V+(1-g.level)*o,y=V+h.time*a,k=V+(1-h.level)*o,S=v+(y-v)*g.curve,x=b+(k-b)*(1-g.curve);e.strokeStyle="#94a3b8",e.lineWidth=1,e.setLineDash([2,2]),e.beginPath(),e.moveTo(v,b),e.lineTo(S,x),e.lineTo(y,k),e.stroke(),e.setLineDash([]),e.fillStyle="#94a3b8",e.strokeStyle="#ffffff",e.lineWidth=1,e.beginPath(),e.arc(S,x,4,0,2*Math.PI),e.fill(),e.stroke()}}},Q=function(e){return e<1?"".concat((1e3*e).toFixed(0),"s"):e<1e3?"".concat(e.toFixed(0),"ms"):e<6e4?"".concat((e/1e3).toFixed(1),"s"):"".concat((e/6e4).toFixed(1),"m")},J=function(e,n,t,a,o,r){var c=f===a?8:6;e.fillStyle=o,e.strokeStyle="#ffffff",e.lineWidth=2,e.beginPath(),e.arc(n,t,c,0,2*Math.PI),e.fill(),e.stroke(),e.fillStyle="#000000",e.font="bold 10px monospace",e.textAlign="center",e.fillText(r,n,t+3)},ee=function(e){console.log(" MOUSE DOWN EVENT FIRED!",{type:e.type,button:e.button,clientX:e.clientX,clientY:e.clientY});var n=d.current;if(n){var a=n.getBoundingClientRect(),o=e.clientX-a.left,r=e.clientY-a.top;console.log(" Mouse coordinates:",{mouseX:o,mouseY:r,editMode:k});var c=a.width-40,i=a.height-40,l=15;if("ADSR"===k){var s=V+w/K*c,p=V+(w+C)/K*c,_=V+(w+C+H+L/2e3*200)/K*c,h=V+(w+C+H+L)/K*c,v=V,b=V+(1-R)*i,y=a.height-V;console.log(" ADSR Click Detection:",{mouseX:o,mouseY:r,tolerance:l,editMode:k,attack_ms:w,decay_ms:C,sustain:R,release_ms:L,timescale:M,totalTime:K,margin:V,plotWidth:c,plotHeight:i,attackX:s,attackY:v,decayX:p,sustainY:b,sustainX:_,releaseX:h,releaseY:y,attackDist:Math.abs(o-s)+Math.abs(r-v),decayDist:Math.abs(o-p)+Math.abs(r-v),sustainDist:Math.abs(o-_)+Math.abs(r-b),releaseDist:Math.abs(o-h)+Math.abs(r-y)}),Math.abs(o-s)<l&&Math.abs(r-v)<l?(console.log(" ATTACK point clicked"),m(0)):Math.abs(o-p)<l&&Math.abs(r-v)<l?(console.log(" DECAY point clicked"),m(1)):Math.abs(o-_)<l&&Math.abs(r-b)<l?(console.log(" SUSTAIN point clicked"),m(2)):Math.abs(o-h)<l&&Math.abs(r-y)<l?(console.log(" RELEASE point clicked"),m(3)):console.log(" No control point hit")}else{for(var S=0;S<q.length;S++){var x=q[S],E=V+x.time*c,P=V+(1-x.level)*i;if(Math.abs(o-E)<l&&Math.abs(r-P)<l){m(S),g({x:o-E,y:r-P});break}}if(null===f&&2===e.detail){var I=(o-V)/c,D=1-(r-V)/i;if(I>=0&&I<=1&&D>=0&&D<=1){var A=[].concat(wn(q),[{time:I,level:D,curve:.5}]).sort(function(e,n){return e.time-n.time});t(u,"breakpoints",A)}}}e.preventDefault()}else console.log(" No canvas ref!")};return(0,a.useEffect)(function(){if(null!==f){var e=function(e){d.current&&function(e){if(null!==f&&console.log(" MOUSE MOVE while dragging:",{isDragging:f,editMode:k}),null!==f){var n=d.current.getBoundingClientRect(),a=e.clientX-n.left,o=e.clientY-n.top,r=n.width-40,c=n.height-40,i=Math.max(0,Math.min(1,(a-V)/r)),l=Math.max(0,Math.min(1,1-(o-V)/c));if("ADSR"===k){console.log(" ADSR drag detected:",{isDragging:f,timeRatio:i,levelRatio:l});var s=2e3;switch(f){case 0:var p=4e3*M,m=Math.max(1,Math.min(p,i*p));console.log(" Attack update:",{newAttack:m,timeRatio:i,maxAttackTime:p,actualModuleId:u}),t(u,"attack_ms",Math.round(m));break;case 1:var _=4e3*M,g=Math.max(1,Math.min(_,i*_));console.log(" Decay update:",{newDecay:g,timeRatio:i,maxDecayTime:_,actualModuleId:u}),t(u,"decay_ms",Math.round(g));break;case 2:console.log(" Sustain update:",{levelRatio:l,timeRatio:i,actualModuleId:u}),t(u,"sustain",l);var h=V+(w+C)/K*r,v=.8*r,b=Math.max(0,Math.min(1,(a-h)/v));b=Math.pow(b,.5);var y=Math.max(50,Math.min(s,50+1950*b));t(u,"release_ms",Math.round(y));break;case 3:var S=V+(w+C+H)/K*r,x=Math.max(0,Math.min(1,(a-S)/(.3*r))),E=Math.max(10,Math.min(s,x*s));console.log(" Release update:",{mouseX:a,sustainX:S,releaseTimeRatio:x,newReleaseTime:E,actualModuleId:u}),t(u,"release_ms",Math.round(E))}}else if(f<q.length){var P=wn(q),R=0,L=1;f>0&&(R=q[f-1].time+.01),f<q.length-1&&(L=q[f+1].time-.01),P[f]=En(En({},P[f]),{},{time:Math.max(R,Math.min(L,i)),level:l}),t(u,"breakpoints",P)}e.preventDefault()}}(En(En({},e),{},{clientX:e.clientX,clientY:e.clientY,preventDefault:function(){}}))},n=function(e){console.log(" GLOBAL MOUSE UP - ending drag"),null!==f&&console.log(" MOUSE UP - ending drag for:",f),m(null)};return document.addEventListener("mousemove",e),document.addEventListener("mouseup",n),function(){document.removeEventListener("mousemove",e),document.removeEventListener("mouseup",n)}}},[f,k,q,w,C,R,L,M,u]),(0,a.useEffect)(function(){var e=function(e){"Escape"===e.key&&c()};return document.addEventListener("keydown",e),function(){return document.removeEventListener("keydown",e)}},[c]),l?a.createElement("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(0, 0, 0, 0.8)",zIndex:2e3,display:"flex",alignItems:"center",justifyContent:"center"}},a.createElement("div",{style:{backgroundColor:"#0c1428",border:"1px solid #1f2937",borderRadius:"12px",width:"95vw",height:"90vh",padding:"20px",display:"flex",flexDirection:"column",overflow:"auto"}},a.createElement("div",{style:{display:"flex",alignItems:"center",justifyContent:"space-between",marginBottom:"20px",paddingBottom:"12px",borderBottom:"1px solid #334155"}},a.createElement("div",{style:{display:"flex",alignItems:"center",justifyContent:"space-between",width:"100%"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("h2",{style:{color:"#22c55e",fontWeight:"bold",fontSize:"24px",margin:0}}," Advanced Envelope Generator"),a.createElement("div",{style:{color:"#94a3b8",fontSize:"16px"}},null==r?void 0:r.type," - ",null==r?void 0:r.id))),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"16px"}},a.createElement("div",{style:{display:"flex",border:"1px solid #374151",borderRadius:"6px",overflow:"hidden"}},a.createElement("button",{onClick:function(){return S("ADSR")},style:{padding:"8px 16px",background:"ADSR"===k?"#22c55e":"#374151",color:"ADSR"===k?"#000":"#cbd5e1",border:"none",fontSize:"14px",fontWeight:"700",cursor:"pointer"}},"ADSR MODE"),a.createElement("button",{onClick:function(){return S("Freeform")},style:{padding:"8px 16px",background:"Freeform"===k?"#22c55e":"#374151",color:"Freeform"===k?"#000":"#cbd5e1",border:"none",fontSize:"14px",fontWeight:"700",cursor:"pointer"}},"FREEFORM MODE")),a.createElement("button",{onClick:c,style:{width:"32px",height:"32px",borderRadius:"4px",border:"none",background:"#dc2626",color:"#fff",fontSize:"18px",fontWeight:"bold",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",boxShadow:"0 2px 4px rgba(0, 0, 0, 0.3)"},title:"Close Editor (ESC)"},""))),a.createElement("div",{style:{flex:1,display:"flex",gap:"20px",overflow:"auto",minHeight:0}},a.createElement("div",{style:{flex:1,display:"flex",flexDirection:"column",justifyContent:"center"}},a.createElement("canvas",{ref:d,width:U,height:W,onMouseDown:ee,style:{border:"2px solid #374151",borderRadius:"8px",cursor:null!==f?"grabbing":"crosshair",backgroundColor:"#0f172a",display:"block",width:l?"800px":"280px",height:l?"320px":"100px"}}),a.createElement("div",{style:{fontSize:"14px",color:"#94a3b8",textAlign:"center",marginTop:"12px",lineHeight:"1.4"}},"ADSR"===k?" Drag control points to adjust envelope  Sustain:  level,  release time  Switch to FREEFORM mode for unlimited breakpoints":" Drag breakpoints to shape envelope  Double-click to add points  Right-click to delete points"),"ADSR"===k&&a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",width:l?"800px":"280px",marginTop:"20px",padding:"16px 20px",backgroundColor:"#0f172a",border:"1px solid #334155",borderRadius:"8px",boxSizing:"border-box"}},a.createElement(In,{label:"Attack",value:w,min:1,max:2e3,step:1,onChange:function(e){return t(u,"attack_ms",e)},color:"#22c55e",unit:"ms"}),a.createElement(In,{label:"Decay",value:C,min:1,max:2e3,step:1,onChange:function(e){return t(u,"decay_ms",e)},color:"#f59e0b",unit:"ms"}),a.createElement(In,{label:"Sustain",value:Math.round(100*R),min:0,max:100,step:1,onChange:function(e){return t(u,"sustain",e/100)},color:"#3b82f6",unit:"%"}),a.createElement(In,{label:"Release",value:L,min:10,max:3e3,step:1,onChange:function(e){return t(u,"release_ms",e)},color:"#ef4444",unit:"ms"}))),a.createElement("div",{style:{width:"300px",display:"flex",flexDirection:"column",gap:"20px",overflowY:"auto",paddingRight:"10px"}},a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"16px",fontSize:"14px"}},a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"8px"}},a.createElement("label",{style:{color:"#22c55e",fontWeight:"700",fontSize:"16px"}},"Loop Mode"),a.createElement("select",{value:I,onChange:function(e){return t(u,"loop_mode",e.target.value)},style:{padding:"8px 12px",background:"#0f172a",border:"2px solid #374151",borderRadius:"6px",color:"#cbd5e1",fontSize:"14px"}},a.createElement("option",{value:"oneshot"}," One-Shot"),a.createElement("option",{value:"loop"}," Loop"),a.createElement("option",{value:"pingpong"}," Ping-Pong"))),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"8px"}},a.createElement("label",{style:{color:"#22c55e",fontWeight:"700",fontSize:"16px"}},"Trigger Mode"),a.createElement("select",{value:D,onChange:function(e){return t(u,"trigger_mode",e.target.value)},style:{padding:"8px 12px",background:"#0f172a",border:"2px solid #374151",borderRadius:"6px",color:"#cbd5e1",fontSize:"14px"}},a.createElement("option",{value:"gate"}," Gate"),a.createElement("option",{value:"trigger"}," Trigger"),a.createElement("option",{value:"lfo"}," LFO"))),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"8px"}},a.createElement("label",{style:{color:"#22c55e",fontWeight:"700",fontSize:"16px"}}," Timescale: ",M<.01?"".concat((1e3*M).toFixed(1),"s"):M<1?"".concat((1e3*M).toFixed(0),"ms"):M<60?"".concat(M.toFixed(1),"s"):"".concat((M/60).toFixed(1),"m")),a.createElement("input",{type:"range",min:"-3",max:"2",step:"0.1",value:Math.log10(M),onChange:function(e){return t(u,"timescale",Math.pow(10,parseFloat(e.target.value)))},style:{width:"100%",height:"8px",background:"#374151",outline:"none",borderRadius:"4px"}}),a.createElement("div",{style:{display:"flex",justifyContent:"space-between",fontSize:"12px",color:"#6b7280"}},a.createElement("span",null,"1ms"),a.createElement("span",null,"1s"),a.createElement("span",null,"100s"))),"ADSR"===k&&a.createElement("div",{style:{backgroundColor:"#111827",border:"1px solid #374151",borderRadius:"8px",padding:"16px"}},a.createElement("h3",{style:{color:"#3b82f6",marginBottom:"12px",fontSize:"16px"}}," Response Curves"),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"12px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#22c55e",fontSize:"12px",width:"60px"}},"Attack:"),a.createElement("select",{value:A,onChange:function(e){return t(u,"attack_curve",e.target.value)},style:{flex:1,padding:"4px 8px",background:"#0f172a",border:"1px solid #374151",borderRadius:"4px",color:"#cbd5e1",fontSize:"12px"}},a.createElement("option",{value:"linear"},"Linear"),a.createElement("option",{value:"exp"},"Exponential"),a.createElement("option",{value:"log"},"Logarithmic"),a.createElement("option",{value:"sine"},"Sine"),a.createElement("option",{value:"quad"},"Quadratic"))),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#f59e0b",fontSize:"12px",width:"60px"}},"Decay:"),a.createElement("select",{value:O,onChange:function(e){return t(u,"decay_curve",e.target.value)},style:{flex:1,padding:"4px 8px",background:"#0f172a",border:"1px solid #374151",borderRadius:"4px",color:"#cbd5e1",fontSize:"12px"}},a.createElement("option",{value:"linear"},"Linear"),a.createElement("option",{value:"exp"},"Exponential"),a.createElement("option",{value:"log"},"Logarithmic"),a.createElement("option",{value:"sine"},"Sine"),a.createElement("option",{value:"quad"},"Quadratic"))),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#ef4444",fontSize:"12px",width:"60px"}},"Release:"),a.createElement("select",{value:T,onChange:function(e){return t(u,"release_curve",e.target.value)},style:{flex:1,padding:"4px 8px",background:"#0f172a",border:"1px solid #374151",borderRadius:"4px",color:"#cbd5e1",fontSize:"12px"}},a.createElement("option",{value:"linear"},"Linear"),a.createElement("option",{value:"exp"},"Exponential"),a.createElement("option",{value:"log"},"Logarithmic"),a.createElement("option",{value:"sine"},"Sine"),a.createElement("option",{value:"quad"},"Quadratic"))))),"ADSR"===k&&a.createElement("div",{style:{backgroundColor:"#111827",border:"1px solid #374151",borderRadius:"8px",overflow:"hidden"}},a.createElement("button",{onClick:function(){return P(!E)},style:{width:"100%",padding:"12px 16px",background:"#1e293b",border:"none",color:"#94a3b8",fontSize:"14px",fontWeight:"600",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"space-between"}},a.createElement("span",{style:{color:"#a78bfa"}}," Sustain Modulation"),a.createElement("span",{style:{transform:E?"rotate(180deg)":"rotate(0deg)",transition:"transform 0.2s"}},"")),E&&a.createElement("div",{style:{padding:"16px"}},a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px",marginBottom:"12px"}},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px",cursor:"pointer"}},a.createElement("input",{type:"checkbox",checked:B,onChange:function(e){return t(u,"sustain_mod_enabled",e.target.checked)},style:{width:"16px",height:"16px"}}),a.createElement("span",{style:{color:"#cbd5e1",fontSize:"12px"}},"Enable Modulation")),a.createElement("select",{value:G,onChange:function(e){return t(u,"sustain_mod_source",e.target.value)},disabled:!B,style:{marginLeft:"auto",padding:"4px 8px",background:B?"#0f172a":"#1e293b",border:"1px solid #374151",borderRadius:"4px",color:B?"#cbd5e1":"#64748b",fontSize:"12px"}},a.createElement("option",{value:"internal"},"Internal LFO"),a.createElement("option",{value:"external"},"External CV")))),"internal"===G&&B&&a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"12px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#a78bfa",fontSize:"12px",width:"60px"}},"Wave:"),a.createElement("select",{value:N,onChange:function(e){return t(u,"sustain_lfo_wave",e.target.value)},style:{flex:1,padding:"4px 8px",background:"#0f172a",border:"1px solid #374151",borderRadius:"4px",color:"#cbd5e1",fontSize:"12px"}},a.createElement("option",{value:"sine"}," Sine"),a.createElement("option",{value:"triangle"}," Triangle"),a.createElement("option",{value:"square"}," Square"),a.createElement("option",{value:"saw"}," Sawtooth"),a.createElement("option",{value:"random"},"? Random"))),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#a78bfa",fontSize:"12px",width:"60px"}},"Rate:"),a.createElement("input",{type:"range",min:"0.1",max:"20",step:"0.1",value:z,onChange:function(e){return t(u,"sustain_lfo_rate",parseFloat(e.target.value))},style:{flex:1,height:"6px",background:"#374151",outline:"none",borderRadius:"3px"}}),a.createElement("span",{style:{color:"#cbd5e1",fontSize:"11px",width:"50px",textAlign:"right"}},z.toFixed(1)," Hz")),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("label",{style:{color:"#a78bfa",fontSize:"12px",width:"60px"}},"Depth:"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:F,onChange:function(e){return t(u,"sustain_lfo_depth",parseFloat(e.target.value))},style:{flex:1,height:"6px",background:"#374151",outline:"none",borderRadius:"3px"}}),a.createElement("span",{style:{color:"#cbd5e1",fontSize:"11px",width:"50px",textAlign:"right"}},Math.round(100*F),"%"))),"external"===G&&B&&a.createElement("div",{style:{padding:"12px",background:"#0f172a",borderRadius:"6px",fontSize:"12px",color:"#94a3b8"}},"Connect a control signal to the Sustain CV input to modulate the sustain level. The incoming CV (0-1) will be multiplied by the sustain level."))),a.createElement("div",{style:{backgroundColor:"#111827",border:"1px solid #374151",borderRadius:"8px",padding:"16px"}},a.createElement("h3",{style:{color:"#f59e0b",marginBottom:"12px",fontSize:"16px"}}," Current Values"),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr",gap:"8px",fontSize:"12px"}},a.createElement("div",null,a.createElement("span",{style:{color:"#22c55e"}},"Attack:")," ",Q(w*M)),a.createElement("div",null,a.createElement("span",{style:{color:"#f59e0b"}},"Decay:")," ",Q(C*M)),a.createElement("div",null,a.createElement("span",{style:{color:"#3b82f6"}},"Sustain:")," ",Math.round(100*R),"%"),a.createElement("div",null,a.createElement("span",{style:{color:"#ef4444"}},"Release:")," ",Q(L*M))))))))):v?a.createElement("div",{style:{marginBottom:"16px"}},a.createElement("div",{style:{border:"1px solid #334155",borderRadius:"8px",background:"#111827",padding:"12px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",justifyContent:"space-between",marginBottom:"12px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("div",{style:{color:"#22c55e",fontWeight:"bold",fontSize:"14px"}},"Envelope Generator"),a.createElement("div",{style:{display:"flex",border:"1px solid #374151",borderRadius:"4px",overflow:"hidden"}},a.createElement("button",{onClick:function(){return S("ADSR")},style:{padding:"4px 8px",background:"ADSR"===k?"#22c55e":"#374151",color:"ADSR"===k?"#000":"#cbd5e1",border:"none",fontSize:"10px",fontWeight:"600",cursor:"pointer"}},"ADSR"),a.createElement("button",{onClick:function(){return S("Freeform")},style:{padding:"4px 8px",background:"Freeform"===k?"#22c55e":"#374151",color:"Freeform"===k?"#000":"#cbd5e1",border:"none",fontSize:"10px",fontWeight:"600",cursor:"pointer"}},"FREE"))),a.createElement("button",{onClick:function(){return b(!1)},style:{background:"none",border:"none",color:"#94a3b8",cursor:"pointer",fontSize:"16px"}},"")),a.createElement("div",{style:{display:"flex",gap:"12px",marginBottom:"12px",fontSize:"11px",flexWrap:"wrap"}},a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"4px"}},a.createElement("label",{style:{color:"#cbd5e1",fontWeight:"600"}},"Loop Mode"),a.createElement("select",{value:I,onChange:function(e){return t(u,"loop_mode",e.target.value)},style:{padding:"4px 6px",background:"#0f172a",border:"1px solid #374151",borderRadius:"4px",color:"#cbd5e1",fontSize:"10px"}},a.createElement("option",{value:"oneshot"},"One-Shot"),a.createElement("option",{value:"loop"},"Loop"),a.createElement("option",{value:"pingpong"},"Ping-Pong"))),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"4px"}},a.createElement("label",{style:{color:"#cbd5e1",fontWeight:"600"}},"Trigger"),a.createElement("select",{value:D,onChange:function(e){return t(u,"trigger_mode",e.target.value)},style:{padding:"4px 6px",background:"#0f172a",border:"1px solid #374151",borderRadius:"4px",color:"#cbd5e1",fontSize:"10px"}},a.createElement("option",{value:"gate"},"Gate"),a.createElement("option",{value:"trigger"},"Trigger"),a.createElement("option",{value:"lfo"},"LFO"))),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"4px",flex:"1",minWidth:"120px"}},a.createElement("label",{style:{color:"#cbd5e1",fontWeight:"600"}},"Timescale: ",M<.01?"".concat((1e3*M).toFixed(1),"s"):M<1?"".concat((1e3*M).toFixed(0),"ms"):M<60?"".concat(M.toFixed(1),"s"):"".concat((M/60).toFixed(1),"m")),a.createElement("input",{type:"range",min:"-3",max:"2",step:"0.1",value:Math.log10(M),onChange:function(e){return t(u,"timescale",Math.pow(10,parseFloat(e.target.value)))},style:{width:"100%",height:"4px",background:"#374151",outline:"none",borderRadius:"2px"}}),a.createElement("div",{style:{display:"flex",justifyContent:"space-between",fontSize:"9px",color:"#6b7280"}},a.createElement("span",null,"1ms"),a.createElement("span",null,"1s"),a.createElement("span",null,"100s")))),a.createElement("div",{style:{border:"1px solid #374151",borderRadius:"6px",overflow:"hidden",marginBottom:"8px"}},a.createElement("canvas",{ref:d,width:U,height:W,onMouseDown:ee,style:{display:"block",cursor:null!==f?"grabbing":"crosshair"}})),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",textAlign:"center"}},"ADSR"===k?"Drag control points  Sustain:  level,  release time  Switch to FREE mode for custom breakpoints":"Drag breakpoints to shape envelope  Double-click to add points  Right-click to delete"),"ADSR"===k&&a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",width:"280px",marginTop:"8px",padding:"8px 20px",backgroundColor:"#0f172a",border:"1px solid #334155",borderRadius:"4px",boxSizing:"border-box"}},a.createElement("div",{style:{transform:"scale(0.8)"}}," ",a.createElement(In,{label:"Attack",value:w,min:1,max:2e3,step:1,onChange:function(e){return t(u,"attack_ms",e)},color:"#22c55e",unit:"ms"})),a.createElement("div",{style:{transform:"scale(0.8)"}},a.createElement(In,{label:"Decay",value:C,min:1,max:2e3,step:1,onChange:function(e){return t(u,"decay_ms",e)},color:"#f59e0b",unit:"ms"})),a.createElement("div",{style:{transform:"scale(0.8)"}},a.createElement(In,{label:"Sustain",value:Math.round(100*R),min:0,max:100,step:1,onChange:function(e){return t(u,"sustain",e/100)},color:"#3b82f6",unit:"%"})),a.createElement("div",{style:{transform:"scale(0.8)"}},a.createElement(In,{label:"Release",value:L,min:10,max:3e3,step:1,onChange:function(e){return t(u,"release_ms",e)},color:"#ef4444",unit:"ms"}))))):a.createElement("div",{style:{marginBottom:"16px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px",cursor:"pointer",padding:"8px",borderRadius:"8px",border:"1px solid #334155",background:"#111827"},onClick:function(){return b(!0)}},a.createElement("div",{style:{color:"#22c55e",fontWeight:"bold"}},"ADSR"===k?"ADSR":"ENV","oneshot"!==I&&a.createElement("span",{style:{color:"#f59e0b"}}," ")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8"}},"ADSR"===k?"A:".concat(Q(w*M)," D:").concat(Q(C*M)," S:").concat(Math.round(100*R),"% R:").concat(Q(L*M)):"".concat(q.length," points, ").concat(Q(1e3*M)," scale")),a.createElement("div",{style:{marginLeft:"auto",color:"#94a3b8"}},"")))};function Dn(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}const An=function(e){var n,t,o,r,c,i,l,s=e.module,u=e.onUpdateParam,d=e.onClose,p=e.fullscreen,f=void 0!==p&&p,m=(i=(0,a.useState)(1),l=2,function(e){if(Array.isArray(e))return e}(i)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,r,c,i=[],l=!0,s=!1;try{if(r=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=r.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(c=t.return(),Object(c)!==c))return}finally{if(s)throw o}}return i}}(i,l)||function(e,n){if(e){if("string"==typeof e)return Dn(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Dn(e,n):void 0}}(i,l)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),_=m[0],g=m[1],h=(null==s?void 0:s.params)||{},v=[.0625,.08333,.125,.16667,.25,.33333,.5,1,2,3,4,6,8,12,16],b=function(e){return h["gate_mode".concat(e)]||!1},y=function(e){return h["rate".concat(e)]||1},k=function(e){return h["prob".concat(e)]||1},S=function(e){if(e<1){var n=1/e;return Math.abs(n-Math.round(n))<.01?"".concat(Math.round(n)):"".concat(n.toFixed(1))}return 1===e?"1":Math.abs(e-Math.round(e))<.01?"".concat(Math.round(e)):"".concat(e.toFixed(1))},x=function(e,n){u&&u(s.id,e,n)},E=function(e){var n=y(e),t=k(e),o=b(e),r=_===e;return a.createElement("div",{key:e,style:{display:"flex",flexDirection:"column",alignItems:"center",gap:"8px"}},a.createElement("div",{onClick:function(){return g(e)},style:{width:"80px",height:"80px",borderRadius:"50%",border:"3px solid ".concat(r?"#22c55e":"#374151"),background:r?"#064e3b":"#111827",display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",cursor:"pointer",position:"relative",transition:"all 0.2s ease"}},a.createElement("div",{style:{color:"#22c55e",fontSize:"20px",fontWeight:"bold",lineHeight:"1"}},S(n)),t<1&&a.createElement("div",{style:{color:"#f59e0b",fontSize:"12px",fontWeight:"600",lineHeight:"1",marginTop:"2px"}},(100*t).toFixed(0),"%"),a.createElement("div",{style:{position:"absolute",top:"4px",right:"4px",width:"12px",height:"12px",borderRadius:"50%",backgroundColor:o?"#ef4444":"#3b82f6",fontSize:"8px",color:"white",display:"flex",alignItems:"center",justifyContent:"center",fontWeight:"bold"}},o?"G":"C")),a.createElement("div",{style:{color:"#94a3b8",fontSize:"12px",fontWeight:"600"}},"OUT",e))};return a.createElement("div",{style:{position:f?"fixed":"absolute",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(0, 0, 0, 0.9)",zIndex:1e3,display:"flex",alignItems:"flex-start",justifyContent:"center",padding:"20px",overflow:"auto"}},a.createElement("div",{style:{width:"100%",maxWidth:"800px",maxHeight:"calc(100vh - 40px)",backgroundColor:"#1f2937",borderRadius:"12px",padding:"24px",border:"1px solid #374151",overflow:"auto"}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"24px"}},a.createElement("h2",{style:{color:"#8b5cf6",margin:0,fontSize:"24px",fontWeight:"bold"}},"Clock Sequencer"),a.createElement("button",{onClick:d,style:{background:"none",border:"none",color:"#94a3b8",fontSize:"24px",cursor:"pointer",padding:"4px",borderRadius:"4px"}},"X")),(c=h.use_outputs_5_8||!1,a.createElement("div",{style:{marginBottom:"20px",padding:"16px",backgroundColor:"#0f172a",borderRadius:"8px",border:"1px solid #374151"}},a.createElement("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr 1fr",gap:"16px",alignItems:"center"}},a.createElement("div",null,a.createElement("label",{style:{display:"block",color:"#e2e8f0",fontSize:"14px",fontWeight:"600",marginBottom:"8px"}},"BPM: ",h.bpm||120),a.createElement("input",{type:"range",min:"30",max:"300",value:h.bpm||120,onChange:function(e){return x("bpm",parseInt(e.target.value))},style:{width:"100%",accentColor:"#8b5cf6"}})),a.createElement("div",null,a.createElement("label",{style:{display:"block",color:"#e2e8f0",fontSize:"14px",fontWeight:"600",marginBottom:"8px"}},"Swing: ",(100*(h.swing||0)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"0.3",step:"0.01",value:h.swing||0,onChange:function(e){return x("swing",parseFloat(e.target.value))},style:{width:"100%",accentColor:"#f59e0b"}})),a.createElement("div",null,a.createElement("button",{onClick:function(){return x("running",!(!1!==h.running))},style:{width:"100%",padding:"12px",borderRadius:"6px",border:"none",backgroundColor:!1!==h.running?"#22c55e":"#ef4444",color:"white",fontSize:"14px",fontWeight:"600",cursor:"pointer"}},!1!==h.running?"RUNNING":"STOPPED"))),a.createElement("div",{style:{marginTop:"16px",display:"flex",alignItems:"center",gap:"12px",padding:"12px",backgroundColor:"#1f2937",borderRadius:"6px",border:"1px solid #374151"}},a.createElement("input",{type:"checkbox",id:"use_outputs_5_8",checked:c,onChange:function(e){return x("use_outputs_5_8",e.target.checked)},style:{width:"20px",height:"20px",cursor:"pointer",accentColor:"#8b5cf6"}}),a.createElement("label",{htmlFor:"use_outputs_5_8",style:{color:"#e2e8f0",fontSize:"14px",fontWeight:"600",cursor:"pointer",flex:1}},"Enable Outputs 5-8 (uses second bank)"),a.createElement("div",{style:{color:"#94a3b8",fontSize:"12px",padding:"4px 8px",backgroundColor:"#0f172a",borderRadius:"4px"}},"Bank ",h.bank||"Auto",c?" + ".concat((h.bank||1)+1):"")))),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"repeat(4, 1fr)",gap:"20px",justifyItems:"center",marginBottom:"20px",padding:"20px",backgroundColor:"#0f172a",borderRadius:"8px",border:"1px solid #374151"}},[1,2,3,4].map(E),!!h.use_outputs_5_8&&[5,6,7,8].map(E)),(n=y(_),t=k(_),o=h["euclid".concat(_)]||1,r=b(_),a.createElement("div",{style:{marginTop:"20px",padding:"16px",backgroundColor:"#0f172a",borderRadius:"8px",border:"1px solid #374151"}},a.createElement("h3",{style:{color:"#22c55e",margin:"0 0 16px 0",fontSize:"16px",fontWeight:"bold"}},"Output ",_," Controls"),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr",gap:"16px",alignItems:"center"}},a.createElement("div",null,a.createElement("label",{style:{display:"block",color:"#e2e8f0",fontSize:"14px",fontWeight:"600",marginBottom:"8px"}},"Rate: ",S(n)),a.createElement("input",{type:"range",min:"0",max:v.length-1,step:"1",value:function(e){for(var n=0,t=Math.abs(e-v[0]),a=1;a<v.length;a++){var o=Math.abs(e-v[a]);o<t&&(t=o,n=a)}return n}(n),onChange:function(e){var n,t=(n=parseInt(e.target.value),v[n]);x("rate".concat(_),t)},style:{width:"100%",accentColor:"#22c55e"}}),a.createElement("div",{style:{color:"#94a3b8",fontSize:"12px",marginTop:"4px"}},n<1?"Division: 1 trigger every ".concat(Math.round(1/n)," beat").concat(Math.round(1/n)>1?"s":""):1===n?"Clock rate: 1 trigger per beat":"Multiplication: ".concat(Math.round(n)," trigger").concat(Math.round(n)>1?"s":""," per beat"))),a.createElement("div",null,a.createElement("label",{style:{display:"block",color:"#e2e8f0",fontSize:"14px",fontWeight:"600",marginBottom:"8px"}},"Probability: ",(100*t).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:t,onChange:function(e){return x("prob".concat(_),parseFloat(e.target.value))},style:{width:"100%",accentColor:"#f59e0b"}}),a.createElement("div",{style:{color:"#94a3b8",fontSize:"12px",marginTop:"4px"}},1===t?"Always triggers":0===t?"Never triggers":"".concat((100*t).toFixed(0),"% chance to trigger"))),a.createElement("div",null,a.createElement("label",{style:{display:"block",color:"#e2e8f0",fontSize:"14px",fontWeight:"600",marginBottom:"8px"}},"Euclidean Fill: ",o,""),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("button",{onClick:function(){var e=Math.max(1,o-1);x("euclid".concat(_),e)},style:{width:"36px",height:"36px",borderRadius:"6px",border:"none",backgroundColor:"#374151",color:"#e2e8f0",fontSize:"18px",fontWeight:"bold",cursor:"pointer",transition:"all 0.2s ease"}},"-"),a.createElement("input",{type:"number",min:"1",max:"8",value:o,onChange:function(e){var n=parseInt(e.target.value);n>=1&&n<=8&&x("euclid".concat(_),n)},style:{flex:1,padding:"8px",borderRadius:"6px",border:"1px solid #374151",backgroundColor:"#1f2937",color:"#22c55e",fontSize:"16px",fontWeight:"bold",textAlign:"center"}}),a.createElement("button",{onClick:function(){var e=Math.min(8,o+1);x("euclid".concat(_),e)},style:{width:"36px",height:"36px",borderRadius:"6px",border:"none",backgroundColor:"#374151",color:"#e2e8f0",fontSize:"18px",fontWeight:"bold",cursor:"pointer",transition:"all 0.2s ease"}},"+")),a.createElement("div",{style:{color:"#94a3b8",fontSize:"12px",marginTop:"4px"}},1===o?"No subdivision (normal rate)":"Fill button multiplies rate by ".concat(o,""))),a.createElement("div",{style:{gridColumn:"1 / -1",marginTop:"8px"}},a.createElement("button",{onClick:function(){return x("gate_mode".concat(_),!r)},style:{width:"100%",padding:"12px",borderRadius:"6px",border:"none",backgroundColor:r?"#ef4444":"#3b82f6",color:"white",fontSize:"14px",fontWeight:"600",cursor:"pointer",transition:"all 0.2s ease"}},r?"GATE Mode":"CLOCK Mode"),a.createElement("div",{style:{color:"#94a3b8",fontSize:"12px",textAlign:"center",marginTop:"4px"}},r?"Outputs gate pulses":"Outputs clock/toggle signals"))))),a.createElement("div",{style:{marginTop:"20px",padding:"16px",backgroundColor:"#0f172a",borderRadius:"8px",border:"1px solid #374151",color:"#94a3b8",fontSize:"12px",lineHeight:"1.5"}},a.createElement("div",null,a.createElement("strong",{style:{color:"#22c55e"}},"Instructions:")),a.createElement("div",{style:{marginTop:"8px"}}," Click circles to select outputs",a.createElement("br",null)," ",a.createElement("strong",null,"Rate slider:")," Discrete musical intervals - divisions (16, 12, 8, 6, 4, 3, 2), center (1), multiplications (2, 3, 4, 6, 8, 12, 16)",a.createElement("br",null)," ",a.createElement("strong",null,"Triplets:")," 12, 6, 3, 3, 6, 12 for polyrhythmic patterns",a.createElement("br",null)," ",a.createElement("strong",null,"Euclidean fill:")," Set subdivision (1-8), then hold hardware button to multiply rate by this value",a.createElement("br",null)," ",a.createElement("strong",null,"During fill:"),' Hardware pot attenuates probability for expressive "thinning"',a.createElement("br",null)," ",a.createElement("strong",null,"Probability:")," Controls output trigger chance (100% = always, 0% = never)",a.createElement("br",null)," ",a.createElement("strong",null,"Gate mode:")," Outputs pulses (for drums), ",a.createElement("strong",null,"Clock mode:")," Outputs toggles (for sequencers)",a.createElement("br",null)," ",a.createElement("strong",null,"Outputs 5-8:")," Enable checkbox to use second hardware bank (8 channels total)"))))};function On(e){return function(e){if(Array.isArray(e))return zn(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||Bn(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Tn(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,r,c,i=[],l=!0,s=!1;try{if(r=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=r.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(c=t.return(),Object(c)!==c))return}finally{if(s)throw o}}return i}}(e,n)||Bn(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Bn(e,n){if(e){if("string"==typeof e)return zn(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?zn(e,n):void 0}}function zn(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}var Fn=function(e){var n=e.module,t=e.onUpdateParam,o=e.onClose,r=(0,a.useRef)(null),c=Tn((0,a.useState)(0),2),i=c[0],l=c[1],s=Tn((0,a.useState)("custom"),2),u=s[0],d=s[1],p=Tn((0,a.useState)(!1),2),f=p[0],m=p[1],_=Tn((0,a.useState)(!1),2),g=_[0],h=_[1],v=Tn((0,a.useState)(256),1)[0],b=Tn((0,a.useState)(function(){var e=n.params.wavetables||[];if(0===e.length){for(var t=[],a=0;a<4;a++){var o=new Float32Array(v);if(0===a)for(var r=0;r<v;r++)o[r]=Math.sin(r/v*2*Math.PI);t.push(o)}return t}return e.map(function(e){return e instanceof Float32Array?e:new Float32Array(e)})}),2),y=b[0],k=b[1],S=(0,a.useCallback)(function(e){for(var n=new Float32Array(v),t=0;t<v;t++){var a=t/v*2*Math.PI;switch(e){case"sine":n[t]=Math.sin(a);break;case"saw":n[t]=t/v*2-1;break;case"square":n[t]=t<v/2?1:-1;break;case"triangle":n[t]=t<v/4?t/v*4:t<3*v/4?2-t/v*4:t/v*4-4;break;case"noise":n[t]=2*Math.random()-1;break;case"pulse25":n[t]=t<v/4?1:-1;break;case"pulse12":n[t]=t<v/8?1:-1;break;default:n[t]=0}}return n},[v]),x=(0,a.useCallback)(function(){var e=r.current;if(e){var n=e.getContext("2d"),t=e.width,a=e.height;n.fillStyle="#1e293b",n.fillRect(0,0,t,a),n.strokeStyle="#334155",n.lineWidth=1,n.beginPath(),n.moveTo(0,a/2),n.lineTo(t,a/2),n.stroke();for(var o=0;o<=8;o++)n.beginPath(),n.moveTo(t/8*o,0),n.lineTo(t/8*o,a),n.stroke();var c=y[i];if(c&&0!==c.length){n.strokeStyle="#22c55e",n.lineWidth=2,n.beginPath();for(var l=0;l<v;l++){var s=l/v*t,u=a/2-c[l]*a*.4;0===l?n.moveTo(s,u):n.lineTo(s,u)}if(n.stroke(),g)for(var d=0;d<y.length;d++)if(d!==i){var p=y[d];if(p&&0!==p.length){n.strokeStyle="rgba(148, 163, 184, 0.3)",n.lineWidth=1,n.beginPath();for(var f=0;f<v;f++){var m=f/v*t,_=a/2-p[f]*a*.4;0===f?n.moveTo(m,_):n.lineTo(m,_)}n.stroke()}}for(var h=0;h<4;h++)n.fillStyle=h===i?"#22c55e":"#475569",n.fillRect(10+25*h,10,20,20),n.fillStyle="#fff",n.font="12px monospace",n.textAlign="center",n.fillText((h+1).toString(),20+25*h,24)}}},[y,i,v,g]),E=(0,a.useCallback)(function(e){if("custom"===u){m(!0);var n=r.current,t=n.getBoundingClientRect(),a=n.width/t.width,o=n.height/t.height,c=(e.clientX-t.left)*a,l=(e.clientY-t.top)*o,s=Math.floor(c/n.width*v),d=1-l/n.height*2;if(s>=0&&s<v){var p=On(y),f=new Float32Array(p[i]);f[s]=Math.max(-1,Math.min(1,d)),p[i]=f,k(p),x()}}},[u,v,y,i,x]),P=(0,a.useCallback)(function(e){if(f&&"custom"===u){var n=r.current,t=n.getBoundingClientRect(),a=n.width/t.width,o=n.height/t.height,c=(e.clientX-t.left)*a,l=(e.clientY-t.top)*o,s=Math.floor(c/n.width*v),d=1-l/n.height*2;if(s>=0&&s<v){var p=On(y),m=new Float32Array(p[i]);m[s]=Math.max(-1,Math.min(1,d)),s>0&&(m[s-1]=(m[s-1]+d)/2),s<v-1&&(m[s+1]=(m[s+1]+d)/2),p[i]=m,k(p),x()}}},[f,u,v,y,i,x]),w=(0,a.useCallback)(function(){f&&(m(!1),t(n.id,"wavetables",y))},[f,y,n.id,t]),C=(0,a.useCallback)(function(e){var a=S(e),o=On(y);o[i]=a,k(o),t(n.id,"wavetables",o),x()},[i,y,S,x,n.id,t]),R=(0,a.useCallback)(function(){for(var e=On(y),a=e[i],o=0,r=0;r<v;r++)o=Math.max(o,Math.abs(a[r]));if(o>0){for(var c=new Float32Array(v),l=0;l<v;l++)c[l]=a[l]/o;e[i]=c}k(e),t(n.id,"wavetables",e),x()},[i,y,v,x,n.id,t]),L=(0,a.useCallback)(function(){for(var e=On(y),a=e[i],o=new Float32Array(v),r=0;r<v;r++){var c=a[(r-1+v)%v],l=a[r],s=a[(r+1)%v];o[r]=(c+2*l+s)/4}e[i]=o,k(e),t(n.id,"wavetables",e),x()},[i,y,v,x,n.id,t]),I=(0,a.useCallback)(function(){var e=y[i];localStorage.setItem("wavetable_clipboard",JSON.stringify(Array.from(e)))},[i,y]),M=(0,a.useCallback)(function(){var e=localStorage.getItem("wavetable_clipboard");if(e)try{var a=JSON.parse(e),o=On(y);o[i]=new Float32Array(a),k(o),t(n.id,"wavetables",o),x()}catch(e){console.error("Failed to paste wavetable:",e)}},[i,y,x,n.id,t]);return(0,a.useEffect)(function(){x()},[x,y,i]),(0,a.useEffect)(function(){var e=function(){return x()};return window.addEventListener("resize",e),function(){return window.removeEventListener("resize",e)}},[x]),(0,a.useEffect)(function(){y&&y.length>0&&t(n.id,"wavetables",y)},[y,n.id]),(0,a.useEffect)(function(){var e=function(e){"Escape"===e.key&&o()};return document.addEventListener("keydown",e),function(){return document.removeEventListener("keydown",e)}},[o]),a.createElement("div",{className:"modal-overlay",onClick:o},a.createElement("div",{className:"modal-content wavetable-editor",onClick:function(e){return e.stopPropagation()}},a.createElement("div",{className:"modal-header",style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"12px",paddingBottom:"12px",borderBottom:"1px solid #334155"}},a.createElement("h2",{style:{margin:0,color:"#22c55e",fontSize:"18px"}}," Wavetable Editor - ",n.id),a.createElement("button",{onClick:o,style:{width:"32px",height:"32px",borderRadius:"4px",border:"none",background:"#dc2626",color:"#fff",fontSize:"18px",fontWeight:"bold",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",boxShadow:"0 2px 4px rgba(0, 0, 0, 0.3)"},title:"Close Editor (ESC)"},"")),a.createElement("div",{className:"wavetable-canvas-container"},a.createElement("canvas",{ref:r,width:800,height:300,onMouseDown:E,onMouseMove:P,onMouseUp:w,onMouseLeave:w,style:{cursor:"custom"===u?"crosshair":"default",width:"100%",height:"300px"}})),a.createElement("div",{className:"wavetable-controls"},a.createElement("div",{className:"control-section"},a.createElement("label",null,"Table Slot:"),a.createElement("div",{className:"table-selector"},[0,1,2,3].map(function(e){return a.createElement("button",{key:e,className:"table-btn ".concat(i===e?"active":""),onClick:function(){return l(e)}},e+1)}))),a.createElement("div",{className:"control-section"},a.createElement("label",null,"Presets:"),a.createElement("div",{className:"preset-buttons"},a.createElement("button",{onClick:function(){return C("sine")}},"Sine"),a.createElement("button",{onClick:function(){return C("saw")}},"Saw"),a.createElement("button",{onClick:function(){return C("square")}},"Square"),a.createElement("button",{onClick:function(){return C("triangle")}},"Triangle"),a.createElement("button",{onClick:function(){return C("pulse25")}},"Pulse 25%"),a.createElement("button",{onClick:function(){return C("pulse12")}},"Pulse 12%"),a.createElement("button",{onClick:function(){return C("noise")}},"Noise"))),a.createElement("div",{className:"control-section"},a.createElement("label",null,"Tools:"),a.createElement("div",{className:"tool-buttons"},a.createElement("button",{className:"custom"===u?"active":"",onClick:function(){return d("custom")}},"Draw"),a.createElement("button",{onClick:R},"Normalize"),a.createElement("button",{onClick:L},"Smooth"),a.createElement("button",{onClick:I},"Copy"),a.createElement("button",{onClick:M},"Paste")))),a.createElement("div",{className:"morphing-section"},a.createElement("h3",null,"ADSR Morphing"),a.createElement("div",{className:"morphing-controls"},a.createElement("label",null,a.createElement("input",{type:"checkbox",checked:n.params.adsr_morph||!1,onChange:function(e){return t(n.id,"adsr_morph",e.target.checked)}}),"Enable ADSR Morphing"),n.params.adsr_morph&&a.createElement(a.Fragment,null,a.createElement("div",{className:"morph-mapping"},a.createElement("div",{className:"morph-row"},a.createElement("label",null,"Attack Table:"),a.createElement("select",{value:n.params.attack_table||0,onChange:function(e){return t(n.id,"attack_table",parseInt(e.target.value))}},[0,1,2,3].map(function(e){return a.createElement("option",{key:e,value:e},"Table ",e+1)}))),a.createElement("div",{className:"morph-row"},a.createElement("label",null,"Decay Table:"),a.createElement("select",{value:n.params.decay_table||1,onChange:function(e){return t(n.id,"decay_table",parseInt(e.target.value))}},[0,1,2,3].map(function(e){return a.createElement("option",{key:e,value:e},"Table ",e+1)}))),a.createElement("div",{className:"morph-row"},a.createElement("label",null,"Sustain Table:"),a.createElement("select",{value:n.params.sustain_table||2,onChange:function(e){return t(n.id,"sustain_table",parseInt(e.target.value))}},[0,1,2,3].map(function(e){return a.createElement("option",{key:e,value:e},"Table ",e+1)}))),a.createElement("div",{className:"morph-row"},a.createElement("label",null,"Release Table:"),a.createElement("select",{value:n.params.release_table||3,onChange:function(e){return t(n.id,"release_table",parseInt(e.target.value))}},[0,1,2,3].map(function(e){return a.createElement("option",{key:e,value:e},"Table ",e+1)})))),a.createElement("label",{style:{marginTop:"10px"}},a.createElement("input",{type:"checkbox",checked:g,onChange:function(e){return h(e.target.checked)}}),"Show All Tables (Preview Morphing)")))),a.createElement("div",{className:"wavetable-info"},a.createElement("p",null,"Table Size: ",v," samples"),a.createElement("p",null,"Click and drag to draw custom waveforms when Draw mode is active"))),a.createElement("style",{jsx:!0},"\n                .wavetable-editor {\n                    width: 900px;\n                    max-width: 90vw;\n                    max-height: 90vh;\n                    overflow-y: auto;\n                }\n                \n                .wavetable-controls {\n                    padding: 20px;\n                    background: #0f172a;\n                    border-radius: 8px;\n                    margin-bottom: 20px;\n                }\n                \n                .control-section {\n                    margin-bottom: 15px;\n                }\n                \n                .control-section label {\n                    display: block;\n                    margin-bottom: 8px;\n                    color: #94a3b8;\n                    font-size: 12px;\n                    text-transform: uppercase;\n                    letter-spacing: 0.5px;\n                }\n                \n                .table-selector {\n                    display: flex;\n                    gap: 10px;\n                }\n                \n                .table-btn {\n                    padding: 8px 16px;\n                    background: #1e293b;\n                    border: 1px solid #334155;\n                    border-radius: 4px;\n                    color: #94a3b8;\n                    cursor: pointer;\n                    transition: all 0.2s;\n                }\n                \n                .table-btn.active {\n                    background: #22c55e;\n                    color: white;\n                    border-color: #22c55e;\n                }\n                \n                .preset-buttons, .tool-buttons {\n                    display: flex;\n                    gap: 8px;\n                    flex-wrap: wrap;\n                }\n                \n                .preset-buttons button, .tool-buttons button {\n                    padding: 6px 12px;\n                    background: #1e293b;\n                    border: 1px solid #334155;\n                    border-radius: 4px;\n                    color: #94a3b8;\n                    cursor: pointer;\n                    font-size: 12px;\n                    transition: all 0.2s;\n                }\n                \n                .preset-buttons button:hover, .tool-buttons button:hover {\n                    background: #334155;\n                    color: white;\n                }\n                \n                .tool-buttons button.active {\n                    background: #3b82f6;\n                    color: white;\n                    border-color: #3b82f6;\n                }\n                \n                .wavetable-canvas-container {\n                    background: #0f172a;\n                    border-radius: 8px;\n                    padding: 20px;\n                    margin-bottom: 20px;\n                }\n                \n                .morphing-section {\n                    background: #0f172a;\n                    border-radius: 8px;\n                    padding: 20px;\n                    margin-bottom: 20px;\n                }\n                \n                .morphing-section h3 {\n                    color: #22c55e;\n                    margin-bottom: 15px;\n                }\n                \n                .morphing-controls label {\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: #94a3b8;\n                    margin-bottom: 10px;\n                }\n                \n                .morph-mapping {\n                    margin-top: 15px;\n                    padding: 15px;\n                    background: #1e293b;\n                    border-radius: 6px;\n                }\n                \n                .morph-row {\n                    display: flex;\n                    align-items: center;\n                    gap: 10px;\n                    margin-bottom: 10px;\n                }\n                \n                .morph-row label {\n                    flex: 0 0 120px;\n                    margin-bottom: 0;\n                }\n                \n                .morph-row select {\n                    flex: 1;\n                    padding: 4px 8px;\n                    background: #0f172a;\n                    border: 1px solid #334155;\n                    border-radius: 4px;\n                    color: white;\n                }\n                \n                .wavetable-info {\n                    padding: 15px;\n                    background: #0f172a;\n                    border-radius: 8px;\n                    color: #64748b;\n                    font-size: 12px;\n                }\n                \n                .wavetable-info p {\n                    margin: 5px 0;\n                }\n            "))};function Nn(e){return Nn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Nn(e)}function Gn(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function qn(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?Gn(Object(t),!0).forEach(function(n){Un(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):Gn(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function Un(e,n,t){return(n=function(e){var n=function(e){if("object"!=Nn(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=Nn(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==Nn(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function Wn(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,r,c,i=[],l=!0,s=!1;try{if(r=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=r.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(c=t.return(),Object(c)!==c))return}finally{if(s)throw o}}return i}}(e,n)||Vn(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Vn(e,n){if(e){if("string"==typeof e)return Hn(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Hn(e,n):void 0}}function Hn(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}const jn=function(e){var n,t,o,r,c=e.module,i=e.onUpdateParam,l=e.onClose,s=e.fullscreen,u=void 0!==s&&s,d=(0,a.useRef)(null),p=Wn((0,a.useState)((null==c||null===(n=c.params)||void 0===n?void 0:n.tuning)||"12-TET"),2),f=p[0],m=p[1],_=Wn((0,a.useState)((null==c||null===(t=c.params)||void 0===t?void 0:t.scale)||"major"),2),g=_[0],h=_[1],v=Wn((0,a.useState)((null==c||null===(o=c.params)||void 0===o?void 0:o.root_note)||"C"),2),b=v[0],y=v[1],k=Wn((0,a.useState)((null==c||null===(r=c.params)||void 0===r?void 0:r.base_octave)||4),2),S=k[0],x=k[1],E=Wn((0,a.useState)(!1),2),P=E[0],w=E[1],C=Wn((0,a.useState)([]),2),R=C[0],L=C[1],I=Wn((0,a.useState)({}),2),M=(I[0],I[1]),D=Wn((0,a.useState)(!1),2),A=D[0],O=D[1],T=Wn((0,a.useState)(""),2),B=T[0],z=T[1],F=Wn((0,a.useState)(null),2),N=F[0],G=F[1],q=Wn((0,a.useState)(.5),2),U=q[0],W=q[1],V={"12-TET":{name:"12-Tone Equal Temperament",intervals:[0,100,200,300,400,500,600,700,800,900,1e3,1100],noteNames:["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]},"19-TET":{name:"19-Tone Equal Temperament",intervals:Array.from({length:19},function(e,n){return 1200*n/19}),noteNames:["C","C+","C#","Db-","D","D+","D#","Eb-","E","E+","F","F+","F#","Gb-","G","G+","G#","Ab-","A"]},"24-TET":{name:"24-Tone Equal Temperament (Quarter-tone)",intervals:Array.from({length:24},function(e,n){return 1200*n/24}),noteNames:["C","C","C#","C#","D","D","D#","D#","E","E","F","F","F#","F#","G","G","G#","G#","A","A","A#","A#","B","B"]},"31-TET":{name:"31-Tone Equal Temperament",intervals:Array.from({length:31},function(e,n){return 1200*n/31}),noteNames:Array.from({length:31},function(e,n){return"".concat(n)})},Just:{name:"Just Intonation (5-limit)",intervals:[0,111.73,203.91,315.64,386.31,498.04,590.22,701.96,813.69,884.36,1017.6,1088.27],noteNames:["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]},Pythagorean:{name:"Pythagorean Tuning",intervals:[0,113.69,203.91,294.13,407.82,498.04,611.73,701.96,792.18,905.87,996.09,1109.78],noteNames:["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]}},H={chromatic:{name:"Chromatic (All Notes)",pattern:[0,1,2,3,4,5,6,7,8,9,10,11]},major:{name:"Major (Ionian)",pattern:[0,2,4,5,7,9,11]},minor:{name:"Natural Minor (Aeolian)",pattern:[0,2,3,5,7,8,10]},dorian:{name:"Dorian",pattern:[0,2,3,5,7,9,10]},phrygian:{name:"Phrygian",pattern:[0,1,3,5,7,8,10]},lydian:{name:"Lydian",pattern:[0,2,4,6,7,9,11]},mixolydian:{name:"Mixolydian",pattern:[0,2,4,5,7,9,10]},locrian:{name:"Locrian",pattern:[0,1,3,5,6,8,10]},pentatonic:{name:"Pentatonic Major",pattern:[0,2,4,7,9]},blues:{name:"Blues",pattern:[0,3,5,6,7,10]},harmonic_minor:{name:"Harmonic Minor",pattern:[0,2,3,5,7,8,11]},whole_tone:{name:"Whole Tone",pattern:[0,2,4,6,8,10]}},j=function(e){return(arguments.length>1&&void 0!==arguments[1]?arguments[1]:440)*Math.pow(2,e/1200)},K=function(e,n){var t=n-80,a=440*Math.pow(2,S-4)*Math.pow(2,-.75),o=a,r=2*a,c=Math.log10(o),i=Math.log10(r);return n-40-(Math.log10(e)-c)/(i-c)*t},$=function(){for(var e=V[f],n=P?{pattern:R}:H[g],t=440*Math.pow(2,S-4),a=[],o=0;o<e.intervals.length;o++){var r=e.intervals[o]-900,c=j(r,t);a.push({freq:c,cents:r,noteIndex:o,octave:S,noteName:e.noteNames[o],inScale:n.pattern.includes(o),isCustom:P})}return a},Y=function(){if(0!==R.length)if(B.trim()){var e={name:B.trim(),pattern:R,tuningSystem:f,created:(new Date).toISOString()};M(function(n){return qn(qn({},n),{},Un({},B.trim(),e))}),H[B.trim()]={name:B.trim()+" (Custom)",pattern:R},h(B.trim()),w(!1),O(!1),z(""),L([]),alert('Scale "'.concat(B.trim(),'" saved successfully!'))}else alert("Please enter a name for your scale!");else alert("Please select some notes first!")},X=function(e,n){i&&c&&i(c.id,e,n)};(0,a.useEffect)(function(){var e=function(e){"Escape"===e.key&&(A?(O(!1),z("")):l())};return document.addEventListener("keydown",e),function(){return document.removeEventListener("keydown",e)}},[l,A]),(0,a.useEffect)(function(){!function(){var e=d.current;if(e){var n=e.getContext("2d"),t=e.width,a=e.height;n.fillStyle="#0c1428",n.fillRect(0,0,t,a);var o=40,r=t-80;n.strokeStyle="#334155",n.fillStyle="#94a3b8",n.font="10px monospace";var c=440*Math.pow(2,S-4)*Math.pow(2,-.75);[Math.round(10*c)/10,Math.round(1.25992*c*10)/10,Math.round(1.49831*c*10)/10,Math.round(2*c*10)/10].forEach(function(e){var r=K(e,a);r>=o&&r<=a-o&&(n.beginPath(),n.moveTo(o,r),n.lineTo(t-o,r),n.stroke(),n.fillText("".concat(e,"Hz"),5,r+3))});var i=o+U*r;n.strokeStyle="#22c55e",n.lineWidth=2,n.beginPath(),n.moveTo(i,o),n.lineTo(i,a-o),n.stroke();var l=$();l.forEach(function(e,t){var c=o+t/(l.length-1)*r,i=K(e.freq,a);n.strokeStyle="#10b981",n.lineWidth=1,n.beginPath(),n.moveTo(c,o),n.lineTo(c,a-o),n.stroke(),e.inScale?(n.fillStyle="#eab308",n.strokeStyle="#fbbf24"):(n.fillStyle="#10b981",n.strokeStyle="#34d399"),n.lineWidth=2,n.beginPath(),n.arc(c,i,9,0,2*Math.PI),n.fill(),n.stroke(),n.fillStyle=e.inScale?"#eab308":"#10b981",n.font="12px monospace";var s=n.measureText(e.noteName+e.octave).width;n.fillText(e.noteName+e.octave,c-s/2,i-15)}),n.strokeStyle="#22c55e",n.lineWidth=3,n.beginPath();var s=l.filter(function(e){return e.inScale});s.forEach(function(e,t){var c=o+s.indexOf(e)/(s.length-1)*r,i=K(e.freq,a);0===t?n.moveTo(c,i):n.lineTo(c,i)}),n.stroke();var u=Math.floor(U*(s.length-1)),p=s[u];if(p){var f=o+U*r,m=K(p.freq,a);n.fillStyle="#f59e0b",n.beginPath(),n.arc(f,m,6,0,2*Math.PI),n.fill(),n.fillStyle="#f59e0b",n.font="12px monospace",n.fillText("".concat(p.noteName).concat(p.octave,": ").concat(p.freq.toFixed(1),"Hz"),f+10,m-10)}N&&(n.fillStyle="#ffffff",n.font="11px monospace",n.fillText("".concat(N.noteName).concat(N.octave,": ").concat(N.freq.toFixed(1),"Hz (").concat(N.cents.toFixed(1)," cents)"),10,a-10))}}()},[f,g,S,P,R,U,N]),(0,a.useEffect)(function(){X("tuning",f)},[f]),(0,a.useEffect)(function(){X("scale",g)},[g]),(0,a.useEffect)(function(){X("base_octave",S)},[S]),(0,a.useEffect)(function(){X("root_note",b)},[b]);var Z=a.createElement("div",{style:{display:"flex",flexDirection:"column",height:"100%",gap:"12px"}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",paddingBottom:"12px",borderBottom:"1px solid #334155"}},a.createElement("h3",{style:{color:"#22c55e",margin:0,fontSize:"18px"}}," Scale & Tuning Visualizer"),a.createElement("button",{onClick:l,style:{width:"32px",height:"32px",borderRadius:"4px",border:"none",background:"#dc2626",color:"#fff",fontSize:"18px",fontWeight:"bold",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",boxShadow:"0 2px 4px rgba(0, 0, 0, 0.3)"},title:"Close Editor (ESC)"},"")),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr",gap:"16px",marginBottom:"12px"}},a.createElement("div",null,a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Tuning System"),a.createElement("select",{value:f,onChange:function(e){return m(e.target.value)},style:{width:"100%",padding:"6px",borderRadius:"4px",border:"1px solid #334155",background:"#0f172a",color:"#e2e8f0",fontSize:"12px"}},Object.entries(V).map(function(e){var n=Wn(e,2),t=n[0],o=n[1];return a.createElement("option",{key:t,value:t},o.name)}))),a.createElement("div",null,P?a.createElement("div",{style:{display:"flex",gap:"4px",marginBottom:"8px"}},a.createElement("button",{onClick:function(){R.length>0?O(!0):alert("Please select some notes first!")},style:{flex:1,padding:"8px",borderRadius:"4px",border:"1px solid #334155",background:R.length>0?"#eab308":"#374151",color:R.length>0?"#0f172a":"#9ca3af",fontSize:"12px",cursor:R.length>0?"pointer":"not-allowed",fontWeight:"bold"},disabled:0===R.length}," Save Scale (",R.length,")"),a.createElement("button",{onClick:function(){w(!1),L([])},style:{padding:"8px 12px",borderRadius:"4px",border:"1px solid #334155",background:"#dc2626",color:"#fff",fontSize:"12px",cursor:"pointer",fontWeight:"bold"}},"")):a.createElement("button",{onClick:function(){w(!0),L([])},style:{width:"100%",padding:"8px",borderRadius:"4px",border:"1px solid #334155",background:"#0f172a",color:"#e2e8f0",fontSize:"12px",cursor:"pointer",fontWeight:"bold",marginBottom:"8px"}}," Create Custom Scale")),!P&&a.createElement("div",null,a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Scale Pattern"),a.createElement("select",{value:g,onChange:function(e){return h(e.target.value)},style:{width:"100%",padding:"6px",borderRadius:"4px",border:"1px solid #334155",background:"#0f172a",color:"#e2e8f0",fontSize:"12px"}},Object.entries(H).map(function(e){var n=Wn(e,2),t=n[0],o=n[1];return a.createElement("option",{key:t,value:t},o.name)}))),P&&a.createElement("div",null,a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Custom Scale: ",R.length," notes selected"),a.createElement("div",{style:{padding:"8px",background:"#0f172a",border:"1px solid #334155",borderRadius:"4px",fontSize:"11px",color:"#94a3b8",fontStyle:"italic"}},"Click on green tuning intervals below to build your custom scale. Selected notes will turn yellow."),R.length>0&&a.createElement("div",{style:{marginTop:"4px",fontSize:"11px",color:"#22c55e"}},"Selected intervals: ",R.join(", "))),a.createElement("div",null,a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Root Note"),a.createElement("select",{value:b,onChange:function(e){return y(e.target.value)},style:{width:"100%",padding:"6px",borderRadius:"4px",border:"1px solid #334155",background:"#0f172a",color:"#e2e8f0",fontSize:"12px"}},["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"].map(function(e){return a.createElement("option",{key:e,value:e},e)}))),a.createElement("div",null,a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Base Octave: ",S),a.createElement("input",{type:"range",min:"0",max:"8",value:S,onChange:function(e){return x(parseInt(e.target.value))},style:{width:"100%"}}))),A&&a.createElement("div",{style:{position:"absolute",top:0,left:0,right:0,bottom:0,background:"rgba(0, 0, 0, 0.8)",display:"flex",alignItems:"center",justifyContent:"center",zIndex:1e3}},a.createElement("div",{style:{background:"#1e293b",border:"1px solid #334155",borderRadius:"8px",padding:"20px",minWidth:"300px",maxWidth:"400px"}},a.createElement("h3",{style:{color:"#e2e8f0",marginTop:0,marginBottom:"16px"}},"Save Custom Scale"),a.createElement("div",{style:{marginBottom:"16px"}},a.createElement("label",{style:{color:"#cbd5e1",fontSize:"12px",display:"block",marginBottom:"4px"}},"Scale Name:"),a.createElement("input",{type:"text",value:B,onChange:function(e){return z(e.target.value)},placeholder:"Enter scale name...",style:{width:"100%",padding:"8px",borderRadius:"4px",border:"1px solid #334155",background:"#0f172a",color:"#e2e8f0",fontSize:"14px"},onKeyDown:function(e){"Enter"===e.key?Y():"Escape"===e.key&&(O(!1),z(""))},autoFocus:!0})),a.createElement("div",{style:{marginBottom:"16px",fontSize:"12px",color:"#94a3b8"}},a.createElement("div",null,"Tuning System: ",a.createElement("span",{style:{color:"#22c55e"}},V[f].name)),a.createElement("div",null,"Selected Notes: ",a.createElement("span",{style:{color:"#eab308"}},R.join(", ")))),a.createElement("div",{style:{display:"flex",gap:"8px"}},a.createElement("button",{onClick:Y,style:{flex:1,padding:"8px 16px",borderRadius:"4px",border:"1px solid #334155",background:"#22c55e",color:"#0f172a",fontSize:"12px",cursor:"pointer",fontWeight:"bold"}}," Save Scale"),a.createElement("button",{onClick:function(){O(!1),z("")},style:{padding:"8px 16px",borderRadius:"4px",border:"1px solid #334155",background:"#374151",color:"#e2e8f0",fontSize:"12px",cursor:"pointer"}},"Cancel")))),a.createElement("div",{style:{flex:1,border:"1px solid #334155",borderRadius:"8px",overflow:"hidden",minHeight:"400px"}},a.createElement("canvas",{ref:d,width:800,height:400,onMouseMove:function(e){var n=d.current,t=n.getBoundingClientRect(),a=n.width/t.width,o=n.height/t.height,r=(e.clientX-t.left)*a,c=(e.clientY-t.top)*o,i=n.width-80;if(r>=40&&r<=n.width-40){var l=(r-40)/i;W(Math.max(0,Math.min(1,l)))}var s=$(),u=null,p=1/0;s.forEach(function(e,t){var a=40+t/(s.length-1)*i,o=K(e.freq,n.height),l=Math.sqrt(Math.pow(r-a,2)+Math.pow(c-o,2));l<15&&l<p&&(p=l,u=e)}),G(u)},onClick:function(e){if(P){var n=d.current,t=n.getBoundingClientRect(),a=n.width/t.width,o=n.height/t.height,r=(e.clientX-t.left)*a,c=(e.clientY-t.top)*o,i=n.width-80,l=$(),s=null,u=1/0;if(l.forEach(function(e,t){var a=40+t/(l.length-1)*i,o=K(e.freq,n.height),d=Math.sqrt(Math.pow(r-a,2)+Math.pow(c-o,2));d<20&&d<u&&(u=d,s=e)}),s){var p=s.noteIndex;R.includes(p)?L(function(e){return e.filter(function(e){return e!==p})}):L(function(e){return[].concat((n=e,function(e){if(Array.isArray(e))return Hn(e)}(n)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(n)||Vn(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),[p]).sort(function(e,n){return e-n});var n})}}},style:{width:"100%",height:"100%",display:"block",cursor:P?"pointer":"crosshair"}})),a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",display:"flex",gap:"16px",flexWrap:"wrap"}},a.createElement("span",null," ",a.createElement("span",{style:{color:"#10b981"}},"Tuning System Intervals")),a.createElement("span",null," ",a.createElement("span",{style:{color:"#eab308"}},"Scale Notes")),a.createElement("span",null," ",a.createElement("span",{style:{color:"#22c55e"}},"S&H Input Position")),N&&a.createElement("span",null," ",a.createElement("span",{style:{color:"#22c55e"}},N.noteName,N.octave,": ",Math.round(10*N.freq)/10,"Hz"))));return u?a.createElement("div",{className:"modal-overlay"},a.createElement("div",{className:"modal-content",style:{maxWidth:"95vw",maxHeight:"90vh"}},Z)):Z},Kn=function(e){var n=e.module,t=e.modules,o=e.onUpdateParam,r=e.onClose,c=e.fullscreen;return a.createElement(dn,{module:n,modules:t,onUpdateParam:o,onClose:r,fullscreen:c})};function $n(e){return $n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},$n(e)}function Yn(e){return function(e){if(Array.isArray(e))return nt(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||et(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Xn(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function Zn(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?Xn(Object(t),!0).forEach(function(n){Qn(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):Xn(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function Qn(e,n,t){return(n=function(e){var n=function(e){if("object"!=$n(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=$n(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==$n(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function Jn(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,r,c,i=[],l=!0,s=!1;try{if(r=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=r.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(c=t.return(),Object(c)!==c))return}finally{if(s)throw o}}return i}}(e,n)||et(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function et(e,n){if(e){if("string"==typeof e)return nt(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?nt(e,n):void 0}}function nt(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}const tt=function(e){var n=e.module,t=(e.modules,e.onUpdateParam),o=e.onClose,r=e.fullscreen,c=Jn((0,a.useState)(void 0!==n.params.harmonic_linking&&n.params.harmonic_linking),2),i=c[0],l=c[1],s=Jn((0,a.useState)(n.params.harmonic_follow_steps||[-1,-1,-1,-1]),2),u=s[0],d=s[1],p=Jn((0,a.useState)(n.params.harmonic_intervals||[7,7,7,7]),2),f=p[0],m=p[1];(0,a.useEffect)(function(){console.log("HarmonicSequencer module.params changed:",n.params);var e,t=n.params.bank0_steps;t&&console.log("bank0_steps step 0 pitchRandomness:",null===(e=t[0])||void 0===e?void 0:e.pitchRandomness)},[n.params]);var _,g,h,v,b,y,k,S=Jn((0,a.useState)(n.params.show_individual_outputs||!1),2),x=S[0],E=S[1],P=function(){return(n.params.steps||[{pitch:0,duration:1,muted:!1,active:!0,pattern:"static",interval:2,probability:.5},{pitch:.25,duration:1,muted:!1,active:!0,pattern:"up_down",interval:3,probability:.7},{pitch:.5,duration:1,muted:!1,active:!0,pattern:"chord",interval:4,probability:.8},{pitch:.75,duration:1,muted:!1,active:!0,pattern:"static",interval:1,probability:.3}]).map(function(e){return Zn(Zn({},e),{},{pitchRandomness:void 0!==e.pitchRandomness?e.pitchRandomness:0,probability:void 0!==e.probability?e.probability:1,patternProbability:void 0!==e.patternProbability?e.patternProbability:1,pattern:e.pattern||"static",interval:void 0!==e.interval?e.interval:2,glissando_time:void 0!==e.glissando_time?e.glissando_time:0,glissando_probability:void 0!==e.glissando_probability?e.glissando_probability:0,glissando_curve:void 0!==e.glissando_curve?e.glissando_curve:"linear"})})},w=function(e,a){var o=Yn(P());o[e]=Zn(Zn({},o[e]),a),console.log("updateStep: step ".concat(e,", updates:"),a),console.log("newSteps[stepIndex]:",o[e]),t(n.id,"steps",o)},C=function(e,n){var t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];console.log("updateStepPitch: step=".concat(e,", pitch=").concat(n));var a=Math.max(0,Math.min(1,n));if(w(e,{pitch:a}),t&&i&&e===harmonicMasterStep){var o=Math.round(12*a);harmonicSlaveSteps.forEach(function(e,n){if(e&&n!==harmonicMasterStep){var t=(o+harmonicInterval)%12/12;w(n,{pitch:Math.max(0,Math.min(1,t))}),console.log("Harmonic link: Step ".concat(harmonicMasterStep+1,"").concat(n+1,", interval=").concat(harmonicInterval," semitones, slavePitch=").concat(t.toFixed(3)))}})}};return a.createElement("div",{style:{position:r?"fixed":"absolute",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(0, 0, 0, 0.9)",zIndex:1e3,display:"flex",alignItems:"flex-start",justifyContent:"center",padding:"40px 20px 20px 20px",overflow:"auto"}},a.createElement("div",{style:{width:"100%",maxWidth:"800px",maxHeight:"calc(100vh - 40px)",backgroundColor:"#0f172a",border:"1px solid #3b82f6",borderRadius:"8px",color:"#e2e8f0",padding:"20px",overflow:"auto"}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"20px"}},a.createElement("h3",{style:{margin:0,color:"#3b82f6"}},"Harmonic Sequencer"),a.createElement("div",{style:{display:"flex",gap:"8px"}},o&&a.createElement("button",{onClick:o,style:{padding:"4px 8px",backgroundColor:"#6b7280",color:"white",border:"none",borderRadius:"4px",cursor:"pointer",fontSize:"12px"}},""))),(h=P(),a.createElement("div",{style:{marginBottom:"20px"}},a.createElement("div",{style:{marginBottom:"20px"}},a.createElement("div",{style:{padding:"16px",backgroundColor:"#1e293b",border:"2px solid #3b82f6",borderRadius:"8px"}},a.createElement("div",{style:{marginBottom:"12px",fontSize:"16px",fontWeight:"bold",color:"#3b82f6"}},"Sequencer Controls"),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"repeat(4, 1fr)",gap:"12px"}},a.createElement("div",null,a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Clock Div: 1/",n.params.clock_div||4),a.createElement("input",{type:"range",min:"1",max:"16",value:n.params.clock_div||4,onChange:function(e){return t(n.id,"clock_div",parseInt(e.target.value))},style:{width:"100%"}})),a.createElement("div",null,a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Gate: ",(100*(n.params.gate_length||.7)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0.1",max:"0.9",step:"0.05",value:n.params.gate_length||.7,onChange:function(e){return t(n.id,"gate_length",parseFloat(e.target.value))},style:{width:"100%"}})),a.createElement("div",null,a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Mode: ",n.params.playback_mode||"iteration"),a.createElement("select",{value:n.params.playback_mode||"iteration",onChange:function(e){return t(n.id,"playback_mode",e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"iteration"},"Iteration (active steps only)"),a.createElement("option",{value:"rest"},"Rest (linear 4 steps)"),a.createElement("option",{value:"reverse"},"Reverse (active steps reversed)"))),a.createElement("div",null,a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"BPM: ",n.params.bpm||120),a.createElement("input",{type:"range",min:"60",max:"200",value:n.params.bpm||120,onChange:function(e){return t(n.id,"bpm",parseInt(e.target.value))},style:{width:"100%",accentColor:"#8b5cf6"}}),a.createElement("div",{style:{color:"#6b7280",fontSize:"10px",marginTop:"2px",textAlign:"center"}},"Auto: Internal when no clock input")),a.createElement("div",null,a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"flex",alignItems:"center",gap:"8px",cursor:"pointer",padding:"4px 0"}},a.createElement("input",{type:"checkbox",checked:i,onChange:function(e){var a=e.target.checked;l(a),t(n.id,"harmonic_linking",a)},style:{accentColor:"#8b5cf6"}}),a.createElement("span",null,"Harmonic Linking")),a.createElement("div",{style:{color:"#6b7280",fontSize:"10px",marginTop:"2px"}},"Master step controls slave steps")),a.createElement("div",null,a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"flex",alignItems:"center",gap:"8px",cursor:"pointer",padding:"4px 0"}},a.createElement("input",{type:"checkbox",checked:n.params.pattern_enabled||!1,onChange:function(e){t(n.id,"pattern_enabled",e.target.checked)},style:{accentColor:"#f59e0b"}}),a.createElement("span",null,"Melodic Patterns")),a.createElement("div",{style:{color:"#6b7280",fontSize:"10px",marginTop:"2px"}},"Patterns around pot position with intervals"))))),a.createElement("div",{style:{marginBottom:"12px",fontSize:"14px",fontWeight:"bold",color:"#e2e8f0"}},"4 Steps"),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"repeat(4, 1fr)",gap:"12px"}},h.map(function(e,o){return a.createElement("div",{key:o,style:{padding:"12px",backgroundColor:e.active?"#1e293b":"#111827",border:"2px solid",borderColor:e.active?"#3b82f6":"#374151",borderRadius:"8px",position:"relative",opacity:e.muted?.5:1}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"8px"}},a.createElement("div",{style:{fontSize:"12px",fontWeight:"bold",color:"#e2e8f0"}},"Step ",o+1),a.createElement("div",{style:{display:"flex",gap:"4px"}},a.createElement("button",{onClick:function(){return function(e){var a=P(),o=!a[e].active;w(e,{active:o});var r=a.filter(function(e){return e.active}).length;t(n.id,"sequence_length",Math.max(1,r))}(o)},style:{width:"16px",height:"16px",backgroundColor:e.active?"#10b981":"#6b7280",border:"none",borderRadius:"2px",cursor:"pointer"},title:e.active?"Step active":"Step inactive"}),a.createElement("button",{onClick:function(){return function(e){var n=!P()[e].muted;w(e,{muted:n})}(o)},style:{width:"16px",height:"16px",backgroundColor:e.muted?"#ef4444":"#6b7280",border:"none",borderRadius:"2px",cursor:"pointer"},title:e.muted?"Step muted":"Step unmuted"}))),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Pitch: ",(100*e.pitch).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:e.pitch,onChange:function(n){console.log("Pitch slider onChange: ".concat(n.target.value,", current step.pitch: ").concat(e.pitch)),C(o,parseFloat(n.target.value))},onInput:function(n){console.log("Pitch slider onInput: ".concat(n.target.value,", current step.pitch: ").concat(e.pitch)),C(o,parseFloat(n.target.value))},style:{width:"100%",height:"4px",backgroundColor:"#374151",borderRadius:"2px",outline:"none"}})),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Duration: ",e.duration.toFixed(2),""),a.createElement("input",{type:"range",min:"0.25",max:"4",step:"0.25",value:e.duration,onChange:function(e){return function(e,n){console.log("updateStepDuration: step=".concat(e,", duration=").concat(n)),w(e,{duration:Math.max(.25,Math.min(4,n))})}(o,parseFloat(e.target.value))},style:{width:"100%",height:"4px",backgroundColor:"#374151",borderRadius:"2px",outline:"none"}})),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Pitch Random: ",(100*(e.pitchRandomness||0)).toFixed(0),"% (val: ",e.pitchRandomness,")"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:e.pitchRandomness||0,onChange:function(e){console.log("Pitch randomness slider onChange: ".concat(e.target.value)),function(e,n){console.log("updateStepPitchRandomness: step=".concat(e,", randomness=").concat(n)),w(e,{pitchRandomness:Math.max(0,Math.min(1,n))})}(o,parseFloat(e.target.value))},style:{width:"100%",height:"20px",backgroundColor:"#374151",borderRadius:"2px",outline:"none",cursor:"pointer",appearance:"auto"}})),n.params.pattern_enabled&&a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Pattern: ",e.pattern||"static"),a.createElement("select",{value:e.pattern||"static",onChange:function(e){var n=e.target.value;w(o,{pattern:n})},style:{width:"100%",padding:"2px 4px",backgroundColor:"#374151",color:"#d1d5db",border:"1px solid #4b5563",borderRadius:"4px",fontSize:"10px"}},a.createElement("option",{value:"static"},"Static"),a.createElement("option",{value:"up_down"},"Up/Down Alt"),a.createElement("option",{value:"chord"},"Chord Arpegg"),a.createElement("option",{value:"random"},"Random Jump"),a.createElement("option",{value:"octave"},"Octave Jump"),a.createElement("option",{value:"fifth"},"Fifth Jump")),e.pattern&&"static"!==e.pattern&&"chord"!==e.pattern&&a.createElement(a.Fragment,null,a.createElement("div",{style:{marginTop:"4px"}},a.createElement("label",{style:{fontSize:"9px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Interval: ",e.interval||2," semitones"),a.createElement("input",{type:"range",min:"1",max:"12",step:"1",value:e.interval||2,onChange:function(e){w(o,{interval:parseInt(e.target.value)})},style:{width:"100%",height:"3px",backgroundColor:"#374151",borderRadius:"2px",outline:"none"}})),a.createElement("div",{style:{marginTop:"4px"}},a.createElement("label",{style:{fontSize:"9px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Pattern Prob: ",(100*(e.patternProbability||1)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.05",value:e.patternProbability||1,onChange:function(e){!function(e,n){console.log("updateStepPatternProbability: step=".concat(e,", patternProbability=").concat(n)),w(e,{patternProbability:Math.max(0,Math.min(1,n))})}(o,parseFloat(e.target.value))},style:{width:"100%",height:"3px",backgroundColor:"#374151",borderRadius:"2px",outline:"none"}}))),"chord"===e.pattern&&a.createElement("div",{style:{marginTop:"8px",padding:"8px",backgroundColor:"#1f2937",borderRadius:"4px",border:"1px solid #374151"}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"4px",fontWeight:"bold"}},"Chord Intervals (semitones from root)"),a.createElement("div",{style:{marginBottom:"6px"}},a.createElement("label",{style:{fontSize:"9px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Presets:"),a.createElement("div",{style:{display:"flex",gap:"4px",flexWrap:"wrap"}},[{name:"Maj",intervals:[0,4,7]},{name:"Min",intervals:[0,3,7]},{name:"Dim",intervals:[0,3,6]},{name:"Aug",intervals:[0,4,8]},{name:"Maj7",intervals:[0,4,7,11]},{name:"Min7",intervals:[0,3,7,10]},{name:"Dom7",intervals:[0,4,7,10]},{name:"Maj9",intervals:[0,4,7,11,14]},{name:"Min9",intervals:[0,3,7,10,14]}].map(function(e){return a.createElement("button",{key:e.name,onClick:function(){w(o,{chordIntervals:e.intervals})},style:{padding:"2px 6px",backgroundColor:"#374151",color:"#d1d5db",border:"1px solid #4b5563",borderRadius:"3px",fontSize:"9px",cursor:"pointer"},onMouseEnter:function(e){return e.target.style.backgroundColor="#4b5563"},onMouseLeave:function(e){return e.target.style.backgroundColor="#374151"}},e.name)}))),a.createElement("div",{style:{marginBottom:"6px"}},a.createElement("label",{style:{fontSize:"9px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Custom: [",(e.chordIntervals||[0,4,7]).join(", "),"]"),a.createElement("input",{type:"text",value:(e.chordIntervals||[0,4,7]).join(", "),onChange:function(e){var n=e.target.value.split(",").map(function(e){var n=parseInt(e.trim());return isNaN(n)?0:Math.max(-12,Math.min(24,n))}).filter(function(e){return!isNaN(e)});n.length>0&&w(o,{chordIntervals:n})},placeholder:"0, 4, 7",style:{width:"100%",padding:"2px 4px",backgroundColor:"#111827",color:"#d1d5db",border:"1px solid #374151",borderRadius:"3px",fontSize:"9px",fontFamily:"monospace"}})),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"6px"}},a.createElement("input",{type:"checkbox",id:"diatonic-".concat(o),checked:!1!==e.chordDiatonic,onChange:function(e){w(o,{chordDiatonic:e.target.checked})},style:{cursor:"pointer"}}),a.createElement("label",{htmlFor:"diatonic-".concat(o),style:{fontSize:"9px",color:"#9ca3af",cursor:"pointer"}},"Diatonic (scale-aware)")))),a.createElement("div",null,a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Step Prob: ",(100*(e.probability||1)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:e.probability||1,onChange:function(e){console.log("Probability slider onChange: ".concat(e.target.value)),function(e,n){console.log("updateStepProbability: step=".concat(e,", probability=").concat(n)),w(e,{probability:Math.max(0,Math.min(1,n))})}(o,parseFloat(e.target.value))},style:{width:"100%",height:"20px",backgroundColor:"#374151",borderRadius:"2px",outline:"none",cursor:"pointer",appearance:"auto"}})),i&&a.createElement("div",{style:{marginTop:"8px"}},a.createElement("div",{style:{display:"flex",gap:"8px"}},a.createElement("div",{style:{flex:1}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Follows: ",-1===u[o]?"None":"Step ".concat(u[o]+1)),a.createElement("select",{value:u[o],onChange:function(e){var a=Yn(u);a[o]=parseInt(e.target.value),d(a),t(n.id,"harmonic_follow_steps",a)},style:{width:"100%",padding:"2px 4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"10px"}},a.createElement("option",{value:-1},"None"),function(e){return[0,1,2,3].filter(function(n){return n!==e&&!function(e,n){if(-1===n)return!1;if(n===e)return!0;for(var t=new Set,a=n;-1!==a&&!t.has(a);){if(t.add(a),a===e)return!0;a=u[a]}return!1}(e,n)})}(o).map(function(e){return a.createElement("option",{key:e,value:e},"Step ",e+1)}))),a.createElement("div",{style:{flex:1}},a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Interval: ",7===f[o]?"+5th":5===f[o]?"+4th":12===f[o]?"+Oct":-7===f[o]?"-5th":"".concat(f[o]>0?"+":"").concat(f[o])),a.createElement("select",{value:f[o],onChange:function(e){var a=Yn(f);a[o]=parseInt(e.target.value),m(a),t(n.id,"harmonic_intervals",a)},disabled:-1===u[o],style:{width:"100%",padding:"2px 4px",backgroundColor:-1===u[o]?"#4b5563":"#374151",color:-1===u[o]?"#9ca3af":"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"10px"}},a.createElement("option",{value:-12},"-Octave"),a.createElement("option",{value:-7},"-5th"),a.createElement("option",{value:-5},"-4th"),a.createElement("option",{value:-4},"-M3rd"),a.createElement("option",{value:-3},"-m3rd"),a.createElement("option",{value:0},"Unison"),a.createElement("option",{value:3},"+m3rd"),a.createElement("option",{value:4},"+M3rd"),a.createElement("option",{value:5},"+4th"),a.createElement("option",{value:7},"+5th"),a.createElement("option",{value:12},"+Octave"))))),a.createElement("div",null,a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Gliss Time: ",(100*(e.glissando_time||0)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:e.glissando_time||0,onChange:function(e){console.log("Glissando time slider onChange: ".concat(e.target.value)),function(e,n){console.log("updateStepGlissandoTime: step=".concat(e,", time=").concat(n)),w(e,{glissando_time:Math.max(0,Math.min(1,n))})}(o,parseFloat(e.target.value))},style:{width:"100%",height:"20px",backgroundColor:"#374151",borderRadius:"2px",outline:"none",cursor:"pointer",appearance:"auto"}})),a.createElement("div",null,a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Gliss Prob: ",(100*(e.glissando_probability||0)).toFixed(0),"%"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:e.glissando_probability||0,onChange:function(e){console.log("Glissando probability slider onChange: ".concat(e.target.value)),function(e,n){console.log("updateStepGlissandoProbability: step=".concat(e,", probability=").concat(n)),w(e,{glissando_probability:Math.max(0,Math.min(1,n))})}(o,parseFloat(e.target.value))},style:{width:"100%",height:"20px",backgroundColor:"#374151",borderRadius:"2px",outline:"none",cursor:"pointer",appearance:"auto"}})),a.createElement("div",null,a.createElement("label",{style:{fontSize:"10px",color:"#9ca3af",display:"block",marginBottom:"2px"}},"Gliss Curve: ",e.glissando_curve||"linear"),a.createElement("select",{value:e.glissando_curve||"linear",onChange:function(e){console.log("Glissando curve select onChange: ".concat(e.target.value)),function(e,n){console.log("updateStepGlissandoCurve: step=".concat(e,", curve=").concat(n)),w(e,{glissando_curve:n})}(o,e.target.value)},style:{width:"100%",padding:"4px 8px",backgroundColor:"#374151",color:"#e2e8f0",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"11px"}},a.createElement("option",{value:"linear"},"Linear"),a.createElement("option",{value:"exponential"},"Exponential"),a.createElement("option",{value:"logarithmic"},"Logarithmic"))))})))),(_={chromatic:{name:"Chromatic (12 notes)",intervals:[0,1,2,3,4,5,6,7,8,9,10,11]},major:{name:"Major",intervals:[0,2,4,5,7,9,11]},minor:{name:"Natural Minor",intervals:[0,2,3,5,7,8,10]},dorian:{name:"Dorian",intervals:[0,2,3,5,7,9,10]},phrygian:{name:"Phrygian",intervals:[0,1,3,5,7,8,10]},lydian:{name:"Lydian",intervals:[0,2,4,6,7,9,11]},mixolydian:{name:"Mixolydian",intervals:[0,2,4,5,7,9,10]},pentatonic_major:{name:"Pentatonic Major",intervals:[0,2,4,7,9]},pentatonic_minor:{name:"Pentatonic Minor",intervals:[0,3,5,7,10]},blues:{name:"Blues Scale",intervals:[0,3,5,6,7,10]},wholetone:{name:"Whole Tone",intervals:[0,2,4,6,8,10]},diminished:{name:"Diminished",intervals:[0,2,3,5,6,8,9,11]}},g=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"],a.createElement("div",{style:{marginBottom:"20px"}},a.createElement("div",{style:{padding:"16px",backgroundColor:"#1e293b",border:"2px solid #8b5cf6",borderRadius:"8px"}},a.createElement("div",{style:{marginBottom:"12px",fontSize:"16px",fontWeight:"bold",color:"#8b5cf6"}},"Musical Scale System"),a.createElement("div",{style:{marginBottom:"16px",fontSize:"12px",color:"#94a3b8",fontStyle:"italic"}},"Step pitches are automatically quantized to musical intervals"),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr 1fr",gap:"16px"}},a.createElement("div",null,a.createElement("label",{style:{fontSize:"14px",color:"#e2e8f0",display:"block",marginBottom:"8px",fontWeight:"bold"}},"Scale"),a.createElement("select",{value:n.params.quantization_scale||"major",onChange:function(e){return t(n.id,"quantization_scale",e.target.value)},style:{width:"100%",padding:"8px 12px",backgroundColor:"#374151",color:"#e2e8f0",border:"2px solid #6b7280",borderRadius:"6px",fontSize:"13px"}},Object.entries(_).map(function(e){var n=Jn(e,2),t=n[0],o=n[1];return a.createElement("option",{key:t,value:t},o.name)}))),a.createElement("div",null,a.createElement("label",{style:{fontSize:"14px",color:"#e2e8f0",display:"block",marginBottom:"8px",fontWeight:"bold"}},"Root Note"),a.createElement("select",{value:n.params.quantization_root||"C",onChange:function(e){return t(n.id,"quantization_root",e.target.value)},style:{width:"100%",padding:"8px 12px",backgroundColor:"#374151",color:"#e2e8f0",border:"2px solid #6b7280",borderRadius:"6px",fontSize:"13px"}},g.map(function(e){return a.createElement("option",{key:e,value:e},e)}))),a.createElement("div",null,a.createElement("label",{style:{fontSize:"14px",color:"#e2e8f0",display:"block",marginBottom:"8px",fontWeight:"bold"}},"Tuning System"),a.createElement("select",{value:n.params.quantization_tuning||"12tet",onChange:function(e){return t(n.id,"quantization_tuning",e.target.value)},style:{width:"100%",padding:"8px 12px",backgroundColor:"#374151",color:"#e2e8f0",border:"2px solid #6b7280",borderRadius:"6px",fontSize:"13px"}},Object.entries({"12tet":{name:"12TET (Equal Temperament)",cents:100},just:{name:"Just Intonation",cents:null},pythagorean:{name:"Pythagorean",cents:null},quarter_tone:{name:"Quarter Tone (24TET)",cents:50},gamelan5:{name:"Gamelan Slendro (5-tone)",cents:240},gamelan7:{name:"Gamelan Pelog (7-tone)",cents:null}}).map(function(e){var n=Jn(e,2),t=n[0],o=n[1];return a.createElement("option",{key:t,value:t},o.name)}))),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"4px",flex:"1"}},a.createElement("label",{style:{fontSize:"11px",fontWeight:"600",color:"#9ca3af",textTransform:"uppercase",letterSpacing:"0.5px"}},"Center Octave"),a.createElement("select",{value:n.params.octave_center||4,onChange:function(e){return t(n.id,"octave_center",parseInt(e.target.value))},style:{width:"100%",padding:"8px 12px",backgroundColor:"#374151",color:"#e2e8f0",border:"2px solid #6b7280",borderRadius:"6px",fontSize:"13px"}},a.createElement("option",{value:2},"Octave 2 (C2-C3)"),a.createElement("option",{value:3},"Octave 3 (C3-C4)"),a.createElement("option",{value:4},"Octave 4 (C4-C5)"),a.createElement("option",{value:5},"Octave 5 (C5-C6)"),a.createElement("option",{value:6},"Octave 6 (C6-C7)")))),a.createElement("div",{style:{marginTop:"12px",padding:"12px",backgroundColor:"#0f172a",borderRadius:"6px"}},a.createElement("div",{style:{fontSize:"12px",fontWeight:"bold",color:"#8b5cf6",marginBottom:"8px"}},"Scale Preview:"),a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8"}},(v=_[n.params.quantization_scale||"major"],b=n.params.quantization_root||"C",y=g.indexOf(b),k=v.intervals.map(function(e){return g[(y+e)%12]}),"".concat(b," ").concat((n.params.quantization_scale||"major").replace("_"," "),": ").concat(k.join(" - ")))))))),a.createElement("div",{style:{marginBottom:"20px"}},a.createElement("div",{style:{marginBottom:"12px",fontSize:"14px",fontWeight:"bold",color:"#e2e8f0"}},"Output Configuration"),a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px",marginBottom:"8px"}},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"6px",fontSize:"12px",color:"#d1d5db"}},a.createElement("input",{type:"checkbox",checked:x,onChange:function(e){var a=e.target.checked;E(a),t(n.id,"show_individual_outputs",a),t(n.id,"individual_outputs_enabled",a)}}),"Show Individual Step Outputs")),x&&a.createElement("div",{style:{padding:"12px",backgroundColor:"#111827",borderRadius:"6px",fontSize:"11px",color:"#9ca3af"}},a.createElement("div",{style:{marginBottom:"8px",fontWeight:"bold",color:"#d1d5db"}},"Individual Step Outputs:"),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"repeat(4, 1fr)",gap:"8px"}},Array.from({length:16},function(e,n){return a.createElement("div",{key:n,style:{textAlign:"center"}},a.createElement("div",null,"Step ",n+1),a.createElement("div",{style:{fontSize:"9px"}},"pitch_step",n+1),a.createElement("div",{style:{fontSize:"9px"}},"gate_step",n+1))})))),a.createElement("div",{style:{marginTop:"20px",padding:"12px",backgroundColor:"#1e293b",borderRadius:"6px",fontSize:"11px",color:"#94a3b8"}},a.createElement("div",{style:{fontWeight:"bold",marginBottom:"6px",color:"#e2e8f0"}},"Hardware Control:"),a.createElement("ul",{style:{margin:0,paddingLeft:"16px"}},a.createElement("li",null,"Knobs control pitch for each step in current bank"),a.createElement("li",null,"Buttons toggle step active/inactive (short press) or mute (long press)"),a.createElement("li",null,"Hold button + turn knob to adjust step duration"),a.createElement("li",null,"Encoder navigates banks, encoder button starts/stops"),a.createElement("li",null,"Hold multiple buttons for loop regions")))))};function at(e){return at="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},at(e)}function ot(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function rt(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?ot(Object(t),!0).forEach(function(n){ct(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ot(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function ct(e,n,t){return(n=function(e){var n=function(e){if("object"!=at(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=at(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==at(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}const it=function(e){var n=e.module,t=(e.modules,e.onUpdateParam),o=e.onClose,r=e.fullscreen,c=n.params||{},i=function(e,a){t(n.id,e,a)},l=r?{position:"fixed",top:0,left:0,right:0,bottom:0,backgroundColor:"#0f172a",zIndex:2e3,display:"flex",flexDirection:"column",padding:"20px",overflowY:"auto"}:{backgroundColor:"#1e293b",borderRadius:"8px",padding:"16px",color:"#e2e8f0"},s={fontSize:r?"24px":"18px",fontWeight:"600",color:"#f1f5f9"},u={marginBottom:"24px",padding:"16px",backgroundColor:"#1e293b",borderRadius:"8px",border:"1px solid #334155"},d={fontSize:"14px",fontWeight:"600",color:"#94a3b8",marginBottom:"12px",textTransform:"uppercase",letterSpacing:"0.5px"},p={display:"grid",gridTemplateColumns:"repeat(auto-fit, minmax(200px, 1fr))",gap:"16px",marginBottom:"12px"},f={display:"flex",flexDirection:"column",gap:"6px"},m={fontSize:"12px",color:"#cbd5e1",fontWeight:"500"},_={backgroundColor:"#0f172a",border:"1px solid #334155",borderRadius:"4px",padding:"8px",color:"#e2e8f0",fontSize:"13px",outline:"none"},g=rt(rt({},_),{},{cursor:"pointer"}),h={fontSize:"10px",color:"#64748b",fontStyle:"italic",marginTop:"4px"};return a.createElement("div",{style:l},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"20px",paddingBottom:"12px",borderBottom:"1px solid #334155"}},a.createElement("div",{style:s},"Drum Designer"),o&&a.createElement("button",{style:{background:"#334155",border:"none",borderRadius:"4px",padding:"8px 16px",color:"#e2e8f0",cursor:"pointer",fontSize:"14px"},onClick:o},r?"Close":"")),a.createElement("div",{style:u},a.createElement("div",{style:d},"Karplus-Strong Engine"),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Mode"),a.createElement("select",{style:g,value:c.ks_mode||"tonal",onChange:function(e){return i("ks_mode",e.target.value)}},a.createElement("option",{value:"tonal"},"Tonal (guitar/bass decay)"),a.createElement("option",{value:"percussive"},"Percussive (marimba/xylophone)"),a.createElement("option",{value:"noise"},"Noise (short drums)"))),a.createElement("div",{style:f},a.createElement("label",{style:m},"Damping (Decay Rate)"),a.createElement("input",{style:_,type:"number",min:"0.8",max:"0.9999",step:"0.001",value:c.ks_damping||.995,onChange:function(e){return i("ks_damping",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"0.8 = fast decay, 0.999 = long sustain")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Brightness"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:c.ks_brightness||.5,onChange:function(e){return i("ks_brightness",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"0 = dark, 1 = bright harmonics")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Level"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:c.ks_level||.3,onChange:function(e){return i("ks_level",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"K-S harmonics volume (0-1)"))),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Stretch (Inharmonicity)"),a.createElement("input",{style:_,type:"number",min:"1.0",max:"1.02",step:"0.001",value:c.ks_stretch||1,onChange:function(e){return i("ks_stretch",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"1.0 = harmonic, higher = bell-like")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Strike Position"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:c.ks_position||.5,onChange:function(e){return i("ks_position",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Affects harmonic content")))),a.createElement("div",{style:u},a.createElement("div",{style:d},"Sine Oscillator (808-Style Bass)"),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Enable Sine"),a.createElement("select",{style:g,value:c.sine_enabled?"true":"false",onChange:function(e){return i("sine_enabled","true"===e.target.value)}},a.createElement("option",{value:"true"},"Enabled"),a.createElement("option",{value:"false"},"Disabled"))),a.createElement("div",{style:f},a.createElement("label",{style:m},"Sine Level"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:c.sine_level||.7,onChange:function(e){return i("sine_level",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Sine fundamental volume (0-1)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Pitch Envelope Amount"),a.createElement("input",{style:_,type:"number",min:"0",max:"6",step:"0.1",value:c.sine_pitch_amount||2,onChange:function(e){return i("sine_pitch_amount",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Octaves of pitch sweep (808 style)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Pitch Decay Time"),a.createElement("input",{style:_,type:"number",min:"10",max:"500",step:"5",value:c.sine_pitch_decay||80,onChange:function(e){return i("sine_pitch_decay",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Pitch envelope decay (ms)")))),a.createElement("div",{style:u},a.createElement("div",{style:d},"Pitch Sweep Mode"),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Sweep Mode"),a.createElement("select",{style:g,value:c.pitch_sweep_mode||"none",onChange:function(e){return i("pitch_sweep_mode",e.target.value)}},a.createElement("option",{value:"none"},"None (static pitch)"),a.createElement("option",{value:"sine"},"Sine (808 pitch drop)"),a.createElement("option",{value:"delay"},"Delay (Boss feedback)")),a.createElement("div",{style:h},"none"===c.pitch_sweep_mode&&"No pitch sweep - static sine/K-S","sine"===c.pitch_sweep_mode&&"808 kick - sine sweeps from high to low","delay"===c.pitch_sweep_mode&&"Boss delay trick - K-S delay modulation")),"delay"===c.pitch_sweep_mode&&a.createElement(a.Fragment,null,a.createElement("div",{style:f},a.createElement("label",{style:m},"Delay Sweep Time"),a.createElement("input",{style:_,type:"number",min:"10",max:"500",step:"5",value:c.delay_sweep_time||150,onChange:function(e){return i("delay_sweep_time",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Time for delay pitch drop (ms)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Delay Sweep Amount"),a.createElement("input",{style:_,type:"number",min:"1",max:"4",step:"0.1",value:c.delay_sweep_amount||2,onChange:function(e){return i("delay_sweep_amount",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Pitch drop multiplier (1 = none, 4 = extreme)"))))),a.createElement("div",{style:u},a.createElement("div",{style:d},"Body Resonance (Formant Filter)"),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Enable Body"),a.createElement("select",{style:g,value:c.body_enabled?"true":"false",onChange:function(e){return i("body_enabled","true"===e.target.value)}},a.createElement("option",{value:"true"},"Enabled"),a.createElement("option",{value:"false"},"Disabled"))),a.createElement("div",{style:f},a.createElement("label",{style:m},"Body Type"),a.createElement("select",{style:g,value:c.body_type||"wood",onChange:function(e){return i("body_type",e.target.value)}},a.createElement("option",{value:"wood"},"Wood (marimba/warm)"),a.createElement("option",{value:"metal"},"Metal (bells/bright)"),a.createElement("option",{value:"glass"},"Glass (crystalline)"))),a.createElement("div",{style:f},a.createElement("label",{style:m},"Body Resonance"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:c.body_resonance||.3,onChange:function(e){return i("body_resonance",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Resonance intensity (0-1)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Body Size"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:c.body_size||.3,onChange:function(e){return i("body_size",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Size scaling (0 = small/dark, 1 = large/bright)")))),a.createElement("div",{style:u},a.createElement("div",{style:d},"Amplitude Envelope"),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Attack"),a.createElement("input",{style:_,type:"number",min:"0",max:"100",step:"0.5",value:c.amp_attack||1,onChange:function(e){return i("amp_attack",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Attack time (ms)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Decay"),a.createElement("input",{style:_,type:"number",min:"10",max:"5000",step:"10",value:c.amp_decay||1500,onChange:function(e){return i("amp_decay",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Decay time (ms)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Sustain"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:c.amp_sustain||.2,onChange:function(e){return i("amp_sustain",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Sustain level (0-1)")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Release"),a.createElement("input",{style:_,type:"number",min:"10",max:"2000",step:"10",value:c.amp_release||200,onChange:function(e){return i("amp_release",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Release time (ms)")))),a.createElement("div",{style:u},a.createElement("div",{style:d},"Output"),a.createElement("div",{style:p},a.createElement("div",{style:f},a.createElement("label",{style:m},"Velocity Sensitivity"),a.createElement("input",{style:_,type:"number",min:"0",max:"1",step:"0.01",value:c.velocity_sensitivity||.7,onChange:function(e){return i("velocity_sensitivity",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"0 = ignore velocity, 1 = full range")),a.createElement("div",{style:f},a.createElement("label",{style:m},"Output Gain"),a.createElement("input",{style:_,type:"number",min:"0.1",max:"10",step:"0.1",value:c.output_gain||3,onChange:function(e){return i("output_gain",parseFloat(e.target.value))}}),a.createElement("div",{style:h},"Master volume multiplier")))))};function lt(e,n){var t="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=bt(e))||n&&e&&"number"==typeof e.length){t&&(e=t);var a=0,o=function(){};return{s:o,n:function(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function(e){throw e},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,c=!0,i=!1;return{s:function(){t=t.call(e)},n:function(){var e=t.next();return c=e.done,e},e:function(e){i=!0,r=e},f:function(){try{c||null==t.return||t.return()}finally{if(i)throw r}}}}function st(){var e,n,t="function"==typeof Symbol?Symbol:{},a=t.iterator||"@@iterator",o=t.toStringTag||"@@toStringTag";function r(t,a,o,r){var l=a&&a.prototype instanceof i?a:i,s=Object.create(l.prototype);return ut(s,"_invoke",function(t,a,o){var r,i,l,s=0,u=o||[],d=!1,p={p:0,n:0,v:e,a:f,f:f.bind(e,4),d:function(n,t){return r=n,i=0,l=e,p.n=t,c}};function f(t,a){for(i=t,l=a,n=0;!d&&s&&!o&&n<u.length;n++){var o,r=u[n],f=p.p,m=r[2];t>3?(o=m===a)&&(l=r[(i=r[4])?5:(i=3,3)],r[4]=r[5]=e):r[0]<=f&&((o=t<2&&f<r[1])?(i=0,p.v=a,p.n=r[1]):f<m&&(o=t<3||r[0]>a||a>m)&&(r[4]=t,r[5]=a,p.n=m,i=0))}if(o||t>1)return c;throw d=!0,a}return function(o,u,m){if(s>1)throw TypeError("Generator is already running");for(d&&1===u&&f(u,m),i=u,l=m;(n=i<2?e:l)||!d;){r||(i?i<3?(i>1&&(p.n=-1),f(i,l)):p.n=l:p.v=l);try{if(s=2,r){if(i||(o="next"),n=r[o]){if(!(n=n.call(r,l)))throw TypeError("iterator result is not an object");if(!n.done)return n;l=n.value,i<2&&(i=0)}else 1===i&&(n=r.return)&&n.call(r),i<2&&(l=TypeError("The iterator does not provide a '"+o+"' method"),i=1);r=e}else if((n=(d=p.n<0)?l:t.call(a,p))!==c)break}catch(n){r=e,i=1,l=n}finally{s=1}}return{value:n,done:d}}}(t,o,r),!0),s}var c={};function i(){}function l(){}function s(){}n=Object.getPrototypeOf;var u=[][a]?n(n([][a]())):(ut(n={},a,function(){return this}),n),d=s.prototype=i.prototype=Object.create(u);function p(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,s):(e.__proto__=s,ut(e,o,"GeneratorFunction")),e.prototype=Object.create(d),e}return l.prototype=s,ut(d,"constructor",s),ut(s,"constructor",l),l.displayName="GeneratorFunction",ut(s,o,"GeneratorFunction"),ut(d),ut(d,o,"Generator"),ut(d,a,function(){return this}),ut(d,"toString",function(){return"[object Generator]"}),(st=function(){return{w:r,m:p}})()}function ut(e,n,t,a){var o=Object.defineProperty;try{o({},"",{})}catch(e){o=0}ut=function(e,n,t,a){function r(n,t){ut(e,n,function(e){return this._invoke(n,t,e)})}n?o?o(e,n,{value:t,enumerable:!a,configurable:!a,writable:!a}):e[n]=t:(r("next",0),r("throw",1),r("return",2))},ut(e,n,t,a)}function dt(e,n,t,a,o,r,c){try{var i=e[r](c),l=i.value}catch(e){return void t(e)}i.done?n(l):Promise.resolve(l).then(a,o)}function pt(e){return function(){var n=this,t=arguments;return new Promise(function(a,o){var r=e.apply(n,t);function c(e){dt(r,a,o,c,i,"next",e)}function i(e){dt(r,a,o,c,i,"throw",e)}c(void 0)})}}function ft(e){return ft="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},ft(e)}function mt(e){return function(e){if(Array.isArray(e))return yt(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||bt(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function _t(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function gt(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?_t(Object(t),!0).forEach(function(n){ht(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):_t(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function ht(e,n,t){return(n=function(e){var n=function(e){if("object"!=ft(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var t=n.call(e,"string");if("object"!=ft(t))return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==ft(n)?n:n+""}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function vt(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,r,c,i=[],l=!0,s=!1;try{if(r=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;l=!1}else for(;!(l=(a=r.call(t)).done)&&(i.push(a.value),i.length!==n);l=!0);}catch(e){s=!0,o=e}finally{try{if(!l&&null!=t.return&&(c=t.return(),Object(c)!==c))return}finally{if(s)throw o}}return i}}(e,n)||bt(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function bt(e,n){if(e){if("string"==typeof e)return yt(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?yt(e,n):void 0}}function yt(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}var kt=function(e){var n=e.onGenerateCode,t=e.onCodePreview,o=e.onLoadPatch,r=e.onSavePatch,c=e.onClearCanvas,i=e.onZoomToFit,l=e.onSnapToGrid,s=e.onOpenSampleEditor,u=e.copyButtonState,d=Ke(),p=d.hasActiveTransfers,f=(0,d.getOverallProgress)(),m=p();return a.createElement("div",{className:"toolbar"},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"16px",flex:1}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px"}},a.createElement("img",{src:ze,alt:"Soniphorm",style:{height:"32px",width:"auto",filter:"invert(1) brightness(1.2)"}}),a.createElement("h1",{style:{margin:0,fontSize:"24px",color:"#e5e7eb"}},"Gen Patcher")),m&&a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"12px",flex:1,maxWidth:"400px"}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"8px",fontSize:"12px",color:"#fbbf24",fontWeight:"500"}},a.createElement("span",null,""),a.createElement("span",null,"Transferring ",f.current,"/",f.total)),a.createElement("div",{style:{flex:1,height:"4px",backgroundColor:"#374151",borderRadius:"2px",overflow:"hidden",position:"relative"}},a.createElement("div",{style:{width:"".concat(f.percentage,"%"),height:"100%",backgroundColor:"#fbbf24",borderRadius:"2px",transition:"width 0.3s ease"}})),a.createElement("div",{style:{fontSize:"11px",color:"#cbd5e1",minWidth:"40px",textAlign:"right"}},f.percentage.toFixed(0),"%"),f.currentFile&&a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",maxWidth:"100px",overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}},f.currentFile))),a.createElement("div",{className:"toolbar-actions"},a.createElement("button",{className:"btn btn-ghost",onClick:i},"Zoom to Fit"),a.createElement("button",{className:"btn btn-ghost",onClick:l},"Snap to Grid"),a.createElement("button",{className:"btn btn-red",onClick:c},"Clear Canvas"),a.createElement("button",{className:"btn btn-ghost",onClick:o},"Load Patch"),a.createElement("button",{className:"btn btn-ghost",onClick:r},"Save Patch"),a.createElement("button",{className:"btn btn-amber",onClick:s},"Sample Editor"),a.createElement("button",{className:"btn btn-green",onClick:n},"copied"===u?"Code Copied!":"Generate Code"),a.createElement("button",{className:"btn btn-ghost",onClick:t},"Code Preview")))},St=function(e){var n=e.onAddModule,t=e.onLoadExamplePatch,o=vt((0,a.useState)({examples:!0,audioSources:!1,mixers:!1,audioProcessors:!1,granularLooping:!1,sequencers:!1,audioIO:!1,control:!1,hardware:!1}),2),r=o[0],c=o[1],i=function(e){try{n(e)}catch(e){alert(e.message)}},l=function(e){var n=e.title,t=e.categoryKey,o=e.count;return a.createElement("h3",{onClick:function(){return function(e){c(function(n){return gt(gt({},n),{},ht({},e,!n[e]))})}(t)},style:{cursor:"pointer",userSelect:"none",display:"flex",justifyContent:"space-between",alignItems:"center"}},a.createElement("span",null,n),a.createElement("span",{style:{fontSize:"0.8em",color:"#94a3b8"}},r[t]?"":""," ",o>0?"(".concat(o,")"):""))};return a.createElement("div",{className:"module-palette"},a.createElement("h2",null,"Modules"),a.createElement("div",{className:"module-categories"},a.createElement("div",{className:"category"},a.createElement(l,{title:"Examples",categoryKey:"examples",count:O.EXAMPLES.length}),r.examples&&a.createElement("div",{className:"module-list"},0===O.EXAMPLES.length?a.createElement("div",{style:{padding:"8px",fontSize:"12px",opacity:.5,fontStyle:"italic"}},"No example patches yet"):O.EXAMPLES.map(function(e,n){return a.createElement("div",{key:n,className:"module-item",onClick:function(){return n=e,void(confirm('Load "'.concat(n.name,'"? This will clear your current patch.'))&&t(n.patch));var n},title:e.description},e.name)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Audio I/O",categoryKey:"audioIO",count:O.AUDIO_IO.length}),r.audioIO&&a.createElement("div",{className:"module-list"},O.AUDIO_IO.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},A[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Hardware",categoryKey:"hardware",count:O.HW.length}),r.hardware&&a.createElement("div",{className:"module-list"},O.HW.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},A[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Audio Sources",categoryKey:"audioSources",count:O.AUDIO_SOURCES.length}),r.audioSources&&a.createElement("div",{className:"module-list"},O.AUDIO_SOURCES.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},A[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Mixers",categoryKey:"mixers",count:O.MIXERS.length}),r.mixers&&a.createElement("div",{className:"module-list"},O.MIXERS.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},A[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Audio Processors",categoryKey:"audioProcessors",count:O.AUDIO_PROCESSORS.length}),r.audioProcessors&&a.createElement("div",{className:"module-list"},O.AUDIO_PROCESSORS.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},A[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Granular & Looping",categoryKey:"granularLooping",count:O.GRANULAR_LOOPING.length}),r.granularLooping&&a.createElement("div",{className:"module-list"},O.GRANULAR_LOOPING.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},A[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Sequencers",categoryKey:"sequencers",count:O.SEQUENCERS.length}),r.sequencers&&a.createElement("div",{className:"module-list"},O.SEQUENCERS.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},A[e].label)}))),a.createElement("div",{className:"category"},a.createElement(l,{title:"Control",categoryKey:"control",count:O.CTRL.length}),r.control&&a.createElement("div",{className:"module-list"},O.CTRL.map(function(e){return a.createElement("div",{key:e,className:"module-item",onClick:function(){return i(e)}},A[e].label)})))))},xt=["#dc2626","#16a34a","#2563eb","#ca8a04","#0891b2","#9333ea","#f8fafc","#ea580c"],Et=function(e){return"Pot"!==e.type&&"LEDButton"!==e.type||!e.params||"number"!=typeof e.params.bank?"#1e293b":xt[e.params.bank-1]||"#1e293b"},Pt=function(e,n,t){if(!n)return console.warn('Module type "'.concat(e.type,'" not found in CATALOG for module ').concat(e.id)),"".concat(e.type," (UNKNOWN)");var a=t.filter(function(n){return n.type===e.type}),o=a.length;if(("Pot"===e.type||"LEDButton"===e.type)&&e.params){var r,c=e.params.bank||1,i=(null===(r=e.id.match(/\d+$/))||void 0===r?void 0:r[0])||"1",l="Pot"===e.type?"Pot":"Button";return"".concat(l," ").concat(i," (Bank ").concat(c,")")}if("HarmonicSequencer"===e.type&&e.params){var s=e.params.start_bank||1;if(o>1){var u=a.sort(function(e,n){return parseInt(e.id.match(/\d+$/)[0])-parseInt(n.id.match(/\d+$/)[0])}).findIndex(function(n){return n.id===e.id})+1;return"".concat(n.label," ").concat(u," (B").concat(s,")")}return"".concat(n.label," (B").concat(s,")")}if(o>1){var d=a.sort(function(e,n){return parseInt(e.id.match(/\d+$/)[0])-parseInt(n.id.match(/\d+$/)[0])}).findIndex(function(n){return n.id===e.id})+1;return"".concat(n.label," ").concat(d)}return n.label},wt=function(e){var n=e.module,t=e.isSelected,o=(e.isGroupSelected,e.onSelect),r=e.onMove,c=e.onPortClick,i=e.onPortRightClick,l=e.connectingFrom,s=e.allModules,u=e.onDelete,d=e.onUpdateParam,p=e.canvasRef,f=e.canvasTransform,m=e.onOpenClockSequencer,_=e.onOpenHarmonicSequencer,g=vt((0,a.useState)(!1),2),h=g[0],v=g[1],b=vt((0,a.useState)({x:0,y:0}),2),y=b[0],k=b[1],S=vt((0,a.useState)({x:0,y:0}),2),x=S[0],E=S[1],P=vt((0,a.useState)(!1),2),w=P[0],C=P[1],R=vt((0,a.useState)(!1),2),L=R[0],I=R[1],M=(0,a.useRef)(),D=N(n),O=A[n.type];if(!O)return a.createElement("g",{transform:"translate(".concat(n.x,", ").concat(n.y,")")},a.createElement("rect",{x:-150,y:-40,width:300,height:80,fill:"#ff0000",stroke:"#ffffff",strokeWidth:"2",rx:8}),a.createElement("text",{x:0,y:0,textAnchor:"middle",fill:"#ffffff",fontSize:"14",fontWeight:"bold"},'ERROR: Module type "',n.type,'" not found'),a.createElement("text",{x:0,y:20,textAnchor:"middle",fill:"#ffffff",fontSize:"12"},"Delete this module (module ID: ",n.id,")"));var T=(0,a.useCallback)(function(e){if(e.stopPropagation(),e.preventDefault(),I(e.ctrlKey||e.metaKey),p.current){var t=p.current.getBoundingClientRect(),a=e.clientX-t.left,o=e.clientY-t.top,r=(a-f.x)/f.scale,c=(o-f.y)/f.scale;k({x:r-n.x,y:c-n.y}),E({x:r,y:c})}v(!0),C(!1)},[n.x,n.y,n.type,p,f]),B=(0,a.useCallback)(function(e){if(h&&p.current){var t=p.current.getBoundingClientRect(),a=e.clientX-t.left,o=e.clientY-t.top,c=(a-f.x)/f.scale,i=(o-f.y)/f.scale;Math.sqrt(Math.pow(c-x.x,2)+Math.pow(i-x.y,2))>5&&C(!0);var l=c-y.x,s=i-y.y;r(n.id,l,s)}},[h,y.x,y.y,x.x,x.y,r,n.id,p,f]),z=(0,a.useCallback)(function(){w||o(gt(gt({},n),{},{openEditor:!1,ctrlKey:L})),v(!1),C(!1),I(!1)},[w,L,o,n]);return(0,a.useEffect)(function(){if(h)return document.addEventListener("mousemove",B),document.addEventListener("mouseup",z),function(){document.removeEventListener("mousemove",B),document.removeEventListener("mouseup",z)}},[h,B,z]),a.createElement("g",{ref:M,className:"node ".concat(t?"selected":"")},a.createElement("rect",{x:n.x,y:n.y,width:D.width,height:D.height,fill:"#0b1220",stroke:t?"#22c55e":"#1f2937",strokeWidth:t?"2":"1",rx:"10",onMouseDown:T,style:{cursor:h?"grabbing":"grab"},filter:t?"drop-shadow(0 6px 16px rgba(0,0,0,0.35)) drop-shadow(0 0 0 2px #22c55e)":"drop-shadow(0 6px 16px rgba(0,0,0,0.35))"}),a.createElement("rect",{x:n.x,y:n.y,width:D.width,height:"24",fill:Et(n),rx:"10",ry:"10",onMouseDown:T,style:{cursor:h?"grabbing":"grab"}}),a.createElement("rect",{x:n.x,y:n.y+12,width:D.width,height:"12",fill:Et(n),onMouseDown:T,style:{cursor:h?"grabbing":"grab"}}),a.createElement("text",{x:n.x+D.width/2,y:n.y+16,fill:"#e2e8f0",fontSize:"12",fontWeight:"600",textAnchor:"middle",style:{pointerEvents:"auto",cursor:"pointer",userSelect:"none"},onClick:function(e){e.stopPropagation(),e.preventDefault(),"Clock"===n.type&&m?m(n):"HarmonicSequencer"===n.type&&_?_(n):o(gt(gt({},n),{},{openEditor:!0}))}},Pt(n,O,s)),a.createElement("g",{className:"delete-btn",onClick:function(e){e.stopPropagation(),u&&u(n.id)},style:{cursor:"pointer"}},a.createElement("rect",{x:n.x+D.width-20,y:n.y+4,width:"16",height:"16",fill:"#1f2937",stroke:"#374151",strokeWidth:"1",rx:"3",ry:"3",opacity:"0.9"}),a.createElement("text",{x:n.x+D.width-12,y:n.y+14,fill:"#e2e8f0",fontSize:"11",fontWeight:"700",textAnchor:"middle",style:{pointerEvents:"none"}},"")),D.left.map(function(e,t){var o,r,l,s="BPMLooper"===n.type&&"clock"===e.port,u="Wavetable"===n.type&&"pitch_cv"===e.port,p=["fm","fm_ratio_cv","fm_amount"].includes(e.port);return"Wavetable"!==n.type||!p||null!==(o=n.params)&&void 0!==o&&o.show_fm_inputs?a.createElement(a.Fragment,{key:e.id},a.createElement("g",null,a.createElement("circle",{cx:e.x,cy:e.y,r:"6",fill:"audio"===e.kind?"#34d399":"#9333ea",stroke:"#1f2937",strokeWidth:"2",className:"jack jack-".concat("audio"===e.kind?"audio":"ctrl"),onClick:function(n){n.stopPropagation(),c&&c(e)},onContextMenu:function(t){i&&i(t,e,n.id)},style:{cursor:"pointer"}}),a.createElement("text",{x:e.x+12,y:e.y+4,fill:"#e2e8f0",fontSize:"10",textAnchor:"start",className:"jack-label",style:{pointerEvents:"none"}},e.port)),s&&a.createElement("g",{onClick:function(e){var t;e.stopPropagation(),d&&d(n.id,"show_trigger_inputs",!(null!==(t=n.params)&&void 0!==t&&t.show_trigger_inputs))},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x+12,y:e.y+8,width:"12",height:"12",rx:"2",fill:"#475569",stroke:"#64748b",strokeWidth:"1"}),a.createElement("text",{x:e.x+18,y:e.y+17,fill:"#e2e8f0",fontSize:"8",fontWeight:"600",textAnchor:"middle",style:{pointerEvents:"none"}},null!==(r=n.params)&&void 0!==r&&r.show_trigger_inputs?"":"")),u&&a.createElement("g",{onClick:function(e){var t;e.stopPropagation(),d&&d(n.id,"show_fm_inputs",!(null!==(t=n.params)&&void 0!==t&&t.show_fm_inputs))},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x+12,y:e.y+8,width:"28",height:"12",rx:"2",fill:"#475569",stroke:"#64748b",strokeWidth:"1"}),a.createElement("text",{x:e.x+16,y:e.y+17,fill:"#e2e8f0",fontSize:"8",fontWeight:"600",textAnchor:"start",style:{pointerEvents:"none"}},null!==(l=n.params)&&void 0!==l&&l.show_fm_inputs?"":""," FM"))):null}),D.right.map(function(e,t){var o,r,s=l&&l.id===e.id,u="HarmonicSequencer"===n.type&&"gate_sum"===e.port,p="DrumDesigner4"===n.type&&"mixR"===e.port;return a.createElement(a.Fragment,{key:e.id},a.createElement("g",null,a.createElement("circle",{cx:e.x,cy:e.y,r:"6",fill:"audio"===e.kind?"#34d399":"#9333ea",stroke:s?"#22d3ee":"#1f2937",strokeWidth:s?"3":"2",className:"jack jack-".concat("audio"===e.kind?"audio":"ctrl"),onClick:function(n){n.stopPropagation(),c&&c(e)},onContextMenu:function(t){i&&i(t,e,n.id)},style:{cursor:"pointer"}}),a.createElement("text",{x:e.x-12,y:e.y+4,fill:"#e2e8f0",fontSize:"10",textAnchor:"end",className:"jack-label",style:{pointerEvents:"none"}},e.port)),u&&a.createElement("g",{onClick:function(e){var t;e.stopPropagation(),d&&d(n.id,"show_individual_outputs",!(null!==(t=n.params)&&void 0!==t&&t.show_individual_outputs))},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x-20,y:e.y+12,width:"16",height:"12",fill:"#374151",stroke:"#6b7280",strokeWidth:"1",rx:"2",opacity:"0.8"}),a.createElement("text",{x:e.x-12,y:e.y+21,fill:"#e2e8f0",fontSize:"8",fontWeight:"600",textAnchor:"middle",style:{pointerEvents:"none"}},null!==(o=n.params)&&void 0!==o&&o.show_individual_outputs?"":"")),p&&a.createElement("g",{onClick:function(e){var t;e.stopPropagation(),d&&d(n.id,"show_individual_outputs",!(null!==(t=n.params)&&void 0!==t&&t.show_individual_outputs))},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x-28,y:e.y+12,width:"24",height:"12",fill:"#374151",stroke:"#6b7280",strokeWidth:"1",rx:"2",opacity:"0.8"}),a.createElement("text",{x:e.x-20,y:e.y+21,fill:"#e2e8f0",fontSize:"8",fontWeight:"600",textAnchor:"start",style:{pointerEvents:"none"}},null!==(r=n.params)&&void 0!==r&&r.show_individual_outputs?"":""," V")))}))},Ct=(0,a.forwardRef)(function(e,n){var t=e.modules,o=e.connections,r=e.selectedModule,c=e.selectedModules,i=e.onSelectModule,l=e.onSelectModules,s=e.onMoveModule,u=e.onPortClick,d=e.onPortRightClick,p=e.connectingFrom,f=e.selectedConnection,m=e.onConnectionClick,_=e.mousePos,g=e.onMouseMove,h=e.onDeleteModule,v=e.onUpdateParam,b=e.onClearSelections,y=e.onOpenClockSequencer,k=e.onOpenHarmonicSequencer,S=e.groups,x=e.selectedGroup,E=e.onSelectGroup,P=e.onMoveGroup,w=e.onToggleGroupCollapse,C=e.onDeleteGroup,R=e.onUpdateGroupLabel,L=e.onEnterGroup,I=e.onExitToRoot,M=e.onMoveStub,D=e.currentContext,A=(0,a.useRef)(),O=vt((0,a.useState)({x:0,y:0,scale:1}),2),T=O[0],B=O[1],z=vt((0,a.useState)(!1),2),F=z[0],G=z[1],q=vt((0,a.useState)({x:0,y:0}),2),U=q[0],W=q[1],V=vt((0,a.useState)(!1),2),H=V[0],j=V[1],K=vt((0,a.useState)({x:0,y:0}),2),$=K[0],Y=K[1],X=vt((0,a.useState)(null),2),Z=X[0],Q=X[1],J=vt((0,a.useState)(null),2),ee=J[0],ne=J[1],te=vt((0,a.useState)(""),2),ae=te[0],oe=te[1],re=(0,a.useCallback)(function(){if(A.current&&0!==t.length){console.log("Zoom to fit: calculating bounding box for",t.length,"modules");var e=1/0,n=1/0,a=-1/0,o=-1/0;t.forEach(function(t){var r=N(t);e=Math.min(e,t.x),n=Math.min(n,t.y),a=Math.max(a,t.x+r.width),o=Math.max(o,t.y+r.height)}),console.log("Bounding box:",{minX:e,minY:n,maxX:a,maxY:o});var r=100;e-=r,n-=r,a+=r,o+=r;var c=A.current.getBoundingClientRect(),i=c.width,l=c.height;console.log("Canvas dimensions:",{canvasWidth:i,canvasHeight:l});var s=a-e,u=o-n,d=i/s,p=l/u,f=Math.min(d,p,1),m=(i-s*f)/2-e*f,_=(l-u*f)/2-n*f;console.log("New transform:",{x:m,y:_,scale:f}),B({x:m,y:_,scale:f})}else console.log("Zoom to fit: no canvas or no modules",{canvasRef:!!A.current,moduleCount:t.length})},[t]),ce=(0,a.useCallback)(function(e){if(!A.current)return!0;var n=A.current.getBoundingClientRect(),t=T.x,a=T.y,o=T.scale,r=(e.x+t)*o,c=(e.y+a)*o,i=N(e),l=i.width*o,s=i.height*o;return r<n.width&&c<n.height&&r+l>0&&c+s>0},[T]);(0,a.useImperativeHandle)(n,function(){return{zoomToFit:re,isModuleVisible:ce}},[re,ce]);var ie,le,se,ue,de,pe,fe,me=function(e){if(H){var n=A.current.getBoundingClientRect(),a=(e.clientX-n.left-T.x)/T.scale,o=(e.clientY-n.top-T.y)/T.scale,r=Math.min(a,$.x),c=Math.min(o,$.y),i=Math.abs(a-$.x),s=Math.abs(o-$.y);Q({x:r,y:c,width:i,height:s});var u=t.filter(function(e){var n=N(e),t=e.x+n.width,a=e.y+n.height;return!(e.x>r+i||t<r||e.y>c+s||a<c)});l&&l(u)}else F&&B(function(n){return gt(gt({},n),{},{x:e.clientX-U.x,y:e.clientY-U.y})});if(g){var d=A.current.getBoundingClientRect(),p=(e.clientX-d.left-T.x)/T.scale,f=(e.clientY-d.top-T.y)/T.scale;g({x:p,y:f})}},_e=function(){if(H&&Z){var e=Z.x,n=Z.y,a=Z.width,o=Z.height,r=t.filter(function(t){var r=N(t),c=t.x+r.width,i=t.y+r.height;return!(t.x>e+a||c<e||t.y>n+o||i<n)});l&&r.length>0&&l(r)}G(!1),j(!1),Q(null)};return(0,a.useEffect)(function(){if(F)return document.addEventListener("mousemove",me),document.addEventListener("mouseup",_e),function(){document.removeEventListener("mousemove",me),document.removeEventListener("mouseup",_e)}},[F,U]),a.createElement("div",{className:"patch-canvas ".concat(F?"panning":""," ").concat(D?"subpatch-context":""),ref:A,onMouseDown:function(e){if(e.target===e.currentTarget||"svg"===e.target.tagName){var n=A.current.getBoundingClientRect(),t=(e.clientX-n.left-T.x)/T.scale,a=(e.clientY-n.top-T.y)/T.scale;e.shiftKey?(j(!0),Y({x:t,y:a}),Q({x:t,y:a,width:0,height:0})):(G(!0),W({x:e.clientX-T.x,y:e.clientY-T.y}),!b||e.ctrlKey||e.metaKey||b())}},onMouseMove:me,onWheel:function(e){e.preventDefault();var n=e.deltaY>0?.9:1.1;B(function(e){return gt(gt({},e),{},{scale:Math.max(.1,Math.min(3,e.scale*n))})})},onDoubleClick:function(e){D&&(e.target.classList.contains("patch-canvas")||e.target.classList.contains("patch-svg")||"svg"===e.target.tagName||"g"===e.target.tagName)&&(e.stopPropagation(),I&&I())}},a.createElement("svg",{className:"patch-svg",width:"100%",height:"100%"},a.createElement("g",{transform:"translate(".concat(T.x,", ").concat(T.y,") scale(").concat(T.scale,")")},S&&S.map(function(e){if(null!==D)return null;if(e.collapsed){var n=Math.max(e.inputPorts.length,e.outputPorts.length),r=Math.max(80,25*n+60),c=200;return a.createElement("g",{key:e.id},a.createElement("rect",{x:e.x,y:e.y,width:c,height:r,fill:"#cbd5e1",stroke:(null==x?void 0:x.id)===e.id?"#22c55e":"#334155",strokeWidth:(null==x?void 0:x.id)===e.id?"3":"2",rx:"10",style:{cursor:"move"},onMouseDown:function(n){n.stopPropagation(),E&&E(e);var t=n.clientX,a=n.clientY,o=e.x,r=e.y,c=function(n){var c=n.clientX-t,i=n.clientY-a,l=o+c,s=r+i;P&&P(e.id,l,s)},i=function(){document.removeEventListener("mousemove",c),document.removeEventListener("mouseup",i)};document.addEventListener("mousemove",c),document.addEventListener("mouseup",i)},onDoubleClick:function(n){n.stopPropagation(),L&&L(e.id)}}),a.createElement("rect",{x:e.x,y:e.y,width:c,height:32,fill:e.color,rx:"10",style:{pointerEvents:"none"}}),a.createElement("rect",{x:e.x,y:e.y+16,width:c,height:16,fill:e.color,style:{pointerEvents:"none"}}),a.createElement("text",{x:e.x+100,y:e.y+20,fill:"#1f2937",fontSize:"14",fontWeight:"700",textAnchor:"middle",style:{userSelect:"none",pointerEvents:"none"}},e.label),a.createElement("text",{x:e.x+100,y:e.y+50,fill:"rgba(31, 41, 55, 0.7)",fontSize:"11",textAnchor:"middle",style:{userSelect:"none",pointerEvents:"none"}},e.moduleIds.length," modules"),a.createElement("g",{onClick:function(n){n.stopPropagation(),C&&C(e.id)},style:{cursor:"pointer"}},a.createElement("circle",{cx:e.x+c-12,cy:e.y+12,r:"10",fill:"rgba(220, 38, 38, 0.9)"}),a.createElement("text",{x:e.x+c-12,y:e.y+16,fill:"white",fontSize:"14",fontWeight:"700",textAnchor:"middle",style:{pointerEvents:"none"}},"")),e.inputPorts.map(function(n,t){var o=e.y+60+25*t,r="audio"===n.kind?"#34d399":"#9333ea";return a.createElement("g",{key:"".concat(e.id,"-in-").concat(t)},a.createElement("circle",{cx:e.x,cy:o,r:"6",fill:r,stroke:"white",strokeWidth:"2",style:{cursor:"pointer"},onClick:function(t){t.stopPropagation();var a={id:"".concat(e.id,":in_").concat(n.targetPort),side:"left",port:"in_".concat(n.targetPort),kind:n.kind,x:e.x,y:o,_internalTarget:{moduleId:n.targetModuleId,port:n.targetPort}};u&&u(a)}}),a.createElement("text",{x:e.x+15,y:o+4,fill:"#1f2937",fontSize:"10",style:{userSelect:"none",pointerEvents:"none"}},n.port))}),e.outputPorts.map(function(n,t){var o=e.y+60+25*t,r="audio"===n.kind?"#34d399":"#9333ea";return a.createElement("g",{key:"".concat(e.id,"-out-").concat(t)},a.createElement("circle",{cx:e.x+c,cy:o,r:"6",fill:r,stroke:"white",strokeWidth:"2",style:{cursor:"pointer"},onClick:function(t){t.stopPropagation();var a={id:"".concat(e.id,":out_").concat(n.sourcePort),side:"right",port:"out_".concat(n.sourcePort),kind:n.kind,x:e.x+c,y:o,_internalSource:{moduleId:n.sourceModuleId,port:n.sourcePort}};u&&u(a)}}),a.createElement("text",{x:e.x+c-15,y:o+4,fill:"#1f2937",fontSize:"10",textAnchor:"end",style:{userSelect:"none",pointerEvents:"none"}},n.port))}),e.inputPorts.map(function(n,r){var c=e.y+60+25*r,i=e.x,l=c,s=o.find(function(t){var a=t.to.id.split(":")[0],o=t.to.port;return a===e.id&&o==="in_".concat(n.targetPort)||e.moduleIds.includes(a)&&o===n.targetPort&&!e.moduleIds.includes(t.from.id.split(":")[0])});if(!s)return null;var u=s.from.id.split(":")[0],d=t.find(function(e){return e.id===u});if(!d)return null;var p=N(d),_=[].concat(mt(p.right),mt(p.left)).find(function(e){return e.id===s.from.id});if(!_)return null;var g=_.x,h=_.y,v=i,b=l,y=v-g,k=.3*Math.abs(y),S="M ".concat(g," ").concat(h," C ").concat(g+k," ").concat(h,", ").concat(v-k," ").concat(b,", ").concat(v," ").concat(b),x="".concat(s.from.id,"-").concat(s.to.id),E=f===x;return a.createElement("path",{key:"group-cable-in-".concat(e.id,"-").concat(r),d:S,stroke:E?"#22c55e":"audio"===n.kind?"#34d399":"#9333ea",strokeWidth:E?"4":"2",fill:"none",className:"cable",style:{cursor:"pointer",filter:E?"drop-shadow(0 0 4px #22c55e)":"none",opacity:E?1:.8},onClick:function(e){e.stopPropagation(),e.preventDefault(),m&&m(x)},onMouseDown:function(e){e.stopPropagation()}})}),e.outputPorts.map(function(n,r){var i=e.y+60+25*r,l=e.x+c,s=i,u=o.find(function(t){var a=t.from.id.split(":")[0],o=t.from.port;return a===e.id&&o==="out_".concat(n.sourcePort)||e.moduleIds.includes(a)&&o===n.sourcePort&&!e.moduleIds.includes(t.to.id.split(":")[0])});if(!u)return null;console.log(" Rendering cable from ".concat(e.id,":out_").concat(n.sourcePort," to ").concat(u.to.id));var d=u.to.id.split(":")[0],p=t.find(function(e){return e.id===d});if(!p)return null;var _=N(p),g=[].concat(mt(_.right),mt(_.left)).find(function(e){return e.id===u.to.id});if(!g)return null;var h=l,v=s,b=g.x,y=g.y,k=b-h,S=.3*Math.abs(k),x="M ".concat(h," ").concat(v," C ").concat(h+S," ").concat(v,", ").concat(b-S," ").concat(y,", ").concat(b," ").concat(y),E="".concat(u.from.id,"-").concat(u.to.id),P=f===E;return a.createElement("path",{key:"group-cable-out-".concat(e.id,"-").concat(r),d:x,stroke:P?"#22c55e":"audio"===n.kind?"#34d399":"#9333ea",strokeWidth:P?"4":"2",fill:"none",className:"cable",style:{cursor:"pointer",filter:P?"drop-shadow(0 0 4px #22c55e)":"none",opacity:P?1:.8},onClick:function(e){e.stopPropagation(),e.preventDefault(),m&&m(E)},onMouseDown:function(e){e.stopPropagation()}})}))}return a.createElement("g",{key:e.id},a.createElement("rect",{x:e.x,y:e.y,width:e.width,height:e.height,fill:e.color,fillOpacity:"0.1",stroke:e.color,strokeWidth:"2",strokeDasharray:"5,5",rx:"10",style:{pointerEvents:"none"}}),a.createElement("g",null,a.createElement("rect",{x:e.x,y:e.y-25,width:Math.max(100,8*e.label.length+60),height:"22",fill:e.color,fillOpacity:"0.9",rx:"4",style:{cursor:ee===e.id?"text":"pointer"},onClick:function(n){n.stopPropagation(),ne(e.id),oe(e.label)}}),ee===e.id?a.createElement("foreignObject",{x:e.x+8,y:e.y-24,width:Math.max(100,8*e.label.length+40),height:"20"},a.createElement("input",{type:"text",value:ae,onChange:function(e){return oe(e.target.value)},onBlur:function(){R&&ae.trim()&&R(e.id,ae.trim()),ne(null)},onKeyDown:function(n){"Enter"===n.key?(R&&ae.trim()&&R(e.id,ae.trim()),ne(null)):"Escape"===n.key&&ne(null)},autoFocus:!0,style:{width:"100%",height:"18px",fontSize:"12px",fontWeight:"600",backgroundColor:"rgba(255, 255, 255, 0.95)",border:"1px solid white",borderRadius:"2px",padding:"2px 4px",color:"#1f2937"},onClick:function(e){return e.stopPropagation()}})):a.createElement("text",{x:e.x+10,y:e.y-10,fill:"white",fontSize:"12",fontWeight:"600",style:{userSelect:"none",cursor:"pointer",pointerEvents:"none"}},e.label),a.createElement("g",{onClick:function(n){n.stopPropagation(),w&&w(e.id)},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x+e.width-50,y:e.y-24,width:"20",height:"20",fill:"rgba(59, 130, 246, 0.9)",rx:"3"}),a.createElement("text",{x:e.x+e.width-40,y:e.y-9,fill:"white",fontSize:"12",fontWeight:"700",textAnchor:"middle",style:{pointerEvents:"none"}},e.collapsed?"":"")),a.createElement("g",{onClick:function(n){n.stopPropagation(),C&&C(e.id)},style:{cursor:"pointer"}},a.createElement("rect",{x:e.x+e.width-25,y:e.y-24,width:"20",height:"20",fill:"rgba(220, 38, 38, 0.9)",rx:"3"}),a.createElement("text",{x:e.x+e.width-15,y:e.y-9,fill:"white",fontSize:"14",fontWeight:"700",textAnchor:"middle",style:{pointerEvents:"none"}},""))))}),o.map(function(e){var n=e.from.id.split(":")[0],o=e.to.id.split(":")[0],r=t.find(function(e){return e.id===n}),c=t.find(function(e){return e.id===o}),i=S&&S.find(function(e){return e.id===n}),l=S&&S.find(function(e){return e.id===o});if(!r&&!i)return null;if(!c&&!l)return null;var s,u,d,p,_=r?S&&S.find(function(e){return e.moduleIds.includes(n)}):i,g=c?S&&S.find(function(e){return e.moduleIds.includes(o)}):l;if(null===D){if(r&&_&&_.collapsed&&!i)return null;if(c&&g&&g.collapsed&&!l)return null}else{var h=_&&_.id===D,v=g&&g.id===D;if(!h||!v)return null}if(r){var b=N(r),y=[].concat(mt(b.right),mt(b.left)).find(function(n){return n.id===e.from.id});if(!y)return null;s=y.x,u=y.y}else{if(!i||!i.collapsed)return null;var k=i.outputPorts.findIndex(function(n){return"".concat(i.id,":out_").concat(n.sourcePort)===e.from.id});if(-1===k)return null;s=i.x+200,u=i.y+60+25*k}if(c){var x=N(c),E=[].concat(mt(x.right),mt(x.left)).find(function(n){return n.id===e.to.id});if(!E)return null;d=E.x,p=E.y}else{if(!l||!l.collapsed)return null;var P=l.inputPorts.findIndex(function(n){return"".concat(l.id,":in_").concat(n.targetPort)===e.to.id});if(-1===P)return null;d=l.x,p=l.y+60+25*P}var w=d-s,C=.3*Math.abs(w),R="M ".concat(s," ").concat(u," C ").concat(s+C," ").concat(u,", ").concat(d-C," ").concat(p,", ").concat(d," ").concat(p),L="".concat(e.from.id,"-").concat(e.to.id),I=f===L;return a.createElement("g",{key:"".concat(e.from.id,"-").concat(e.to.id),className:"cable",style:{cursor:"pointer"},onClick:function(e){e.stopPropagation(),e.preventDefault(),m&&m(L)},onMouseDown:function(e){e.stopPropagation()}},a.createElement("path",{d:R,stroke:"transparent",strokeWidth:"15",fill:"none",style:{pointerEvents:"stroke"}}),a.createElement("path",{d:R,stroke:I?"#22c55e":"audio"===e.from.kind?"#34d399":"#9333ea",strokeWidth:I?"4":"2",fill:"none",style:{filter:I?"drop-shadow(0 0 4px #22c55e)":"none",opacity:I?1:.8,pointerEvents:"none"}}))}),p&&_&&(ie=p.x,le=p.y,se=_.x,ue=_.y,de=se-ie,pe=.3*Math.abs(de),fe="M ".concat(ie," ").concat(le," C ").concat(ie+pe," ").concat(le,", ").concat(se-pe," ").concat(ue,", ").concat(se," ").concat(ue),a.createElement("path",{d:fe,stroke:"audio"===p.kind?"#34d399":"#9333ea",strokeWidth:"2",strokeDasharray:"5,5",fill:"none",opacity:"0.6",style:{pointerEvents:"none"}})),t.map(function(e){var n=S&&S.find(function(n){return n.moduleIds.includes(e.id)});if(null===D){if(n&&n.collapsed)return null}else if(!n||n.id!==D)return null;var o=c.some(function(n){return n.id===e.id});return a.createElement(wt,{key:e.id,module:e,isSelected:(null==r?void 0:r.id)===e.id||o,isGroupSelected:o,onSelect:i,onMove:s,onPortClick:u,onPortRightClick:d,connectingFrom:p,allModules:t,onDelete:h,onUpdateParam:v,canvasRef:A,canvasTransform:T,onOpenClockSequencer:y,onOpenHarmonicSequencer:k})}),D&&function(e,n){var o=S&&S.find(function(e){return e.id===D});if(!o)return null;var r=[];return null===(e=o.inputPorts)||void 0===e||e.forEach(function(e,n){var o="audio"===e.kind?"#34d399":"#9333ea",c=Math.max(100,7*"".concat(e.externalSource,":").concat(e.port).length),i=e.x||50,l=e.y||50+40*n,s=t.find(function(n){return n.id===e.targetModuleId});if(s){var u=N(s).left.find(function(n){return n.id==="".concat(s.id,":").concat(e.targetPort)});if(u){var d=u.x,p=u.y,f=i+c+20,m=l;r.push(a.createElement("path",{key:"stub-cable-in-".concat(n),d:"M ".concat(f," ").concat(m," C ").concat(f+50," ").concat(m,", ").concat(d-50," ").concat(p,", ").concat(d," ").concat(p),stroke:o,strokeWidth:"3",fill:"none",className:"cable",style:{pointerEvents:"none"}}))}}}),null===(n=o.outputPorts)||void 0===n||n.forEach(function(e,n){var o="audio"===e.kind?"#34d399":"#9333ea",c=(Math.max(100,7*"".concat(e.externalTarget,":").concat(e.port).length),e.x||1200),i=e.y||50+40*n,l=t.find(function(n){return n.id===e.sourceModuleId});if(l){var s=N(l).right.find(function(n){return n.id==="".concat(l.id,":").concat(e.sourcePort)});if(s){var u=s.x,d=s.y,p=c-20,f=i;r.push(a.createElement("path",{key:"stub-cable-out-".concat(n),d:"M ".concat(u," ").concat(d," C ").concat(u+50," ").concat(d,", ").concat(p-50," ").concat(f,", ").concat(p," ").concat(f),stroke:o,strokeWidth:"3",fill:"none",className:"cable",style:{pointerEvents:"none"}}))}}}),r}(),t.map(function(e){var n=S&&S.find(function(n){return n.moduleIds.includes(e.id)});if(null===D){if(n&&n.collapsed)return null}else if(!n||n.id!==D)return null;var o=c.some(function(n){return n.id===e.id});return a.createElement(wt,{key:e.id,module:e,isSelected:(null==r?void 0:r.id)===e.id||o,isGroupSelected:o,onSelect:i,onMove:s,onPortClick:u,onPortRightClick:d,connectingFrom:p,allModules:t,onDelete:h,onUpdateParam:v,canvasRef:A,canvasTransform:T,onOpenClockSequencer:y,onOpenHarmonicSequencer:k})}),D&&function(e,n){var t=S&&S.find(function(e){return e.id===D});if(!t)return null;var o=[];return null===(e=t.inputPorts)||void 0===e||e.forEach(function(e,n){var t="audio"===e.kind?"#34d399":"#9333ea",r="".concat(e.externalSource,":").concat(e.port),c=Math.max(100,7*r.length),i=e.x||50,l=e.y||50+40*n,s=i+c+20,u=l;o.push(a.createElement("g",{key:"stub-in-".concat(n)},a.createElement("g",{style:{cursor:"move"},onMouseDown:function(e){e.stopPropagation();var t=e.clientX,a=e.clientY,o=i,r=l,c=function(e){var c=e.clientX-t,i=e.clientY-a;M&&M(D,"input",n,o+c,r+i)},s=function(){document.removeEventListener("mousemove",c),document.removeEventListener("mouseup",s)};document.addEventListener("mousemove",c),document.addEventListener("mouseup",s)}},a.createElement("rect",{x:i,y:l-10,width:c,height:20,fill:"rgba(31, 41, 55, 0.9)",stroke:t,strokeWidth:"1",rx:"3"}),a.createElement("text",{x:i+5,y:l+4,fill:"white",fontSize:"11",fontWeight:"500",style:{userSelect:"none",pointerEvents:"none"}},r),a.createElement("path",{d:"M ".concat(i+c+5," ").concat(l-5," l 8 5 l -8 5 z"),fill:t,style:{pointerEvents:"none"}}),a.createElement("circle",{cx:s,cy:u,r:"6",fill:t,stroke:"white",strokeWidth:"2",style:{cursor:"pointer"}}))))}),null===(n=t.outputPorts)||void 0===n||n.forEach(function(e,n){var t="audio"===e.kind?"#34d399":"#9333ea",r="".concat(e.externalTarget,":").concat(e.port),c=Math.max(100,7*r.length),i=e.x||1200,l=e.y||50+40*n,s=i-20,u=l;o.push(a.createElement("g",{key:"stub-out-".concat(n)},a.createElement("g",{style:{cursor:"move"},onMouseDown:function(e){e.stopPropagation();var t=e.clientX,a=e.clientY,o=i,r=l,c=function(e){var c=e.clientX-t,i=e.clientY-a;M&&M(D,"output",n,o+c,r+i)},s=function(){document.removeEventListener("mousemove",c),document.removeEventListener("mouseup",s)};document.addEventListener("mousemove",c),document.addEventListener("mouseup",s)}},a.createElement("circle",{cx:s,cy:u,r:"6",fill:t,stroke:"white",strokeWidth:"2",style:{cursor:"pointer"}}),a.createElement("path",{d:"M ".concat(i-8," ").concat(l-5," l 8 5 l -8 5 z"),fill:t,style:{pointerEvents:"none"}}),a.createElement("rect",{x:i,y:l-10,width:c,height:20,fill:"rgba(31, 41, 55, 0.9)",stroke:t,strokeWidth:"1",rx:"3"}),a.createElement("text",{x:i+5,y:l+4,fill:"white",fontSize:"11",fontWeight:"500",style:{userSelect:"none",pointerEvents:"none"}},r))))}),o}(),Z&&Z.width>0&&Z.height>0&&a.createElement("rect",{x:Z.x,y:Z.y,width:Z.width,height:Z.height,fill:"rgba(34, 197, 94, 0.1)",stroke:"#22c55e",strokeWidth:"2",strokeDasharray:"5,5",style:{pointerEvents:"none"}}))))}),Rt=function(e){var n=e.selectedModule,t=e.selectedModules,o=e.selectedGroup,r=e.onUpdateParam,c=e.onUpdateGroupLabel,i=e.onUngroupModules,l=e.modules,s=e.onShowNetlist,u=e.netlistCopyState,d=e.onCreateGroup,p=e.cpuEstimate,f=vt((0,a.useState)(!1),2),m=f[0],_=f[1],g=vt((0,a.useState)(!1),2),h=g[0],v=g[1],b=vt((0,a.useState)(!1),2),y=b[0],k=b[1],S=vt((0,a.useState)(!1),2),x=S[0],E=S[1],P=vt((0,a.useState)(!1),2),w=P[0],C=P[1],R=vt((0,a.useState)(!1),2),L=R[0],I=R[1],M=vt((0,a.useState)(!1),2),D=M[0],O=M[1],T=vt((0,a.useState)(!1),2),B=T[0],z=T[1],F=vt((0,a.useState)(!1),2),N=F[0],q=F[1],U=vt((0,a.useState)(!1),2),W=U[0],V=U[1],H=vt((0,a.useState)(!1),2),j=H[0],K=H[1],$=vt((0,a.useState)(!1),2),Y=$[0],X=$[1],Z=vt((0,a.useState)(!1),2),Q=Z[0],J=Z[1],ee=vt((0,a.useState)(!1),2),ne=ee[0],te=ee[1],ae=n&&("SamplePlayer"===n.type||"SDPlayer"===n.type||"KickDrum"===n.type||"SnareDrum"===n.type),oe=n&&"KickDrum"===n.type,re=n&&"SnareDrum"===n.type,ce=n&&"DrumDesigner"===n.type,ie=n&&"ADSR"===n.type,le=n&&"Clock"===n.type,se=n&&"Wavetable"===n.type,ue=n&&"Scale"===n.type,de=n&&"HarmonicSequencer"===n.type,pe=n&&"Distortion"===n.type;if((0,a.useEffect)(function(){n&&n.openEditor&&(ae?_(!0):ie?v(!0):le?k(!0):se?C(!0):ue?I(!0):de?V(!0):pe&&K(!0))},[null==n?void 0:n.id,null==n?void 0:n.openEditor]),o)return a.createElement("div",{className:"inspector"},a.createElement("h2",null,"Group Properties"),a.createElement("div",{className:"inspector-content"},a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginBottom:"8px"}},o.moduleIds.length," modules in group")),a.createElement("div",{className:"params"},a.createElement("h3",null,"Group Settings"),a.createElement("div",{className:"param"},a.createElement("label",null,"Group Name"),a.createElement("input",{type:"text",value:o.label,onChange:function(e){c&&c(o.id,e.target.value)},placeholder:"Enter group name"})),a.createElement("button",{className:"btn btn-red",onClick:function(){i&&i(o.id)},style:{width:"100%",marginTop:"12px"}},"Ungroup"),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"8px"}},"Double-click the group to enter subpatch view")));if(t.length>0)return a.createElement("div",{className:"inspector"},a.createElement("h2",null,"Group Selection"),a.createElement("div",{className:"inspector-content"},a.createElement("p",null,t.length," modules selected"),a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginTop:"8px"}},t.map(function(e){var n;return(null===(n=A[e.type])||void 0===n?void 0:n.label)||e.type}).join(", "))),a.createElement("div",{className:"params"},a.createElement("h3",null,"Group Actions"),a.createElement("button",{className:"btn btn-green",onClick:d,style:{width:"100%",marginBottom:"8px"}},"Create Visual Group"),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"4px",marginBottom:"12px"}},"Group modules with colored background for organization")),a.createElement("div",{className:"params"},a.createElement("h3",null,"Keyboard Shortcuts"),a.createElement("div",{style:{fontSize:"11px",lineHeight:"1.6"}},a.createElement("div",null,a.createElement("kbd",null,"Ctrl+C")," / ",a.createElement("kbd",null,"Cmd+C")," - Copy"),a.createElement("div",null,a.createElement("kbd",null,"Ctrl+V")," / ",a.createElement("kbd",null,"Cmd+V")," - Paste"),a.createElement("div",null,a.createElement("kbd",null,"Delete")," - Delete selected"),a.createElement("div",null,a.createElement("kbd",null,"Esc")," - Clear selection"))),a.createElement("div",{className:"params"},a.createElement("h3",null,"Debug Tools"),a.createElement("button",{className:"btn ".concat("copied"===u?"btn-green":"btn-amber"),onClick:s,style:{width:"100%",marginBottom:"8px"},disabled:"copying"===u},"copied"===u?"Copied!":"copying"===u?"Copying...":"Copy Netlist")));if(!n){var fe=(null==p?void 0:p.percentage)||0,me=fe>80?"#ef4444":fe>50?"#f59e0b":"#10b981";return a.createElement("div",{className:"inspector"},a.createElement("h2",null,"Properties"),a.createElement("div",{className:"inspector-content"},a.createElement("p",null,"Select a module to view properties"),a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginTop:"12px",lineHeight:"1.6"}},a.createElement("div",null,a.createElement("strong",null,"Selection:")),a.createElement("div",null," Click module to select"),a.createElement("div",null," ",a.createElement("kbd",null,"Shift+Drag")," for rectangle select"),a.createElement("div",null," ",a.createElement("kbd",null,"Ctrl+Click")," to toggle selection"))),a.createElement("div",{className:"params",style:{marginTop:"8px"}},a.createElement("h3",null,"CPU Usage Estimate"),a.createElement("div",{style:{marginBottom:"8px"}},a.createElement("div",{style:{display:"flex",justifyContent:"space-between",fontSize:"12px",marginBottom:"4px",color:me}},a.createElement("span",{style:{fontWeight:"bold"}},fe.toFixed(1),"%"),a.createElement("span",{style:{fontSize:"10px",color:"#94a3b8"}},(null==p?void 0:p.estimatedCycles)||0," / ",(null==p?void 0:p.availableCycles)||5442," cycles")),a.createElement("div",{style:{width:"100%",height:"20px",backgroundColor:"#1e293b",borderRadius:"4px",overflow:"hidden",border:"1px solid #334155"}},a.createElement("div",{style:{width:"".concat(Math.min(fe,100),"%"),height:"100%",backgroundColor:me,transition:"width 0.3s ease, background-color 0.3s ease"}})),fe>80&&a.createElement("div",{style:{fontSize:"10px",color:"#ef4444",marginTop:"4px",fontWeight:"bold"}}," WARNING: High CPU usage!"),a.createElement("div",{style:{fontSize:"10px",color:"#64748b",marginTop:"6px",fontStyle:"italic"}},"Core 1 (Audio)  Dual-core optimized"),(null==p?void 0:p.core0ModuleCount)>0&&a.createElement("div",{style:{fontSize:"10px",color:"#64748b",marginTop:"2px",fontStyle:"italic"}},"Core 0 (Control): ",p.core0ModuleCount," modules @ 100Hz"))),a.createElement("div",{className:"params"},a.createElement("h3",null,"Debug Tools"),a.createElement("button",{className:"btn ".concat("copied"===u?"btn-green":"btn-amber"),onClick:s,style:{width:"100%",marginBottom:"8px"},disabled:"copying"===u},"copied"===u?"Copied!":"copying"===u?"Copying...":"Copy Netlist")))}var _e,ge,he,ve,be,ye,ke,Se=A[n.type];return a.createElement("div",{className:"inspector"},a.createElement("h2",{style:{borderLeft:"Pot"!==n.type&&"LEDButton"!==n.type||void 0===n.params.bank?"none":"4px solid ".concat(xt[n.params.bank-1]),paddingLeft:"Pot"!==n.type&&"LEDButton"!==n.type||void 0===n.params.bank?"0":"12px",cursor:ce?"pointer":"default"},onClick:function(){ce&&q(!0)}},Se.label,("Pot"===n.type||"LEDButton"===n.type)&&void 0!==n.params.bank&&a.createElement("span",{style:{fontSize:"10px",opacity:.7,marginLeft:"8px"}},"(Bank ",n.params.bank,")")),a.createElement("p",{className:"module-desc"},Se.desc),(ae||oe||re||ce||ie||le||se||ue||de||pe)&&a.createElement("div",{style:{fontSize:"10px",color:"#6b7280",marginBottom:"12px",fontStyle:"italic"}}," Click the module title to open the dedicated editor"),a.createElement("div",{className:"params"},a.createElement("h3",null,"Parameters"),console.log("INSPECTOR RENDERING - Module type:",n.type,"Params:",Object.keys(n.params)),Object.entries(n.params).map(function(e){var t=vt(e,2),o=t[0],c=t[1];if(console.log("Processing param:",o,"=",c,"type:",ft(c)),"Wavetable"===n.type&&o.startsWith("fm_"))return console.log(" Skipping FM param:",o),null;if("StereoMixer4"===n.type&&["g1","g2","g3","g4","pan1","pan2","pan3","pan4","mute1","mute2","mute3","mute4","solo_channel"].includes(o))return console.log(" Skipping mixer control param:",o),null;if("DrumDesigner4"===n.type&&(o.startsWith("voice1_")||o.startsWith("voice2_")||o.startsWith("voice3_")||o.startsWith("voice4_")||"voice1_enabled"===o||"voice2_enabled"===o||"voice3_enabled"===o||"voice4_enabled"===o||"selected_voice"===o))return console.log(" Skipping DrumDesigner4 voice param:",o),null;if("bank"===o&&("Pot"===n.type||"LEDButton"===n.type))return a.createElement("div",{key:o,className:"param"},a.createElement("label",null,o," (1-8):"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,parseInt(e.target.value))}},[1,2,3,4,5,6].map(function(e){return a.createElement("option",{key:e,value:e},"Bank ",e," (",["red","green","blue","yellow","cyan","magenta"][e-1],")")})));if("locked"===o&&("Pot"===n.type||"LEDButton"===n.type))return a.createElement("div",{key:o,className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},"Banking Mode:",a.createElement("button",{className:"btn ".concat(c?"btn-amber":"btn-ghost"),onClick:function(){r(n.id,o,!c)},style:{fontSize:"12px",padding:"4px 8px",minWidth:"80px"}},c?" Locked":" Banked")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px",fontStyle:"italic"}},c?"Control active in ALL banks (persistent)":"Control only active in Bank ".concat(n.params.bank||1)),a.createElement("div",{style:{fontSize:"9px",color:"#6b7280",marginTop:"4px",padding:"4px",backgroundColor:"#1e293b",borderRadius:"3px"}}," ",a.createElement("strong",null,"Lock Button:")," Essential controls (like triggers) should be locked so they're always accessible. When adding new controls, locked slots are automatically skipped."));if("Pot"===n.type&&"pin"===o||"LEDButton"===n.type&&("pin"===o||"ledPin"===o))return null;if("index"===o&&"GateIn"===n.type)return a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Gate Input:"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,parseInt(e.target.value))}},a.createElement("option",{value:1},"Gate In 1 (GPA4)"),a.createElement("option",{value:2},"Gate In 2 (GPA5)")));if("mode"===o&&"GateIn"===n.type)return a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Mode:"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,e.target.value)}},a.createElement("option",{value:"trigger"},"Trigger (pulse on rising edge)"),a.createElement("option",{value:"gate"},"Gate (sustained high)")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px",fontStyle:"italic"}},"trigger"===c?"Pulse output on rising edge (for piezo/drums)":"Sustained high while input active (for CV gates)"));if("ks_mode"===o&&"DrumDesigner"===n.type)return a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"K-S Mode:"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,e.target.value)}},a.createElement("option",{value:"tonal"},"Tonal (guitar/bass decay)"),a.createElement("option",{value:"percussive"},"Percussive (marimba/xylophone)"),a.createElement("option",{value:"noise"},"Noise (short drums)")));if("body_type"===o&&"DrumDesigner"===n.type)return a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Body Type:"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,e.target.value)}},a.createElement("option",{value:"wood"},"Wood"),a.createElement("option",{value:"metal"},"Metal"),a.createElement("option",{value:"glass"},"Glass")));if("pitch_sweep_mode"===o&&"DrumDesigner"===n.type)return a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Pitch Sweep Mode:"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,e.target.value)}},a.createElement("option",{value:"none"},"None (static pitch)"),a.createElement("option",{value:"sine"},"Sine (808 pitch drop)"),a.createElement("option",{value:"delay"},"Delay (Boss feedback)")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px",fontStyle:"italic"}},"none"===c&&"No pitch sweep - static sine/K-S","sine"===c&&"808 kick - sine sweeps from high to low","delay"===c&&"Boss delay trick - K-S delay modulation"));if("mode"===o&&"Filter"===n.type)return a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Filter Mode:"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,e.target.value)}},a.createElement("option",{value:"lowpass"},"Lowpass (cuts highs)"),a.createElement("option",{value:"highpass"},"Highpass (cuts lows)"),a.createElement("option",{value:"bandpass"},"Bandpass (narrow band)"),a.createElement("option",{value:"notch"},"Notch (removes band)")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px",fontStyle:"italic"}},"lowpass"===c&&"Removes frequencies above cutoff","highpass"===c&&"Removes frequencies below cutoff","bandpass"===c&&"Only frequencies around cutoff pass","notch"===c&&"Removes frequencies around cutoff"));if("index"===o&&("Pot"===n.type||"LEDButton"===n.type)){var i=n.params.bank||1,s=l.filter(function(e){var t;return e.type===n.type&&e.id!==n.id&&((null===(t=e.params)||void 0===t?void 0:t.bank)||1)===i}).map(function(e){var n;return(null===(n=e.params)||void 0===n?void 0:n.index)||1}),u={};s.forEach(function(e){u[e]=(u[e]||0)+1});var d=l.filter(function(e){return e.type===n.type}).length;return a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Physical ","Pot"===n.type?"Pot":"Button"," (1-",4,"):"),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginBottom:"4px"}},"Bank ",i,": ",d,"/",24," total ",n.type,"s used"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,parseInt(e.target.value))}},Array.from({length:4},function(e,t){var o=t+1,r=u[o]||0,c=r>0?" (".concat(r," used)"):" (free)";return a.createElement("option",{key:o,value:o},"Pot"===n.type?"Pot":"Button"," ",o,c)})))}if("ADSR"===n.type&&["attack_ms","decay_ms","sustain","release_ms"].includes(o))return null;if("Clock"===n.type&&"bank"!==o&&"use_outputs_5_8"!==o&&"show_advanced_outputs"!==o)return null;if("HarmonicSequencer"===n.type){if("step_count"===o){var p=c,f=n.params.start_bank||1,m=G(0,f,l.filter(function(e){return e.id!==n.id}));return a.createElement("div",{key:o,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Step Count (Inspector Only)"),a.createElement("select",{value:p,onChange:function(e){var t=parseInt(e.target.value),a=G(0,f,l.filter(function(e){return e.id!==n.id}));r(n.id,"step_count",t),r(n.id,"banks_required",a.banksRequired),r(n.id,"end_bank",a.endBank)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:4},"4 steps (1 bank)"),a.createElement("option",{value:8},"8 steps (2 banks)"),a.createElement("option",{value:12},"12 steps (3 banks)"),a.createElement("option",{value:16},"16 steps (4 banks)")),a.createElement("div",{style:{fontSize:"9px",color:m.isValid?"#22c55e":"#ef4444",marginTop:"4px",padding:"4px",backgroundColor:"#1e293b",borderRadius:"3px"}},m.isValid?a.createElement(a.Fragment,null," Will use banks ",f,"-",m.endBank):a.createElement(a.Fragment,null," Cannot fit ",p," steps starting at bank ",f),!m.isValid&&m.conflicts.length>0&&a.createElement("div",{style:{color:"#ef4444",marginTop:"2px"}},"Conflicts with: ",m.conflicts.map(function(e){return"".concat(e.type," ").concat(e.id)}).join(", ")),m.endBank>8&&a.createElement("div",{style:{color:"#ef4444",marginTop:"2px"}},"Would need bank ",m.endBank," (only 6 banks available)")))}if("start_bank"===o){n.params.step_count;var _=c,g=G(0,_,l.filter(function(e){return e.id!==n.id}));return a.createElement("div",{key:o,className:"param"},a.createElement("label",{style:{fontSize:"12px",color:"#9ca3af",display:"block",marginBottom:"4px"}},"Starting Bank"),a.createElement("select",{value:_,onChange:function(e){var t=parseInt(e.target.value),a=G(0,t,l.filter(function(e){return e.id!==n.id}));r(n.id,"start_bank",t),r(n.id,"banks_required",a.banksRequired),r(n.id,"end_bank",a.endBank)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},[1,2,3,4,5,6].map(function(e){var t=G(0,e,l.filter(function(e){return e.id!==n.id}));return a.createElement("option",{key:e,value:e,style:{color:t.isValid?"white":"#ef4444"}},"Bank ",e," ",t.isValid?"":"(conflicts)")})),a.createElement("div",{style:{fontSize:"9px",color:g.isValid?"#22c55e":"#ef4444",marginTop:"4px",padding:"4px",backgroundColor:"#1e293b",borderRadius:"3px"}},g.isValid?a.createElement(a.Fragment,null," Will use banks ",_,"-",g.endBank):a.createElement(a.Fragment,null," Cannot place sequencer at bank ",_),!g.isValid&&g.conflicts.length>0&&a.createElement("div",{style:{color:"#ef4444",marginTop:"2px"}},"Conflicts with: ",g.conflicts.map(function(e){return"".concat(e.type," ").concat(e.id)}).join(", ")),g.endBank>8&&a.createElement("div",{style:{color:"#ef4444",marginTop:"2px"}},"Would need bank ",g.endBank," (only 6 available)")))}if(["banks_required","end_bank"].includes(o))return null;if(["hardware_pots","hardware_btns"].includes(o))return null;if(o.includes("pin")||o.includes("Pin")||o.includes("_pins"))return null;if(o.includes("encoder")||o.includes("Encoder")||o.includes("enc_")||o.includes("encBtn"))return null;if(["loop_start","loop_end","loop_active"].includes(o))return null;if(o.match(/^bank[0-3]_steps$/)||["sequence_length","steps","clock_div","swing","gate_length","playback_mode","running","current_step","show_individual_outputs","individual_outputs_enabled","scale_connected","scale_root","quantization_scale","quantization_root","quantization_tuning","octave_center"].includes(o))return null}if(["KickDrum","SnareDrum","Percussion","PercussionSynth"].includes(n.type))return null;if("SamplePlayer"===n.type){if("polyphonic"===o)return a.createElement("div",{key:o,className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("input",{type:"checkbox",checked:c,onChange:function(e){r(n.id,o,e.target.checked)}}),o,":",a.createElement("span",{style:{fontSize:"10px",color:c?"#22c55e":"#94a3b8",fontWeight:"bold"}},c?"6-Voice PSRAM Mode":"Single Voice Mode")),c&&a.createElement("div",{style:{fontSize:"9px",color:"#6b7280",marginTop:"4px",padding:"4px",backgroundColor:"#1e293b",borderRadius:"3px"}}," ",a.createElement("strong",null,"Polyphonic Mode:")," Enables concurrent voices with PSRAM sample caching. Auto-loads sample1.wav to sample8.wav into memory for instant triggering."));if("max_voices"===o&&n.params.polyphonic)return a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Voice Count (affects performance):"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,parseInt(e.target.value))}},a.createElement("option",{value:1},"1 Voice (Minimal CPU)"),a.createElement("option",{value:2},"2 Voices (Light CPU)"),a.createElement("option",{value:3},"3 Voices (Low CPU)"),a.createElement("option",{value:4},"4 Voices (Medium CPU)"),a.createElement("option",{value:6},"6 Voices (Standard)"),a.createElement("option",{value:8},"8 Voices (High CPU)")),a.createElement("div",{style:{fontSize:"9px",color:"#6b7280",marginTop:"2px",fontStyle:"italic"}},"More voices = higher CPU usage but richer polyphony"));if("auto_load_samples"===o)return a.createElement("div",{key:o,className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("input",{type:"checkbox",checked:c,onChange:function(e){r(n.id,o,e.target.checked)}}),"Auto-load samples:",a.createElement("span",{style:{fontSize:"10px",color:c?"#22c55e":"#94a3b8"}},c?"Load sample1-8.wav on first trigger":"Manual loading only")));if("voice_allocation"===o)return a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Voice allocation strategy:"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,e.target.value)}},a.createElement("option",{value:"round_robin"},"Round Robin (balanced)"),a.createElement("option",{value:"oldest_first"},"Oldest First (voice stealing)"),a.createElement("option",{value:"random"},"Random (chaotic)")))}return"Oscillator"===n.type&&"waveform"===o?a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Waveform:"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"sine"},"Sine Wave"),a.createElement("option",{value:"triangle"},"Triangle Wave"),a.createElement("option",{value:"saw"},"Sawtooth Wave"),a.createElement("option",{value:"square"},"Square Wave"))):"Distortion"===n.type&&"preset"===o?a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Preset:"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,e.target.value)}},a.createElement("option",{value:"clean"},"Clean (soft clipping)"),a.createElement("option",{value:"overdrive"},"Overdrive (smooth saturation)"),a.createElement("option",{value:"fuzz"},"Fuzz (hard clipping)"),a.createElement("option",{value:"speaker"},"Speaker (cabinet compression)"),a.createElement("option",{value:"bitcrush"},"Bitcrush (quantized)"),a.createElement("option",{value:"saturatorlive"},"SaturatorLive (Ableton OD+Sat)"))):"Distortion"===n.type&&"bypassMode"===o?a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Bypass Mode:"),a.createElement("select",{value:c,onChange:function(e){r(n.id,o,e.target.value)}},a.createElement("option",{value:"toggle"},"Toggle (button switches on/off)"),a.createElement("option",{value:"gate"},"Gate (active while held)"))):"Distortion"===n.type&&"presetCrossfade"===o?a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Preset Crossfade: ",c.toFixed(2)," (0=instant, 1=smooth)"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:c,onChange:function(e){r(n.id,o,parseFloat(e.target.value))},style:{width:"100%"}})):"Distortion"===n.type&&"drive"===o?a.createElement("div",{key:o,className:"param"},a.createElement("label",null,"Drive: ",c.toFixed(1)," (0-10)"),a.createElement("input",{type:"range",min:"0",max:"10",step:"0.1",value:c,onChange:function(e){r(n.id,o,parseFloat(e.target.value))},style:{width:"100%"}})):"boolean"==typeof c?a.createElement("div",{key:o,className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("input",{type:"checkbox",checked:c,onChange:function(e){r(n.id,o,e.target.checked)}}),o,":",a.createElement("span",{style:{fontSize:"10px",color:c?"#22c55e":"#94a3b8",fontWeight:"bold"}},c?"ENABLED":"DISABLED"))):a.createElement("div",{key:o,className:"param"},a.createElement("label",null,o,":"),a.createElement("input",{type:"number"==typeof c?"number":"text",defaultValue:c,onBlur:function(e){var t="number"==typeof c?parseFloat(e.target.value)||0:e.target.value;r(n.id,o,t)},onKeyDown:function(e){if("Enter"===e.key){var t="number"==typeof c?parseFloat(e.target.value)||0:e.target.value;r(n.id,o,t),e.target.blur()}}}))})),"Wavetable"===n.type&&(console.log(" FM SECTION RENDERING for module:",n.id,"expanded:",Y),a.createElement("div",{className:"params"},a.createElement("h3",{style:{cursor:"pointer",display:"flex",alignItems:"center",gap:"8px",userSelect:"none"},onClick:function(){X(!Y)}},Y?"":""," FM Synthesis"),Y&&a.createElement(a.Fragment,null,a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginBottom:"8px",lineHeight:"1.4"}},"Connect an audio signal to the FM input jack to enable frequency modulation. Modulator can track carrier frequency at a ratio, or run independently."),a.createElement("div",{className:"param"},a.createElement("label",null,"FM Amount: ",(null===(be=n.params.fm_amount)||void 0===be?void 0:be.toFixed(2))||"0.00"," (modulation depth)"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:n.params.fm_amount||0,onChange:function(e){r(n.id,"fm_amount",parseFloat(e.target.value))},style:{width:"100%"}})),a.createElement("div",{className:"param"},a.createElement("label",{style:{display:"flex",alignItems:"center",gap:"8px"}},a.createElement("input",{type:"checkbox",checked:n.params.fm_tracking||!1,onChange:function(e){r(n.id,"fm_tracking",e.target.checked)}}),"FM Tracking:",a.createElement("span",{style:{fontSize:"10px",color:n.params.fm_tracking?"#22c55e":"#94a3b8"}},n.params.fm_tracking?"Modulator tracks carrier  ratio":"Independent modulator freq"))),n.params.fm_tracking&&a.createElement(a.Fragment,null,a.createElement("div",{className:"param"},a.createElement("label",null,"C:M Ratio: ",(null===(ye=n.params.fm_ratio)||void 0===ye?void 0:ye.toFixed(2))||"1.00"," (carrier:modulator)"),a.createElement("input",{type:"range",min:"0.25",max:"8",step:"0.01",value:n.params.fm_ratio||1,onChange:function(e){r(n.id,"fm_ratio",parseFloat(e.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"4px"}},n.params.fm_ratio>=1?"1:".concat((null===(ke=n.params.fm_ratio)||void 0===ke?void 0:ke.toFixed(2))||"1.00"," (modulator ").concat(n.params.fm_ratio," carrier)"):"".concat((1/(n.params.fm_ratio||1)).toFixed(2),":1 (modulator ").concat((1/(n.params.fm_ratio||1)).toFixed(2),")"))),a.createElement("div",{className:"param"},a.createElement("label",null,"Ratio Mode:"),a.createElement("select",{value:n.params.fm_ratio_mode||"zones",onChange:function(e){r(n.id,"fm_ratio_mode",e.target.value)},style:{width:"100%",padding:"4px",backgroundColor:"#374151",color:"white",border:"1px solid #6b7280",borderRadius:"4px",fontSize:"12px"}},a.createElement("option",{value:"free"},"Free (continuous sweep)"),a.createElement("option",{value:"quantized"},"Quantized (snap to pure ratios)"),a.createElement("option",{value:"zones"},"Zones (detents at pure ratios)")),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"4px"}},"free"===n.params.fm_ratio_mode&&"Smooth continuous ratio control","quantized"===n.params.fm_ratio_mode&&"Snaps to 1:1, 1:2, 2:1, 1:3, etc.","zones"===n.params.fm_ratio_mode&&"Magnetic zones near pure ratios")))))),"StereoMixer4"===n.type&&a.createElement("div",{className:"params"},a.createElement("h3",{style:{cursor:"pointer",display:"flex",alignItems:"center",gap:"8px",userSelect:"none"},onClick:function(){J(!Q)}},Q?"":""," Channel Controls"),Q&&a.createElement(a.Fragment,null,a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginBottom:"8px",lineHeight:"1.4"}},"Hardware controls via banking (Banks ",n.params.start_bank||2," & ",(n.params.start_bank||2)+1,"). These parameters set initial values."),a.createElement("div",{style:{marginBottom:"12px",paddingTop:"8px",borderTop:"1px solid #374151"}},a.createElement("h4",{style:{fontSize:"12px",color:"#60a5fa",marginBottom:"8px"}},"Channel Volumes (Bank ",n.params.start_bank||2,")"),["g1","g2","g3","g4"].map(function(e,t){return a.createElement("div",{key:e,className:"param"},a.createElement("label",null,"Ch",t+1," Volume: ",(n.params[e]||0).toFixed(2)),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:n.params[e]||0,onChange:function(t){r(n.id,e,parseFloat(t.target.value))},style:{width:"100%"}}))})),a.createElement("div",{style:{marginBottom:"12px",paddingTop:"8px",borderTop:"1px solid #374151"}},a.createElement("h4",{style:{fontSize:"12px",color:"#60a5fa",marginBottom:"8px"}},"Channel Panning (Bank ",(n.params.start_bank||2)+1,")"),["pan1","pan2","pan3","pan4"].map(function(e,t){var o=n.params[e]||.5,c=o<.4?"L":o>.6?"R":"C";return a.createElement("div",{key:e,className:"param"},a.createElement("label",null,"Ch",t+1," Pan: ",c," (",o.toFixed(2),")"),a.createElement("input",{type:"range",min:"0",max:"1",step:"0.01",value:o,onChange:function(t){r(n.id,e,parseFloat(t.target.value))},style:{width:"100%"}}),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8",marginTop:"2px"}},"0.0 = Left, 0.5 = Center, 1.0 = Right"))})))),"DrumDesigner4"===n.type&&a.createElement("div",{className:"params"},a.createElement("h3",{style:{cursor:"pointer",display:"flex",alignItems:"center",gap:"8px",userSelect:"none"},onClick:function(){te(!ne)}},ne?"":""," Voice Controls"),ne&&a.createElement(a.Fragment,null,a.createElement("div",{style:{fontSize:"11px",color:"#94a3b8",marginBottom:"12px",lineHeight:"1.4"}},"Configure each of the 4 percussion voices. Disable unused voices to save CPU."),a.createElement("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr",gap:"8px",marginBottom:"16px"}},[1,2,3,4].map(function(e){var t=!1!==n.params["voice".concat(e,"_enabled")];return a.createElement("div",{key:e,style:{padding:"8px",backgroundColor:t?"#1e293b":"#0f172a",border:"2px solid ".concat(t?"#3b82f6":"#334155"),borderRadius:"4px",cursor:"pointer",opacity:t?1:.5,transition:"all 0.2s"},onClick:function(){r(n.id,"voice".concat(e,"_enabled"),!t)}},a.createElement("div",{style:{display:"flex",alignItems:"center",gap:"6px",marginBottom:"4px"}},a.createElement("input",{type:"checkbox",checked:t,onChange:function(){},style:{cursor:"pointer"}}),a.createElement("span",{style:{fontWeight:"bold",fontSize:"12px"}},"Voice ",e)),a.createElement("div",{style:{fontSize:"10px",color:"#94a3b8"}},["marimba","snare","hihat","tom"][e-1]))})),a.createElement("div",{className:"param",style:{marginBottom:"16px"}},a.createElement("label",{style:{fontWeight:"bold",color:"#60a5fa"}},"Edit Voice:"),a.createElement("select",{value:n.params.selected_voice||1,onChange:function(e){r(n.id,"selected_voice",parseInt(e.target.value))},style:{width:"100%",padding:"6px",backgroundColor:"#1e293b",border:"1px solid #475569",borderRadius:"4px",color:"#e2e8f0"}},[1,2,3,4].map(function(e){var t=!1!==n.params["voice".concat(e,"_enabled")];return a.createElement("option",{key:e,value:e,disabled:!t},"Voice ",e," ",t?"":"(disabled)")}))),function(){var e=n.params.selected_voice||1;if(!1===n.params["voice".concat(e,"_enabled")])return a.createElement("div",{style:{padding:"12px",backgroundColor:"#0f172a",borderRadius:"4px",fontSize:"12px",color:"#94a3b8",textAlign:"center"}},"Voice ",e," is disabled. Enable it above to edit parameters.");var t=[{key:"voice".concat(e,"_pitch"),label:"Pitch (MIDI)",min:24,max:96,step:1},{key:"voice".concat(e,"_ks_damping"),label:"Damping",min:0,max:1,step:.01},{key:"voice".concat(e,"_ks_level"),label:"K-S Level",min:0,max:1,step:.01},{key:"voice".concat(e,"_sine_level"),label:"Sine Level",min:0,max:1,step:.01},{key:"voice".concat(e,"_amp_attack"),label:"Attack (ms)",min:.1,max:100,step:.1},{key:"voice".concat(e,"_amp_decay"),label:"Decay (ms)",min:10,max:2e3,step:10},{key:"voice".concat(e,"_amp_release"),label:"Release (ms)",min:10,max:1e3,step:10},{key:"voice".concat(e,"_output_gain"),label:"Output Gain",min:0,max:5,step:.1}];return a.createElement("div",null,a.createElement("h4",{style:{fontSize:"12px",color:"#60a5fa",marginBottom:"8px",paddingTop:"8px",borderTop:"1px solid #374151"}},"Voice ",e," Parameters"),t.map(function(e){var t=e.key,o=e.label,c=e.min,i=e.max,l=e.step,s=n.params[t]||0;return a.createElement("div",{key:t,className:"param"},a.createElement("label",null,o,": ",s.toFixed(l>=1?0:2)),a.createElement("input",{type:"range",min:c,max:i,step:l,value:s,onChange:function(e){r(n.id,t,parseFloat(e.target.value))},style:{width:"100%"}}))}))}())),l.some(function(e){return"Pot"===e.type||"LEDButton"===e.type})&&a.createElement("div",{className:"params"},a.createElement("h3",{style:{cursor:"pointer",display:"flex",alignItems:"center",gap:"8px",userSelect:"none"},onClick:function(){E(!x)}},x?"":""," Hardware Banking Overview"),x&&a.createElement(a.Fragment,null,a.createElement("div",{style:{fontSize:"11px",lineHeight:"1.4"}},(he=l.filter(function(e){return"Pot"===e.type}),ve={},he.forEach(function(e){var n,t=(null===(n=e.params)||void 0===n?void 0:n.bank)||1;ve[t]||(ve[t]=[]),ve[t].push(e)}),a.createElement("div",{style:{marginBottom:"12px"}},a.createElement("div",{style:{fontWeight:"bold",color:"#22c55e",marginBottom:"4px"}}," Pots: ",he.length,"/32 total (",he.length>32?"OVER LIMIT!":"OK",")"),[1,2,3,4,5,6].map(function(e){var t=ve[e]||[],o=0===t.length;return a.createElement("div",{key:e,style:{display:"flex",alignItems:"center",marginBottom:"2px",opacity:o?.5:1}},a.createElement("div",{style:{width:"12px",height:"12px",backgroundColor:xt[e-1],borderRadius:"2px",marginRight:"6px"}}),a.createElement("div",{style:{minWidth:"60px"}},"Bank ",e,":"),a.createElement("div",{style:{flex:1}},o?"empty":t.map(function(e,o){var r,c=(null===(r=e.params)||void 0===r?void 0:r.index)||1;return a.createElement("span",{key:e.id,style:{marginRight:"4px",color:e.id===(null==n?void 0:n.id)?"#22c55e":"#cbd5e1"}},"P",c,o<t.length-1?",":"")})))}))),(_e=l.filter(function(e){return"LEDButton"===e.type}),ge={},_e.forEach(function(e){var n,t=(null===(n=e.params)||void 0===n?void 0:n.bank)||1;ge[t]||(ge[t]=[]),ge[t].push(e)}),a.createElement("div",null,a.createElement("div",{style:{fontWeight:"bold",color:"#22c55e",marginBottom:"4px"}}," Buttons: ",_e.length,"/32 total (",_e.length>32?"OVER LIMIT!":"OK",")"),[1,2,3,4,5,6].map(function(e){var t=ge[e]||[],o=0===t.length;return a.createElement("div",{key:e,style:{display:"flex",alignItems:"center",marginBottom:"2px",opacity:o?.5:1}},a.createElement("div",{style:{width:"12px",height:"12px",backgroundColor:xt[e-1],borderRadius:"2px",marginRight:"6px"}}),a.createElement("div",{style:{minWidth:"60px"}},"Bank ",e,":"),a.createElement("div",{style:{flex:1}},o?"empty":t.map(function(e,o){var r,c=(null===(r=e.params)||void 0===r?void 0:r.index)||1;return a.createElement("span",{key:e.id,style:{marginRight:"4px",color:e.id===(null==n?void 0:n.id)?"#22c55e":"#cbd5e1"}},"B",c,o<t.length-1?",":"")})))}))),a.createElement("div",{style:{marginTop:"8px",padding:"6px",backgroundColor:"#0f172a",borderRadius:"4px",border:"1px solid #334155"}},a.createElement("div",{style:{fontWeight:"bold",color:"#f59e0b",marginBottom:"2px"}}," Dedicated Banking System"),a.createElement("div",null,"4 physical pots  6 banks = 24 virtual pots max"),a.createElement("div",null,"4 physical buttons  6 banks = 24 virtual buttons max"),a.createElement("div",{style:{marginTop:"6px",fontSize:"10px",color:"#94a3b8"}},a.createElement("div",{style:{fontWeight:"bold",color:"#22c55e",marginBottom:"2px"}}," Encoder Navigation (clockwise):"),a.createElement("div",null,"Bank 1: Gate1 LED  Bank 2: Gate2 LED  Bank 3: MIDI-IN LED"),a.createElement("div",null,"Bank 4: MIDI-OUT LED  Bank 5: Gate3 LED  Bank 6: Gate4 LED"),a.createElement("div",null,"Bank 5: Gate3 LED  Bank 6: Gate4 LED  wraps to Bank 1"),a.createElement("div",{style:{marginTop:"4px",fontStyle:"italic"}}," Encoder button: confirm bank selection"),a.createElement("div",{style:{fontStyle:"italic"}}," LEDs fade back to normal operation after selection"),a.createElement("div",{style:{fontStyle:"italic"}}," Second encoder press: show current bank")),a.createElement("div",{style:{marginTop:"6px",fontSize:"10px",padding:"4px",backgroundColor:"#1e293b",borderRadius:"3px"}},a.createElement("span",{style:{color:"#f59e0b"}}," Future:")," WS2812B LEDs under pots/buttons will match bank colors"))))),a.createElement("div",{className:"params"},a.createElement("h3",null,"Debug Tools"),a.createElement("button",{className:"btn ".concat("copied"===u?"btn-green":"btn-amber"),onClick:s,style:{width:"100%",marginBottom:"8px"},disabled:"copying"===u},"copied"===u?"Copied!":"copying"===u?"Copying...":"Copy Netlist")),m&&n&&a.createElement(kn,{componentName:"Sample Editor",onRetry:function(){_(!1),setTimeout(function(){return _(!0)},100)}},a.createElement(dn,{module:n,onUpdateParam:r,onClose:function(){return _(!1)},modules:l})),h&&n&&a.createElement(Mn,{module:n,onUpdateParam:r,onClose:function(){return v(!1)},fullscreen:!0}),y&&n&&a.createElement(An,{module:n,onUpdateParam:r,onClose:function(){return k(!1)},fullscreen:!0}),w&&n&&a.createElement(Fn,{module:n,onUpdateParam:r,onClose:function(){return C(!1)}}),L&&n&&a.createElement(jn,{module:n,onUpdateParam:r,onClose:function(){return I(!1)},fullscreen:!0}),W&&n&&a.createElement(tt,{module:n,modules:l,onUpdateParam:r,onClose:function(){return V(!1)},fullscreen:!0}),D&&n&&a.createElement(Kn,{module:n,modules:l,onUpdateParam:r,onClose:function(){return O(!1)},fullscreen:!0}),B&&n&&a.createElement(Kn,{module:n,modules:l,onUpdateParam:r,onClose:function(){return z(!1)},fullscreen:!0}),N&&n&&a.createElement(it,{module:n,modules:l,onUpdateParam:r,onClose:function(){return q(!1)},fullscreen:!0}),j&&n&&a.createElement(mn,{module:n,onUpdateParam:r,onClose:function(){return K(!1)}}))},Lt=function(){var e=[],n=vt((0,a.useState)([]),2),t=n[0],o=n[1],r=vt((0,a.useState)(function(){return console.log("Loading default connections:",e),e}),2),c=r[0],i=r[1],l=vt((0,a.useState)(null),2),s=l[0],u=l[1],d=vt((0,a.useState)([]),2),p=d[0],f=d[1],m=vt((0,a.useState)(null),2),_=m[0],g=m[1],h=vt((0,a.useState)(null),2),v=h[0],b=h[1],y=vt((0,a.useState)(null),2),k=(y[0],y[1]),S=vt((0,a.useState)([]),2),x=S[0],E=S[1],P=vt((0,a.useState)(null),2),w=P[0],C=P[1],R=vt((0,a.useState)(null),2),L=R[0],I=R[1],M=vt((0,a.useState)(!1),2),D=(M[0],M[1],vt((0,a.useState)({x:0,y:0}),2)),O=(D[0],D[1],vt((0,a.useState)(!1),2)),T=(O[0],O[1],vt((0,a.useState)(null),2)),z=T[0],F=T[1],G=vt((0,a.useState)({x:0,y:0}),2),q=G[0],U=G[1],W=vt((0,a.useState)(""),2),V=W[0],H=W[1],j=vt((0,a.useState)(!1),2),K=j[0],$=j[1],Y=vt((0,a.useState)("idle"),2),X=Y[0],Z=Y[1],Q=vt((0,a.useState)({percentage:0,breakdown:[]}),2),J=Q[0],ee=Q[1],ne=vt((0,a.useState)(!1),2),te=(ne[0],ne[1],vt((0,a.useState)(!1),2)),ae=te[0],oe=te[1],re=vt((0,a.useState)(""),2),ce=re[0],ie=re[1],le=vt((0,a.useState)(null),2),se=(le[0],le[1],vt((0,a.useState)(!1),2)),ue=(se[0],se[1],vt((0,a.useState)(null),2)),de=(ue[0],ue[1],vt((0,a.useState)(!1),2)),pe=de[0],fe=de[1],me=vt((0,a.useState)(null),2),_e=me[0],ge=me[1],he=vt((0,a.useState)(!1),2),ve=he[0],be=he[1],ye=vt((0,a.useState)(null),2),ke=ye[0],Se=ye[1],xe=vt((0,a.useState)(!1),2),Ee=(xe[0],xe[1],vt((0,a.useState)(null),2)),Pe=(Ee[0],Ee[1],vt((0,a.useState)(!1),2)),we=(Pe[0],Pe[1],vt((0,a.useState)(null),2)),Ce=(we[0],we[1],vt((0,a.useState)(!1),2)),Re=Ce[0],Le=Ce[1],Ie=vt((0,a.useState)("idle"),2),Me=Ie[0],De=Ie[1],Ae=(0,a.useRef)(),Oe=vt((0,a.useState)(null),2),Te=Oe[0],ze=Oe[1],Fe=vt((0,a.useState)([]),2),Ne=Fe[0],Ge=Fe[1],qe=vt((0,a.useState)(-1),2),Ue=qe[0],We=qe[1],Ve=vt((0,a.useState)(!1),2),He=Ve[0],je=Ve[1],Ke=(0,a.useCallback)(function(){if(He)console.log("Skipping history save during undo/redo");else{var e={modules:JSON.parse(JSON.stringify(t)),connections:JSON.parse(JSON.stringify(c)),groups:JSON.parse(JSON.stringify(x))};console.log("Saving to history. Current index: ".concat(Ue,", Snapshot:"),{modules:e.modules.length,connections:e.connections.length,groups:e.groups.length}),Ge(function(n){var t=n.slice(0,Ue+1);return t.push(e),t.length>50?(t.shift(),t):(console.log("History updated. New length: ".concat(t.length)),t)}),We(function(e){return Math.min(e+1,49)})}},[t,c,x,Ue,He]);(0,a.useEffect)(function(){var e={modules:JSON.parse(JSON.stringify(t)),connections:JSON.parse(JSON.stringify(c)),groups:JSON.parse(JSON.stringify(x))};Ge([e]),We(0),console.log("Saved initial state to history")},[]),(0,a.useEffect)(function(){return document.addEventListener("keydown",Xe),function(){return document.removeEventListener("keydown",Xe)}},[_,s,p,w,v,c,t,x,Ne,Ue]),(0,a.useEffect)(function(){try{var e=new Be(t,c,x).estimateCPU();ee(e)}catch(e){console.error("CPU estimation error:",e),ee({percentage:0,breakdown:[]})}},[t,c,x]);var $e=function(e,n,t){o(function(a){return a.map(function(a){if(a.id!==e)return a;var o=gt(gt({},a.params),{},ht({},n,t));if("LEDButton"===a.type&&"index"===n){var r={1:{pin:0,ledPin:6},2:{pin:1,ledPin:7},3:{pin:2,ledPin:8},4:{pin:3,ledPin:9}}[t];r&&(o.pin=r.pin,o.ledPin=r.ledPin)}if("Pot"===a.type&&"index"===n){var c={1:7,2:3,3:4,4:5}[t];void 0!==c&&(o.pin=c)}return gt(gt({},a),{},{params:o})})}),(null==s?void 0:s.id)===e&&u(function(e){var a=gt(gt({},e.params),{},ht({},n,t));if("LEDButton"===e.type&&"index"===n){var o={1:{pin:0,ledPin:6},2:{pin:1,ledPin:7},3:{pin:2,ledPin:8},4:{pin:3,ledPin:9}}[t];o&&(a.pin=o.pin,a.ledPin=o.ledPin)}if("Pot"===e.type&&"index"===n){var r={1:7,2:3,3:4,4:5}[t];void 0!==r&&(a.pin=r)}return gt(gt({},e),{},{params:a})})},Ye=function(e){console.log("Deleting module: ".concat(e)),Ke(),o(function(n){var t=n.filter(function(n){return n.id!==e});return console.log("Modules after delete: ".concat(t.length," (was ").concat(n.length,")")),t}),i(function(n){return n.filter(function(n){var t=n.from.id.split(":")[0],a=n.to.id.split(":")[0];return t!==e&&a!==e})}),E(function(n){return n.map(function(n){var t,a,o,r;if(!n.moduleIds.includes(e))return n;var c=(null===(t=n.inputPorts)||void 0===t?void 0:t.filter(function(n){return n.targetModuleId!==e}))||[],i=(null===(a=n.outputPorts)||void 0===a?void 0:a.filter(function(n){return n.sourceModuleId!==e}))||[],l=n.moduleIds.filter(function(n){return n!==e});return console.log("Cleaned up group ".concat(n.id,": removed ").concat((null===(o=n.inputPorts)||void 0===o?void 0:o.length)-c.length," input ports, ").concat((null===(r=n.outputPorts)||void 0===r?void 0:r.length)-i.length," output ports")),gt(gt({},n),{},{moduleIds:l,inputPorts:c,outputPorts:i})})}),(null==s?void 0:s.id)===e&&u(null)},Xe=function(e){if("INPUT"!==e.target.tagName&&"SELECT"!==e.target.tagName&&"TEXTAREA"!==e.target.tagName)if(!e.ctrlKey&&!e.metaKey||"z"!==e.key||e.shiftKey)if((e.ctrlKey||e.metaKey)&&"z"===e.key&&e.shiftKey){if(e.preventDefault(),Ue<Ne.length-1){var n=Ne[Ue+1];je(!0),o(n.modules),i(n.connections),E(n.groups),We(function(e){return e+1}),u(null),f([]),g(null),C(null),setTimeout(function(){return je(!1)},100),console.log("Redo to history index ".concat(Ue+1))}}else if(!e.ctrlKey&&!e.metaKey||"c"!==e.key){if(!e.ctrlKey&&!e.metaKey||"v"!==e.key){if("Delete"===e.key||"Backspace"===e.key)if(_)r=_,Ke(),i(function(e){return e.filter(function(e){return"".concat(e.from.id,"-").concat(e.to.id)!==r})}),g(null);else if(w)Ke(),Qe(w.id);else if(p.length>0){Ke();var a=new Set(p.map(function(e){return e.id}));o(function(e){return e.filter(function(e){return!a.has(e.id)})}),i(function(e){return e.filter(function(e){var n=e.from.id.split(":")[0],t=e.to.id.split(":")[0];return!a.has(n)&&!a.has(t)})}),f([])}else s&&Ye(s.id);var r;"Escape"===e.key&&(F(null),g(null),u(null),f([]),k(null),C(null))}else if(e.preventDefault(),v&&v.modules.length>0){Ke();var l=50;if(v.group)for(var d=v.group.x,m=v.group.y,h=!0,y=function(){var e=d+l,n=m+l;(h=x.some(function(t){return Math.abs(t.x-e)<20&&Math.abs(t.y-n)<20}))&&(l+=50)};h&&l<500;)y();else for(var S=v.modules.map(function(e){return{x:e.x,y:e.y}}),P=!0;P&&l<500;)(P=S.some(function(e){var n=e.x+l,a=e.y+l;return t.some(function(e){return Math.abs(e.x-n)<20&&Math.abs(e.y-a)<20})}))&&(l+=50);var R=new Map,L=v.modules.map(function(e){var n=B(e.type,e.x+l,e.y+l,t);return R.set(e.id,n.id),n.params=gt({},e.params),n}),I=v.connections.map(function(e){var n=e.from.id.split(":")[0],t=e.to.id.split(":")[0],a=e.from.id.split(":")[1],o=e.to.id.split(":")[1],r=R.get(n),c=R.get(t);return r&&c?{from:{id:"".concat(r,":").concat(a),port:e.from.port,kind:e.from.kind},to:{id:"".concat(c,":").concat(o),port:e.to.port,kind:e.to.kind}}:null}).filter(function(e){return null!==e});if(o(function(e){return[].concat(mt(e),mt(L))}),i(function(e){return[].concat(mt(e),mt(I))}),v.group){var M=v.group.moduleIds.map(function(e){return R.get(e)}).filter(function(e){return e}),D=x.filter(function(e){return e.label.startsWith(v.group.label)}).length,A=D>0?"".concat(v.group.label," (").concat(D,")"):v.group.label,O={id:"group".concat(Date.now()),label:A,moduleIds:M,x:v.group.x+l,y:v.group.y+l,color:v.group.color,collapsed:v.group.collapsed,inputPorts:v.group.inputPorts?v.group.inputPorts.map(function(e){var n=R.get(e.targetModuleId)||e.targetModuleId;return{id:"".concat(n,":").concat(e.port),port:e.port,kind:e.kind,targetModuleId:n,targetPort:e.targetPort||e.port,x:e.x?e.x+l:e.x,y:e.y?e.y+l:e.y}}):[],outputPorts:v.group.outputPorts?v.group.outputPorts.map(function(e){var n=R.get(e.sourceModuleId)||e.sourceModuleId;return{id:"".concat(n,":").concat(e.port),port:e.port,kind:e.kind,sourceModuleId:n,sourcePort:e.sourcePort||e.port,x:e.x?e.x+l:e.x,y:e.y?e.y+l:e.y}}):[]};E(function(e){return[].concat(mt(e),[O])}),C(O),f([]),u(null),console.log("Pasted group with ".concat(L.length," modules and ").concat(I.length," connections"))}else f(L),u(null),console.log("Pasted ".concat(L.length," modules and ").concat(I.length," connections"))}}else{if(e.preventDefault(),w){var T=t.filter(function(e){return w.moduleIds.includes(e.id)}),z=new Set(T.map(function(e){return e.id})),N=c.filter(function(e){var n=e.from.id.split(":")[0],t=e.to.id.split(":")[0];return z.has(n)&&z.has(t)});return b({modules:T,connections:N,group:w}),void console.log("Copied group with ".concat(T.length," modules and ").concat(N.length," connections"))}var G=p.length>0?p:s?[s]:[];if(G.length>0){var q=new Set(G.map(function(e){return e.id})),U=c.filter(function(e){var n=e.from.id.split(":")[0],t=e.to.id.split(":")[0];return q.has(n)&&q.has(t)});b({modules:G,connections:U}),console.log("Copied ".concat(G.length," modules and ").concat(U.length," connections"))}}else if(e.preventDefault(),console.log("Undo requested. Current index: ".concat(Ue,", History length: ").concat(Ne.length)),Ue>0){var W=Ne[Ue-1];console.log("Restoring state from index ".concat(Ue-1,":"),{modules:W.modules.length,connections:W.connections.length,groups:W.groups.length}),je(!0),o(W.modules),i(W.connections),E(W.groups),We(function(e){return e-1}),u(null),f([]),g(null),C(null),setTimeout(function(){return je(!1)},100)}else console.log("Cannot undo: at oldest history state")},Ze=function(){var e=pt(st().m(function e(){var n,a,o,r,i,l;return st().w(function(e){for(;;)switch(e.p=e.n){case 0:if(0!==t.length){e.n=1;break}return alert("No modules in patch. Add some modules first."),e.a(2);case 1:if(e.p=1,console.log("Generating code using frontend CodeGenerator..."),console.log("Modules: ".concat(t.length,", Connections: ").concat(c.length)),n=new Be(t,c,x),a=n.estimateCPU(),console.log("CPU Estimate:",a),console.log("  Estimated: ".concat(a.percentage,"% (").concat(a.estimatedCycles," / ").concat(a.availableCycles," cycles)")),a.breakdown.forEach(function(e){console.log("  ".concat(e.id," (").concat(e.type,"): ").concat(e.cost," units"))}),o=n.generate(),H(o),e.p=2,!navigator.clipboard||!window.isSecureContext){e.n=4;break}return e.n=3,navigator.clipboard.writeText(o);case 3:e.n=5;break;case 4:(r=document.createElement("textarea")).value=o,r.style.position="fixed",r.style.left="-999999px",r.style.top="-999999px",document.body.appendChild(r),r.focus(),r.select(),document.execCommand("copy"),document.body.removeChild(r);case 5:console.log(" Code copied to clipboard successfully"),console.log("Estimated CPU: ".concat(a.percentage,"% (").concat(a.estimatedCycles," / ").concat(a.availableCycles," cycles per sample)")),a.percentage>80&&console.warn(" WARNING: High CPU usage!"),Z("copied"),setTimeout(function(){return Z("idle")},2e3),e.n=7;break;case 6:e.p=6,i=e.v,console.error("Failed to copy to clipboard:",i),alert("Failed to copy to clipboard. Use Code Preview to manually copy.");case 7:console.log(" Code generated successfully"),console.log("Code length: ".concat(o.length," characters")),e.n=9;break;case 8:e.p=8,l=e.v,console.error("Code generation error:",l),alert("Code generation failed: ".concat(l.message));case 9:return e.a(2)}},e,null,[[2,6],[1,8]])}));return function(){return e.apply(this,arguments)}}(),Qe=function(e){var n=x.find(function(n){return n.id===e});if(n){var t=new Set(n.moduleIds);o(function(e){return e.filter(function(e){return!t.has(e.id)})}),i(function(n){return n.filter(function(n){var a=n.from.id.split(":")[0],o=n.to.id.split(":")[0];return!t.has(a)&&!t.has(o)&&a!==e&&o!==e})}),E(function(n){return n.filter(function(n){return n.id!==e})}),(null==w?void 0:w.id)===e&&C(null),L===e&&I(null),console.log("Deleted group ".concat(e," and ").concat(t.size," contained modules"))}},Je=function(e,n){E(function(t){return t.map(function(t){return t.id===e?gt(gt({},t),{},{label:n}):t})}),(null==w?void 0:w.id)===e&&C(function(e){return gt(gt({},e),{},{label:n})})},en=function(){var e=pt(st().m(function e(){var n,a,o,r,i;return st().w(function(e){for(;;)switch(e.p=e.n){case 0:if(0!==t.length){e.n=1;break}return De("idle"),e.a(2);case 1:return De("copying"),n=function(e){return x.find(function(n){return n.moduleIds.includes(e)})},a="",o=[],r={},c.forEach(function(e){var a=e.from.id.split(":"),c=e.to.id.split(":"),i=a[0],l=c[0],s=a[1]||"",u=c[1]||"",d=t.find(function(e){return e.id===i}),p=t.find(function(e){return e.id===l}),f=n(i),m=n(l),_=e.from.kind||"unknown";if("unknown"===_&&(s.match(/^(L|R|left|right|outL|outR|inL|inR)$/i)||u.match(/^(L|R|left|right|outL|outR|inL|inR)$/i)?_="audio":(s.match(/^(value|press|freq|wave|fm|btn\d+)$/i)||u.match(/^(value|press|freq|wave|fm|btn\d+)$/i))&&(_="control")),f||m)if(f&&m&&f.id===m.id){r[f.id]||(r[f.id]=[]);var g=d?Pt(d,A[d.type],t):i,h=p?Pt(p,A[p.type],t):l;r[f.id].push("  [".concat(_,"] ").concat(g,":").concat(s,"  ").concat(h,":").concat(u))}else{var v,b;if(f){var y=f.outputPorts.find(function(e){return e.sourceModuleId===i&&e.sourcePort===s});v=y?"".concat(f.label,":out_").concat(y.port):"".concat(f.label,":").concat(s)}else v=d?Pt(d,A[d.type],t):i,v="".concat(v,":").concat(s);if(m){var k=m.inputPorts.find(function(e){return e.targetModuleId===l&&e.targetPort===u});b=k?"".concat(m.label,":in_").concat(k.port):"".concat(m.label,":").concat(u)}else b=p?Pt(p,A[p.type],t):l,b="".concat(b,":").concat(u);o.push("[".concat(_,"] ").concat(v,"  ").concat(b))}else{var S=d?Pt(d,A[d.type],t):i,x=p?Pt(p,A[p.type],t):l;o.push("[".concat(_,"] ").concat(S,":").concat(s,"  ").concat(x,":").concat(u))}}),o.length>0&&(a+="=== EXTERNAL CONNECTIONS ===\n",a+=o.join("\n")+"\n"),Object.keys(r).length>0&&(a+="\n=== INTERNAL GROUP CONNECTIONS ===\n",Object.keys(r).forEach(function(e){var n=x.find(function(n){return n.id===e});a+="\n".concat(n?n.label:e,":\n"),a+=r[e].join("\n")+"\n"})),e.p=2,e.n=3,navigator.clipboard.writeText(a);case 3:De("copied"),setTimeout(function(){De("idle")},1e3),e.n=5;break;case 4:e.p=4,i=e.v,console.error("Failed to copy to clipboard:",i),De("idle"),alert("Failed to copy to clipboard. Check console for details.");case 5:return e.a(2)}},e,null,[[2,4]])}));return function(){return e.apply(this,arguments)}}(),nn=function(){console.log("handleZoomToFit called, canvasRef:",Ae.current),Ae.current&&Ae.current.zoomToFit?Ae.current.zoomToFit():console.log("No zoomToFit function available")};return a.createElement("div",{className:"app"},a.createElement(kt,{onGenerateCode:Ze,onCodePreview:function(){if(!V){if(0===t.length)return void alert("No modules in patch. Add some modules first.");try{var e=new Be(t,c,x).generate();H(e)}catch(e){return console.error("Code generation error:",e),void alert("Code generation failed: ".concat(e.message))}}$(!0)},onSavePatch:function(){var e=prompt("Enter patch name:","Untitled Patch");if(null!==e){var n=e.trim().replace(/[^a-z0-9_\- ]/gi,"_")||"Untitled",a={version:"1.0",name:e,created:(new Date).toISOString(),modules:t.map(function(e){return{id:e.id,type:e.type,x:e.x,y:e.y,params:e.params}}),connections:c.map(function(e){return{from:e.from,to:e.to}})},o=JSON.stringify(a,null,2),r=new Blob([o],{type:"application/json"}),i=URL.createObjectURL(r),l=document.createElement("a");l.href=i,l.download="".concat(n,".json"),document.body.appendChild(l),l.click(),document.body.removeChild(l),URL.revokeObjectURL(i),console.log("Patch saved as: ".concat(n,".json"))}else console.log("Patch save cancelled")},onLoadPatch:function(){var e=document.createElement("input");e.type="file",e.accept=".json",e.onchange=function(e){var n=e.target.files[0];if(n){var t=new FileReader;t.onload=function(e){try{var n=JSON.parse(e.target.result);if(!n.modules||!n.connections)throw new Error("Invalid patch format: missing modules or connections");o([]),i([]);var t=n.modules.map(function(e){return{id:e.id,type:e.type,x:e.x||100,y:e.y||100,params:e.params||{}}}),a=new Set(t.map(function(e){return e.id})),r=n.connections.map(function(e){return{from:e.from,to:e.to}}).filter(function(e){var n=e.from.id.split(":")[0],t=e.to.id.split(":")[0],o=a.has(n)&&a.has(t);return o||console.warn("  Skipping invalid connection: ".concat(e.from.id,"  ").concat(e.to.id," (module not found)")),o}),c=n.connections.length-r.length;c>0&&console.warn("  Removed ".concat(c," invalid connection(s) referencing non-existent modules")),o(t),i(r),console.log("Patch loaded: ".concat(t.length," modules, ").concat(r.length," connections"))}catch(e){console.error("Error loading patch:",e),alert("Error loading patch: ".concat(e.message))}},t.readAsText(n)}},e.click()},onClearCanvas:function(){0!==t.length||0!==c.length||0!==x.length?window.confirm("Clear all ".concat(t.length," modules, ").concat(c.length," connections, and ").concat(x.length," groups from the canvas?\n\nThis cannot be undone."))&&(o([]),i([]),E([]),u(null),F(null),g(null),C(null),console.log("Canvas cleared")):alert("Canvas is already empty")},onZoomToFit:nn,onSnapToGrid:function(){var e=50,n=200,a=function(e,n){return!(e.x+140+10<=n.x||n.x+140+10<=e.x||e.y+100+10<=n.y||n.y+100+10<=e.y)},r=function(n,t,o){var r,c=lt(arguments.length>3&&void 0!==arguments[3]?arguments[3]:[]);try{var i,l=function(){var n=r.value,t=Math.round(n.x/e)*e,c=Math.round(n.y/e)*e,i={x:t,y:c};if(!o.some(function(e){return a(i,e)}))return{v:{x:t,y:c}}};for(c.s();!(r=c.n()).done;)if(i=l())return i.v}catch(e){c.e(e)}finally{c.f()}var s=Math.round(n/e)*e,u=Math.round(t/e)*e,d={x:s,y:u};if(!o.some(function(e){return a(d,e)}))return{x:s,y:u};for(var p=1;p<=20;p++)for(var f,m=function(){var e=g[_];if(e.x>=0&&e.y>=0){var n={x:e.x,y:e.y};if(!o.some(function(e){return a(n,e)}))return{v:e}}},_=0,g=[{x:s+p*e,y:u},{x:s-p*e,y:u},{x:s,y:u+p*e},{x:s,y:u-p*e},{x:s+p*e,y:u+p*e},{x:s-p*e,y:u-p*e},{x:s+p*e,y:u-p*e},{x:s-p*e,y:u+p*e}];_<g.length;_++)if(f=m())return f.v;return{x:s,y:u}},i=t.filter(function(e){return"Pot"===e.type||"LEDButton"===e.type}),l=t.filter(function(e){return"Pot"!==e.type&&"LEDButton"!==e.type}),s=[];l.forEach(function(e){var n=r(e.x,e.y,s);s.push(gt(gt({},e),{},{x:n.x,y:n.y}))}),i.forEach(function(t){var a=function(e,n){var t=e.id,a=c.filter(function(e){var n=e.from.id.split(":")[0],a=e.to.id.split(":")[0];return n===t||a===t}),o=new Set;return a.forEach(function(e){var n=e.from.id.split(":")[0],a=e.to.id.split(":")[0];n!==t&&o.add(n),a!==t&&o.add(a)}),n.filter(function(e){return o.has(e.id)})}(t,s);if(a.length>0){for(var o=a.reduce(function(e,n){return e+n.x},0)/a.length,i=a.reduce(function(e,n){return e+n.y},0)/a.length,l=[],u=0;u<=300;u+=e)l.push({x:o-n,y:i+u}),0!==u&&l.push({x:o-n,y:i-u});for(var d=0;d<=300;d+=e)l.push({x:o-n-e,y:i+d}),0!==d&&l.push({x:o-n-e,y:i-d});var p=r(t.x,t.y,s,l);s.push(gt(gt({},t),{},{x:p.x,y:p.y}))}else{var f=r(t.x,t.y,s);s.push(gt(gt({},t),{},{x:f.x,y:f.y}))}}),o(s),console.log("Snapped ".concat(t.length," modules to ").concat(e,"px grid (controls near connected modules)"))},onOpenSampleEditor:function(){Le(!0)},copyButtonState:X}),a.createElement("div",{className:"main-content"},a.createElement(St,{onAddModule:function(e){try{Ke(),console.log("Adding ".concat(e," module. Current modules:"),t.map(function(e){return e.id}));var n=B(e,null,null,t);console.log("Created new module:",n),o(function(e){var t=[].concat(mt(e),[n]);return console.log("Updated modules:",t.map(function(e){return e.id})),setTimeout(function(){Ae.current&&Ae.current.isModuleVisible&&(Ae.current.isModuleVisible(n)||(console.log("New module is outside viewport, auto-zooming to fit"),nn()))},50),t}),L&&(E(function(e){return e.map(function(e){return e.id===L?gt(gt({},e),{},{moduleIds:[].concat(mt(e.moduleIds),[n.id])}):e})}),console.log("Added module ".concat(n.id," to group ").concat(L)))}catch(n){console.error("Error adding ".concat(e," module:"),n),alert("Error adding ".concat(e," module: ").concat(n.message))}},onLoadExamplePatch:function(e){try{if(!e.modules||!e.connections)throw new Error("Invalid patch format: missing modules or connections");console.log(" LOADING EXAMPLE PATCH - Original modules:",e.modules.map(function(e){return{id:e.id,type:e.type}})),o([]),i([]);var n=e.modules.map(function(e){var n={id:e.id,type:e.type,x:e.x||100,y:e.y||100,params:e.params||{}};return console.log("   Loaded module:",n.id,n.type),n}),t=new Set(n.map(function(e){return e.id})),a=e.connections.map(function(e){return{from:e.from,to:e.to}}).filter(function(e){var n=e.from.id.split(":")[0],a=e.to.id.split(":")[0],o=t.has(n)&&t.has(a);return o||console.warn("  Example patch: Skipping invalid connection: ".concat(e.from.id,"  ").concat(e.to.id," (module not found)")),o}),r=e.connections.length-a.length;r>0&&(console.warn("  Example patch: Removed ".concat(r," invalid connection(s) referencing non-existent modules")),alert("Warning: Example patch had ".concat(r," invalid connection(s) that were removed. This example patch needs to be fixed."))),o(n),i(a),console.log("Example patch loaded: ".concat(n.length," modules, ").concat(a.length," connections"))}catch(e){console.error("Error loading example patch:",e),alert("Error loading example patch: ".concat(e.message))}}}),a.createElement(Ct,{ref:Ae,modules:t,connections:c,selectedModule:s,selectedModules:p,onSelectModule:function(e){if(e.ctrlKey){var n=p.some(function(n){return n.id===e.id});f(n?function(n){return n.filter(function(n){return n.id!==e.id})}:function(n){return[].concat(mt(n),[e])}),u(null)}else u(e),f([]);g(null)},onSelectModules:function(e){f(e),u(null),g(null)},onMoveModule:function(e,n,a){if(p.some(function(n){return n.id===e})&&p.length>1){var r=t.find(function(n){return n.id===e});if(!r)return;var c=n-r.x,i=a-r.y,l=new Set(p.map(function(e){return e.id}));o(function(e){return e.map(function(e){return l.has(e.id)?gt(gt({},e),{},{x:e.x+c,y:e.y+i}):e})}),f(function(e){return e.map(function(e){return gt(gt({},e),{},{x:e.x+c,y:e.y+i})})})}else o(function(t){return t.map(function(t){return t.id===e?gt(gt({},t),{},{x:n,y:a}):t})}),(null==s?void 0:s.id)===e&&u(function(e){return gt(gt({},e),{},{x:n,y:a})})},onPortClick:function(e){if(console.log("Port clicked:",e),z){if(console.log("Completing connection. From:",z,"To:",e),console.log("Validation: port.side =",e.side,", connectingFrom.kind =",z.kind,", port.kind =",e.kind),"left"===e.side&&e.kind===z.kind){var n={id:"".concat(z.id,"->").concat(e.id),from:z,to:e},a=c.some(function(n){return n.from.id===z.id&&n.to.id===e.id});if("control"===e.kind&&c.some(function(n){return n.to.id===e.id}))return console.log("Control input already has connection"),alert("Cannot connect: Control input ".concat(e.id," already has a connection")),void F(null);if(a)console.log("Connection already exists");else{console.log("Creating new connection:",n),Ke(),i(function(e){return[].concat(mt(e),[n])});var r=e.id.split(":")[0],l=t.find(function(e){return e.id===r});if(l&&"Automation"===l.type){var s=e.port;if(s.startsWith("in_")){var u,d=parseInt(s.split("_")[1]),p=(null===(u=l.params)||void 0===u?void 0:u.num_inputs)||1;d===p&&p<8&&(console.log("Automation ".concat(l.id,": Expanding from ").concat(p," to ").concat(p+1," inputs")),o(function(e){return e.map(function(e){return e.id===r?gt(gt({},e),{},{params:gt(gt({},e.params),{},{num_inputs:p+1})}):e})}))}}if(l&&"MIDIOut"===l.type){var f=e.port;if(f.startsWith("cc_")){var m,_=parseInt(f.split("_")[1]),g=(null===(m=l.params)||void 0===m?void 0:m.num_cc)||1;_===g&&g<8&&(console.log("MIDIOut ".concat(l.id,": Expanding from ").concat(g," to ").concat(g+1," CC ports")),o(function(e){return e.map(function(e){return e.id===r?gt(gt({},e),{},{params:gt(gt({},e.params),{},{num_cc:g+1})}):e})}))}}if(l&&"Wavetable"===l.type&&"fm"===e.port){var h,v,b=(null===(h=l.params)||void 0===h?void 0:h.fm_amount)||0,y=(null===(v=l.params)||void 0===v?void 0:v.fm_tracking)||!1;0!==b||y||(console.log("Oscillator ".concat(l.id,": Auto-enabling FM (amount: 0.5, tracking: true)")),o(function(e){return e.map(function(e){return e.id===r?gt(gt({},e),{},{params:gt(gt({},e.params),{},{fm_amount:.5,fm_tracking:!0})}):e})}))}}}else console.log("Invalid connection - validation failed:",{portSide:e.side,expectedSide:"left",portKind:e.kind,connectingFromKind:z.kind,kindsMatch:e.kind===z.kind});F(null)}else"right"===e.side?(console.log("Starting connection from output port:",e.id),console.log("Full port object:",e),F(e)):console.log("Cannot start connection from input port")},onPortRightClick:function(e,n,t){console.log("handlePortRightClick called:",{port:n,moduleId:t,currentContext:L}),e.preventDefault(),e.stopPropagation(),L?(console.log("Port right-clicked:",n,"Module:",t,"Context:",L),ze({x:e.clientX,y:e.clientY,port:n,moduleId:t,groupId:L}),console.log("Context menu set at:",e.clientX,e.clientY)):console.log("Not inside a group - context menu not available. CurrentContext:",L)},connectingFrom:z,selectedConnection:_,onConnectionClick:function(e){g(e),u(null)},mousePos:q,onMouseMove:U,onDeleteModule:Ye,onUpdateParam:$e,onOpenClockSequencer:function(e){ge(e),fe(!0)},onOpenHarmonicSequencer:function(e){Se(e),be(!0)},onClearSelections:function(){u(null),f([]),g(null),C(null)},groups:x,selectedGroup:w,onSelectGroup:function(e){C(e),u(null),f([]),g(null)},onMoveGroup:function(e,n,t){E(function(a){return a.map(function(a){return a.id===e?gt(gt({},a),{},{x:n,y:t}):a})}),(null==w?void 0:w.id)===e&&C(function(e){return gt(gt({},e),{},{x:n,y:t})})},onToggleGroupCollapse:function(e){E(function(n){return n.map(function(n){return n.id===e?gt(gt({},n),{},{collapsed:!n.collapsed}):n})})},onDeleteGroup:Qe,onUpdateGroupLabel:Je,onEnterGroup:function(e){console.log("Entering subpatch:",e),I(e),u(null),f([])},onExitToRoot:function(){console.log("Exiting to root patch"),I(null),u(null),f([])},onMoveStub:function(e,n,t,a,o){E(function(r){return r.map(function(r){if(r.id===e){if("input"===n){var c=mt(r.inputPorts);return c[t]=gt(gt({},c[t]),{},{x:a,y:o}),gt(gt({},r),{},{inputPorts:c})}if("output"===n){var i=mt(r.outputPorts);return i[t]=gt(gt({},i[t]),{},{x:a,y:o}),gt(gt({},r),{},{outputPorts:i})}}return r})})},currentContext:L}),a.createElement(Rt,{selectedModule:s,selectedModules:p,selectedGroup:w,onUpdateParam:$e,onUpdateGroupLabel:Je,onUngroupModules:function(e){console.log("Ungrouping:",e),E(function(n){return n.filter(function(n){return n.id!==e})}),C(null),L===e&&I(null)},modules:t,onShowNetlist:en,netlistCopyState:Me,onCreateGroup:function(){var e=p.length>0?p:s?[s]:[];if(0!==e.length){Ke();var n=new Set(e.map(function(e){return e.id})),a=[],o=[];c.forEach(function(r){var c=r.from.id.split(":")[0],i=r.to.id.split(":")[0],l=n.has(c),s=n.has(i);if(!l&&s){var u=e.find(function(e){return e.id===i}),d=t.find(function(e){return e.id===c}),p=u.x-180,f=u.y+20;a.push({id:"".concat(r.to.id),port:r.to.port,kind:r.to.kind,targetModuleId:i,targetPort:r.to.port,x:p,y:f,externalSource:d.type})}if(l&&!s){var m=e.find(function(e){return e.id===c}),_=t.find(function(e){return e.id===i}),g=N(m),h=m.x+g.width+50,v=m.y+20;o.push({id:"".concat(r.from.id),port:r.from.port,kind:r.from.kind,sourceModuleId:c,sourcePort:r.from.port,x:h,y:v,externalTarget:_.type})}});var r=1/0,i=1/0,l=-1/0,d=-1/0;e.forEach(function(e){var n=N(e);r=Math.min(r,e.x),i=Math.min(i,e.y),l=Math.max(l,e.x+n.width),d=Math.max(d,e.y+n.height)});var m=(r+l)/2,_=(i+d)/2,g={id:"Group".concat(x.length+1),label:"Group ".concat(x.length+1),x:m-100,y:_-75,moduleIds:e.map(function(e){return e.id}),collapsed:!0,inputPorts:a,outputPorts:o,color:"hsl(".concat(60*x.length%360,", 70%, 50%)")};E(function(e){return[].concat(mt(e),[g])}),f([]),u(null),console.log("Created subpatch: ".concat(g.id," with ").concat(g.moduleIds.length," modules, ").concat(a.length," inputs, ").concat(o.length," outputs"))}else alert("Select modules to group first")},cpuEstimate:J})),K&&a.createElement("div",{className:"modal-backdrop",onClick:function(){return $(!1)}},a.createElement("div",{className:"modal-content",onClick:function(e){return e.stopPropagation()},style:{maxWidth:"90%",maxHeight:"90%",width:"1000px"}},a.createElement("div",{className:"modal-header"},a.createElement("h2",null,"Generated Arduino Code"),a.createElement("button",{className:"modal-close",onClick:function(){return $(!1)}},"")),a.createElement("div",{className:"modal-body",style:{display:"flex",flexDirection:"column",height:"600px"}},a.createElement("div",{style:{display:"flex",justifyContent:"flex-end",gap:"8px",marginBottom:"12px"}},a.createElement("button",{className:"btn btn-ghost",onClick:function(){var e=new Blob([V],{type:"text/plain"}),n=URL.createObjectURL(e),t=document.createElement("a");t.href=n,t.download="2409Code.ino",document.body.appendChild(t),t.click(),document.body.removeChild(t),URL.revokeObjectURL(n)}}," Download .ino"),a.createElement("button",{className:"btn ".concat("btn-green"),onClick:pt(st().m(function e(){var n,t;return st().w(function(e){for(;;)switch(e.p=e.n){case 0:if(e.p=0,!navigator.clipboard||!window.isSecureContext){e.n=2;break}return e.n=1,navigator.clipboard.writeText(V);case 1:e.n=3;break;case 2:(n=document.createElement("textarea")).value=V,n.style.position="fixed",n.style.left="-999999px",n.style.top="-999999px",document.body.appendChild(n),n.focus(),n.select(),document.execCommand("copy"),document.body.removeChild(n);case 3:Z("copied"),setTimeout(function(){return Z("idle")},1500),e.n=5;break;case 4:e.p=4,t=e.v,console.error("Failed to copy:",t),alert("Failed to copy to clipboard. Check console for details.");case 5:return e.a(2)}},e,null,[[0,4]])}))},"copied"===X?" Code Copied!":" Copy Code")),a.createElement("textarea",{value:V,readOnly:!0,style:{flex:1,fontFamily:'Monaco, "Cascadia Code", "Fira Code", Consolas, monospace',fontSize:"12px",padding:"12px",border:"1px solid #374151",borderRadius:"6px",backgroundColor:"#0f172a",color:"#e2e8f0",resize:"none",whiteSpace:"pre"}})))),ae&&a.createElement("div",{className:"modal-backdrop",onClick:function(){return oe(!1)}},a.createElement("div",{className:"modal-content",onClick:function(e){return e.stopPropagation()},style:{maxWidth:"800px",maxHeight:"80%"}},a.createElement("div",{className:"modal-header"},a.createElement("h2",null,"Load Patch from Netlist"),a.createElement("button",{className:"modal-close",onClick:function(){return oe(!1)}},"")),a.createElement("div",{className:"modal-body",style:{display:"flex",flexDirection:"column",gap:"16px"}},a.createElement("div",{style:{color:"#94a3b8",fontSize:"13px"}},a.createElement("p",{style:{marginBottom:"8px"}},"Paste netlist from generated Arduino sketch header or manually format:"),a.createElement("pre",{style:{backgroundColor:"#0f172a",padding:"8px",borderRadius:"4px",fontSize:"11px",overflow:"auto"}},"[audio] Oscillator 1:L  VCA:inL\n[audio] Oscillator 1:R  VCA:inR\n[ctrl] Pot 1 (Bank 1):value  Oscillator 1:freq")),a.createElement("textarea",{value:ce,onChange:function(e){return ie(e.target.value)},placeholder:"Paste netlist here...",style:{minHeight:"300px",fontFamily:'Monaco, "Cascadia Code", "Fira Code", Consolas, monospace',fontSize:"12px",padding:"12px",border:"1px solid #374151",borderRadius:"6px",backgroundColor:"#1e293b",color:"#e2e8f0",resize:"vertical"}}),a.createElement("div",{style:{display:"flex",justifyContent:"flex-end",gap:"8px"}},a.createElement("button",{className:"btn btn-ghost",onClick:function(){oe(!1),ie("")}},"Cancel"),a.createElement("button",{className:"btn btn-green",onClick:function(){try{var e=function(e){var n,t=e.split("\n"),a=[],o=new Set,r=/\[(audio|ctrl|control)\]\s+([^:]+):(\S+)\s+\s+([^:]+):(\S+)/,c=lt(t);try{for(c.s();!(n=c.n()).done;){var i=n.value.match(r);if(i){var l=vt(i,6),s=(l[0],l[1]),u=l[2],d=l[3],p=l[4],f=l[5];a.push({kind:"control"===s?"ctrl":s,from:{module:u.trim(),port:d.trim()},to:{module:p.trim(),port:f.trim()}}),o.add(u.trim()),o.add(p.trim())}}}catch(e){c.e(e)}finally{c.f()}return{connections:a,moduleNames:Array.from(o)}}(ce),n=e.connections,t=e.moduleNames;if(0===n.length)return void alert("No valid connections found in netlist. Expected format:\n[audio] Module1:port  Module2:port\n[ctrl] Module3:port  Module4:port");console.log("Parsed connections:",n),console.log("Module names:",t),Ke();var a=[],r={},c=100,l=100;t.forEach(function(e,n){for(var t=e.split(/\s+\d+/)[0].trim(),o=null,i=0,s=Object.entries(A);i<s.length;i++){var u=vt(s[i],2),d=u[0];if(u[1].label===t||d===t){o=d;break}}if(o){var p=B(o,c,l,a);(c+=200)>1e3&&(c=100,l+=150),a.push(p),r[e]=p.id}else console.warn("Unknown module type: ".concat(e,", skipping"))});var s=[];n.forEach(function(e){var n=r[e.from.module],t=r[e.to.module];n&&t?s.push({from:{id:"".concat(n,":").concat(e.from.port),port:e.from.port,kind:e.kind},to:{id:"".concat(t,":").concat(e.to.port),port:e.to.port,kind:e.kind}}):console.warn("Skipping connection: ".concat(e.from.module,":").concat(e.from.port,"  ").concat(e.to.module,":").concat(e.to.port," (module not found)"))}),o(a),i(s),oe(!1),ie(""),console.log("Loaded ".concat(a.length," modules and ").concat(s.length," connections from netlist"))}catch(e){console.error("Netlist parsing error:",e),alert("Failed to load netlist: ".concat(e.message))}},disabled:!ce.trim()},"Load Patch"))))),pe&&_e&&a.createElement(An,{module:t.find(function(e){return e.id===_e.id})||_e,onUpdateParam:$e,onClose:function(){fe(!1),ge(null)},fullscreen:!0}),ve&&ke&&a.createElement(tt,{module:t.find(function(e){return e.id===ke.id})||ke,modules:t,onUpdateParam:$e,onClose:function(){be(!1),Se(null)},fullscreen:!0}),Te&&a.createElement(a.Fragment,null,a.createElement("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,zIndex:9999},onClick:function(){return ze(null)}}),a.createElement("div",{style:{position:"fixed",left:Te.x,top:Te.y,backgroundColor:"#1e293b",border:"1px solid #334155",borderRadius:"8px",padding:"4px 0",minWidth:"200px",boxShadow:"0 4px 12px rgba(0, 0, 0, 0.5)",zIndex:1e4,color:"#e2e8f0"},onClick:function(e){return e.stopPropagation()}},a.createElement("div",{style:{padding:"8px 16px",cursor:"pointer",fontSize:"14px",transition:"background 0.2s"},onMouseEnter:function(e){return e.target.style.background="#334155"},onMouseLeave:function(e){return e.target.style.background="transparent"},onClick:function(){if(Te){var e=Te.groupId,n=Te.moduleId,t=Te.port;(function(e,n,t,a,o){console.log("Exposing port ".concat(t," on group ").concat(e," from module ").concat(n)),E(function(r){return r.map(function(r){if(r.id!==e)return r;var c="".concat(n,":").concat(t);if("left"===o){if(r.inputPorts.some(function(e){return e.id===c}))return console.log("Port ".concat(c," already exposed as input")),r;var i={id:c,port:t,kind:a,targetModuleId:n,targetPort:t};return gt(gt({},r),{},{inputPorts:[].concat(mt(r.inputPorts),[i])})}if(r.outputPorts.some(function(e){return e.id===c}))return console.log("Port ".concat(c," already exposed as output")),r;var l={id:c,port:t,kind:a,sourceModuleId:n,sourcePort:t};return gt(gt({},r),{},{outputPorts:[].concat(mt(r.outputPorts),[l])})})}),console.log("Port exposed successfully")})(e,n,t.port,t.kind,t.side),ze(null)}}},"Expose as Group Port"),a.createElement("div",{style:{padding:"4px 16px",fontSize:"12px",color:"#94a3b8",borderTop:"1px solid #334155",marginTop:"4px"}},"left"===Te.port.side?"Input":"Output","  ","audio"===Te.port.kind?"Audio":"Control"))),Re&&a.createElement(kn,{componentName:"Standalone Sample Editor",onRetry:function(){Le(!1),setTimeout(function(){return Le(!0)},100)}},a.createElement(dn,{module:{id:"standalone",type:"SampleEditor",params:{sample_number:1,custom_suffix:"",sample_name:""}},onUpdateParam:function(e,n,t){console.log("Standalone Sample Editor param update:",n,t)},onClose:function(){return Le(!1)},modules:[]})))};o.createRoot(document.getElementById("root")).render(a.createElement($e,null,a.createElement(Lt,null)))})();